/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/ 		var executeModules = data[2];
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 		// add entry modules from loaded chunk to deferred list
/******/ 		deferredModules.push.apply(deferredModules, executeModules || []);
/******/
/******/ 		// run deferred modules when all chunks ready
/******/ 		return checkDeferredModules();
/******/ 	};
/******/ 	function checkDeferredModules() {
/******/ 		var result;
/******/ 		for(var i = 0; i < deferredModules.length; i++) {
/******/ 			var deferredModule = deferredModules[i];
/******/ 			var fulfilled = true;
/******/ 			for(var j = 1; j < deferredModule.length; j++) {
/******/ 				var depId = deferredModule[j];
/******/ 				if(installedChunks[depId] !== 0) fulfilled = false;
/******/ 			}
/******/ 			if(fulfilled) {
/******/ 				deferredModules.splice(i--, 1);
/******/ 				result = __webpack_require__(__webpack_require__.s = deferredModule[0]);
/******/ 			}
/******/ 		}
/******/
/******/ 		return result;
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		34: 0
/******/ 	};
/******/
/******/ 	var deferredModules = [];
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/javascripts/build/shared/";
/******/
/******/ 	var jsonpArray = window["socrataFrontendWebpackJsonp"] = window["socrataFrontendWebpackJsonp"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// add entry module to deferred list
/******/ 	deferredModules.push([2969,1,0]);
/******/ 	// run deferred modules when ready
/******/ 	return checkDeferredModules();
/******/ })
/************************************************************************/
/******/ ({

/***/ 2969:
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(42);
__webpack_require__(2970);
__webpack_require__(2971);
__webpack_require__(2972);
__webpack_require__(2973);
__webpack_require__(2974);
__webpack_require__(2975);
__webpack_require__(2976);
__webpack_require__(2977);
__webpack_require__(1313);
__webpack_require__(2978);
__webpack_require__(2979);
__webpack_require__(2980);
__webpack_require__(2981);
__webpack_require__(2982);
__webpack_require__(2983);
__webpack_require__(2984);
__webpack_require__(2985);
__webpack_require__(2986);
__webpack_require__(2987);
__webpack_require__(2988);
__webpack_require__(2989);
__webpack_require__(2990);
__webpack_require__(2991);
__webpack_require__(2992);
__webpack_require__(2993);
__webpack_require__(2994);
__webpack_require__(923);
__webpack_require__(924);
__webpack_require__(2995);
__webpack_require__(2996);
__webpack_require__(2997);
__webpack_require__(2998);
__webpack_require__(2999);
__webpack_require__(3000);
__webpack_require__(3001);
__webpack_require__(3002);
__webpack_require__(3003);
__webpack_require__(3004);
__webpack_require__(3005);
__webpack_require__(3006);
__webpack_require__(3007);
__webpack_require__(3008);
__webpack_require__(3009);
__webpack_require__(3010);
__webpack_require__(3011);
__webpack_require__(3012);
__webpack_require__(3013);
__webpack_require__(3014);
__webpack_require__(3015);
__webpack_require__(3016);
__webpack_require__(3017);
__webpack_require__(3018);
__webpack_require__(925);
__webpack_require__(3019);
__webpack_require__(3020);
__webpack_require__(3021);
__webpack_require__(3022);
__webpack_require__(3023);
__webpack_require__(3024);
module.exports = __webpack_require__(3025);


/***/ }),

/***/ 2970:
/***/ (function(module, exports) {

/*** IMPORTS FROM imports-loader ***/
var define = undefined;
var require = undefined;
var module = undefined;
var exports = undefined;
(function() {

/*
 * CAUTION: This file (and everything in this directory) is marked as noParse
 * in our Webpack configuration. This means it cannot import modules, and that
 * it will not be transpiled to ES5. Do *NOT* use any ES6 features that our
 * supported browsers don't support natively (i.e., IE11 does not support arrow
 * functions).
 */

/**
 * @version: 1.0 Alpha-1
 * @author: Coolite Inc. http://www.coolite.com/
 * @date: 2008-05-13
 * @copyright: Copyright (c) 2006-2008, Coolite Inc. (http://www.coolite.com/). All rights reserved.
 * @license: Licensed under The MIT License. See license.txt and http://www.datejs.com/license/. 
 * @website: http://www.datejs.com/
 */
Date.CultureInfo={name:"en-US",englishName:"English (United States)",nativeName:"English (United States)",dayNames:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],abbreviatedDayNames:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],shortestDayNames:["Su","Mo","Tu","We","Th","Fr","Sa"],firstLetterDayNames:["S","M","T","W","T","F","S"],monthNames:["January","February","March","April","May","June","July","August","September","October","November","December"],abbreviatedMonthNames:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],amDesignator:"AM",pmDesignator:"PM",firstDayOfWeek:0,twoDigitYearMax:2029,dateElementOrder:"mdy",formatPatterns:{shortDate:"M/d/yyyy",longDate:"dddd, MMMM dd, yyyy",shortTime:"h:mm tt",longTime:"h:mm:ss tt",fullDateTime:"dddd, MMMM dd, yyyy h:mm:ss tt",sortableDateTime:"yyyy-MM-ddTHH:mm:ss",universalSortableDateTime:"yyyy-MM-dd HH:mm:ssZ",rfc1123:"ddd, dd MMM yyyy HH:mm:ss GMT",monthDay:"MMMM dd",yearMonth:"MMMM, yyyy"},regexPatterns:{jan:/^jan(uary)?/i,feb:/^feb(ruary)?/i,mar:/^mar(ch)?/i,apr:/^apr(il)?/i,may:/^may/i,jun:/^jun(e)?/i,jul:/^jul(y)?/i,aug:/^aug(ust)?/i,sep:/^sep(t(ember)?)?/i,oct:/^oct(ober)?/i,nov:/^nov(ember)?/i,dec:/^dec(ember)?/i,sun:/^su(n(day)?)?/i,mon:/^mo(n(day)?)?/i,tue:/^tu(e(s(day)?)?)?/i,wed:/^we(d(nesday)?)?/i,thu:/^th(u(r(s(day)?)?)?)?/i,fri:/^fr(i(day)?)?/i,sat:/^sa(t(urday)?)?/i,future:/^next/i,past:/^last|past|prev(ious)?/i,add:/^(\+|aft(er)?|from|hence)/i,subtract:/^(\-|bef(ore)?|ago)/i,yesterday:/^yes(terday)?/i,today:/^t(od(ay)?)?/i,tomorrow:/^tom(orrow)?/i,now:/^n(ow)?/i,millisecond:/^ms|milli(second)?s?/i,second:/^sec(ond)?s?/i,minute:/^mn|min(ute)?s?/i,hour:/^h(our)?s?/i,week:/^w(eek)?s?/i,month:/^m(onth)?s?/i,day:/^d(ay)?s?/i,year:/^y(ear)?s?/i,shortMeridian:/^(a|p)/i,longMeridian:/^(a\.?m?\.?|p\.?m?\.?)/i,timezone:/^((e(s|d)t|c(s|d)t|m(s|d)t|p(s|d)t)|((gmt)?\s*(\+|\-)\s*\d\d\d\d?)|gmt|utc)/i,ordinalSuffix:/^\s*(st|nd|rd|th)/i,timeContext:/^\s*(\:|a(?!u|p)|p)/i},timezones:[{name:"UTC",offset:"-000"},{name:"GMT",offset:"-000"},{name:"EST",offset:"-0500"},{name:"EDT",offset:"-0400"},{name:"CST",offset:"-0600"},{name:"CDT",offset:"-0500"},{name:"MST",offset:"-0700"},{name:"MDT",offset:"-0600"},{name:"PST",offset:"-0800"},{name:"PDT",offset:"-0700"}]};
(function(){var $D=Date,$P=$D.prototype,$C=$D.CultureInfo,p=function(s,l){if(!l){l=2;}
return("000"+s).slice(l*-1);};$P.clearTime=function(){this.setHours(0);this.setMinutes(0);this.setSeconds(0);this.setMilliseconds(0);return this;};$P.setTimeToNow=function(){var n=new Date();this.setHours(n.getHours());this.setMinutes(n.getMinutes());this.setSeconds(n.getSeconds());this.setMilliseconds(n.getMilliseconds());return this;};$D.today=function(){return new Date().clearTime();};$D.compare=function(date1,date2){if(isNaN(date1)||isNaN(date2)){throw new Error(date1+" - "+date2);}else if(date1 instanceof Date&&date2 instanceof Date){return(date1<date2)?-1:(date1>date2)?1:0;}else{throw new TypeError(date1+" - "+date2);}};$D.equals=function(date1,date2){return(date1.compareTo(date2)===0);};$D.getDayNumberFromName=function(name){var n=$C.dayNames,m=$C.abbreviatedDayNames,o=$C.shortestDayNames,s=name.toLowerCase();for(var i=0;i<n.length;i++){if(n[i].toLowerCase()==s||m[i].toLowerCase()==s||o[i].toLowerCase()==s){return i;}}
return-1;};$D.getMonthNumberFromName=function(name){var n=$C.monthNames,m=$C.abbreviatedMonthNames,s=name.toLowerCase();for(var i=0;i<n.length;i++){if(n[i].toLowerCase()==s||m[i].toLowerCase()==s){return i;}}
return-1;};$D.isLeapYear=function(year){return((year%4===0&&year%100!==0)||year%400===0);};$D.getDaysInMonth=function(year,month){return[31,($D.isLeapYear(year)?29:28),31,30,31,30,31,31,30,31,30,31][month];};$D.getTimezoneAbbreviation=function(offset){var z=$C.timezones,p;for(var i=0;i<z.length;i++){if(z[i].offset===offset){return z[i].name;}}
return null;};$D.getTimezoneOffset=function(name){var z=$C.timezones,p;for(var i=0;i<z.length;i++){if(z[i].name===name.toUpperCase()){return z[i].offset;}}
return null;};$P.clone=function(){return new Date(this.getTime());};$P.compareTo=function(date){return Date.compare(this,date);};$P.equals=function(date){return Date.equals(this,date||new Date());};$P.between=function(start,end){return this.getTime()>=start.getTime()&&this.getTime()<=end.getTime();};$P.isAfter=function(date){return this.compareTo(date||new Date())===1;};$P.isBefore=function(date){return(this.compareTo(date||new Date())===-1);};$P.isToday=function(){return this.isSameDay(new Date());};$P.isSameDay=function(date){return this.clone().clearTime().equals(date.clone().clearTime());};$P.addMilliseconds=function(value){this.setMilliseconds(this.getMilliseconds()+value);return this;};$P.addSeconds=function(value){return this.addMilliseconds(value*1000);};$P.addMinutes=function(value){return this.addMilliseconds(value*60000);};$P.addHours=function(value){return this.addMilliseconds(value*3600000);};$P.addDays=function(value){this.setDate(this.getDate()+value);return this;};$P.addWeeks=function(value){return this.addDays(value*7);};$P.addMonths=function(value){var n=this.getDate();this.setDate(1);this.setMonth(this.getMonth()+value);this.setDate(Math.min(n,$D.getDaysInMonth(this.getFullYear(),this.getMonth())));return this;};$P.addYears=function(value){return this.addMonths(value*12);};$P.add=function(config){if(typeof config=="number"){this._orient=config;return this;}
var x=config;if(x.milliseconds){this.addMilliseconds(x.milliseconds);}
if(x.seconds){this.addSeconds(x.seconds);}
if(x.minutes){this.addMinutes(x.minutes);}
if(x.hours){this.addHours(x.hours);}
if(x.weeks){this.addWeeks(x.weeks);}
if(x.months){this.addMonths(x.months);}
if(x.years){this.addYears(x.years);}
if(x.days){this.addDays(x.days);}
return this;};var $y,$m,$d;$P.getWeek=function(){var a,b,c,d,e,f,g,n,s,w;$y=(!$y)?this.getFullYear():$y;$m=(!$m)?this.getMonth()+1:$m;$d=(!$d)?this.getDate():$d;if($m<=2){a=$y-1;b=(a/4|0)-(a/100|0)+(a/400|0);c=((a-1)/4|0)-((a-1)/100|0)+((a-1)/400|0);s=b-c;e=0;f=$d-1+(31*($m-1));}else{a=$y;b=(a/4|0)-(a/100|0)+(a/400|0);c=((a-1)/4|0)-((a-1)/100|0)+((a-1)/400|0);s=b-c;e=s+1;f=$d+((153*($m-3)+2)/5)+58+s;}
g=(a+b)%7;d=(f+g-e)%7;n=(f+3-d)|0;if(n<0){w=53-((g-s)/5|0);}else if(n>364+s){w=1;}else{w=(n/7|0)+1;}
$y=$m=$d=null;return w;};$P.getISOWeek=function(){$y=this.getUTCFullYear();$m=this.getUTCMonth()+1;$d=this.getUTCDate();return p(this.getWeek());};$P.setWeek=function(n){return this.moveToDayOfWeek(1).addWeeks(n-this.getWeek());};$D._validate=function(n,min,max,name){if(typeof n=="undefined"){return false;}else if(typeof n!="number"){throw new TypeError(n+" is not a Number.");}else if(n<min||n>max){throw new RangeError(n+" is not a valid value for "+name+".");}
return true;};$D.validateMillisecond=function(value){return $D._validate(value,0,999,"millisecond");};$D.validateSecond=function(value){return $D._validate(value,0,59,"second");};$D.validateMinute=function(value){return $D._validate(value,0,59,"minute");};$D.validateHour=function(value){return $D._validate(value,0,23,"hour");};$D.validateDay=function(value,year,month){return $D._validate(value,1,$D.getDaysInMonth(year,month),"day");};$D.validateMonth=function(value){return $D._validate(value,0,11,"month");};$D.validateYear=function(value){return $D._validate(value,0,9999,"year");};$P.set=function(config){if($D.validateMillisecond(config.millisecond)){this.addMilliseconds(config.millisecond-this.getMilliseconds());}
if($D.validateSecond(config.second)){this.addSeconds(config.second-this.getSeconds());}
if($D.validateMinute(config.minute)){this.addMinutes(config.minute-this.getMinutes());}
if($D.validateHour(config.hour)){this.addHours(config.hour-this.getHours());}
if($D.validateMonth(config.month)){this.addMonths(config.month-this.getMonth());}
if($D.validateYear(config.year)){this.addYears(config.year-this.getFullYear());}
if($D.validateDay(config.day,this.getFullYear(),this.getMonth())){this.addDays(config.day-this.getDate());}
if(config.timezone){this.setTimezone(config.timezone);}
if(config.timezoneOffset){this.setTimezoneOffset(config.timezoneOffset);}
if(config.week&&$D._validate(config.week,0,53,"week")){this.setWeek(config.week);}
return this;};$P.moveToFirstDayOfMonth=function(){return this.set({day:1});};$P.moveToLastDayOfMonth=function(){return this.set({day:$D.getDaysInMonth(this.getFullYear(),this.getMonth())});};$P.moveToNthOccurrence=function(dayOfWeek,occurrence){var shift=0;if(occurrence>0){shift=occurrence-1;}
else if(occurrence===-1){this.moveToLastDayOfMonth();if(this.getDay()!==dayOfWeek){this.moveToDayOfWeek(dayOfWeek,-1);}
return this;}
return this.moveToFirstDayOfMonth().addDays(-1).moveToDayOfWeek(dayOfWeek,+1).addWeeks(shift);};$P.moveToDayOfWeek=function(dayOfWeek,orient){var diff=(dayOfWeek-this.getDay()+7*(orient||+1))%7;return this.addDays((diff===0)?diff+=7*(orient||+1):diff);};$P.moveToMonth=function(month,orient){var diff=(month-this.getMonth()+12*(orient||+1))%12;return this.addMonths((diff===0)?diff+=12*(orient||+1):diff);};$P.getOrdinalNumber=function(){return Math.ceil((this.clone().clearTime()-new Date(this.getFullYear(),0,1))/86400000)+1;};$P.getTimezone=function(){return $D.getTimezoneAbbreviation(this.getUTCOffset());};$P.setTimezoneOffset=function(offset){var here=this.getTimezoneOffset(),there=Number(offset)*-6/10;return this.addMinutes(there-here);};$P.setTimezone=function(offset){return this.setTimezoneOffset($D.getTimezoneOffset(offset));};$P.hasDaylightSavingTime=function(){return(Date.today().set({month:0,day:1}).getTimezoneOffset()!==Date.today().set({month:6,day:1}).getTimezoneOffset());};$P.isDaylightSavingTime=function(){return(this.hasDaylightSavingTime()&&new Date().getTimezoneOffset()===Date.today().set({month:6,day:1}).getTimezoneOffset());};$P.getUTCOffset=function(){var n=this.getTimezoneOffset()*-10/6,r;if(n<0){r=(n-10000).toString();return r.charAt(0)+r.substr(2);}else{r=(n+10000).toString();return"+"+r.substr(1);}};$P.getElapsed=function(date){return(date||new Date())-this;};if(!$P.toISOString){$P.toISOString=function(){function f(n){return n<10?'0'+n:n;}
return'"'+this.getUTCFullYear()+'-'+
f(this.getUTCMonth()+1)+'-'+
f(this.getUTCDate())+'T'+
f(this.getUTCHours())+':'+
f(this.getUTCMinutes())+':'+
f(this.getUTCSeconds())+'Z"';};}
$P._toString=$P.toString;$P.toString=function(format){var x=this;if(format&&format.length==1){var c=$C.formatPatterns;x.t=x.toString;switch(format){case"d":return x.t(c.shortDate);case"D":return x.t(c.longDate);case"F":return x.t(c.fullDateTime);case"m":return x.t(c.monthDay);case"r":return x.t(c.rfc1123);case"s":return x.t(c.sortableDateTime);case"t":return x.t(c.shortTime);case"T":return x.t(c.longTime);case"u":return x.t(c.universalSortableDateTime);case"y":return x.t(c.yearMonth);}}
var ord=function(n){switch(n*1){case 1:case 21:case 31:return"st";case 2:case 22:return"nd";case 3:case 23:return"rd";default:return"th";}};return format?format.replace(/(\\)?(dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|S)/g,function(m){if(m.charAt(0)==="\\"){return m.replace("\\","");}
x.h=x.getHours;switch(m){case"hh":return p(x.h()<13?(x.h()===0?12:x.h()):(x.h()-12));case"h":return x.h()<13?(x.h()===0?12:x.h()):(x.h()-12);case"HH":return p(x.h());case"H":return x.h();case"mm":return p(x.getMinutes());case"m":return x.getMinutes();case"ss":return p(x.getSeconds());case"s":return x.getSeconds();case"yyyy":return p(x.getFullYear(),4);case"yy":return p(x.getFullYear());case"dddd":return $C.dayNames[x.getDay()];case"ddd":return $C.abbreviatedDayNames[x.getDay()];case"dd":return p(x.getDate());case"d":return x.getDate();case"MMMM":return $C.monthNames[x.getMonth()];case"MMM":return $C.abbreviatedMonthNames[x.getMonth()];case"MM":return p((x.getMonth()+1));case"M":return x.getMonth()+1;case"t":return x.h()<12?$C.amDesignator.substring(0,1):$C.pmDesignator.substring(0,1);case"tt":return x.h()<12?$C.amDesignator:$C.pmDesignator;case"S":return ord(x.getDate());default:return m;}}):this._toString();};}());
(function(){var $D=Date,$P=$D.prototype,$C=$D.CultureInfo,$N=Number.prototype;$P._orient=+1;$P._nth=null;$P._is=false;$P._same=false;$P._isSecond=false;$N._dateElement="day";$P.next=function(){this._orient=+1;return this;};$D.next=function(){return $D.today().next();};$P.last=$P.prev=$P.previous=function(){this._orient=-1;return this;};$D.last=$D.prev=$D.previous=function(){return $D.today().last();};$P.is=function(){this._is=true;return this;};$P.same=function(){this._same=true;this._isSecond=false;return this;};$P.today=function(){return this.same().day();};$P.weekday=function(){if(this._is){this._is=false;return(!this.is().sat()&&!this.is().sun());}
return false;};$P.at=function(time){return(typeof time==="string")?$D.parse(this.toString("d")+" "+time):this.set(time);};$N.fromNow=$N.after=function(date){var c={};c[this._dateElement]=this;return((!date)?new Date():date.clone()).add(c);};$N.ago=$N.before=function(date){var c={};c[this._dateElement]=this*-1;return((!date)?new Date():date.clone()).add(c);};var dx=("sunday monday tuesday wednesday thursday friday saturday").split(/\s/),mx=("january february march april may june july august september october november december").split(/\s/),px=("Millisecond Second Minute Hour Day Week Month Year").split(/\s/),pxf=("Milliseconds Seconds Minutes Hours Date Week Month FullYear").split(/\s/),nth=("final first second third fourth fifth").split(/\s/),de;$P.toObject=function(){var o={};for(var i=0;i<px.length;i++){o[px[i].toLowerCase()]=this["get"+pxf[i]]();}
return o;};$D.fromObject=function(config){config.week=null;return Date.today().set(config);};var df=function(n){return function(){if(this._is){this._is=false;return this.getDay()==n;}
if(this._nth!==null){if(this._isSecond){this.addSeconds(this._orient*-1);}
this._isSecond=false;var ntemp=this._nth;this._nth=null;var temp=this.clone().moveToLastDayOfMonth();this.moveToNthOccurrence(n,ntemp);if(this>temp){throw new RangeError($D.getDayName(n)+" does not occur "+ntemp+" times in the month of "+$D.getMonthName(temp.getMonth())+" "+temp.getFullYear()+".");}
return this;}
return this.moveToDayOfWeek(n,this._orient);};};var sdf=function(n){return function(){var t=$D.today(),shift=n-t.getDay();if(n===0&&$C.firstDayOfWeek===1&&t.getDay()!==0){shift=shift+7;}
return t.addDays(shift);};};for(var i=0;i<dx.length;i++){$D[dx[i].toUpperCase()]=$D[dx[i].toUpperCase().substring(0,3)]=i;$D[dx[i]]=$D[dx[i].substring(0,3)]=sdf(i);$P[dx[i]]=$P[dx[i].substring(0,3)]=df(i);}
var mf=function(n){return function(){if(this._is){this._is=false;return this.getMonth()===n;}
return this.moveToMonth(n,this._orient);};};var smf=function(n){return function(){return $D.today().set({month:n,day:1});};};for(var j=0;j<mx.length;j++){$D[mx[j].toUpperCase()]=$D[mx[j].toUpperCase().substring(0,3)]=j;$D[mx[j]]=$D[mx[j].substring(0,3)]=smf(j);$P[mx[j]]=$P[mx[j].substring(0,3)]=mf(j);}
var ef=function(j){return function(){if(this._isSecond){this._isSecond=false;return this;}
if(this._same){this._same=this._is=false;var o1=this.toObject(),o2=(arguments[0]||new Date()).toObject(),v="",k=j.toLowerCase();for(var m=(px.length-1);m>-1;m--){v=px[m].toLowerCase();if(o1[v]!=o2[v]){return false;}
if(k==v){break;}}
return true;}
if(j.substring(j.length-1)!="s"){j+="s";}
return this["add"+j](this._orient);};};var nf=function(n){return function(){this._dateElement=n;return this;};};for(var k=0;k<px.length;k++){de=px[k].toLowerCase();$P[de]=$P[de+"s"]=ef(px[k]);$N[de]=$N[de+"s"]=nf(de);}
$P._ss=ef("Second");var nthfn=function(n){return function(dayOfWeek){if(this._same){return this._ss(arguments[0]);}
if(dayOfWeek||dayOfWeek===0){return this.moveToNthOccurrence(dayOfWeek,n);}
this._nth=n;if(n===2&&(dayOfWeek===undefined||dayOfWeek===null)){this._isSecond=true;return this.addSeconds(this._orient);}
return this;};};for(var l=0;l<nth.length;l++){$P[nth[l]]=(l===0)?nthfn(-1):nthfn(l);}}());
(function(){Date.Parsing={Exception:function(s){this.message="Parse error at '"+s.substring(0,10)+" ...'";}};var $P=Date.Parsing;var _=$P.Operators={rtoken:function(r){return function(s){var mx=s.match(r);if(mx){return([mx[0],s.substring(mx[0].length)]);}else{throw new $P.Exception(s);}};},token:function(s){return function(s){return _.rtoken(new RegExp("^\s*"+s+"\s*"))(s);};},stoken:function(s){return _.rtoken(new RegExp("^"+s));},until:function(p){return function(s){var qx=[],rx=null;while(s.length){try{rx=p.call(this,s);}catch(e){qx.push(rx[0]);s=rx[1];continue;}
break;}
return[qx,s];};},many:function(p){return function(s){var rx=[],r=null;while(s.length){try{r=p.call(this,s);}catch(e){return[rx,s];}
rx.push(r[0]);s=r[1];}
return[rx,s];};},optional:function(p){return function(s){var r=null;try{r=p.call(this,s);}catch(e){return[null,s];}
return[r[0],r[1]];};},not:function(p){return function(s){try{p.call(this,s);}catch(e){return[null,s];}
throw new $P.Exception(s);};},ignore:function(p){return p?function(s){var r=null;r=p.call(this,s);return[null,r[1]];}:null;},product:function(){var px=arguments[0],qx=Array.prototype.slice.call(arguments,1),rx=[];for(var i=0;i<px.length;i++){rx.push(_.each(px[i],qx));}
return rx;},cache:function(rule){var cache={},r=null;return function(s){try{r=cache[s]=(cache[s]||rule.call(this,s));}catch(e){r=cache[s]=e;}
if(r instanceof $P.Exception){throw r;}else{return r;}};},any:function(){var px=arguments;return function(s){var r=null;for(var i=0;i<px.length;i++){if(px[i]==null){continue;}
try{r=(px[i].call(this,s));}catch(e){r=null;}
if(r){return r;}}
throw new $P.Exception(s);};},each:function(){var px=arguments;return function(s){var rx=[],r=null;for(var i=0;i<px.length;i++){if(px[i]==null){continue;}
try{r=(px[i].call(this,s));}catch(e){throw new $P.Exception(s);}
rx.push(r[0]);s=r[1];}
return[rx,s];};},all:function(){var px=arguments,_=_;return _.each(_.optional(px));},sequence:function(px,d,c){d=d||_.rtoken(/^\s*/);c=c||null;if(px.length==1){return px[0];}
return function(s){var r=null,q=null;var rx=[];for(var i=0;i<px.length;i++){try{r=px[i].call(this,s);}catch(e){break;}
rx.push(r[0]);try{q=d.call(this,r[1]);}catch(ex){q=null;break;}
s=q[1];}
if(!r){throw new $P.Exception(s);}
if(q){throw new $P.Exception(q[1]);}
if(c){try{r=c.call(this,r[1]);}catch(ey){throw new $P.Exception(r[1]);}}
return[rx,(r?r[1]:s)];};},between:function(d1,p,d2){d2=d2||d1;var _fn=_.each(_.ignore(d1),p,_.ignore(d2));return function(s){var rx=_fn.call(this,s);return[[rx[0][0],r[0][2]],rx[1]];};},list:function(p,d,c){d=d||_.rtoken(/^\s*/);c=c||null;return(p instanceof Array?_.each(_.product(p.slice(0,-1),_.ignore(d)),p.slice(-1),_.ignore(c)):_.each(_.many(_.each(p,_.ignore(d))),px,_.ignore(c)));},set:function(px,d,c){d=d||_.rtoken(/^\s*/);c=c||null;return function(s){var r=null,p=null,q=null,rx=null,best=[[],s],last=false;for(var i=0;i<px.length;i++){q=null;p=null;r=null;last=(px.length==1);try{r=px[i].call(this,s);}catch(e){continue;}
rx=[[r[0]],r[1]];if(r[1].length>0&&!last){try{q=d.call(this,r[1]);}catch(ex){last=true;}}else{last=true;}
if(!last&&q[1].length===0){last=true;}
if(!last){var qx=[];for(var j=0;j<px.length;j++){if(i!=j){qx.push(px[j]);}}
p=_.set(qx,d).call(this,q[1]);if(p[0].length>0){rx[0]=rx[0].concat(p[0]);rx[1]=p[1];}}
if(rx[1].length<best[1].length){best=rx;}
if(best[1].length===0){break;}}
if(best[0].length===0){return best;}
if(c){try{q=c.call(this,best[1]);}catch(ey){throw new $P.Exception(best[1]);}
best[1]=q[1];}
return best;};},forward:function(gr,fname){return function(s){return gr[fname].call(this,s);};},replace:function(rule,repl){return function(s){var r=rule.call(this,s);return[repl,r[1]];};},process:function(rule,fn){return function(s){var r=rule.call(this,s);return[fn.call(this,r[0]),r[1]];};},min:function(min,rule){return function(s){var rx=rule.call(this,s);if(rx[0].length<min){throw new $P.Exception(s);}
return rx;};}};var _generator=function(op){return function(){var args=null,rx=[];if(arguments.length>1){args=Array.prototype.slice.call(arguments);}else if(arguments[0]instanceof Array){args=arguments[0];}
if(args){for(var i=0,px=args.shift();i<px.length;i++){args.unshift(px[i]);rx.push(op.apply(null,args));args.shift();return rx;}}else{return op.apply(null,arguments);}};};var gx="optional not ignore cache".split(/\s/);for(var i=0;i<gx.length;i++){_[gx[i]]=_generator(_[gx[i]]);}
var _vector=function(op){return function(){if(arguments[0]instanceof Array){return op.apply(null,arguments[0]);}else{return op.apply(null,arguments);}};};var vx="each any all".split(/\s/);for(var j=0;j<vx.length;j++){_[vx[j]]=_vector(_[vx[j]]);}}());(function(){var $D=Date,$P=$D.prototype,$C=$D.CultureInfo;var flattenAndCompact=function(ax){var rx=[];for(var i=0;i<ax.length;i++){if(ax[i]instanceof Array){rx=rx.concat(flattenAndCompact(ax[i]));}else{if(ax[i]){rx.push(ax[i]);}}}
return rx;};$D.Grammar={};$D.Translator={hour:function(s){return function(){this.hour=Number(s);};},minute:function(s){return function(){this.minute=Number(s);};},second:function(s){return function(){this.second=Number(s);};},meridian:function(s){return function(){this.meridian=s.slice(0,1).toLowerCase();};},timezone:function(s){return function(){var n=s.replace(/[^\d\+\-]/g,"");if(n.length){this.timezoneOffset=Number(n);}else{this.timezone=s.toLowerCase();}};},day:function(x){var s=x[0];return function(){this.day=Number(s.match(/\d+/)[0]);};},month:function(s){return function(){this.month=(s.length==3)?"jan feb mar apr may jun jul aug sep oct nov dec".indexOf(s)/4:Number(s)-1;};},year:function(s){return function(){var n=Number(s);this.year=((s.length>2)?n:(n+(((n+2000)<$C.twoDigitYearMax)?2000:1900)));};},rday:function(s){return function(){switch(s){case"yesterday":this.days=-1;break;case"tomorrow":this.days=1;break;case"today":this.days=0;break;case"now":this.days=0;this.now=true;break;}};},finishExact:function(x){x=(x instanceof Array)?x:[x];for(var i=0;i<x.length;i++){if(x[i]){x[i].call(this);}}
var now=new Date();if((this.hour||this.minute)&&(!this.month&&!this.year&&!this.day)){this.day=now.getDate();}
if(!this.year){this.year=now.getFullYear();}
if(!this.month&&this.month!==0){this.month=now.getMonth();}
if(!this.day){this.day=1;}
if(!this.hour){this.hour=0;}
if(!this.minute){this.minute=0;}
if(!this.second){this.second=0;}
if(this.meridian&&this.hour){if(this.meridian=="p"&&this.hour<12){this.hour=this.hour+12;}else if(this.meridian=="a"&&this.hour==12){this.hour=0;}}
if(this.day>$D.getDaysInMonth(this.year,this.month)){throw new RangeError(this.day+" is not a valid value for days.");}
var r=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second);if(this.timezone){r.set({timezone:this.timezone});}else if(this.timezoneOffset){r.set({timezoneOffset:this.timezoneOffset});}
return r;},finish:function(x){x=(x instanceof Array)?flattenAndCompact(x):[x];if(x.length===0){return null;}
for(var i=0;i<x.length;i++){if(typeof x[i]=="function"){x[i].call(this);}}
var today=$D.today();if(this.now&&!this.unit&&!this.operator){return new Date();}else if(this.now){today=new Date();}
var expression=!!(this.days&&this.days!==null||this.orient||this.operator);var gap,mod,orient;orient=((this.orient=="past"||this.operator=="subtract")?-1:1);if(!this.now&&"hour minute second".indexOf(this.unit)!=-1){today.setTimeToNow();}
if(this.month||this.month===0){if("year day hour minute second".indexOf(this.unit)!=-1){this.value=this.month+1;this.month=null;expression=true;}}
if(!expression&&this.weekday&&!this.day&&!this.days){var temp=Date[this.weekday]();this.day=temp.getDate();if(!this.month){this.month=temp.getMonth();}
this.year=temp.getFullYear();}
if(expression&&this.weekday&&this.unit!="month"){this.unit="day";gap=($D.getDayNumberFromName(this.weekday)-today.getDay());mod=7;this.days=gap?((gap+(orient*mod))%mod):(orient*mod);}
if(this.month&&this.unit=="day"&&this.operator){this.value=(this.month+1);this.month=null;}
if(this.value!=null&&this.month!=null&&this.year!=null){this.day=this.value*1;}
if(this.month&&!this.day&&this.value){today.set({day:this.value*1});if(!expression){this.day=this.value*1;}}
if(!this.month&&this.value&&this.unit=="month"&&!this.now){this.month=this.value;expression=true;}
if(expression&&(this.month||this.month===0)&&this.unit!="year"){this.unit="month";gap=(this.month-today.getMonth());mod=12;this.months=gap?((gap+(orient*mod))%mod):(orient*mod);this.month=null;}
if(!this.unit){this.unit="day";}
if(!this.value&&this.operator&&this.operator!==null&&this[this.unit+"s"]&&this[this.unit+"s"]!==null){this[this.unit+"s"]=this[this.unit+"s"]+((this.operator=="add")?1:-1)+(this.value||0)*orient;}else if(this[this.unit+"s"]==null||this.operator!=null){if(!this.value){this.value=1;}
this[this.unit+"s"]=this.value*orient;}
if(this.meridian&&this.hour){if(this.meridian=="p"&&this.hour<12){this.hour=this.hour+12;}else if(this.meridian=="a"&&this.hour==12){this.hour=0;}}
if(this.weekday&&!this.day&&!this.days){var temp=Date[this.weekday]();this.day=temp.getDate();if(temp.getMonth()!==today.getMonth()){this.month=temp.getMonth();}}
if((this.month||this.month===0)&&!this.day){this.day=1;}
if(!this.orient&&!this.operator&&this.unit=="week"&&this.value&&!this.day&&!this.month){return Date.today().setWeek(this.value);}
if(expression&&this.timezone&&this.day&&this.days){this.day=this.days;}
return(expression)?today.add(this):today.set(this);}};var _=$D.Parsing.Operators,g=$D.Grammar,t=$D.Translator,_fn;g.datePartDelimiter=_.rtoken(/^([\s\-\.\,\/\x27]+)/);g.timePartDelimiter=_.stoken(":");g.whiteSpace=_.rtoken(/^\s*/);g.generalDelimiter=_.rtoken(/^(([\s\,]|at|@|on)+)/);var _C={};g.ctoken=function(keys){var fn=_C[keys];if(!fn){var c=$C.regexPatterns;var kx=keys.split(/\s+/),px=[];for(var i=0;i<kx.length;i++){px.push(_.replace(_.rtoken(c[kx[i]]),kx[i]));}
fn=_C[keys]=_.any.apply(null,px);}
return fn;};g.ctoken2=function(key){return _.rtoken($C.regexPatterns[key]);};g.h=_.cache(_.process(_.rtoken(/^(0[0-9]|1[0-2]|[1-9])/),t.hour));g.hh=_.cache(_.process(_.rtoken(/^(0[0-9]|1[0-2])/),t.hour));g.H=_.cache(_.process(_.rtoken(/^([0-1][0-9]|2[0-3]|[0-9])/),t.hour));g.HH=_.cache(_.process(_.rtoken(/^([0-1][0-9]|2[0-3])/),t.hour));g.m=_.cache(_.process(_.rtoken(/^([0-5][0-9]|[0-9])/),t.minute));g.mm=_.cache(_.process(_.rtoken(/^[0-5][0-9]/),t.minute));g.s=_.cache(_.process(_.rtoken(/^([0-5][0-9]|[0-9])/),t.second));g.ss=_.cache(_.process(_.rtoken(/^[0-5][0-9]/),t.second));g.hms=_.cache(_.sequence([g.H,g.m,g.s],g.timePartDelimiter));g.t=_.cache(_.process(g.ctoken2("shortMeridian"),t.meridian));g.tt=_.cache(_.process(g.ctoken2("longMeridian"),t.meridian));g.z=_.cache(_.process(_.rtoken(/^((\+|\-)\s*\d\d\d\d)|((\+|\-)\d\d\:?\d\d)/),t.timezone));g.zz=_.cache(_.process(_.rtoken(/^((\+|\-)\s*\d\d\d\d)|((\+|\-)\d\d\:?\d\d)/),t.timezone));g.zzz=_.cache(_.process(g.ctoken2("timezone"),t.timezone));g.timeSuffix=_.each(_.ignore(g.whiteSpace),_.set([g.tt,g.zzz]));g.time=_.each(_.optional(_.ignore(_.stoken("T"))),g.hms,g.timeSuffix);g.d=_.cache(_.process(_.each(_.rtoken(/^([0-2]\d|3[0-1]|\d)/),_.optional(g.ctoken2("ordinalSuffix"))),t.day));g.dd=_.cache(_.process(_.each(_.rtoken(/^([0-2]\d|3[0-1])/),_.optional(g.ctoken2("ordinalSuffix"))),t.day));g.ddd=g.dddd=_.cache(_.process(g.ctoken("sun mon tue wed thu fri sat"),function(s){return function(){this.weekday=s;};}));g.M=_.cache(_.process(_.rtoken(/^(1[0-2]|0\d|\d)/),t.month));g.MM=_.cache(_.process(_.rtoken(/^(1[0-2]|0\d)/),t.month));g.MMM=g.MMMM=_.cache(_.process(g.ctoken("jan feb mar apr may jun jul aug sep oct nov dec"),t.month));g.y=_.cache(_.process(_.rtoken(/^(\d\d?)/),t.year));g.yy=_.cache(_.process(_.rtoken(/^(\d\d)/),t.year));g.yyy=_.cache(_.process(_.rtoken(/^(\d\d?\d?\d?)/),t.year));g.yyyy=_.cache(_.process(_.rtoken(/^(\d\d\d\d)/),t.year));_fn=function(){return _.each(_.any.apply(null,arguments),_.not(g.ctoken2("timeContext")));};g.day=_fn(g.d,g.dd);g.month=_fn(g.M,g.MMM);g.year=_fn(g.yyyy,g.yy);g.orientation=_.process(g.ctoken("past future"),function(s){return function(){this.orient=s;};});g.operator=_.process(g.ctoken("add subtract"),function(s){return function(){this.operator=s;};});g.rday=_.process(g.ctoken("yesterday tomorrow today now"),t.rday);g.unit=_.process(g.ctoken("second minute hour day week month year"),function(s){return function(){this.unit=s;};});g.value=_.process(_.rtoken(/^\d\d?(st|nd|rd|th)?/),function(s){return function(){this.value=s.replace(/\D/g,"");};});g.expression=_.set([g.rday,g.operator,g.value,g.unit,g.orientation,g.ddd,g.MMM]);_fn=function(){return _.set(arguments,g.datePartDelimiter);};g.mdy=_fn(g.ddd,g.month,g.day,g.year);g.ymd=_fn(g.ddd,g.year,g.month,g.day);g.dmy=_fn(g.ddd,g.day,g.month,g.year);g.date=function(s){return((g[$C.dateElementOrder]||g.mdy).call(this,s));};g.format=_.process(_.many(_.any(_.process(_.rtoken(/^(dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|zz?z?)/),function(fmt){if(g[fmt]){return g[fmt];}else{throw $D.Parsing.Exception(fmt);}}),_.process(_.rtoken(/^[^dMyhHmstz]+/),function(s){return _.ignore(_.stoken(s));}))),function(rules){return _.process(_.each.apply(null,rules),t.finishExact);});var _F={};var _get=function(f){return _F[f]=(_F[f]||g.format(f)[0]);};g.formats=function(fx){if(fx instanceof Array){var rx=[];for(var i=0;i<fx.length;i++){rx.push(_get(fx[i]));}
return _.any.apply(null,rx);}else{return _get(fx);}};g._formats=g.formats(["\"yyyy-MM-ddTHH:mm:ssZ\"","yyyy-MM-ddTHH:mm:ssZ","yyyy-MM-ddTHH:mm:ssz","yyyy-MM-ddTHH:mm:ss","yyyy-MM-ddTHH:mmZ","yyyy-MM-ddTHH:mmz","yyyy-MM-ddTHH:mm","ddd, MMM dd, yyyy H:mm:ss tt","ddd MMM d yyyy HH:mm:ss zzz","MMddyyyy","ddMMyyyy","Mddyyyy","ddMyyyy","Mdyyyy","dMyyyy","yyyy","Mdyy","dMyy","d"]);g._start=_.process(_.set([g.date,g.time,g.expression],g.generalDelimiter,g.whiteSpace),t.finish);g.start=function(s){try{var r=g._formats.call({},s);if(r[1].length===0){return r;}}catch(e){}
return g._start.call({},s);};$D._parse=$D.parse;$D.parse=function(s){var r=null;if(!s){return null;}
if(s instanceof Date){return s;}
// michael.chui@socrata.com: Strip milliseconds since none of the formats deal with them.
try{r=$D.Grammar.start.call({},s.replace(/^\s*(\S*(\s+\S+)*)\s*$/,"$1").replace(/\.\d{3}Z?/, ''));}catch(e){return null;}
return((r[1].length===0)?r[0]:null);};$D.getParseFunction=function(fx){var fn=$D.Grammar.formats(fx);return function(s){var r=null;try{r=fn.call({},s);}catch(e){return null;}
return((r[1].length===0)?r[0]:null);};};$D.parseExact=function(s,fx){return $D.getParseFunction(fx)(s);};}());
/**
 * @version: 1.0 Alpha-1
 * @author: Coolite Inc. http://www.coolite.com/
 * @date: 2008-05-13
 * @copyright: Copyright (c) 2006-2008, Coolite Inc. (http://www.coolite.com/). All rights reserved.
 * @license: Licensed under The MIT License. See license.txt and http://www.datejs.com/license/. 
 * @website: http://www.datejs.com/
 */
(function(){var $D=Date,$P=$D.prototype,$C=$D.CultureInfo,$f=[],p=function(s,l){if(!l){l=2;}
return("000"+s).slice(l*-1);};$D.normalizeFormat=function(format){$f=[];var t=new Date().$format(format);return $f.join("");};$D.strftime=function(format,time){return new Date(time*1000).$format(format);};$D.strtotime=function(time){var d=$D.parse(time);d.addMinutes(d.getTimezoneOffset()*-1);return Math.round($D.UTC(d.getUTCFullYear(),d.getUTCMonth(),d.getUTCDate(),d.getUTCHours(),d.getUTCMinutes(),d.getUTCSeconds(),d.getUTCMilliseconds())/1000);};$P.$format=function(format){var x=this,y,t=function(v){$f.push(v);return x.toString(v);};return format?format.replace(/(%|\\)?.|%%/g,function(m){if(m.charAt(0)==="\\"||m.substring(0,2)==="%%"){return m.replace("\\","").replace("%%","%");}
switch(m){case"d":case"%d":return t("dd");case"D":case"%a":return t("ddd");case"j":case"%e":return t("d");case"l":case"%A":return t("dddd");case"N":case"%u":return x.getDay()+1;case"S":return t("S");case"w":case"%w":return x.getDay();case"z":return x.getOrdinalNumber();case"%j":return p(x.getOrdinalNumber(),3);case"%U":var d1=x.clone().set({month:0,day:1}).addDays(-1).moveToDayOfWeek(0),d2=x.clone().addDays(1).moveToDayOfWeek(0,-1);return(d2<d1)?"00":p((d2.getOrdinalNumber()-d1.getOrdinalNumber())/7+1);case"W":case"%V":return x.getISOWeek();case"%W":return p(x.getWeek());case"F":case"%B":return t("MMMM");case"m":case"%m":return t("MM");case"M":case"%b":case"%h":return t("MMM");case"n":return t("M");case"t":return $D.getDaysInMonth(x.getFullYear(),x.getMonth());case"L":return($D.isLeapYear(x.getFullYear()))?1:0;case"o":case"%G":return x.setWeek(x.getISOWeek()).toString("yyyy");case"%g":return x.$format("%G").slice(-2);case"Y":case"%Y":return t("yyyy");case"y":case"%y":return t("yy");case"a":case"%p":return t("tt").toLowerCase();case"A":return t("tt").toUpperCase();case"g":case"%I":return t("h");case"G":return t("H");case"h":return t("hh");case"H":case"%H":return t("HH");case"i":case"%M":return t("mm");case"s":case"%S":return t("ss");case"u":return p(x.getMilliseconds(),3);case"I":return(x.isDaylightSavingTime())?1:0;case"O":return x.getUTCOffset();case"P":y=x.getUTCOffset();return y.substring(0,y.length-2)+":"+y.substring(y.length-2);case"e":case"T":case"%z":case"%Z":return x.getTimezone();case"Z":return x.getTimezoneOffset()*-60;case"B":var now=new Date();return Math.floor(((now.getHours()*3600)+(now.getMinutes()*60)+now.getSeconds()+(now.getTimezoneOffset()+60)*60)/86.4);case"c":return x.toISOString().replace(/\"/g,"");case"U":return $D.strtotime("now");case"%c":return t("d")+" "+t("t");case"%C":return Math.floor(x.getFullYear()/100+1);case"%D":return t("MM/dd/yy");case"%n":return"\\n";case"%t":return"\\t";case"%r":return t("hh:mm tt");case"%R":return t("H:mm");case"%T":return t("H:mm:ss");case"%x":return t("d");case"%X":return t("t");default:$f.push(m);return m;}}):this._toString();};if(!$P.format){$P.format=$P.$format;}}());

}.call(window));

/***/ }),

/***/ 2971:
/***/ (function(module, exports) {

/*** IMPORTS FROM imports-loader ***/
var define = undefined;
var require = undefined;
var module = undefined;
var exports = undefined;
(function() {

/*
 * CAUTION: This file (and everything in this directory) is marked as noParse
 * in our Webpack configuration. This means it cannot import modules, and that
 * it will not be transpiled to ES5. Do *NOT* use any ES6 features that our
 * supported browsers don't support natively (i.e., IE11 does not support arrow
 * functions).
 */

/*
 * jqModal - Minimalist Modaling with jQuery
 *   (http://dev.iceburg.net/jquery/jqModal/)
 *
 * Copyright (c) 2007,2008 Brice Burgess <bhb@iceburg.net>
 * Dual licensed under the MIT and GPL licenses:
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 *
 * $Version: 03/01/2009 +r14
 * 	* Updated July 2019 to support jquery 3.4.1
 * - bind/unbind is deprecated: https://jquery.com/upgrade-guide/3.0/#deprecated-bind-and-delegate
 */
(function($) {
$.fn.jqm=function(o){
var p={
overlay: 50,
overlayClass: 'jqmOverlay',
closeClass: 'jqmClose',
trigger: '.jqModal',
ajax: F,
ajaxText: '',
target: F,
modal: F,
toTop: F,
onShow: F,
onHide: F,
onLoad: F
};
return this.each(function(){if(this._jqm)return H[this._jqm].c=$.extend({},H[this._jqm].c,o);s++;this._jqm=s;
H[s]={c:$.extend(p,$.jqm.params,o),a:F,w:$(this).addClass('jqmID'+s),s:s};
if(p.trigger)$(this).jqmAddTrigger(p.trigger);
});};

$.fn.jqmAddClose=function(e){return hs(this,e,'jqmHide');};
$.fn.jqmAddTrigger=function(e){return hs(this,e,'jqmShow');};
$.fn.jqmShow=function(t){return this.each(function(){t=t||window.event;$.jqm.open(this._jqm,t);});};
$.fn.jqmHide=function(t){return this.each(function(){t=t||window.event;$.jqm.close(this._jqm,t)});};

$.jqm = {
hash:{},
open:function(s,t){var h=H[s],c=h.c,cc='.'+c.closeClass,z=(parseInt(h.w.css('z-index'))),z=(z>0)?z:3000,o=$('<div></div>').css({height:'100%',width:'100%',position:'fixed',left:0,top:0,'z-index':z-1,opacity:c.overlay/100});if(h.a)return F;h.t=t;h.a=true;h.w.css('z-index',z);
 if(c.modal) {if(!A[0])L('on');A.push(s);}
 else if(c.overlay > 0)h.w.jqmAddClose(o);
 else o=F;

 h.o=(o)?o.addClass(c.overlayClass).prependTo('body'):F;
 if(ie6){$('html,body').css({height:'100%',width:'100%'});if(o){o=o.css({position:'absolute'})[0];for(var y in {Top:1,Left:1})o.style.setExpression(y.toLowerCase(),"(_=(document.documentElement.scroll"+y+" || document.body.scroll"+y+"))+'px'");}}

 if(c.ajax) {var r=c.target||h.w,u=c.ajax,r=(typeof r == 'string')?$(r,h.w):$(r),u=(u.substr(0,1) == '@')?$(t).attr(u.substring(1)):u;
  r.html(c.ajaxText).load(u,function(){if(c.onLoad)c.onLoad.call(this,h);if(cc)h.w.jqmAddClose($(cc,h.w));e(h);});}
 else if(cc)h.w.jqmAddClose($(cc,h.w));

 if(c.toTop&&h.o)h.w.before('<span id="jqmP'+h.w[0]._jqm+'"></span>').insertAfter(h.o);
 (c.onShow)?c.onShow(h):h.w.show();e(h);return F;
},
close:function(s){var h=H[s];if(!h.a)return F;h.a=F;
 if(A[0]){A.pop();if(!A[0])L('off');}
 if(h.c.toTop&&h.o)$('#jqmP'+h.w[0]._jqm).after(h.w).remove();
 if(h.c.onHide)h.c.onHide(h);else{h.w.hide();if(h.o)h.o.remove();} return F;
},
params:{}};
var s=0,H=$.jqm.hash,A=[],ie6=$.browser.msie&&($.browser.version == "6.0"),F=false,
i=$('<iframe src="javascript:false;document.write(\'\');" class="jqm"></iframe>').css({opacity:0}),
e=function(h){if(ie6)if(h.o)h.o.html('<p style="width:100%;height:100%"/>').prepend(i);else if(!$('iframe.jqm',h.w)[0])h.w.prepend(i); f(h);},
f=function(h){try{$(':input:visible',h.w)[0].focus();}catch(_){}},
L=function(t){$()[t]("keypress",m)[t]("keydown",m)[t]("mousedown",m);},
m=function(e){var h=H[A[A.length-1]],r=(!$(e.target).parents('.jqmID'+h.s)[0]);if(r)f(h);return !r;},
hs=function(w,t,c){return w.each(function(){var s=this._jqm;$(t).each(function() {
 if(!this[c]){this[c]=[];$(this).on('click', function(){for(var i in {jqmShow:1,jqmHide:1})for(var s in this[i])if(H[this[i][s]])H[this[i][s]].w[i](this);return F;});}this[c].push(s);});});};
})(jQuery);

}.call(window));

/***/ }),

/***/ 2972:
/***/ (function(module, exports) {

/*** IMPORTS FROM imports-loader ***/
var define = undefined;
var require = undefined;
var module = undefined;
var exports = undefined;
(function() {

/*
 * CAUTION: This file (and everything in this directory) is marked as noParse
 * in our Webpack configuration. This means it cannot import modules, and that
 * it will not be transpiled to ES5. Do *NOT* use any ES6 features that our
 * supported browsers don't support natively (i.e., IE11 does not support arrow
 * functions).
 */

/*
 * @name BeautyTips
 * @desc a tooltips/baloon-help plugin for jQuery
 *
 * @author Jeff Robbins - Lullabot - http://www.lullabot.com
 * @version 0.9.5 release candidate 1  (5/20/2009)
 */

 /**
  * Updated July 2019 to use non-deprecated jquery 3 syntax:
  * - andSelf() removed: https://jquery.com/upgrade-guide/3.0/#breaking-change-andself-removed-use-addback
  * - bind/unbind deprecated: https://jquery.com/upgrade-guide/3.0/#deprecated-bind-and-delegate
  */

jQuery.bt = {version: '0.9.5-rc1'};

/*
 * @type jQuery
 * @cat Plugins/bt
 * @requires jQuery v1.2+ (not tested on versions prior to 1.2.6)
 *
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 * Encourage development. If you use BeautyTips for anything cool
 * or on a site that people have heard of, please drop me a note.
 * - jeff ^at lullabot > com
 *
 * No guarantees, warranties, or promises of any kind
 *
 */

;(function($) {
  /**
   * @credit Inspired by Karl Swedberg's ClueTip
   *    (http://plugins.learningjquery.com/cluetip/), which in turn was inspired
   *    by Cody Lindley's jTip (http://www.codylindley.com)
   *
   * @fileoverview
   * Beauty Tips is a jQuery tooltips plugin which uses the canvas drawing element
   * in the HTML5 spec in order to dynamically draw tooltip "talk bubbles" around
   * the descriptive help text associated with an item. This is in many ways
   * similar to Google Maps which both provides similar talk-bubbles and uses the
   * canvas element to draw them.
   *
   * The canvas element is supported in modern versions of FireFox, Safari, and
   * Opera. However, Internet Explorer needs a separate library called ExplorerCanvas
   * included on the page in order to support canvas drawing functions. ExplorerCanvas
   * was created by Google for use with their web apps and you can find it here:
   * http://excanvas.sourceforge.net/
   *
   * Beauty Tips was written to be simple to use and pretty. All of its options
   * are documented at the bottom of this file and defaults can be overwritten
   * globally for the entire page, or individually on each call.
   *
   * By default each tooltip will be positioned on the side of the target element
   * which has the most free space. This is affected by the scroll position and
   * size of the current window, so each Beauty Tip is redrawn each time it is
   * displayed. It may appear above an element at the bottom of the page, but when
   * the page is scrolled down (and the element is at the top of the page) it will
   * then appear below it. Additionally, positions can be forced or a preferred
   * order can be defined. See examples below.
   *
   * To fix z-index problems in IE6, include the bgiframe plugin on your page
   * http://plugins.jquery.com/project/bgiframe - BeautyTips will automatically
   * recognize it and use it.
   *
   * BeautyTips also works with the hoverIntent plugin
   * http://cherne.net/brian/resources/jquery.hoverIntent.html
   * see hoverIntent example below for usage
   *
   * Usage
   * The function can be called in a number of ways.
   * $(selector).bt();
   * $(selector).bt('Content text');
   * $(selector).bt('Content text', {option1: value, option2: value});
   * $(selector).bt({option1: value, option2: value});
   *
   * For more/better documentation and lots of examples, visit the demo page included with the distribution
   *
   */

    var incrId = 0;

  jQuery.fn.bt = function(content, options) {

    var contentSelect = false;
    if (typeof content != 'string')
    {
        options = content;
        if (options.content)
        {
            content = options.content;
        }
        else
        {
            contentSelect = true;
            content = false;
        }
    }

    // if hoverIntent is installed, use that as default instead of hover
    if (jQuery.fn.hoverIntent && jQuery.bt.defaults.trigger == 'hover') {
      jQuery.bt.defaults.trigger = 'hoverIntent';
    }

    return this.each(function(index) {

      var opts = jQuery.extend(false, jQuery.bt.defaults, jQuery.bt.options, options);

      // clint.tseng@socrata.com: allow outside access of opts for hacky shit
      this._opts = opts;

      this._internalId = 'btId' + incrId++;

      // clean up the options
      opts.spikeLength = numb(opts.spikeLength);
      opts.spikeGirth = numb(opts.spikeGirth);
      opts.overlap = numb(opts.overlap);

      var ajaxTimeout = false;


      /**
       *  The BIG TURN ON
       *  Any element that has been initiated
       */
      this.btOn = function () {
        if (_.isFunction(opts.onShowCallback) && !opts.onShowCallback())
        {
            // provide a way to ditch out of showing the thing
            return;
        }

        if (typeof $(this).data('bt-box') == 'object') {
          // if there's already a popup, remove it before creating a new one.
          this.btOff();
        }

        // trigger preBuild function
        // preBuild has no argument since the box hasn't been built yet
        opts.preBuild.apply(this);

        // turn off other tips
        $(jQuery.bt.vars.closeWhenOpenStack).btOff();

        // add the class to the target element (for hilighting, for example)
        // bt-active is always applied to all, but activeClass can apply another
        $(this).addClass('bt-active ' + opts.activeClass);

        if (contentSelect && opts.ajaxPath == null) {
          // bizarre, I know
          if (opts.killTitle) {
            // if we've killed the title attribute, it's been stored in 'bt-xTitle' so get it..
            $(this).attr('title', $(this).attr('bt-xTitle'));
          }
          // then evaluate the selector... title is now in place
          content = $.isFunction(opts.contentSelector) ? opts.contentSelector.apply(this) : eval(opts.contentSelector);
          if (opts.killTitle) {
            // now remove the title again, so we don't get double tips
            $(this).attr('title', '');
          }
        }

        // ----------------------------------------------
        // All the Ajax(ish) stuff is in this next bit...
        // ----------------------------------------------
        if (opts.ajaxPath != null && content == false) {
          if (typeof opts.ajaxPath == 'object') {
            var url = eval(opts.ajaxPath[0]);
            url += opts.ajaxPath[1] ? ' ' + opts.ajaxPath[1] : '';
          }
          else {
            var url = opts.ajaxPath;
          }
          var off = url.indexOf(" ");
          if ( off >= 0 ) {
            var selector = url.slice(off, url.length);
            url = url.slice(0, off);
          }

          // load any data cached for the given ajax path
          var cacheData = opts.ajaxCache ? $(document.body).data('btCache-' + url.replace(/\./g, '')) : null;
          if (typeof cacheData == 'string') {
            content = selector ? $("<div/>").append(cacheData.replace(/<script(.|\s)*?\/script>/g, "")).find(selector) : cacheData;
          }
          else {
            var target = this;

            // set up the options
            var ajaxOpts = jQuery.extend(false,
            {
              type: opts.ajaxType,
              data: opts.ajaxData,
              cache: opts.ajaxCache,
              url: url,
              complete: function(XMLHttpRequest, textStatus) {
                if (textStatus == 'success' || textStatus == 'notmodified') {
                  if (opts.ajaxCache) {
                    $(document.body).data('btCache-' + url.replace(/\./g, ''), XMLHttpRequest.responseText);
                  }
                  ajaxTimeout = false;
                  content = selector ?
                    // Create a dummy div to hold the results
                    $("<div/>")
                      // inject the contents of the document in, removing the scripts
                      // to avoid any 'Permission Denied' errors in IE
                      .append(XMLHttpRequest.responseText.replace(/<script(.|\s)*?\/script>/g, ""))

                      // Locate the specified elements
                      .find(selector) :

                    // If not, just inject the full result
                    XMLHttpRequest.responseText;

                }
                else {
                  if (textStatus == 'timeout') {
                    // if there was a timeout, we don't cache the result
                    ajaxTimeout = true;
                  }
                  content = opts.ajaxError.replace(/%error/g, XMLHttpRequest.statusText);
                }
                // if the user rolls out of the target element before the ajax request comes back, don't show it
                if ($(target).hasClass('bt-active')) {
                  target.btOn();
                }
              }
            }, opts.ajaxOpts);
            // do the ajax request
            jQuery.ajax(ajaxOpts);
            // load the throbber while the magic happens
            content = opts.ajaxLoading;
          }
        }
        // </ ajax stuff >


        // now we start actually figuring out where to place the tip

        // figure out how to compensate for the shadow, if present
        var shadowMarginX = 0; // extra added to width to compensate for shadow
        var shadowMarginY = 0; // extra added to height
        var shadowShiftX = 0;  // amount to shift the tip horizontally to allow for shadow
        var shadowShiftY = 0;  // amount to shift vertical

        if (opts.shadow && !shadowSupport()) {
          // if browser doesn't support drop shadows, turn them off
          opts.shadow = false;
          // and bring in the noShadows options
          jQuery.extend(opts, opts.noShadowOpts);
        }

        if (opts.shadow) {
          // figure out horizontal placement
          if (opts.shadowBlur > Math.abs(opts.shadowOffsetX)) {
            shadowMarginX = opts.shadowBlur * 2;
          }
          else {
            shadowMarginX = opts.shadowBlur + Math.abs(opts.shadowOffsetX);
          }
          shadowShiftX = (opts.shadowBlur - opts.shadowOffsetX) > 0 ? opts.shadowBlur - opts.shadowOffsetX : 0;

          // now vertical
          if (opts.shadowBlur > Math.abs(opts.shadowOffsetY)) {
            shadowMarginY = opts.shadowBlur * 2;
          }
          else {
            shadowMarginY = opts.shadowBlur + Math.abs(opts.shadowOffsetY);
          }
          shadowShiftY = (opts.shadowBlur - opts.shadowOffsetY) > 0 ? opts.shadowBlur - opts.shadowOffsetY : 0;
        }

        if (opts.offsetParent){
          // if offsetParent is defined by user
          var offsetParent = $(opts.offsetParent);
          var offsetParentPos = offsetParent.offset();
          var pos = $(this).offset();
          var top = numb(pos.top) - numb(offsetParentPos.top) + numb($(this).css('margin-top')) - shadowShiftY; // IE can return 'auto' for margins
          var left = numb(pos.left) - numb(offsetParentPos.left) + numb($(this).css('margin-left')) - shadowShiftX;
          // jeff.scherpelz@socrata.com: Need to account for scrollTop & scrollLeft,
          // except for body (because Chrome returns the window scroll)
          if (offsetParent[0].tagName.toLowerCase() != 'body')
          {
              top += offsetParent.scrollTop();
              left += offsetParent.scrollLeft();
          }
        }
        else {
          // if the target element is absolutely positioned, use its parent's offsetParent instead of its own
          // JS: I don't think we actually want to do this...?
          var offsetParent = //($(this).css('position') == 'absolute') ? $(this).parents().eq(0).offsetParent() :
                $(this).offsetParent();
          var pos = $(this).btPosition();
          var top = numb(pos.top) + numb($(this).css('margin-top')) - shadowShiftY; // IE can return 'auto' for margins
          var left = numb(pos.left) + numb($(this).css('margin-left')) - shadowShiftX;
        }

        var width = $(this).btOuterWidth();
        var height = $(this).btOuterHeight();

        if (typeof content == 'object') {
          // if content is a DOM object (as opposed to text)
          // use a clone, rather than removing the original element
          // and ensure that it's visible
          var original = content;
          var clone = $(original).clone(true).show();
          // also store a reference to the original object in the clone data
          // and a reference to the clone in the original
          var origClones = $(original).data('bt-clones') || [];
          origClones.push(clone);
          $(original).data('bt-clones', origClones);
          $(clone).data('bt-orig', original);
          $(this).data('bt-content-orig', {original: original, clone: clone});
          content = clone;
        }
        if (typeof content == 'null' || content == '') {
          // if content is empty, bail out...
          return;
        }

        // create the tip content div, populate it, and style it
        var $text = $('<div class="bt-content"></div>').append(content).css({padding: opts.padding, position: 'absolute', width: (opts.shrinkToFit ? 'auto' : opts.width), zIndex: opts.textzIndex, left: shadowShiftX, top: shadowShiftY}).css(opts.cssStyles);
        // create the wrapping box which contains text and canvas
        // put the content in it, style it, and append it to the same offset parent as the target
        var $box = $('<div class="bt-wrapper"></div>').append($text).addClass(opts.cssClass).css({position: 'absolute', width: opts.width, zIndex: opts.wrapperzIndex, visibility:'hidden'}).appendTo(offsetParent);

        // use bgiframe to get around z-index problems in IE6
        // http://plugins.jquery.com/project/bgiframe
        if (jQuery.fn.bgiframe) {
          $text.bgiframe();
          $box.bgiframe();
        }

        $(this).data('bt-box', $box);

        // see if the text box will fit in the various positions
        var scrollTop = numb($(document).scrollTop());
        var scrollLeft = numb($(document).scrollLeft());
        var docWidth = numb($(window).width());
        var docHeight = numb($(window).height());
        var winRight = scrollLeft + docWidth;
        var winBottom = scrollTop + docHeight;
        var space = new Object();
        var thisOffset = $(this).offset();
        space.top = thisOffset.top - scrollTop;
        space.bottom = docHeight - ((thisOffset.top + height) - scrollTop);
        space.left = thisOffset.left - scrollLeft;
        space.right = docWidth - ((thisOffset.left + width) - scrollLeft);
        var textOutHeight = numb($text.outerHeight());
        var textOutWidth = numb($text.btOuterWidth());
        if (opts.positions.constructor == String) {
          opts.positions = opts.positions.replace(/ /, '').split(',');
        }

        // Giacomo Ferrari <giacomo.ferrari@socrata.com> 5/31/2013:
        // Added base-position and sub-position concept. You can now specify
        // {bottom, top}-{,left, right} in the position.
        // {left, right}-{,top, bottom} are not supported at this time.

        var position, splitPosition, basePosition, subPosition;
        if (opts.positions[0] == 'most') {
          // figure out which is the largest
          position = 'top'; // prime the pump
          for (var pig in space) {  //            <-------  pigs in space!
            if (!space.hasOwnProperty(pig)) { continue; } // Giacomo Ferrari <giacomo.ferrari@socrata.com> 6/19/2013: IE8 also iterates over array methods; we don't want them.
            position = space[pig] > space[position] ? pig : position;
          }
          basePosition = position;
        }
        else {
          for (var x in opts.positions) {
            if (!opts.positions.hasOwnProperty(x)) { continue; } // Giacomo Ferrari <giacomo.ferrari@socrata.com> 6/19/2013: IE8 also iterates over array methods; we don't want them.
            position = opts.positions[x];
            splitPosition = position.split('-');
            basePosition = splitPosition[0];
            subPosition = splitPosition[1];
            // @todo: acommodate shadow space in the following lines...
            if ((basePosition == 'left' || basePosition == 'right') && space[basePosition] > textOutWidth + opts.spikeLength) {
              break;
            }
            else if ((basePosition == 'top' || basePosition == 'bottom') && space[basePosition] > textOutHeight + opts.spikeLength) {
              break;
            }
          }
        }
        // horizontal (left) offset for the box
        var horiz = left + ((width - textOutWidth) * .5);

        if (subPosition === 'left') {
          horiz = left - textOutWidth/2;
        }
        else if (subPosition === 'right') {
          horiz = left + ((width - textOutWidth/2));
        }

        // vertical (top) offset for the box
        var vert = top + ((height - textOutHeight) * .5);
        var points = new Array();
        var textTop, textLeft, textRight, textBottom, textTopSpace, textBottomSpace, textLeftSpace, textRightSpace, crossPoint, textCenter, spikePoint;

        // Yes, yes, this next bit really could use to be condensed
        // each switch case is basically doing the same thing in slightly different ways
        switch(basePosition) {

          // ================= EXPLICIT ====================
          case 'explicit':
            var explicitPos = opts.explicitPosition;
            // spike on bottom
            $text.css('margin-bottom', opts.spikeLength + 'px');
            horiz = left + explicitPos[0] - textOutWidth/2;
            $box.css({top: (explicitPos[1] + top - $text.outerHeight(true)) + opts.overlap, left: horiz});
            // move text left/right if extends out of window
            textRightSpace = (winRight - opts.windowMargin) - ($text.offset().left + $text.btOuterWidth(true));
            var xShift = shadowShiftX;
            if (textRightSpace < 0) {
              // shift it left
              $box.css('left', (numb($box.css('left')) + textRightSpace) + 'px');
              xShift -= textRightSpace;
            }
            // we test left space second to ensure that left of box is visible
            textLeftSpace = ($text.offset().left + numb($text.css('margin-left'))) - (scrollLeft + opts.windowMargin);
            if (textLeftSpace < 0) {
              // shift it right
              $box.css('left', (numb($box.css('left')) - textLeftSpace) + 'px');
              xShift += textLeftSpace;
            }
            textTop = $text.btPosition().top + numb($text.css('margin-top'));
            textLeft = $text.btPosition().left + numb($text.css('margin-left'));
            textRight = textLeft + $text.btOuterWidth();
            textBottom = textTop + $text.outerHeight();
            textCenter = {x: textLeft + ($text.btOuterWidth()*opts.centerPointX), y: textTop + ($text.outerHeight()*opts.centerPointY)};
            // points[points.length] = {x: x, y: y};
            points[points.length] = spikePoint = {y: textBottom + opts.spikeLength, x: ((textRight-textLeft) * .5) + xShift, type: 'spike'};
            crossPoint = findIntersectX(spikePoint.x, spikePoint.y, textCenter.x, textCenter.y, textBottom);
            // make sure that the crossPoint is not outside of text box boundaries
            crossPoint.x = crossPoint.x < textLeft + opts.spikeGirth/2 + opts.cornerRadius ? textLeft + opts.spikeGirth/2 + opts.cornerRadius : crossPoint.x;
            crossPoint.x =  crossPoint.x > (textRight - opts.spikeGirth/2) - opts.cornerRadius ? (textRight - opts.spikeGirth/2) - opts.CornerRadius : crossPoint.x;
            points[points.length] = {x: crossPoint.x - (opts.spikeGirth/2), y: textBottom, type: 'join'};
            points[points.length] = {x: textLeft, y: textBottom, type: 'corner'};  // left bottom corner
            points[points.length] = {x: textLeft, y: textTop, type: 'corner'};     // left top corner
            points[points.length] = {x: textRight, y: textTop, type: 'corner'};    // right top corner
            points[points.length] = {x: textRight, y: textBottom, type: 'corner'}; // right bottom corner
            points[points.length] = {x: crossPoint.x + (opts.spikeGirth/2), y: textBottom, type: 'join'};
            points[points.length] = spikePoint;
            break;
          // =================== TOP =======================
          case 'top':
            // spike on bottom
            $text.css('margin-bottom', opts.spikeLength + 'px');
            $box.css({top: (top - $text.outerHeight(true)) + opts.overlap, left: horiz});
            // move text left/right if extends out of window
            textRightSpace = (winRight - opts.windowMargin) - ($text.offset().left + $text.btOuterWidth(true));
            var xShift = shadowShiftX;
            if (textRightSpace < 0) {
              // shift it left
              $box.css('left', (numb($box.css('left')) + textRightSpace) + 'px');
              xShift -= textRightSpace;
            }
            // we test left space second to ensure that left of box is visible
            textLeftSpace = ($text.offset().left + numb($text.css('margin-left'))) - (scrollLeft + opts.windowMargin);
            if (textLeftSpace < 0) {
              // shift it right
              $box.css('left', (numb($box.css('left')) - textLeftSpace) + 'px');
              xShift += textLeftSpace;
            }
            textTop = $text.btPosition().top + numb($text.css('margin-top'));
            textLeft = $text.btPosition().left + numb($text.css('margin-left'));
            textRight = textLeft + $text.btOuterWidth();
            textBottom = textTop + $text.outerHeight();
            textCenter = {x: textLeft + ($text.btOuterWidth()*opts.centerPointX), y: textTop + ($text.outerHeight()*opts.centerPointY)};
            // points[points.length] = {x: x, y: y};
            points[points.length] = spikePoint = {y: textBottom + opts.spikeLength, x: ((textRight-textLeft) * .5) + xShift, type: 'spike'};
            crossPoint = findIntersectX(spikePoint.x, spikePoint.y, textCenter.x, textCenter.y, textBottom);
            // make sure that the crossPoint is not outside of text box boundaries
            crossPoint.x = crossPoint.x < textLeft + opts.spikeGirth/2 + opts.cornerRadius ? textLeft + opts.spikeGirth/2 + opts.cornerRadius : crossPoint.x;
            crossPoint.x =  crossPoint.x > (textRight - opts.spikeGirth/2) - opts.cornerRadius ? (textRight - opts.spikeGirth/2) - opts.CornerRadius : crossPoint.x;
            points[points.length] = {x: crossPoint.x - (opts.spikeGirth/2), y: textBottom, type: 'join'};
            points[points.length] = {x: textLeft, y: textBottom, type: 'corner'};  // left bottom corner
            points[points.length] = {x: textLeft, y: textTop, type: 'corner'};     // left top corner
            points[points.length] = {x: textRight, y: textTop, type: 'corner'};    // right top corner
            points[points.length] = {x: textRight, y: textBottom, type: 'corner'}; // right bottom corner
            points[points.length] = {x: crossPoint.x + (opts.spikeGirth/2), y: textBottom, type: 'join'};
            points[points.length] = spikePoint;
            break;

          // =================== LEFT =======================
          case 'left':
            // spike on right
            $text.css('margin-right', opts.spikeLength + 'px');
            $box.css({top: vert + 'px', left: ((left - $text.btOuterWidth(true)) + opts.overlap) + 'px'});
            // move text up/down if extends out of window
            textBottomSpace = (winBottom - opts.windowMargin) - ($text.offset().top + $text.outerHeight(true));
            var yShift = shadowShiftY;
            if (textBottomSpace < 0) {
              // shift it up
              $box.css('top', (numb($box.css('top')) + textBottomSpace) + 'px');
              yShift -= textBottomSpace;
            }
            // we ensure top space second to ensure that top of box is visible
            textTopSpace = ($text.offset().top + numb($text.css('margin-top'))) - (scrollTop + opts.windowMargin);
            if (textTopSpace < 0) {
              // shift it down
              $box.css('top', (numb($box.css('top')) - textTopSpace) + 'px');
              yShift += textTopSpace;
            }
            textTop = $text.btPosition().top + numb($text.css('margin-top'));
            textLeft = $text.btPosition().left + numb($text.css('margin-left'));
            textRight = textLeft + $text.btOuterWidth();
            textBottom = textTop + $text.outerHeight();
            textCenter = {x: textLeft + ($text.btOuterWidth()*opts.centerPointX), y: textTop + ($text.outerHeight()*opts.centerPointY)};
            points[points.length] = spikePoint = {x: textRight + opts.spikeLength, y: ((textBottom-textTop) * .5) + yShift, type: 'spike'};
            crossPoint = findIntersectY(spikePoint.x, spikePoint.y, textCenter.x, textCenter.y, textRight);
            // make sure that the crossPoint is not outside of text box boundaries
            crossPoint.y = crossPoint.y < textTop + opts.spikeGirth/2 + opts.cornerRadius ? textTop + opts.spikeGirth/2 + opts.cornerRadius : crossPoint.y;
            crossPoint.y =  crossPoint.y > (textBottom - opts.spikeGirth/2) - opts.cornerRadius ? (textBottom - opts.spikeGirth/2) - opts.cornerRadius : crossPoint.y;
            points[points.length] = {x: textRight, y: crossPoint.y + opts.spikeGirth/2, type: 'join'};
            points[points.length] = {x: textRight, y: textBottom, type: 'corner'}; // right bottom corner
            points[points.length] = {x: textLeft, y: textBottom, type: 'corner'};  // left bottom corner
            points[points.length] = {x: textLeft, y: textTop, type: 'corner'};     // left top corner
            points[points.length] = {x: textRight, y: textTop, type: 'corner'};    // right top corner
            points[points.length] = {x: textRight, y: crossPoint.y - opts.spikeGirth/2, type: 'join'};
            points[points.length] = spikePoint;
            break;

          // =================== BOTTOM =======================
          case 'bottom':
            // spike on top
            $text.css('margin-top', opts.spikeLength + 'px');
            $box.css({top: (top + height) - opts.overlap, left: horiz});
            // move text up/down if extends out of window
            textRightSpace = (winRight - opts.windowMargin) - ($text.offset().left + $text.btOuterWidth(true));
            var xShift = shadowShiftX;
            if (textRightSpace < 0) {
              // shift it left
              $box.css('left', (numb($box.css('left')) + textRightSpace) + 'px');
              xShift -= textRightSpace;
            }
            // we ensure left space second to ensure that left of box is visible
            textLeftSpace = ($text.offset().left + numb($text.css('margin-left')))  - (scrollLeft + opts.windowMargin);
            if (textLeftSpace < 0) {
              // shift it right
              $box.css('left', (numb($box.css('left')) - textLeftSpace) + 'px');
              xShift += textLeftSpace;
            }
            textTop = $text.btPosition().top + numb($text.css('margin-top'));
            textLeft = $text.btPosition().left + numb($text.css('margin-left'));
            textRight = textLeft + $text.btOuterWidth();
            textBottom = textTop + $text.outerHeight();
            textCenter = {x: textLeft + ($text.btOuterWidth()*opts.centerPointX), y: textTop + ($text.outerHeight()*opts.centerPointY)};
            points[points.length] = spikePoint = {x: ((textRight-textLeft) * .5) + xShift, y: shadowShiftY, type: 'spike'};
            crossPoint = findIntersectX(spikePoint.x, spikePoint.y, textCenter.x, textCenter.y, textTop);
            // make sure that the crossPoint is not outside of text box boundaries
            crossPoint.x = crossPoint.x < textLeft + opts.spikeGirth/2 + opts.cornerRadius ? textLeft + opts.spikeGirth/2 + opts.cornerRadius : crossPoint.x;
            crossPoint.x =  crossPoint.x > (textRight - opts.spikeGirth/2) - opts.cornerRadius ? (textRight - opts.spikeGirth/2) - opts.cornerRadius : crossPoint.x;
            points[points.length] = {x: crossPoint.x + opts.spikeGirth/2, y: textTop, type: 'join'};
            points[points.length] = {x: textRight, y: textTop, type: 'corner'};    // right top corner
            points[points.length] = {x: textRight, y: textBottom, type: 'corner'}; // right bottom corner
            points[points.length] = {x: textLeft, y: textBottom, type: 'corner'};  // left bottom corner
            points[points.length] = {x: textLeft, y: textTop, type: 'corner'};     // left top corner
            points[points.length] = {x: crossPoint.x - (opts.spikeGirth/2), y: textTop, type: 'join'};
            points[points.length] = spikePoint;
            break;

          // =================== RIGHT =======================
          case 'right':
            // spike on left
            $text.css('margin-left', (opts.spikeLength + 'px'));
            $box.css({top: vert + 'px', left: ((left + width) - opts.overlap) + 'px'});
            // move text up/down if extends out of window
            textBottomSpace = (winBottom - opts.windowMargin) - ($text.offset().top + $text.outerHeight(true));
            var yShift = shadowShiftY;
            if (textBottomSpace < 0) {
              // shift it up
              $box.css('top', (numb($box.css('top')) + textBottomSpace) + 'px');
              yShift -= textBottomSpace;
            }
            // we ensure top space second to ensure that top of box is visible
            textTopSpace = ($text.offset().top + numb($text.css('margin-top'))) - (scrollTop + opts.windowMargin);
            if (textTopSpace < 0) {
              // shift it down
              $box.css('top', (numb($box.css('top')) - textTopSpace) + 'px');
              yShift += textTopSpace;
            }
            textTop = $text.btPosition().top + numb($text.css('margin-top'));
            textLeft = $text.btPosition().left + numb($text.css('margin-left'));
            textRight = textLeft + $text.btOuterWidth();
            textBottom = textTop + $text.outerHeight();
            textCenter = {x: textLeft + ($text.btOuterWidth()*opts.centerPointX), y: textTop + ($text.outerHeight()*opts.centerPointY)};
            points[points.length] = spikePoint = {x: shadowShiftX, y: ((textBottom-textTop) * .5) + yShift, type: 'spike'};
            crossPoint = findIntersectY(spikePoint.x, spikePoint.y, textCenter.x, textCenter.y, textLeft);
            // make sure that the crossPoint is not outside of text box boundaries
            crossPoint.y = crossPoint.y < textTop + opts.spikeGirth/2 + opts.cornerRadius ? textTop + opts.spikeGirth/2 + opts.cornerRadius : crossPoint.y;
            crossPoint.y =  crossPoint.y > (textBottom - opts.spikeGirth/2) - opts.cornerRadius ? (textBottom - opts.spikeGirth/2) - opts.cornerRadius : crossPoint.y;
            points[points.length] = {x: textLeft, y: crossPoint.y - opts.spikeGirth/2, type: 'join'};
            points[points.length] = {x: textLeft, y: textTop, type: 'corner'};     // left top corner
            points[points.length] = {x: textRight, y: textTop, type: 'corner'};    // right top corner
            points[points.length] = {x: textRight, y: textBottom, type: 'corner'}; // right bottom corner
            points[points.length] = {x: textLeft, y: textBottom, type: 'corner'};  // left bottom corner
            points[points.length] = {x: textLeft, y: crossPoint.y + opts.spikeGirth/2, type: 'join'};
            points[points.length] = spikePoint;
            break;
        } // </ switch >

        var canvas = document.createElement('canvas');
        $(canvas).attr('width', (numb($text.btOuterWidth(true)) + opts.strokeWidth*2 + shadowMarginX)).attr('height', (numb($text.outerHeight(true)) + opts.strokeWidth*2 + shadowMarginY)).appendTo($box).css({position: 'absolute', zIndex: opts.boxzIndex});


        // if excanvas is set up, we need to initialize the new canvas element
        if (typeof G_vmlCanvasManager != 'undefined') {
          canvas = G_vmlCanvasManager.initElement(canvas);
        }

        if (opts.cornerRadius > 0) {
          // round the corners!
          var newPoints = new Array();
          var newPoint;
          for (var i=0; i<points.length; i++) {
            if (points[i].type == 'corner') {
              // create two new arc points
              // find point between this and previous (using modulo in case of ending)
              newPoint = betweenPoint(points[i], points[(i-1)%points.length], opts.cornerRadius);
              newPoint.type = 'arcStart';
              newPoints[newPoints.length] = newPoint;
              // the original corner point
              newPoints[newPoints.length] = points[i];
              // find point between this and next
              newPoint = betweenPoint(points[i], points[(i+1)%points.length], opts.cornerRadius);
              newPoint.type = 'arcEnd';
              newPoints[newPoints.length] = newPoint;
            }
            else {
              newPoints[newPoints.length] = points[i];
            }
          }
          // overwrite points with new version
          points = newPoints;
        }

        var ctx = canvas.getContext("2d");

        if (opts.shadow && opts.shadowOverlap !== true) {

          var shadowOverlap = numb(opts.shadowOverlap);

          // keep the shadow (and canvas) from overlapping the target element
          switch (position) {
            case 'top':
              if (opts.shadowOffsetX + opts.shadowBlur - shadowOverlap > 0) {
                $box.css('top', (numb($box.css('top')) - (opts.shadowOffsetX + opts.shadowBlur - shadowOverlap)));
              }
              break;
            case 'right':
              if (shadowShiftX - shadowOverlap > 0) {
                $box.css('left', (numb($box.css('left')) + shadowShiftX - shadowOverlap));
              }
              break;
            case 'bottom':
              if (shadowShiftY - shadowOverlap > 0) {
                $box.css('top', (numb($box.css('top')) + shadowShiftY - shadowOverlap));
              }
              break;
            case 'left':
              if (opts.shadowOffsetY + opts.shadowBlur - shadowOverlap > 0) {
                $box.css('left', (numb($box.css('left')) - (opts.shadowOffsetY + opts.shadowBlur - shadowOverlap)));
              }
              break;
          }
        }

        drawIt.call(ctx, points, opts.strokeWidth);
        ctx.fillStyle = opts.fill;
        if (opts.shadow) {
          ctx.shadowOffsetX = opts.shadowOffsetX;
          ctx.shadowOffsetY = opts.shadowOffsetY;
          ctx.shadowBlur = opts.shadowBlur;
          ctx.shadowColor =  opts.shadowColor;
        }
        ctx.closePath();
        ctx.fill();
        if (opts.strokeWidth > 0) {
          ctx.shadowColor = 'rgba(0, 0, 0, 0)'; //remove shadow from stroke
          ctx.lineWidth = opts.strokeWidth;
          ctx.strokeStyle = opts.strokeStyle;
          ctx.beginPath();
          drawIt.call(ctx, points, opts.strokeWidth);
          ctx.closePath();
          ctx.stroke();
        }

        // trigger preShow function
        // function receives the box element (the balloon wrapper div) as an argument
        opts.preShow.apply(this, [$box[0]]);

        // switch from visibility: hidden to display: none so we can run animations
        $box.css({display:'none', visibility: 'visible'});

        // Here's where we show the tip
        opts.showTip.apply(this, [$box[0]]);

        if (opts.overlay) {
          // EXPERIMENTAL AND FOR TESTING ONLY!!!!
          var overlay = $('<div class="bt-overlay"></div>').css({
              position: 'absolute',
              backgroundColor: 'blue',
              top: top,
              left: left,
              width: width,
              height: height,
              opacity: '.2'
            }).appendTo(offsetParent);
          $(this).data('overlay', overlay);
        }

        if ((opts.ajaxPath != null && opts.ajaxCache == false) || ajaxTimeout) {
          // if ajaxCache is not enabled or if there was a server timeout,
          // remove the content variable so it will be loaded again from server
          content = false;
        }

        // stick this element into the clickAnywhereToClose stack
        if (opts.clickAnywhereToClose) {
          jQuery.bt.vars.clickAnywhereStack.push(this);
          $(document).on('mousedown', jQuery.bt.docClick);
        }

        // stick this element into the closeWhenOthersOpen stack
        if (opts.closeWhenOthersOpen) {
          jQuery.bt.vars.closeWhenOpenStack.push(this);
        }

        // trigger postShow function
        // function receives the box element (the balloon wrapper div) as an argument
        if (_.isFunction(opts.postShow))
        { opts.postShow.apply(this, [$box[0]]); }


      }; // </ turnOn() >

      this.btOff = function() {

        var box = $(this).data('bt-box');

        // trigger preHide function
        // function receives the box element (the balloon wrapper div) as an argument
        opts.preHide.apply(this, [box]);

        var i = this;

        // set up the stuff to happen AFTER the tip is hidden
        i.btCleanup = function(){
          var box = $(i).data('bt-box');
          var contentOrig = $(i).data('bt-content-orig');
          var overlay = $(i).data('bt-overlay');
          if (!$.isBlank(box) && typeof box == 'object') {
            $(box).remove();
            $(i).removeData('bt-box');
          }
          if (!$.isBlank(contentOrig) && typeof contentOrig == 'object') {
            var clones = $(contentOrig.original).data('bt-clones');
            $(contentOrig).data('bt-clones', arrayRemove(clones, contentOrig.clone));
          }
          if (!$.isBlank(overlay) && typeof overlay == 'object') {
            $(overlay).remove();
            $(i).removeData('bt-overlay');
          }

          // remove this from the stacks
          jQuery.bt.vars.clickAnywhereStack = arrayRemove(jQuery.bt.vars.clickAnywhereStack, i);
          jQuery.bt.vars.closeWhenOpenStack = arrayRemove(jQuery.bt.vars.closeWhenOpenStack, i);

          // remove the 'bt-active' and activeClass classes from target
          $(i).removeClass('bt-active ' + opts.activeClass);

          // trigger postHide function
          // no box argument since it has been removed from the DOM
          opts.postHide.apply(i);

        }

        opts.hideTip.apply(this, [box, i.btCleanup]);

      }; // </ turnOff() >

      var refresh = this.btRefresh = function() {
        this.btOff();
        this.btOn();
      };

      this.btDestroy = function() {
          $(this).off('.' + this._internalId);
      };

      /**
       * This is sort of the "starting spot" for the this.each()
       * These are the init functions to handle the .bt() call
       */

      if (opts.killTitle) {
        $(this).find('[title]').addBack().each(function() {
          if (!$(this).attr('bt-xTitle')) {
            $(this).attr('bt-xTitle', $(this).attr('title'));
            $(this).attr('title', '');
          }
        });
      }

      if (typeof opts.trigger == 'string') {
        opts.trigger = [opts.trigger];
      }
      if (opts.trigger[0] == 'hoverIntent') {
        var hoverOpts = jQuery.extend(opts.hoverIntentOpts, {
          over: function() {
            this.btOn();
          },
          out: function() {
            this.btOff();
          }});
        $(this).hoverIntent(hoverOpts);

      }
      else if (opts.trigger[0] == 'hover') {
        var isHover = false;
        $(this).on('mouseenter.' + this._internalId, function() {
            if (!isHover)
            {
                isHover = true;
                this.btOn();
            }
          })
        .on('mouseleave.' + this._internalId, function() {
            isHover = false;
            this.btOff();
          }
        );
      }
      else if (opts.trigger[0] == 'now') {
        // toggle the on/off right now
        // note that 'none' gives more control (see below)
        if ($(this).hasClass('bt-active')) {
          this.btOff();
        }
        else {
          this.btOn();
        }
      }
      else if (opts.trigger[0] == 'none') {
        // initialize the tip with no event trigger
        // use javascript to turn on/off tip as follows:
        // $('#selector').btOn();
        // $('#selector').btOff();
      }
      else if (opts.trigger.length > 1 && opts.trigger[0] != opts.trigger[1]) {
        $(this)
          .on(opts.trigger[0] + '.' + this._internalId, function() {
            this.btOn();
          })
          .on(opts.trigger[1] + '.' + this._internalId, function() {
            this.btOff();
          });
      }
      else {
        // toggle using the same event
        $(this).on(opts.trigger[0] + '.' + this._internalId, function() {
          if ($(this).hasClass('bt-active')) {
            this.btOff();
          }
          else {
            this.btOn();
          }
        });
      }

    }); // </ this.each() >


    function drawIt(points, strokeWidth) {
      this.moveTo(points[0].x, points[0].y);
      for (i=1;i<points.length;i++) {
        if (points[i-1].type == 'arcStart') {
          // if we're creating a rounded corner
          //ctx.arc(round5(points[i].x), round5(points[i].y), points[i].startAngle, points[i].endAngle, opts.cornerRadius, false);
          this.quadraticCurveTo(round5(points[i].x, strokeWidth), round5(points[i].y, strokeWidth), round5(points[(i+1)%points.length].x, strokeWidth), round5(points[(i+1)%points.length].y, strokeWidth));
          i++;
          //ctx.moveTo(round5(points[i].x), round5(points[i].y));
        }
        else {
          this.lineTo(round5(points[i].x, strokeWidth), round5(points[i].y, strokeWidth));
        }
      }
    }; // </ drawIt() >

    /**
     * For odd stroke widths, round to the nearest .5 pixel to avoid antialiasing
     * http://developer.mozilla.org/en/Canvas_tutorial/Applying_styles_and_colors
     */
    function round5(num, strokeWidth) {
      var ret;
      strokeWidth = numb(strokeWidth);
      if (strokeWidth%2) {
        ret = num;
      }
      else {
        ret = Math.round(num - .5) + .5;
      }
      return ret;
    }; // </ round5() >

    /**
     * Ensure that a number is a number... or zero
     */
    function numb(num) {
      return parseInt(num) || 0;
    }; // </ numb() >

    /**
     * Remove an element from an array
     */
    function arrayRemove(arr, elem) {
      var x, newArr = new Array();
      for (x in arr) {
        if (arr[x] != elem) {
          newArr.push(arr[x]);
        }
      }
      return newArr;
    }; // </ arrayRemove() >

    /**
     * Does the current browser support canvas?
     * This is a variation of http://code.google.com/p/browser-canvas-support/
     */
    function canvasSupport() {
      var canvas_compatible = false;
      try {
        canvas_compatible = !!(document.createElement('canvas').getContext('2d')); // S60
      } catch(e) {
        canvas_compatible = !!(document.createElement('canvas').getContext); // IE
      }
      return canvas_compatible;
    }

    /**
     * Does the current browser support canvas drop shadows?
     */
    function shadowSupport() {

      // to test for drop shadow support in the current browser, uncomment the next line
      // return true;

      // until a good feature-detect is found, we have to look at user agents
      try {
        var userAgent = navigator.userAgent.toLowerCase();
        if (/webkit/.test(userAgent)) {
          // WebKit.. let's go!
          return true;
        }
        else if (/gecko|mozilla/.test(userAgent) && parseFloat(userAgent.match(/firefox\/(\d+(?:\.\d+)+)/)[1]) >= 3.1){
          // Mozilla 3.1 or higher
          return true;
        }
      }
      catch(err) {
        // if there's an error, just keep going, we'll assume that drop shadows are not supported
      }

      return false;

    } // </ shadowSupport() >

    /**
     * Given two points, find a point which is dist pixels from point1 on a line to point2
     */
    function betweenPoint(point1, point2, dist) {
      // figure out if we're horizontal or vertical
      var y, x;
      if (point1.x == point2.x) {
        // vertical
        y = point1.y < point2.y ? point1.y + dist : point1.y - dist;
        return {x: point1.x, y: y};
      }
      else if (point1.y == point2.y) {
        // horizontal
        x = point1.x < point2.x ? point1.x + dist : point1.x - dist;
        return {x:x, y: point1.y};
      }
    }; // </ betweenPoint() >

    function centerPoint(arcStart, corner, arcEnd) {
      var x = corner.x == arcStart.x ? arcEnd.x : arcStart.x;
      var y = corner.y == arcStart.y ? arcEnd.y : arcStart.y;
      var startAngle, endAngle;
      if (arcStart.x < arcEnd.x) {
        if (arcStart.y > arcEnd.y) {
          // arc is on upper left
          startAngle = (Math.PI/180)*180;
          endAngle = (Math.PI/180)*90;
        }
        else {
          // arc is on upper right
          startAngle = (Math.PI/180)*90;
          endAngle = 0;
        }
      }
      else {
        if (arcStart.y > arcEnd.y) {
          // arc is on lower left
          startAngle = (Math.PI/180)*270;
          endAngle = (Math.PI/180)*180;
        }
        else {
          // arc is on lower right
          startAngle = 0;
          endAngle = (Math.PI/180)*270;
        }
      }
      return {x: x, y: y, type: 'center', startAngle: startAngle, endAngle: endAngle};
    }; // </ centerPoint() >

    /**
     * Find the intersection point of two lines, each defined by two points
     * arguments are x1, y1 and x2, y2 for r1 (line 1) and r2 (line 2)
     * It's like an algebra party!!!
     */
    function findIntersect(r1x1, r1y1, r1x2, r1y2, r2x1, r2y1, r2x2, r2y2) {

      if (r2x1 == r2x2) {
        return findIntersectY(r1x1, r1y1, r1x2, r1y2, r2x1);
      }
      if (r2y1 == r2y2) {
        return findIntersectX(r1x1, r1y1, r1x2, r1y2, r2y1);
      }

      // m = (y1 - y2) / (x1 - x2)  // <-- how to find the slope
      // y = mx + b                 // the 'classic' linear equation
      // b = y - mx                 // how to find b (the y-intersect)
      // x = (y - b)/m              // how to find x
      var r1m = (r1y1 - r1y2) / (r1x1 - r1x2);
      var r1b = r1y1 - (r1m * r1x1);
      var r2m = (r2y1 - r2y2) / (r2x1 - r2x2);
      var r2b = r2y1 - (r2m * r2x1);

      var x = (r2b - r1b) / (r1m - r2m);
      var y = r1m * x + r1b;

      return {x: x, y: y};
    }; // </ findIntersect() >

    /**
     * Find the y intersection point of a line and given x vertical
     */
    function findIntersectY(r1x1, r1y1, r1x2, r1y2, x) {
      if (r1y1 == r1y2) {
        return {x: x, y: r1y1};
      }
      var r1m = (r1y1 - r1y2) / (r1x1 - r1x2);
      var r1b = r1y1 - (r1m * r1x1);

      var y = r1m * x + r1b;

      return {x: x, y: y};
    }; // </ findIntersectY() >

    /**
     * Find the x intersection point of a line and given y horizontal
     */
    function findIntersectX(r1x1, r1y1, r1x2, r1y2, y) {
      if (r1x1 == r1x2) {
        return {x: r1x1, y: y};
      }
      var r1m = (r1y1 - r1y2) / (r1x1 - r1x2);
      var r1b = r1y1 - (r1m * r1x1);

      // y = mx + b     // your old friend, linear equation
      // x = (y - b)/m  // linear equation solved for x
      var x = (y - r1b) / r1m;

      return {x: x, y: y};

    }; // </ findIntersectX() >

  }; // </ jQuery.fn.bt() >

  /**
   * jQuery's compat.js (used in Drupal's jQuery upgrade module, overrides the $().position() function
   *  this is a copy of that function to allow the plugin to work when compat.js is present
   *  once compat.js is fixed to not override existing functions, this function can be removed
   *  and .btPosion() can be replaced with .position() above...
   */
  jQuery.fn.btPosition = function() {

    function num(elem, prop) {
      return elem[0] && parseInt( jQuery.curCSS(elem[0], prop, true), 10 ) || 0;
    };

    var left = 0, top = 0, results;

    if ( this[0] ) {
      // Get *real* offsetParent
      var offsetParent = this.offsetParent(),

      // Get correct offsets
      offset       = this.offset(),
      parentOffset = /^body|html$/i.test(offsetParent[0].tagName) ? { top: 0, left: 0 } : offsetParent.offset();

      // Subtract element margins
      // note: when an element has margin: auto the offsetLeft and marginLeft
      // are the same in Safari causing offset.left to incorrectly be 0
      offset.top  -= num( this, 'marginTop' );
      offset.left -= num( this, 'marginLeft' );

      // Add offsetParent borders
      parentOffset.top  += num( offsetParent, 'borderTopWidth' );
      parentOffset.left += num( offsetParent, 'borderLeftWidth' );

      // Subtract the two offsets
      results = {
        top:  offset.top  - parentOffset.top,
        left: offset.left - parentOffset.left
      };
    }

    return results;
  }; // </ jQuery.fn.btPosition() >


  /**
  * jQuery's dimensions.js overrides the $().btOuterWidth() function
  *  this is a copy of original jQuery's outerWidth() function to
  *  allow the plugin to work when dimensions.js is present
  *  Giacomo Ferrari <giacomo.ferrari@socrata.com> 5/31/2013: This doesn't work
  *  with SVGElements. Patched so that it does.
  */
  jQuery.fn.btOuterWidth = function(margin) {

      function num(elem, prop) {
          return elem[0] && parseInt(jQuery.curCSS(elem[0], prop, true), 10) || 0;
      };

      if (window.SVGElement && this[0] instanceof SVGElement) {
          return this[0].getBoundingClientRect().width;
      }
      else {
          return this["innerWidth"]()
          + num(this, "borderLeftWidth")
          + num(this, "borderRightWidth")
          + (margin ? num(this, "marginLeft")
          + num(this, "marginRight") : 0);
      }

  }; // </ jQuery.fn.btOuterWidth() >

  /**
  *  Giacomo Ferrari <giacomo.ferrari@socrata.com> 5/31/2013: Regular outerHeight
  *  doesn't work with SVG elements. This does.
  */
  jQuery.fn.btOuterHeight = function() {

      if (window.SVGElement && this[0] instanceof SVGElement) {
          return this[0].getBoundingClientRect().height;
      }
      else {
          return this.outerHeight();
      }

  }; // </ jQuery.fn.btOuterHeight() >

  /**
   * A convenience function to run btOn() (if available)
   * for each selected item
   */
  jQuery.fn.btOn = function() {
    return this.each(function(index){
      if (jQuery.isFunction(this.btOn)) {
        this.btOn();
      }
    });
  }; // </ $().btOn() >

  /**
   *
   * A convenience function to run btOff() (if available)
   * for each selected item
   */
  jQuery.fn.btOff = function() {
    return this.each(function(index){
      if (jQuery.isFunction(this.btOff)) {
        this.btOff();
      }
    });
  }; // </ $().btOff() >

  jQuery.fn.btDestroy = function() {
    return this.each(function(index){
      if (jQuery.isFunction(this.btDestroy)) {
        this.btDestroy();
      }
    });
  }; // </ $().btDestroy() >

  jQuery.bt.vars = {clickAnywhereStack: [], closeWhenOpenStack: []};

  /**
   * This function gets bound to the document's click event
   * It turns off all of the tips in the click-anywhere-to-close stack
   */
  jQuery.bt.docClick = function(e) {
    if (!e) {
      var e = window.event;
    };
    // if clicked element is a child of neither a tip NOR a target
    // and there are tips in the stack
    if (!$(e.target).parents().addBack().filter('.bt-wrapper, .bt-active').length && jQuery.bt.vars.clickAnywhereStack.length) {
      // if clicked element isn't inside tip, close tips in stack
      $(jQuery.bt.vars.clickAnywhereStack).btOff();
      $(document).off('click', jQuery.bt.docClick);
    }
  }; // </ docClick() >

  /**
   * Defaults for the beauty tips
   *
   * Note this is a variable definition and not a function. So defaults can be
   * written for an entire page by simply redefining attributes like so:
   *
   *   jQuery.bt.options.width = 400;
   *
   * Be sure to use *jQuery.bt.options* and not jQuery.bt.defaults when overriding
   *
   * This would make all Beauty Tips boxes 400px wide.
   *
   * Each of these options may also be overridden during
   *
   * Can be overriden globally or at time of call.
   *
   */
  jQuery.bt.defaults = {
    trigger:         'hover',                // trigger to show/hide tip
                                             // use [on, off] to define separate on/off triggers
                                             // also use space character to allow multiple  to trigger
                                             // examples:
                                             //   ['focus', 'blur'] // focus displays, blur hides
                                             //   'dblclick'        // dblclick toggles on/off
                                             //   ['focus mouseover', 'blur mouseout'] // multiple triggers
                                             //   'now'             // shows/hides tip without event
                                             //   'none'            // use $('#selector').btOn(); and ...btOff();
                                             //   'hoverIntent'     // hover using hoverIntent plugin (settings below)
                                             // note:
                                             //   hoverIntent becomes default if available

    clickAnywhereToClose: true,              // clicking anywhere outside of the tip will close it
    closeWhenOthersOpen: false,              // tip will be closed before another opens - stop >= 2 tips being on

    shrinkToFit:      false,                 // should short single-line content get a narrower balloon?
    width:            '200px',               // width of tooltip box

    padding:          '10px',                // padding for content (get more fine grained with cssStyles)
    spikeGirth:       10,                    // width of spike
    spikeLength:      15,                    // length of spike
    overlap:          0,                     // spike overlap (px) onto target (can cause problems with 'hover' trigger)
    overlay:          false,                 // display overlay on target (use CSS to style) -- BUGGY!
    killTitle:        true,                  // kill title tags to avoid double tooltips

    textzIndex:       9999,                  // z-index for the text
    boxzIndex:        9998,                  // z-index for the "talk" box (should always be less than textzIndex)
    wrapperzIndex:    9997,
    offsetParent:     null,                  // DOM node to append the tooltip into.
                                             // Must be positioned relative or absolute. Can be selector or object
    positions:        ['most'],              // preference of positions for tip (will use first with available space)
                                             // possible values 'top', 'bottom', 'left', 'right', 'top-left', 'top-right',
                                             // 'bottom-left', and 'bottom-right' as an array in order of
                                             // preference. Last value will be used if others don't have enough space.
                                             // or use 'most' to use the area with the most space
    fill:             "rgb(255, 255, 102)",  // fill color for the tooltip box, you can use any CSS-style color definition method
                                             // http://www.w3.org/TR/css3-color/#numerical - not all methods have been tested

    windowMargin:     10,                    // space (px) to leave between text box and browser edge

    strokeWidth:      1,                     // width of stroke around box, **set to 0 for no stroke**
    strokeStyle:      "#000",                // color/alpha of stroke

    cornerRadius:     5,                     // radius of corners (px), set to 0 for square corners

                      // following values are on a scale of 0 to 1 with .5 being centered

    centerPointX:     .5,                    // the spike extends from center of the target edge to this point
    centerPointY:     .5,                    // defined by percentage horizontal (x) and vertical (y)

    shadow:           false,                 // use drop shadow? (only displays in Safari and FF 3.1) - experimental
    shadowOffsetX:    2,                     // shadow offset x (px)
    shadowOffsetY:    2,                     // shadow offset y (px)
    shadowBlur:       3,                     // shadow blur (px)
    shadowColor:      "#000",                // shadow color/alpha
    shadowOverlap:   false,                  // when shadows overlap the target element it can cause problem with hovering
                                             // set this to true to overlap or set to a numeric value to define the amount of overlap
    noShadowOpts:     {strokeStyle: '#999'},  // use this to define 'fall-back' options for browsers which don't support drop shadows

    cssClass:         '',                    // CSS class to add to the box wrapper div (of the TIP)
    cssStyles:        {},                    // styles to add the text box
                                             //   example: {fontFamily: 'Georgia, Times, serif', fontWeight: 'bold'}

    activeClass:      'bt-active',           // class added to TARGET element when its BeautyTip is active

    content: null,                           // option to pass in an object for the content
    contentSelector:  "$(this).attr('title')", // if there is no content argument, use this selector to retrieve the title
                                             // a function which returns the content may also be passed here

    ajaxPath:         null,                  // if using ajax request for content, this contains url and (opt) selector
                                             // this will override content and contentSelector
                                             // examples (see jQuery load() function):
                                             //   '/demo.html'
                                             //   '/help/ajax/snip'
                                             //   '/help/existing/full div#content'

                                             // ajaxPath can also be defined as an array
                                             // in which case, the first value will be parsed as a jQuery selector
                                             // the result of which will be used as the ajaxPath
                                             // the second (optional) value is the content selector as above
                                             // examples:
                                             //    ["$(this).attr('href')", 'div#content']
                                             //    ["$(this).parents('.wrapper').find('.title').attr('href')"]
                                             //    ["$('#some-element').val()"]

    ajaxError:        '<strong>ERROR:</strong> <em>%error</em>',
                                             // error text, use "%error" to insert error from server
    ajaxLoading:     '<blink>Loading...</blink>',  // yes folks, it's the blink tag!
    ajaxData:         {},                    // key/value pairs
    ajaxType:         'GET',                 // 'GET' or 'POST'
    ajaxCache:        true,                  // cache ajax results and do not send request to same url multiple times
    ajaxOpts:         {},                    // any other ajax options - timeout, passwords, processing functions, etc...
                                             // see http://docs.jquery.com/Ajax/jQuery.ajax#options

    preBuild:         function(){},          // function to run before popup is built
    preShow:          function(box){},       // function to run before popup is displayed
    showTip:          function(box){
                        $(box).show();
                      },
    postShow:         function(box){},       // function to run after popup is built and displayed

    preHide:          function(box){},       // function to run before popup is removed
    hideTip:          function(box, callback) {
                        $(box).hide();
                        callback();   // you MUST call "callback" at the end of your animations
                      },
    postHide:         function(){},          // function to run after popup is removed

    hoverIntentOpts:  {                          // options for hoverIntent (if installed)
                        interval: 300,           // http://cherne.net/brian/resources/jquery.hoverIntent.html
                        timeout: 500
                      }

  }; // </ jQuery.bt.defaults >

  jQuery.bt.options = {};

})(jQuery);

// @todo
// use larger canvas (extend to edge of page when windowMargin is active)
// add options to shift position of tip vert/horiz and position of spike tip
// create drawn (canvas) shadows
// use overlay to allow overlap with hover
// experiment with making tooltip a subelement of the target
// handle non-canvas-capable browsers elegantly

}.call(window));

/***/ }),

/***/ 2973:
/***/ (function(module, exports) {

/*** IMPORTS FROM imports-loader ***/
var define = undefined;
var require = undefined;
var module = undefined;
var exports = undefined;
(function() {

/*
 * CAUTION: This file (and everything in this directory) is marked as noParse
 * in our Webpack configuration. This means it cannot import modules, and that
 * it will not be transpiled to ES5. Do *NOT* use any ES6 features that our
 * supported browsers don't support natively (i.e., IE11 does not support arrow
 * functions).
 */

/**
 * Copyright (c) 2005 - 2009, James Auldridge
 * All rights reserved.
 *
 * Licensed under the BSD, MIT, and GPL (your choice!) Licenses:
 *  http://code.google.com/p/cookies/wiki/License
 *
 */
var jaaulde=window.jaaulde||{};jaaulde.utils=jaaulde.utils||{};jaaulde.utils.cookies=(function()
{var cookies=[];var defaultOptions={hoursToLive:null,path:'/',domain:null,secure:false};var resolveOptions=function(options)
{var returnValue;if(typeof options!=='object'||options===null)
{returnValue=defaultOptions;}
else
{returnValue={hoursToLive:(typeof options.hoursToLive==='number'&&options.hoursToLive!==0?options.hoursToLive:defaultOptions.hoursToLive),path:(typeof options.path==='string'&&options.path!==''?options.path:defaultOptions.path),domain:(typeof options.domain==='string'&&options.domain!==''?options.domain:defaultOptions.domain),secure:(typeof options.secure==='boolean'&&options.secure?options.secure:defaultOptions.secure)};}
return returnValue;};var expiresGMTString=function(hoursToLive)
{var dateObject=new Date();dateObject.setTime(dateObject.getTime()+(hoursToLive*60*60*1000));return dateObject.toGMTString();};var assembleOptionsString=function(options)
{options=resolveOptions(options);return((typeof options.hoursToLive==='number'?'; expires='+expiresGMTString(options.hoursToLive):'')+'; path='+options.path+
(typeof options.domain==='string'?'; domain='+options.domain:'')+
(options.secure===true?'; secure':''));};var splitCookies=function()
{cookies={};var pair,name,value,separated=document.cookie.split(';');for(var i=0;i<separated.length;i=i+1)
{pair=separated[i].split('=');name=pair[0].replace(/^\s*/,'').replace(/\s*$/,'');value=decodeURIComponent(pair[1]);cookies[name]=value;}
return cookies;};var constructor=function(){};constructor.prototype.get=function(cookieName)
{var returnValue;splitCookies();if(typeof cookieName==='string')
{returnValue=(typeof cookies[cookieName]!=='undefined')?cookies[cookieName]:null;}
else if(typeof cookieName==='object'&&cookieName!==null)
{returnValue={};for(var item in cookieName)
{if(typeof cookies[cookieName[item]]!=='undefined')
{returnValue[cookieName[item]]=cookies[cookieName[item]];}
else
{returnValue[cookieName[item]]=null;}}}
else
{returnValue=cookies;}
return returnValue;};constructor.prototype.filter=function(cookieNameRegExp)
{var returnValue={};splitCookies();if(typeof cookieNameRegExp==='string')
{cookieNameRegExp=new RegExp(cookieNameRegExp);}
for(var cookieName in cookies)
{if(cookieName.match(cookieNameRegExp))
{returnValue[cookieName]=cookies[cookieName];}}
return returnValue;};constructor.prototype.set=function(cookieName,value,options)
{if(typeof value==='undefined'||value===null)
{if(typeof options!=='object'||options===null)
{options={};}
value='';options.hoursToLive=-8760;}
var optionsString=assembleOptionsString(options);document.cookie=cookieName+'='+encodeURIComponent(value)+optionsString;};constructor.prototype.del=function(cookieName,options)
{var allCookies={};if(typeof options!=='object'||options===null)
{options={};}
if(typeof cookieName==='boolean'&&cookieName===true)
{allCookies=this.get();}
else if(typeof cookieName==='string')
{allCookies[cookieName]=true;}
for(var name in allCookies)
{if(typeof name==='string'&&name!=='')
{this.set(name,null,options);}}};constructor.prototype.test=function()
{var returnValue=false,testName='cT',testValue='data';this.set(testName,testValue);if(this.get(testName)===testValue)
{this.del(testName);returnValue=true;}
return returnValue;};constructor.prototype.setOptions=function(options)
{if(typeof options!=='object')
{options=null;}
defaultOptions=resolveOptions(options);};return new constructor();})();(function()
{if(window.jQuery)
{(function($)
{$.cookies=jaaulde.utils.cookies;var extensions={cookify:function(options)
{return this.each(function()
{var i,resolvedName=false,resolvedValue=false,name='',value='',nameAttrs=['name','id'],nodeName,inputType;for(i in nameAttrs)
{if(!isNaN(i))
{name=$(this).attr(nameAttrs[i]);if(typeof name==='string'&&name!=='')
{resolvedName=true;break;}}}
if(resolvedName)
{nodeName=this.nodeName.toLowerCase();if(nodeName!=='input'&&nodeName!=='textarea'&&nodeName!=='select'&&nodeName!=='img')
{value=$(this).html();resolvedValue=true;}
else
{inputType=$(this).attr('type');if(typeof inputType==='string'&&inputType!=='')
{inputType=inputType.toLowerCase();}
if(inputType!=='radio'&&inputType!=='checkbox')
{value=$(this).val();resolvedValue=true;}}
if(resolvedValue)
{if(typeof value!=='string'||value==='')
{value=null;}
$.cookies.set(name,value,options);}}});},cookieFill:function()
{return this.each(function()
{var i,resolvedName=false,name='',value,nameAttrs=['name','id'],iteration=0,nodeName;for(i in nameAttrs)
{if(!isNaN(i))
{name=$(this).attr(nameAttrs[i]);if(typeof name==='string'&&name!=='')
{resolvedName=true;break;}}}
if(resolvedName)
{value=$.cookies.get(name);if(value!==null)
{nodeName=this.nodeName.toLowerCase();if(nodeName==='input'||nodeName==='textarea'||nodeName==='select')
{$(this).val(value);}
else
{$(this).html(value);}}}
iteration=0;});},cookieBind:function(options)
{return this.each(function()
{$(this).cookieFill().change(function()
{$(this).cookify(options);});});}};$.each(extensions,function(i)
{$.fn[i]=this;});})(window.jQuery);}})();

}.call(window));

/***/ }),

/***/ 2974:
/***/ (function(module, exports) {

/*** IMPORTS FROM imports-loader ***/
var define = undefined;
var require = undefined;
var module = undefined;
var exports = undefined;
(function() {

/*
 * CAUTION: This file (and everything in this directory) is marked as noParse
 * in our Webpack configuration. This means it cannot import modules, and that
 * it will not be transpiled to ES5. Do *NOT* use any ES6 features that our
 * supported browsers don't support natively (i.e., IE11 does not support arrow
 * functions).
 */

/*
 * jQuery Form Example Plugin 1.4.3
 * Populate form inputs with example text that disappears on focus.
 *
 * e.g.
 *  $('input#name').example('Bob Smith');
 *  $('input[@title]').example(function() {
 *    return $(this).attr('title');
 *  });
 *  $('textarea#message').example('Type your message here', {
 *    className: 'example_text'
 *  });
 *
 * Copyright (c) Paul Mucur (http://mucur.name), 2007-2008.
 * Dual-licensed under the BSD (BSD-LICENSE.txt) and GPL (GPL-LICENSE.txt)
 * licenses.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
(function($) {

  $.fn.example = function(text, args) {

    /* Only calculate once whether a callback has been used. */
    var isCallback = $.isFunction(text);

    /* Merge the arguments and given example text into one options object. */
    var options = $.extend({}, args, {example: text});

    return this.each(function() {

      /* Reduce method calls by saving the current jQuery object. */
      var $this = $(this);

      /* Merge the plugin defaults with the given options and, if present,
       * any metadata.
       */
      if ($.metadata) {
        var o = $.extend({}, $.fn.example.defaults, $this.metadata(), options);
      } else {
        var o = $.extend({}, $.fn.example.defaults, options);
      }

      /* The following event handlers only need to be bound once
       * per class name. In order to do this, an array of used
       * class names is stored and checked on each use of the plugin.
       * If the class name is in the array then this whole section
       * is skipped. If not, the events are bound and the class name
       * added to the array.
       *
       * As of 1.3.2, the class names are stored as keys in the
       * array, rather than as elements. This removes the need for
       * $.inArray().
       */
      if (!$.fn.example.boundClassNames[o.className]) {

        /* Because Gecko-based browsers cache form values
         * but ignore all other attributes such as class, all example
         * values must be cleared on page unload to prevent them from
         * being saved.
         */
        $(window).on('unload', function() {
          $('.' + o.className).val('');
        });

        /* Clear fields that are still examples before any form is submitted
         * otherwise those examples will be sent along as well.
         *
         * Prior to 1.3, this would only be bound to forms that were
         * parents of example fields but this meant that a page with
         * multiple forms would not work correctly.
         */
        $('form').on('submit', function() {

          /* Clear only the fields inside this particular form. */
          $(this).find('.' + o.className).val('');
        });

        /* Add the class name to the array. */
        $.fn.example.boundClassNames[o.className] = true;
      }

      /* Several browsers will cache form values even if they are cleared
       * on unload, so this will clear any value that matches the example
       * text and hasn't been specified in the value attribute.
       *
       * If a callback is used, it is not possible or safe to predict
       * what the example text is going to be so all non-default values
       * are cleared. This means that caching is effectively disabled for
       * that field.
       *
       * Many thanks to Klaus Hartl for helping resolve this issue.
       */
      // jeff.scherpelz@socrata.com - 16 Jun 2011
      // Patch this for jQuery 1.6 per https://github.com/mudge/jquery_example/issues/4
      if (!$this.attr('value') && (isCallback || $this.val() == o.example))
        $this.val('');

      /*
       * clint.tseng@socrata.com - 25 may 2011
       * activeElement will straight up exception in IE9 if called too early.
       * In these cases, just assume the element doesn't have focus anyway.
       * The focus event will fire after this in these cases.
       */
       var activeElement = null;
       try
       {
           activeElement = document.activeElement;
       }
       catch(e) {}

      /* Initially place the example text in the field if it is empty
       * and doesn't have focus yet.
       */
      if ($this.val() == '' && this != activeElement) {
        $this.addClass(o.className);

        /* The text argument can now be a function; if this is the case,
         * call it, passing the current element as `this`.
         */
        $this.val(isCallback ? o.example.call(this) : o.example);
      }

      /* Make the example text disappear when someone focuses.
       *
       * To determine whether the value of the field is an example or not,
       * check for the example class name only; comparing the actual value
       * seems wasteful and can stop people from using example values as real
       * input.
       */
      $this.on('focus', function() {

        /* jQuery 1.1 has no hasClass(), so is() must be used instead. */
        if ($(this).is('.' + o.className)) {
          $(this).val('');
          $(this).removeClass(o.className);
        }
      });

      /* Detect a change event to the field and remove the example class. */
      $this.on('change', function() {
        if ($(this).is('.' + o.className)) {
          $(this).removeClass(o.className);
        }
      });

      /* Make the example text reappear if the input is blank on blurring. */
      $this.on('blur', function() {
        // clint.tseng@socrata.com - 29 mar 2013 (fuck, it's been 2 years?)
        // also update the text if we blur and we have text but we're .prompt
        // so that we can just .blur() on the element to update it remotely.
        //
        // this only ever adds prompt, so i don't think this can do anything
        // it didn't do before besides the above.
        if ($(this).val() == '' || $(this).is('.' + o.className)) {
          $(this).addClass(o.className);

          /* Re-evaluate the callback function every time the user
           * blurs the field without entering anything. While this
           * is not as efficient as caching the value, it allows for
           * more dynamic applications of the plugin.
           */
          $(this).val(isCallback ? o.example.call(this) : o.example);
        }
      });
    });
  };

  /* Users can override the defaults for the plugin like so:
   *
   *   $.fn.example.defaults.className = 'not_example';
   */
  $.fn.example.defaults = {
    className: 'example'
  };

  /* All the class names used are stored as keys in the following array. */
  $.fn.example.boundClassNames = [];

})(jQuery);

}.call(window));

/***/ }),

/***/ 2975:
/***/ (function(module, exports) {

/*** IMPORTS FROM imports-loader ***/
var define = undefined;
var require = undefined;
var module = undefined;
var exports = undefined;
(function() {

/*
 * CAUTION: This file (and everything in this directory) is marked as noParse
 * in our Webpack configuration. This means it cannot import modules, and that
 * it will not be transpiled to ES5. Do *NOT* use any ES6 features that our
 * supported browsers don't support natively (i.e., IE11 does not support arrow
 * functions).
 */

/*
 * JSizes - JQuery plugin v0.32
 *
 * Licensed under the revised BSD License.
 * Copyright 2008, Bram Stein
 * All rights reserved.
 */
(function(B){var A=function(C){return parseInt(C,10)||0};B.each(["min","max"],function(D,C){B.fn[C+"Size"]=function(G){var F,E;if(G){if(G.width){this.css(C+"-width",G.width)}if(G.height){this.css(C+"-height",G.height)}return this}else{F=this.css(C+"-width");E=this.css(C+"-height");return{width:(C==="max"&&(F===undefined||F==="none"||A(F)===-1)&&Number.MAX_VALUE)||A(F),height:(C==="max"&&(E===undefined||E==="none"||A(E)===-1)&&Number.MAX_VALUE)||A(E)}}}});B.fn.isVisible=function(){return this.css("visibility")!=="hidden"&&this.css("display")!=="none"};B.each(["border","margin","padding"],function(D,C){B.fn[C]=function(E){if(E){if(E.top){this.css(C+"-top"+(C==="border"?"-width":""),E.top)}if(E.bottom){this.css(C+"-bottom"+(C==="border"?"-width":""),E.bottom)}if(E.left){this.css(C+"-left"+(C==="border"?"-width":""),E.left)}if(E.right){this.css(C+"-right"+(C==="border"?"-width":""),E.right)}return this}else{return{top:A(this.css(C+"-top"+(C==="border"?"-width":""))),bottom:A(this.css(C+"-bottom"+(C==="border"?"-width":""))),left:A(this.css(C+"-left"+(C==="border"?"-width":""))),right:A(this.css(C+"-right"+(C==="border"?"-width":"")))}}}})})(jQuery);

}.call(window));

/***/ }),

/***/ 2976:
/***/ (function(module, exports) {

/*** IMPORTS FROM imports-loader ***/
var define = undefined;
var require = undefined;
var module = undefined;
var exports = undefined;
(function() {

/*
 * CAUTION: This file (and everything in this directory) is marked as noParse
 * in our Webpack configuration. This means it cannot import modules, and that
 * it will not be transpiled to ES5. Do *NOT* use any ES6 features that our
 * supported browsers don't support natively (i.e., IE11 does not support arrow
 * functions).
 */

/*
  License:
  Tache 1.0 jQuery Plugin

  Copyright (c) 2008 Jon Combe (http://joncom.be)

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation
  files (the "Software"), to deal in the Software without
  restriction, including without limitation the rights to use,
  copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the
  Software is furnished to do so, subject to the following
  conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
  OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  OTHER DEALINGS IN THE SOFTWARE.
*/

/*
  v1.1 (jeff.scherpelz@blist.com): Added support for data parameters besides strings
  v1.2 (jeff.scherpelz@blist.com): Support for de-duping in-process requests
*/

(function($) {

  // define public plugin contents
  $.Tache = {
    Data:         [],
    InProcessData: [],
    Delete:       function(a) { Delete(a) },
    DeleteAll:    function()  { DeleteAll() },
    Get:          function(a) { Get(a) },
    SetTimeout:   function(a) { SetTimeout(a) },
    Timeout:      600   // 600 seconds = 10 minutes
  };

  // PRIVATE: create a unique identifier
  function CreateID(oAJAX) {
    var sIdentifier = oAJAX.url;
    sIdentifier += ((typeof oAJAX.data == "string") ? oAJAX.data :
        oAJAX.data ? $.param(oAJAX.data).split('&').sort().join('&') : "" );
    sIdentifier += ((typeof oAJAX.dataType == "string") ? oAJAX.dataType : "");
    sIdentifier += ((typeof oAJAX.type == "string") ? oAJAX.type : "");
    return sIdentifier;
  }

  // PUBLIC: delete a single data item
  function Delete(oAJAX) {
    // exit now if we haven't been passed a URL
    if (typeof oAJAX.url != "string") {
      alert("No AJAX URL passed");
      return;
    }

    // delete expired and
    var sIdentifier = CreateID(oAJAX);
    var dtNow = new Date();
    for (var i = $.Tache.Data.length; i > 0; i--) {
      if ((((dtNow.valueOf() - $.Tache.Data[i-1].dtAge.valueOf()) / 1000) > $.Tache.Timeout ) || ($.Tache.Data[i-1].sIdentifier == sIdentifier)) {
          $.Tache.Data.splice(i-1, 1);
      }
    }
    for (var i = $.Tache.InProcessData.length; i > 0; i--) {
      if ((((dtNow.valueOf() - $.Tache.InProcessData[i-1].dtAge.valueOf()) / 1000) > $.Tache.Timeout ) || ($.Tache.InProcessData[i-1].sIdentifier == sIdentifier)) {
          $.Tache.InProcessData.splice(i-1, 1);
      }
    }
  }

  // PUBLIC: delete all cached data
  function DeleteAll() {
    $.Tache.Data = [];
    $.Tache.InProcessData = [];
  }

  // PUBLIC: return the data of ajax call either directly from the server or from memory if pre-loaded
  function Get(oAJAX) {
    // exit now if we haven't been passed a URL
    if (typeof oAJAX.url != "string") {
      alert("No AJAX URL passed");
      return;
    }

    // find if the data has been cached has already been called, deleting expired requests as we go
    var sIdentifier = CreateID(oAJAX);
    var dtNow = new Date();
    for (var i = $.Tache.Data.length; i > 0; i--) {
      if ( ((dtNow.valueOf() - $.Tache.Data[i-1].dtAge.valueOf()) / 1000) > $.Tache.Timeout ) {
          // delete expired request
          $.Tache.Data.splice(i-1, 1);
      } else if ($.Tache.Data[i-1].sIdentifier == sIdentifier) {
          var item = $.Tache.Data[i-1];
          if (item.hasOwnProperty('oData'))
          { oAJAX.success(item.oData); }
          else if (item.hasOwnProperty('oErrorReq'))
          { oAJAX.error(item.oErrorReq); }
          return;
      }
    }

    // Check the in-process queue, also
    for (var i = $.Tache.InProcessData.length; i > 0; i--) {
      if ( ((dtNow.valueOf() - $.Tache.InProcessData[i-1].dtAge.valueOf()) / 1000) > $.Tache.Timeout ) {
          // delete expired request
          $.Tache.InProcessData.splice(i-1, 1);
      } else if ($.Tache.InProcessData[i-1].sIdentifier == sIdentifier) {
          $.Tache.InProcessData[i-1].oReqs.push(oAJAX);
          return;
      }
    }

    // the data wasn't found; alter the callback to insert the soon-to-be requested data into the cache
    var oCallback = oAJAX.success;
    $.Tache.InProcessData.push({ sIdentifier: sIdentifier, dtAge: new Date(), oReqs: [oAJAX]});
    oAJAX.success = function(oNewData, ts, xhr) {
      // Don't cache pending response
      if (xhr.status == 200)
      { $.Tache.Data.push({ sIdentifier: sIdentifier, oData: oNewData, dtAge: new Date() }); }

      oAJAX.success = oCallback;
      for (var i = 0; i < $.Tache.InProcessData.length; i++)
      {
        if ($.Tache.InProcessData[i].sIdentifier == sIdentifier)
        {
            var ipItem = $.Tache.InProcessData.splice(i, 1)[0];
            for (var j = 0; j < ipItem.oReqs.length; j++) {
              ipItem.oReqs[j].success.apply(this, arguments);
            }
        }
      }
    };
    var oeCallback = oAJAX.error;
    oAJAX.error = function(xhr)
    {
        // Don't cache internal errors
        if (xhr.status < 500)
        { $.Tache.Data.push({ sIdentifier: sIdentifier, oErrorReq: xhr, dtAge: new Date() }); }

        oAJAX.error = oeCallback;
        for (var i = 0; i < $.Tache.InProcessData.length; i++)
        {
            if ($.Tache.InProcessData[i].sIdentifier == sIdentifier)
            {
                var ipItem = $.Tache.InProcessData.splice(i, 1)[0];
                for (var j = 0; j < ipItem.oReqs.length; j++)
                {
                    if (ipItem.oReqs[j].error instanceof Function)
                    { ipItem.oReqs[j].error.apply(this, arguments); }
                }
            }
        }
    };
    $.ajax(oAJAX);
  }

  // PUBLIC: set the timeout value
  function SetTimeout(iSeconds) {
    $.Tache.Timeout = iSeconds;
  }

})(jQuery);

}.call(window));

/***/ }),

/***/ 2977:
/***/ (function(module, exports) {

/*** IMPORTS FROM imports-loader ***/
var define = undefined;
var require = undefined;
var module = undefined;
var exports = undefined;
(function() {

/*
 * CAUTION: This file (and everything in this directory) is marked as noParse
 * in our Webpack configuration. This means it cannot import modules, and that
 * it will not be transpiled to ES5. Do *NOT* use any ES6 features that our
 * supported browsers don't support natively (i.e., IE11 does not support arrow
 * functions).
 */

/*

TO DO: Test in all browsers, clean up theme file, prepare documentation, minisite?

Uniform v1.5
Copyright © 2009 Josh Pyles / Pixelmatrix Design LLC
http://pixelmatrixdesign.com

Requires jQuery 1.3 or newer

Much thanks to Thomas Reynolds and Buck Wilson for their help and advice on this

Also, thanks to David Kaneda and Eugene Bond for their contributions to the plugin

License:
MIT License - http://www.opensource.org/licenses/mit-license.php

Usage:

$(function(){
    $("select, :radio, :checkbox").uniform();
});

You can customize the classes that Uniform uses:

$("select, :radio, :checkbox").uniform({
  selectClass: 'mySelectClass',
  radioClass: 'myRadioClass',
  checkboxClass: 'myCheckboxClass',
  checkedClass: 'myCheckedClass',
  focusClass: 'myFocusClass'
});

Enjoy!

*/

// clint.tseng@socrata.com 13/05/10:
//    adding .uniform class to uniform elems
//    attaching hover events to associated labels

// clint.tseng@socrata.com 19/05/10:
// set width of select to match that of its target

// clint.tseng@socrata.com 19/05/10:
// setting filename not working with multiple file inputs

// clint.tseng@socrata.com 19/05/10:
// setting filename not happening if form input was preserved

// jeff.scherpelz@socrata.com 21/10/10:
// add another div in select to do dynamic sizing, since jq1.4.3 broke getting the
// styled width of a hidden element

// clint.tseng@socrata.com 03/01/11
// forbid double-uniforming

// clint.tseng@socrata.com 04/27/11
// rewrite dom manip for massive perf gain
//  note: wrap is slow.

/**
 * Updated July 2019 to support jquery 3:
 * - bind/unbind is deprecated: https://jquery.com/upgrade-guide/3.0/#deprecated-bind-and-delegate
 */

(function($) {
    $.uniform = {
        options: {
            selectClass:   'selector',
            radioClass: 'radio',
            checkboxClass: 'checker',
            fileClass: 'uploader',
            filenameClass: 'filename',
            fileBtnClass: 'action',
            globalClass: 'uniform',
            fileDefaultText: 'No file selected',
            fileBtnText: 'Choose File',
            checkedClass: 'checked',
            focusClass: 'focus',
            disabledClass: 'disabled',
            activeClass: 'active',
            hoverClass: 'hover',
            useID: true,
            idPrefix: 'uniform',
            resetSelector: false
        },
        elements: []
    };

    if($.browser.msie && $.browser.version < 7){
        $.selectOpacity = false;
    }else{
        $.selectOpacity = true;
    }

    $.fn.uniform = function(options) {

        options = $.extend($.uniform.options, options);

        var el = this;
        //code for specifying a reset button
        if(options.resetSelector != false){
            $(options.resetSelector).on('mouseup', function(){
                function resetThis(){
                    $.uniform.update(el);
                }
                setTimeout(resetThis, 10);
            });
        }

        function doSelect(elem){

            var divTag = '<div><div class="container"><div><span></span></div></div></div>';

            elem.css('opacity', 0);

            elem.after(divTag);
            divTag = elem.next();
            divTag.append(elem);

            var spanTag = divTag.find('span');

            // assign class and id
            divTag.addClass(options.selectClass).addClass(options.globalClass);
            if(options.useID){
                divTag.attr("id", options.idPrefix+"-"+elem.attr("id"));
            }

            // get selection
            var $selected = elem.find(':selected:first');
            if ($selected.length === 0)
            { $selected = elem.find('option:first'); }
            spanTag.text($selected.text());

            elem.on('change', function() {
                spanTag.text(elem.find(":selected").text());
            })
            .on('focus', function() {
                divTag.addClass(options.focusClass);
            })
            .on('blur', function() {
                divTag.removeClass(options.focusClass);
            })
            .on('mousedown.uniform touchbegin.uniform', function() {
                divTag.addClass(options.activeClass);
            })
            .on('mouseup.uniform touchend.uniform', function() {
                divTag.removeClass(options.activeClass);
            })
            .on('click.uniform', function() {
                divTag.removeClass(options.activeClass);
            })
            .on('mouseenter', function() {
                divTag.addClass(options.hoverClass);
            })
            .on('mouseout', function() {
                divTag.removeClass(options.hoverClass);
            })
            .on('keypress', function(){
              spanTag.text(elem.find(":selected").text());
            });

            //handle disabled state
            if($(elem).attr("disabled")){
                //box is checked by default, check our box
                divTag.addClass(options.disabledClass);
            }

            storeElement(elem);

        };

        function doCheckbox(elem){

            var divTag = '<div><span></span></div>';

            //wrap with the proper elements
            elem.after(divTag);
            divTag = elem.next();
            var spanTag = divTag.children();
            spanTag.append(elem);

            // assign class and id
            if(options.useID){
                divTag.attr("id", options.idPrefix+"-"+elem.attr("id"));
            }
            divTag.addClass(options.checkboxClass).addClass(options.globalClass);

            //hide normal input and add focus classes
            $(elem)
            .css("opacity", 0)
            .on('focus', function(){

                divTag.addClass(options.focusClass);
            })
            .on('blur', function(){

                divTag.removeClass(options.focusClass);
            })
            .on('click', function(){

                if(!$(elem).attr("checked")){
                    //box was just unchecked, uncheck span
                    spanTag.removeClass(options.checkedClass);
                }else{
                    //box was just checked, check span.
                    spanTag.addClass(options.checkedClass);
                }
            })
            .on('mousedown', function() {
                divTag.addClass(options.activeClass);
            })
            .on('mouseup', function() {
                divTag.removeClass(options.activeClass);
            })
            .on('mouseenter', function() {
                divTag.addClass(options.hoverClass);
            })
            .on('mouseout', function() {
                divTag.removeClass(options.hoverClass);
            });

            //handle defaults
            if($(elem).attr("checked")){
                //box is checked by default, check our box
                spanTag.addClass(options.checkedClass);
            }

            //handle disabled state
            if($(elem).attr("disabled")){
                //box is checked by default, check our box
                divTag.addClass(options.disabledClass);
            }

            //cxlt: bind label hover
            attachLabelHover($(elem), divTag);

            storeElement(elem);

        };

        function doRadio(elem){

            var divTag = '<div><span></span></div>';

            //wrap with the proper elements
            elem.after(divTag);
            divTag = elem.next();
            var spanTag = divTag.children();
            spanTag.append(elem);

            //assign class and id
            if(options.useID){
                divTag.attr("id", options.idPrefix+"-"+elem.attr("id"));
            }
            divTag.addClass(options.radioClass).addClass(options.globalClass);

            //hide normal input and add focus classes
            $(elem)
            .css("opacity", 0)
            .on('focus', function(){
                divTag.addClass(options.focusClass);
            })
            .on('blur', function(){
                divTag.removeClass(options.focusClass);
            })
            .on('click', function(){
                if(!$(elem).attr("checked")){
                    //box was just unchecked, uncheck span
                    spanTag.removeClass(options.checkedClass);
                }else{
                    //box was just checked, check span
                    $("."+options.radioClass + " span."+options.checkedClass + ":has([name='" + $(elem).attr('name') + "'])").removeClass(options.checkedClass);
                    spanTag.addClass(options.checkedClass);
                }
            })
            .on('mousedown', function() {
              if(!$(elem).is(":disabled")){
                divTag.addClass(options.activeClass);
              }
            })
            .on('mouseup', function() {
                divTag.removeClass(options.activeClass);
            })
            .on('mouseenter', function() {
                divTag.addClass(options.hoverClass);
            })
            .on('mouseout', function() {
                divTag.removeClass(options.hoverClass);
            });

            //handle defaults
            if($(elem).attr("checked")){
                //box is checked by default, check span
                spanTag.addClass(options.checkedClass);
            }
            //handle disabled state
            if($(elem).attr("disabled")){
                //box is checked by default, check our box
                divTag.addClass(options.disabledClass);
            }

            //cxlt: bind label hovers
            attachLabelHover($(elem), divTag);

            storeElement(elem);

        };

        function doFile(elem){
        // clint.tseng@socrata.com 19/05/10:
        // setting filename not working with multiple file inputs
          var $el = $(elem);

            var divTag = $('<div />'),
                filenameTag = $('<span>' +
                    $.htmlEscape(options.fileDefaultText) + '</span>'),
                btnTag = $('<span>' +
                    $.htmlEscape(options.fileBtnText) + '</span>');

            divTag.addClass(options.fileClass).addClass(options.globalClass);
            filenameTag.addClass(options.filenameClass);
            btnTag.addClass(options.fileBtnClass);

            if(options.useID){
                divTag.attr("id", options.idPrefix+"-"+$el.attr("id"));
            }

            //wrap with the proper elements
            $el.wrap(divTag);
            $el.after(btnTag);
            $el.after(filenameTag);

            //redefine variables
            divTag = $el.closest("div");
            filenameTag = $el.siblings("."+options.filenameClass);
            btnTag = $el.siblings("."+options.fileBtnClass);

            //set the size
            if(!$el.attr("size")){
                var divWidth = divTag.width();
                //$el.css("width", divWidth);
                $el.attr("size", divWidth/10);
            }

          // clint.tseng@socrata.com 19/05/10:
          // setting filename not happening if form input was
          // preserved
          var setFilename = function()
          {
              var filename = $el.val();

              if (filename === '')
              {
                  filename = options.fileDefaultText;
              }
              else
              {
                  filename = filename.split(/[\/\\]+/);
                  filename = filename[(filename.length-1)];
                  filenameTag.text(filename);
              }
          }
          setFilename();

          //actions
          $el
            .css("opacity", 0)
            .focus(function(){
                divTag.addClass(options.focusClass);
            })
            .on('blur', function(){
                divTag.removeClass(options.focusClass);
            })
            .on('mousedown', function() {
              if(!$(elem).is(":disabled")){
                divTag.addClass(options.activeClass);
              }
            })
            .on('mouseup', function() {
                divTag.removeClass(options.activeClass);
            })
            .on('mouseenter', function() {
                divTag.addClass(options.hoverClass);
            })
            .on('mouseout', function() {
                divTag.removeClass(options.hoverClass);
            });

          // clint.tseng@socrata.com 20/05/10:
          // IE7 not updating file input as expected
          if ($.browser.msie)
          {
              // IE suspends timeout fires until after the file select
              // chrome is dismissed
              $el.on('click', function() {
                  setTimeout(setFilename, 0);
              });
          }
          else
          {
              $el.on('change', setFilename);
          }

          //handle defaults
          if($el.attr("disabled")){
                //box is checked by default, check our box
                divTag.addClass(options.disabledClass);
            }

            storeElement(elem);

        }

        function storeElement(elem){
          //store this element in our global array
          elem = $(elem).get();
          if(elem.length > 1){
            $.each(elem, function(i, val){
              $.uniform.elements.push(val);
            });
          }else{
            $.uniform.elements.push(elem);
          }
        }

        $.uniform.update = function(elem){
          if(elem == undefined){
            elem = $($.uniform.elements);
          }
          //sanitize input
          elem = $(elem);

          elem.each(function(){
            //do to each item in the selector
            //function to reset all classes
            var $e = $(this);
            if ($e.parents('body').length < 1) { return; }

            var spanTag;
            var divTag;
            if($e.is("select")){
                //element is a select
                spanTag = $e.siblings('div').find('span');
                divTag = $e.parent("div");

                divTag.removeClass(options.hoverClass+" "+options.focusClass+" "+options.activeClass);

                //reset current selected text
                spanTag.html($.htmlEscape($e.find(":selected").text()));

                if($e.is(":disabled")){
                    divTag.addClass(options.disabledClass);
                }else{
                  divTag.removeClass(options.disabledClass);
                }

            }else if($e.is(":checkbox")){
                //element is a checkbox
                spanTag = $e.closest("span");
                divTag = $e.closest("div");

                  divTag.removeClass(options.hoverClass+" "+options.focusClass+" "+options.activeClass);
                  spanTag.removeClass(options.checkedClass);

                if($e.is(":checked")){
                    spanTag.addClass(options.checkedClass);
                }
                if($e.is(":disabled")){
                    divTag.addClass(options.disabledClass);
                }else{
                    divTag.removeClass(options.disabledClass);
                }

            }else if($e.is(":radio")){
                //element is a radio
                spanTag = $e.closest("span");
                divTag = $e.closest("div");

                divTag.removeClass(options.hoverClass+" "+options.focusClass+" "+options.activeClass);
                spanTag.removeClass(options.checkedClass);

                if($e.is(":checked")){
                    spanTag.addClass(options.checkedClass);
                }

                if($e.is(":disabled")){
                    divTag.addClass(options.disabledClass);
                }else{
                    divTag.removeClass(options.disabledClass);
                }
            }else if($e.is(":file")){
              divTag = $e.parent("div");
              var filenameTag = $e.siblings(options.filenameClass);
              var btnTag = $e.siblings(options.fileBtnClass);

              divTag.removeClass(options.hoverClass+" "+options.focusClass+" "+options.activeClass);

              filenameTag.text($e.val());

              if($e.is(":disabled")){
                    divTag.addClass(options.disabledClass);
                }else{
                    divTag.removeClass(options.disabledClass);
                }
            }
          });
        };

        function attachLabelHover($e, divTag)
        {
            // cxlt: yeah, it really should be hover, but they're styled the same.
            // cxlt2: go up one level; assume the label is on the same nest as the orig input
            var id = $e.attr('id');
            if (!$.isBlank(id))
            {
                divTag.parent().on('mouseover', 'label[for="' + id + '"]', function()
                {
                    divTag.addClass('focus');
                });
                divTag.parent().on('mouseout', 'label[for="' + id + '"]', function()
                {
                    divTag.removeClass('focus');
                });
            }
        };

        return this.each(function() {
            if($.selectOpacity){
                var elem = $(this);

                if (elem.data('jquery.uniformed') === true)
                { return; }

                if(elem.is("select")){
                    //element is a select
                    if(elem.attr("multiple") != true){
                      //element is not a multi-select
                      doSelect(elem);
                    }
                }else if(elem.is(":checkbox")){
                    //element is a checkbox
                    doCheckbox(elem);
                }else if(elem.is(":radio")){
                    //element is a radio
                    doRadio(elem);
                }else if(elem.is(":file")){
                  //element is a file upload
                  doFile(elem);
                }

                elem.data('jquery.uniformed', true);
            }
        });
    };
})(jQuery);

}.call(window));

/***/ }),

/***/ 2978:
/***/ (function(module, exports) {

/*** IMPORTS FROM imports-loader ***/
var define = undefined;
var require = undefined;
var module = undefined;
var exports = undefined;
(function() {

/*
 * CAUTION: This file (and everything in this directory) is marked as noParse
 * in our Webpack configuration. This means it cannot import modules, and that
 * it will not be transpiled to ES5. Do *NOT* use any ES6 features that our
 * supported browsers don't support natively (i.e., IE11 does not support arrow
 * functions).
 */

/*!
 * jQuery Validation Plugin v1.15.0
 *
 * http://jqueryvalidation.org/
 *
 * Copyright (c) 2016 Jörn Zaefferer
 * Released under the MIT license
 */
(function( factory ) {
  if ( typeof define === "function" && define.amd ) {
    define( ["jquery", "./jquery.validate"], factory );
  } else if (typeof module === "object" && module.exports) {
    module.exports = factory( require( "jquery" ) );
  } else {
    factory( jQuery );
  }
}(function( $ ) {

( function() {

  function stripHtml( value ) {

    // Remove html tags and space chars
    return value.replace( /<.[^<>]*?>/g, " " ).replace( /&nbsp;|&#160;/gi, " " )

    // Remove punctuation
    .replace( /[.(),;:!?%#$'\"_+=\/\-“”’]*/g, "" );
  }

  $.validator.addMethod( "maxWords", function( value, element, params ) {
    return this.optional( element ) || stripHtml( value ).match( /\b\w+\b/g ).length <= params;
  }, $.validator.format( "Please enter {0} words or less." ) );

  $.validator.addMethod( "minWords", function( value, element, params ) {
    return this.optional( element ) || stripHtml( value ).match( /\b\w+\b/g ).length >= params;
  }, $.validator.format( "Please enter at least {0} words." ) );

  $.validator.addMethod( "rangeWords", function( value, element, params ) {
    var valueStripped = stripHtml( value ),
      regex = /\b\w+\b/g;
    return this.optional( element ) || valueStripped.match( regex ).length >= params[ 0 ] && valueStripped.match( regex ).length <= params[ 1 ];
  }, $.validator.format( "Please enter between {0} and {1} words." ) );

}() );

// Accept a value from a file input based on a required mimetype
$.validator.addMethod( "accept", function( value, element, param ) {

  // Split mime on commas in case we have multiple types we can accept
  var typeParam = typeof param === "string" ? param.replace( /\s/g, "" ) : "image/*",
  optionalValue = this.optional( element ),
  i, file, regex;

  // Element is optional
  if ( optionalValue ) {
    return optionalValue;
  }

  if ( $( element ).attr( "type" ) === "file" ) {

    // Escape string to be used in the regex
    // see: http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
    // Escape also "/*" as "/.*" as a wildcard
    typeParam = typeParam.replace( /[\-\[\]\/\{\}\(\)\+\?\.\\\^\$\|]/g, "\\$&" ).replace( /,/g, "|" ).replace( "\/*", "/.*" );

    // Check if the element has a FileList before checking each file
    if ( element.files && element.files.length ) {
      regex = new RegExp( ".?(" + typeParam + ")$", "i" );
      for ( i = 0; i < element.files.length; i++ ) {
        file = element.files[ i ];

        // Grab the mimetype from the loaded file, verify it matches
        if ( !file.type.match( regex ) ) {
          return false;
        }
      }
    }
  }

  // Either return true because we've validated each file, or because the
  // browser does not support element.files and the FileList feature
  return true;
}, $.validator.format( "Please enter a value with a valid mimetype." ) );

$.validator.addMethod( "alphanumeric", function( value, element ) {
  return this.optional( element ) || /^\w+$/i.test( value );
}, "Letters, numbers, and underscores only please" );

/*
 * Dutch bank account numbers (not 'giro' numbers) have 9 digits
 * and pass the '11 check'.
 * We accept the notation with spaces, as that is common.
 * acceptable: 123456789 or 12 34 56 789
 */
$.validator.addMethod( "bankaccountNL", function( value, element ) {
  if ( this.optional( element ) ) {
    return true;
  }
  if ( !( /^[0-9]{9}|([0-9]{2} ){3}[0-9]{3}$/.test( value ) ) ) {
    return false;
  }

  // Now '11 check'
  var account = value.replace( / /g, "" ), // Remove spaces
    sum = 0,
    len = account.length,
    pos, factor, digit;
  for ( pos = 0; pos < len; pos++ ) {
    factor = len - pos;
    digit = account.substring( pos, pos + 1 );
    sum = sum + factor * digit;
  }
  return sum % 11 === 0;
}, "Please specify a valid bank account number" );

$.validator.addMethod( "bankorgiroaccountNL", function( value, element ) {
  return this.optional( element ) ||
      ( $.validator.methods.bankaccountNL.call( this, value, element ) ) ||
      ( $.validator.methods.giroaccountNL.call( this, value, element ) );
}, "Please specify a valid bank or giro account number" );

/**
 * BIC is the business identifier code (ISO 9362). This BIC check is not a guarantee for authenticity.
 *
 * BIC pattern: BBBBCCLLbbb (8 or 11 characters long; bbb is optional)
 *
 * Validation is case-insensitive. Please make sure to normalize input yourself.
 *
 * BIC definition in detail:
 * - First 4 characters - bank code (only letters)
 * - Next 2 characters - ISO 3166-1 alpha-2 country code (only letters)
 * - Next 2 characters - location code (letters and digits)
 *   a. shall not start with '0' or '1'
 *   b. second character must be a letter ('O' is not allowed) or digit ('0' for test (therefore not allowed), '1' denoting passive participant, '2' typically reverse-billing)
 * - Last 3 characters - branch code, optional (shall not start with 'X' except in case of 'XXX' for primary office) (letters and digits)
 */
$.validator.addMethod( "bic", function( value, element ) {
    return this.optional( element ) || /^([A-Z]{6}[A-Z2-9][A-NP-Z1-9])(X{3}|[A-WY-Z0-9][A-Z0-9]{2})?$/.test( value.toUpperCase() );
}, "Please specify a valid BIC code" );

/*
 * Código de identificación fiscal ( CIF ) is the tax identification code for Spanish legal entities
 * Further rules can be found in Spanish on http://es.wikipedia.org/wiki/C%C3%B3digo_de_identificaci%C3%B3n_fiscal
 */
$.validator.addMethod( "cifES", function( value ) {
  "use strict";

  var num = [],
    controlDigit, sum, i, count, tmp, secondDigit;

  value = value.toUpperCase();

  // Quick format test
  if ( !value.match( "((^[A-Z]{1}[0-9]{7}[A-Z0-9]{1}$|^[T]{1}[A-Z0-9]{8}$)|^[0-9]{8}[A-Z]{1}$)" ) ) {
    return false;
  }

  for ( i = 0; i < 9; i++ ) {
    num[ i ] = parseInt( value.charAt( i ), 10 );
  }

  // Algorithm for checking CIF codes
  sum = num[ 2 ] + num[ 4 ] + num[ 6 ];
  for ( count = 1; count < 8; count += 2 ) {
    tmp = ( 2 * num[ count ] ).toString();
    secondDigit = tmp.charAt( 1 );

    sum += parseInt( tmp.charAt( 0 ), 10 ) + ( secondDigit === "" ? 0 : parseInt( secondDigit, 10 ) );
  }

  /* The first (position 1) is a letter following the following criteria:
   *  A. Corporations
   *  B. LLCs
   *  C. General partnerships
   *  D. Companies limited partnerships
   *  E. Communities of goods
   *  F. Cooperative Societies
   *  G. Associations
   *  H. Communities of homeowners in horizontal property regime
   *  J. Civil Societies
   *  K. Old format
   *  L. Old format
   *  M. Old format
   *  N. Nonresident entities
   *  P. Local authorities
   *  Q. Autonomous bodies, state or not, and the like, and congregations and religious institutions
   *  R. Congregations and religious institutions (since 2008 ORDER EHA/451/2008)
   *  S. Organs of State Administration and regions
   *  V. Agrarian Transformation
   *  W. Permanent establishments of non-resident in Spain
   */
  if ( /^[ABCDEFGHJNPQRSUVW]{1}/.test( value ) ) {
    sum += "";
    controlDigit = 10 - parseInt( sum.charAt( sum.length - 1 ), 10 );
    value += controlDigit;
    return ( num[ 8 ].toString() === String.fromCharCode( 64 + controlDigit ) || num[ 8 ].toString() === value.charAt( value.length - 1 ) );
  }

  return false;

}, "Please specify a valid CIF number." );

/*
 * Brazillian CPF number (Cadastrado de Pessoas Físicas) is the equivalent of a Brazilian tax registration number.
 * CPF numbers have 11 digits in total: 9 numbers followed by 2 check numbers that are being used for validation.
 */
$.validator.addMethod( "cpfBR", function( value ) {

  // Removing special characters from value
  value = value.replace( /([~!@#$%^&*()_+=`{}\[\]\-|\\:;'<>,.\/? ])+/g, "" );

  // Checking value to have 11 digits only
  if ( value.length !== 11 ) {
    return false;
  }

  var sum = 0,
    firstCN, secondCN, checkResult, i;

  firstCN = parseInt( value.substring( 9, 10 ), 10 );
  secondCN = parseInt( value.substring( 10, 11 ), 10 );

  checkResult = function( sum, cn ) {
    var result = ( sum * 10 ) % 11;
    if ( ( result === 10 ) || ( result === 11 ) ) {
      result = 0;
    }
    return ( result === cn );
  };

  // Checking for dump data
  if ( value === "" ||
    value === "00000000000" ||
    value === "11111111111" ||
    value === "22222222222" ||
    value === "33333333333" ||
    value === "44444444444" ||
    value === "55555555555" ||
    value === "66666666666" ||
    value === "77777777777" ||
    value === "88888888888" ||
    value === "99999999999"
  ) {
    return false;
  }

  // Step 1 - using first Check Number:
  for ( i = 1; i <= 9; i++ ) {
    sum = sum + parseInt( value.substring( i - 1, i ), 10 ) * ( 11 - i );
  }

  // If first Check Number (CN) is valid, move to Step 2 - using second Check Number:
  if ( checkResult( sum, firstCN ) ) {
    sum = 0;
    for ( i = 1; i <= 10; i++ ) {
      sum = sum + parseInt( value.substring( i - 1, i ), 10 ) * ( 12 - i );
    }
    return checkResult( sum, secondCN );
  }
  return false;

}, "Please specify a valid CPF number" );

// http://jqueryvalidation.org/creditcard-method/
// based on http://en.wikipedia.org/wiki/Luhn_algorithm
$.validator.addMethod( "creditcard", function( value, element ) {
  if ( this.optional( element ) ) {
    return "dependency-mismatch";
  }

  // Accept only spaces, digits and dashes
  if ( /[^0-9 \-]+/.test( value ) ) {
    return false;
  }

  var nCheck = 0,
    nDigit = 0,
    bEven = false,
    n, cDigit;

  value = value.replace( /\D/g, "" );

  // Basing min and max length on
  // http://developer.ean.com/general_info/Valid_Credit_Card_Types
  if ( value.length < 13 || value.length > 19 ) {
    return false;
  }

  for ( n = value.length - 1; n >= 0; n-- ) {
    cDigit = value.charAt( n );
    nDigit = parseInt( cDigit, 10 );
    if ( bEven ) {
      if ( ( nDigit *= 2 ) > 9 ) {
        nDigit -= 9;
      }
    }

    nCheck += nDigit;
    bEven = !bEven;
  }

  return ( nCheck % 10 ) === 0;
}, "Please enter a valid credit card number." );

/* NOTICE: Modified version of Castle.Components.Validator.CreditCardValidator
 * Redistributed under the the Apache License 2.0 at http://www.apache.org/licenses/LICENSE-2.0
 * Valid Types: mastercard, visa, amex, dinersclub, enroute, discover, jcb, unknown, all (overrides all other settings)
 */
$.validator.addMethod( "creditcardtypes", function( value, element, param ) {
  if ( /[^0-9\-]+/.test( value ) ) {
    return false;
  }

  value = value.replace( /\D/g, "" );

  var validTypes = 0x0000;

  if ( param.mastercard ) {
    validTypes |= 0x0001;
  }
  if ( param.visa ) {
    validTypes |= 0x0002;
  }
  if ( param.amex ) {
    validTypes |= 0x0004;
  }
  if ( param.dinersclub ) {
    validTypes |= 0x0008;
  }
  if ( param.enroute ) {
    validTypes |= 0x0010;
  }
  if ( param.discover ) {
    validTypes |= 0x0020;
  }
  if ( param.jcb ) {
    validTypes |= 0x0040;
  }
  if ( param.unknown ) {
    validTypes |= 0x0080;
  }
  if ( param.all ) {
    validTypes = 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040 | 0x0080;
  }
  if ( validTypes & 0x0001 && /^(5[12345])/.test( value ) ) { // Mastercard
    return value.length === 16;
  }
  if ( validTypes & 0x0002 && /^(4)/.test( value ) ) { // Visa
    return value.length === 16;
  }
  if ( validTypes & 0x0004 && /^(3[47])/.test( value ) ) { // Amex
    return value.length === 15;
  }
  if ( validTypes & 0x0008 && /^(3(0[012345]|[68]))/.test( value ) ) { // Dinersclub
    return value.length === 14;
  }
  if ( validTypes & 0x0010 && /^(2(014|149))/.test( value ) ) { // Enroute
    return value.length === 15;
  }
  if ( validTypes & 0x0020 && /^(6011)/.test( value ) ) { // Discover
    return value.length === 16;
  }
  if ( validTypes & 0x0040 && /^(3)/.test( value ) ) { // Jcb
    return value.length === 16;
  }
  if ( validTypes & 0x0040 && /^(2131|1800)/.test( value ) ) { // Jcb
    return value.length === 15;
  }
  if ( validTypes & 0x0080 ) { // Unknown
    return true;
  }
  return false;
}, "Please enter a valid credit card number." );

/**
 * Validates currencies with any given symbols by @jameslouiz
 * Symbols can be optional or required. Symbols required by default
 *
 * Usage examples:
 *  currency: ["£", false] - Use false for soft currency validation
 *  currency: ["$", false]
 *  currency: ["RM", false] - also works with text based symbols such as "RM" - Malaysia Ringgit etc
 *
 *  <input class="currencyInput" name="currencyInput">
 *
 * Soft symbol checking
 *  currencyInput: {
 *     currency: ["$", false]
 *  }
 *
 * Strict symbol checking (default)
 *  currencyInput: {
 *     currency: "$"
 *     //OR
 *     currency: ["$", true]
 *  }
 *
 * Multiple Symbols
 *  currencyInput: {
 *     currency: "$,£,¢"
 *  }
 */
$.validator.addMethod( "currency", function( value, element, param ) {
    var isParamString = typeof param === "string",
        symbol = isParamString ? param : param[ 0 ],
        soft = isParamString ? true : param[ 1 ],
        regex;

    symbol = symbol.replace( /,/g, "" );
    symbol = soft ? symbol + "]" : symbol + "]?";
    regex = "^[" + symbol + "([1-9]{1}[0-9]{0,2}(\\,[0-9]{3})*(\\.[0-9]{0,2})?|[1-9]{1}[0-9]{0,}(\\.[0-9]{0,2})?|0(\\.[0-9]{0,2})?|(\\.[0-9]{1,2})?)$";
    regex = new RegExp( regex );
    return this.optional( element ) || regex.test( value );

}, "Please specify a valid currency" );

$.validator.addMethod( "dateFA", function( value, element ) {
  return this.optional( element ) || /^[1-4]\d{3}\/((0?[1-6]\/((3[0-1])|([1-2][0-9])|(0?[1-9])))|((1[0-2]|(0?[7-9]))\/(30|([1-2][0-9])|(0?[1-9]))))$/.test( value );
}, $.validator.messages.date );

/**
 * Return true, if the value is a valid date, also making this formal check dd/mm/yyyy.
 *
 * @example $.validator.methods.date("01/01/1900")
 * @result true
 *
 * @example $.validator.methods.date("01/13/1990")
 * @result false
 *
 * @example $.validator.methods.date("01.01.1900")
 * @result false
 *
 * @example <input name="pippo" class="{dateITA:true}" />
 * @desc Declares an optional input element whose value must be a valid date.
 *
 * @name $.validator.methods.dateITA
 * @type Boolean
 * @cat Plugins/Validate/Methods
 */
$.validator.addMethod( "dateITA", function( value, element ) {
  var check = false,
    re = /^\d{1,2}\/\d{1,2}\/\d{4}$/,
    adata, gg, mm, aaaa, xdata;
  if ( re.test( value ) ) {
    adata = value.split( "/" );
    gg = parseInt( adata[ 0 ], 10 );
    mm = parseInt( adata[ 1 ], 10 );
    aaaa = parseInt( adata[ 2 ], 10 );
    xdata = new Date( Date.UTC( aaaa, mm - 1, gg, 12, 0, 0, 0 ) );
    if ( ( xdata.getUTCFullYear() === aaaa ) && ( xdata.getUTCMonth() === mm - 1 ) && ( xdata.getUTCDate() === gg ) ) {
      check = true;
    } else {
      check = false;
    }
  } else {
    check = false;
  }
  return this.optional( element ) || check;
}, $.validator.messages.date );

$.validator.addMethod( "dateNL", function( value, element ) {
  return this.optional( element ) || /^(0?[1-9]|[12]\d|3[01])[\.\/\-](0?[1-9]|1[012])[\.\/\-]([12]\d)?(\d\d)$/.test( value );
}, $.validator.messages.date );

// Older "accept" file extension method. Old docs: http://docs.jquery.com/Plugins/Validation/Methods/accept
$.validator.addMethod( "extension", function( value, element, param ) {
  param = typeof param === "string" ? param.replace( /,/g, "|" ) : "png|jpe?g|gif";
  return this.optional( element ) || value.match( new RegExp( "\\.(" + param + ")$", "i" ) );
}, $.validator.format( "Please enter a value with a valid extension." ) );

/**
 * Dutch giro account numbers (not bank numbers) have max 7 digits
 */
$.validator.addMethod( "giroaccountNL", function( value, element ) {
  return this.optional( element ) || /^[0-9]{1,7}$/.test( value );
}, "Please specify a valid giro account number" );

/**
 * IBAN is the international bank account number.
 * It has a country - specific format, that is checked here too
 *
 * Validation is case-insensitive. Please make sure to normalize input yourself.
 */
$.validator.addMethod( "iban", function( value, element ) {

  // Some quick simple tests to prevent needless work
  if ( this.optional( element ) ) {
    return true;
  }

  // Remove spaces and to upper case
  var iban = value.replace( / /g, "" ).toUpperCase(),
    ibancheckdigits = "",
    leadingZeroes = true,
    cRest = "",
    cOperator = "",
    countrycode, ibancheck, charAt, cChar, bbanpattern, bbancountrypatterns, ibanregexp, i, p;

  // Check the country code and find the country specific format
  countrycode = iban.substring( 0, 2 );
  bbancountrypatterns = {
    "AL": "\\d{8}[\\dA-Z]{16}",
    "AD": "\\d{8}[\\dA-Z]{12}",
    "AT": "\\d{16}",
    "AZ": "[\\dA-Z]{4}\\d{20}",
    "BE": "\\d{12}",
    "BH": "[A-Z]{4}[\\dA-Z]{14}",
    "BA": "\\d{16}",
    "BR": "\\d{23}[A-Z][\\dA-Z]",
    "BG": "[A-Z]{4}\\d{6}[\\dA-Z]{8}",
    "CR": "\\d{17}",
    "HR": "\\d{17}",
    "CY": "\\d{8}[\\dA-Z]{16}",
    "CZ": "\\d{20}",
    "DK": "\\d{14}",
    "DO": "[A-Z]{4}\\d{20}",
    "EE": "\\d{16}",
    "FO": "\\d{14}",
    "FI": "\\d{14}",
    "FR": "\\d{10}[\\dA-Z]{11}\\d{2}",
    "GE": "[\\dA-Z]{2}\\d{16}",
    "DE": "\\d{18}",
    "GI": "[A-Z]{4}[\\dA-Z]{15}",
    "GR": "\\d{7}[\\dA-Z]{16}",
    "GL": "\\d{14}",
    "GT": "[\\dA-Z]{4}[\\dA-Z]{20}",
    "HU": "\\d{24}",
    "IS": "\\d{22}",
    "IE": "[\\dA-Z]{4}\\d{14}",
    "IL": "\\d{19}",
    "IT": "[A-Z]\\d{10}[\\dA-Z]{12}",
    "KZ": "\\d{3}[\\dA-Z]{13}",
    "KW": "[A-Z]{4}[\\dA-Z]{22}",
    "LV": "[A-Z]{4}[\\dA-Z]{13}",
    "LB": "\\d{4}[\\dA-Z]{20}",
    "LI": "\\d{5}[\\dA-Z]{12}",
    "LT": "\\d{16}",
    "LU": "\\d{3}[\\dA-Z]{13}",
    "MK": "\\d{3}[\\dA-Z]{10}\\d{2}",
    "MT": "[A-Z]{4}\\d{5}[\\dA-Z]{18}",
    "MR": "\\d{23}",
    "MU": "[A-Z]{4}\\d{19}[A-Z]{3}",
    "MC": "\\d{10}[\\dA-Z]{11}\\d{2}",
    "MD": "[\\dA-Z]{2}\\d{18}",
    "ME": "\\d{18}",
    "NL": "[A-Z]{4}\\d{10}",
    "NO": "\\d{11}",
    "PK": "[\\dA-Z]{4}\\d{16}",
    "PS": "[\\dA-Z]{4}\\d{21}",
    "PL": "\\d{24}",
    "PT": "\\d{21}",
    "RO": "[A-Z]{4}[\\dA-Z]{16}",
    "SM": "[A-Z]\\d{10}[\\dA-Z]{12}",
    "SA": "\\d{2}[\\dA-Z]{18}",
    "RS": "\\d{18}",
    "SK": "\\d{20}",
    "SI": "\\d{15}",
    "ES": "\\d{20}",
    "SE": "\\d{20}",
    "CH": "\\d{5}[\\dA-Z]{12}",
    "TN": "\\d{20}",
    "TR": "\\d{5}[\\dA-Z]{17}",
    "AE": "\\d{3}\\d{16}",
    "GB": "[A-Z]{4}\\d{14}",
    "VG": "[\\dA-Z]{4}\\d{16}"
  };

  bbanpattern = bbancountrypatterns[ countrycode ];

  // As new countries will start using IBAN in the
  // future, we only check if the countrycode is known.
  // This prevents false negatives, while almost all
  // false positives introduced by this, will be caught
  // by the checksum validation below anyway.
  // Strict checking should return FALSE for unknown
  // countries.
  if ( typeof bbanpattern !== "undefined" ) {
    ibanregexp = new RegExp( "^[A-Z]{2}\\d{2}" + bbanpattern + "$", "" );
    if ( !( ibanregexp.test( iban ) ) ) {
      return false; // Invalid country specific format
    }
  }

  // Now check the checksum, first convert to digits
  ibancheck = iban.substring( 4, iban.length ) + iban.substring( 0, 4 );
  for ( i = 0; i < ibancheck.length; i++ ) {
    charAt = ibancheck.charAt( i );
    if ( charAt !== "0" ) {
      leadingZeroes = false;
    }
    if ( !leadingZeroes ) {
      ibancheckdigits += "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ".indexOf( charAt );
    }
  }

  // Calculate the result of: ibancheckdigits % 97
  for ( p = 0; p < ibancheckdigits.length; p++ ) {
    cChar = ibancheckdigits.charAt( p );
    cOperator = "" + cRest + "" + cChar;
    cRest = cOperator % 97;
  }
  return cRest === 1;
}, "Please specify a valid IBAN" );

$.validator.addMethod( "integer", function( value, element ) {
  return this.optional( element ) || /^-?\d+$/.test( value );
}, "A positive or negative non-decimal number please" );

$.validator.addMethod( "ipv4", function( value, element ) {
  return this.optional( element ) || /^(25[0-5]|2[0-4]\d|[01]?\d\d?)\.(25[0-5]|2[0-4]\d|[01]?\d\d?)\.(25[0-5]|2[0-4]\d|[01]?\d\d?)\.(25[0-5]|2[0-4]\d|[01]?\d\d?)$/i.test( value );
}, "Please enter a valid IP v4 address." );

$.validator.addMethod( "ipv6", function( value, element ) {
  return this.optional( element ) || /^((([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}:[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){5}:([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){4}:([0-9A-Fa-f]{1,4}:){0,2}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){3}:([0-9A-Fa-f]{1,4}:){0,3}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){2}:([0-9A-Fa-f]{1,4}:){0,4}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|(([0-9A-Fa-f]{1,4}:){0,5}:((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|(::([0-9A-Fa-f]{1,4}:){0,5}((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|([0-9A-Fa-f]{1,4}::([0-9A-Fa-f]{1,4}:){0,5}[0-9A-Fa-f]{1,4})|(::([0-9A-Fa-f]{1,4}:){0,6}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){1,7}:))$/i.test( value );
}, "Please enter a valid IP v6 address." );

$.validator.addMethod( "lettersonly", function( value, element ) {
  return this.optional( element ) || /^[a-z]+$/i.test( value );
}, "Letters only please" );

$.validator.addMethod( "letterswithbasicpunc", function( value, element ) {
  return this.optional( element ) || /^[a-z\-.,()'"\s]+$/i.test( value );
}, "Letters or punctuation only please" );

$.validator.addMethod( "mobileNL", function( value, element ) {
  return this.optional( element ) || /^((\+|00(\s|\s?\-\s?)?)31(\s|\s?\-\s?)?(\(0\)[\-\s]?)?|0)6((\s|\s?\-\s?)?[0-9]){8}$/.test( value );
}, "Please specify a valid mobile number" );

/* For UK phone functions, do the following server side processing:
 * Compare original input with this RegEx pattern:
 * ^\(?(?:(?:00\)?[\s\-]?\(?|\+)(44)\)?[\s\-]?\(?(?:0\)?[\s\-]?\(?)?|0)([1-9]\d{1,4}\)?[\s\d\-]+)$
 * Extract $1 and set $prefix to '+44<space>' if $1 is '44', otherwise set $prefix to '0'
 * Extract $2 and remove hyphens, spaces and parentheses. Phone number is combined $prefix and $2.
 * A number of very detailed GB telephone number RegEx patterns can also be found at:
 * http://www.aa-asterisk.org.uk/index.php/Regular_Expressions_for_Validating_and_Formatting_GB_Telephone_Numbers
 */
$.validator.addMethod( "mobileUK", function( phone_number, element ) {
  phone_number = phone_number.replace( /\(|\)|\s+|-/g, "" );
  return this.optional( element ) || phone_number.length > 9 &&
    phone_number.match( /^(?:(?:(?:00\s?|\+)44\s?|0)7(?:[1345789]\d{2}|624)\s?\d{3}\s?\d{3})$/ );
}, "Please specify a valid mobile number" );

/*
 * The número de identidad de extranjero ( NIE )is a code used to identify the non-nationals in Spain
 */
$.validator.addMethod( "nieES", function( value ) {
  "use strict";

  value = value.toUpperCase();

  // Basic format test
  if ( !value.match( "((^[A-Z]{1}[0-9]{7}[A-Z0-9]{1}$|^[T]{1}[A-Z0-9]{8}$)|^[0-9]{8}[A-Z]{1}$)" ) ) {
    return false;
  }

  // Test NIE
  //T
  if ( /^[T]{1}/.test( value ) ) {
    return ( value[ 8 ] === /^[T]{1}[A-Z0-9]{8}$/.test( value ) );
  }

  //XYZ
  if ( /^[XYZ]{1}/.test( value ) ) {
    return (
      value[ 8 ] === "TRWAGMYFPDXBNJZSQVHLCKE".charAt(
        value.replace( "X", "0" )
          .replace( "Y", "1" )
          .replace( "Z", "2" )
          .substring( 0, 8 ) % 23
      )
    );
  }

  return false;

}, "Please specify a valid NIE number." );

/*
 * The Número de Identificación Fiscal ( NIF ) is the way tax identification used in Spain for individuals
 */
$.validator.addMethod( "nifES", function( value ) {
  "use strict";

  value = value.toUpperCase();

  // Basic format test
  if ( !value.match( "((^[A-Z]{1}[0-9]{7}[A-Z0-9]{1}$|^[T]{1}[A-Z0-9]{8}$)|^[0-9]{8}[A-Z]{1}$)" ) ) {
    return false;
  }

  // Test NIF
  if ( /^[0-9]{8}[A-Z]{1}$/.test( value ) ) {
    return ( "TRWAGMYFPDXBNJZSQVHLCKE".charAt( value.substring( 8, 0 ) % 23 ) === value.charAt( 8 ) );
  }

  // Test specials NIF (starts with K, L or M)
  if ( /^[KLM]{1}/.test( value ) ) {
    return ( value[ 8 ] === String.fromCharCode( 64 ) );
  }

  return false;

}, "Please specify a valid NIF number." );

jQuery.validator.addMethod( "notEqualTo", function( value, element, param ) {
  return this.optional( element ) || !$.validator.methods.equalTo.call( this, value, element, param );
}, "Please enter a different value, values must not be the same." );

$.validator.addMethod( "nowhitespace", function( value, element ) {
  return this.optional( element ) || /^\S+$/i.test( value );
}, "No white space please" );

/**
* Return true if the field value matches the given format RegExp
*
* @example $.validator.methods.pattern("AR1004",element,/^AR\d{4}$/)
* @result true
*
* @example $.validator.methods.pattern("BR1004",element,/^AR\d{4}$/)
* @result false
*
* @name $.validator.methods.pattern
* @type Boolean
* @cat Plugins/Validate/Methods
*/
$.validator.addMethod( "pattern", function( value, element, param ) {
  if ( this.optional( element ) ) {
    return true;
  }
  if ( typeof param === "string" ) {
    param = new RegExp( "^(?:" + param + ")$" );
  }
  return param.test( value );
}, "Invalid format." );

/**
 * Dutch phone numbers have 10 digits (or 11 and start with +31).
 */
$.validator.addMethod( "phoneNL", function( value, element ) {
  return this.optional( element ) || /^((\+|00(\s|\s?\-\s?)?)31(\s|\s?\-\s?)?(\(0\)[\-\s]?)?|0)[1-9]((\s|\s?\-\s?)?[0-9]){8}$/.test( value );
}, "Please specify a valid phone number." );

/* For UK phone functions, do the following server side processing:
 * Compare original input with this RegEx pattern:
 * ^\(?(?:(?:00\)?[\s\-]?\(?|\+)(44)\)?[\s\-]?\(?(?:0\)?[\s\-]?\(?)?|0)([1-9]\d{1,4}\)?[\s\d\-]+)$
 * Extract $1 and set $prefix to '+44<space>' if $1 is '44', otherwise set $prefix to '0'
 * Extract $2 and remove hyphens, spaces and parentheses. Phone number is combined $prefix and $2.
 * A number of very detailed GB telephone number RegEx patterns can also be found at:
 * http://www.aa-asterisk.org.uk/index.php/Regular_Expressions_for_Validating_and_Formatting_GB_Telephone_Numbers
 */
$.validator.addMethod( "phoneUK", function( phone_number, element ) {
  phone_number = phone_number.replace( /\(|\)|\s+|-/g, "" );
  return this.optional( element ) || phone_number.length > 9 &&
    phone_number.match( /^(?:(?:(?:00\s?|\+)44\s?)|(?:\(?0))(?:\d{2}\)?\s?\d{4}\s?\d{4}|\d{3}\)?\s?\d{3}\s?\d{3,4}|\d{4}\)?\s?(?:\d{5}|\d{3}\s?\d{3})|\d{5}\)?\s?\d{4,5})$/ );
}, "Please specify a valid phone number" );

/**
 * Matches US phone number format
 *
 * where the area code may not start with 1 and the prefix may not start with 1
 * allows '-' or ' ' as a separator and allows parens around area code
 * some people may want to put a '1' in front of their number
 *
 * 1(212)-999-2345 or
 * 212 999 2344 or
 * 212-999-0983
 *
 * but not
 * 111-123-5434
 * and not
 * 212 123 4567
 */
$.validator.addMethod( "phoneUS", function( phone_number, element ) {
  phone_number = phone_number.replace( /\s+/g, "" );
  return this.optional( element ) || phone_number.length > 9 &&
    phone_number.match( /^(\+?1-?)?(\([2-9]([02-9]\d|1[02-9])\)|[2-9]([02-9]\d|1[02-9]))-?[2-9]([02-9]\d|1[02-9])-?\d{4}$/ );
}, "Please specify a valid phone number" );

/* For UK phone functions, do the following server side processing:
 * Compare original input with this RegEx pattern:
 * ^\(?(?:(?:00\)?[\s\-]?\(?|\+)(44)\)?[\s\-]?\(?(?:0\)?[\s\-]?\(?)?|0)([1-9]\d{1,4}\)?[\s\d\-]+)$
 * Extract $1 and set $prefix to '+44<space>' if $1 is '44', otherwise set $prefix to '0'
 * Extract $2 and remove hyphens, spaces and parentheses. Phone number is combined $prefix and $2.
 * A number of very detailed GB telephone number RegEx patterns can also be found at:
 * http://www.aa-asterisk.org.uk/index.php/Regular_Expressions_for_Validating_and_Formatting_GB_Telephone_Numbers
 */

// Matches UK landline + mobile, accepting only 01-3 for landline or 07 for mobile to exclude many premium numbers
$.validator.addMethod( "phonesUK", function( phone_number, element ) {
  phone_number = phone_number.replace( /\(|\)|\s+|-/g, "" );
  return this.optional( element ) || phone_number.length > 9 &&
    phone_number.match( /^(?:(?:(?:00\s?|\+)44\s?|0)(?:1\d{8,9}|[23]\d{9}|7(?:[1345789]\d{8}|624\d{6})))$/ );
}, "Please specify a valid uk phone number" );

/**
 * Matches a valid Canadian Postal Code
 *
 * @example jQuery.validator.methods.postalCodeCA( "H0H 0H0", element )
 * @result true
 *
 * @example jQuery.validator.methods.postalCodeCA( "H0H0H0", element )
 * @result false
 *
 * @name jQuery.validator.methods.postalCodeCA
 * @type Boolean
 * @cat Plugins/Validate/Methods
 */
$.validator.addMethod( "postalCodeCA", function( value, element ) {
  return this.optional( element ) || /^[ABCEGHJKLMNPRSTVXY]\d[ABCEGHJKLMNPRSTVWXYZ] *\d[ABCEGHJKLMNPRSTVWXYZ]\d$/i.test( value );
}, "Please specify a valid postal code" );

/*
* Valida CEPs do brasileiros:
*
* Formatos aceitos:
* 99999-999
* 99.999-999
* 99999999
*/
$.validator.addMethod( "postalcodeBR", function( cep_value, element ) {
  return this.optional( element ) || /^\d{2}.\d{3}-\d{3}?$|^\d{5}-?\d{3}?$/.test( cep_value );
}, "Informe um CEP válido." );

/* Matches Italian postcode (CAP) */
$.validator.addMethod( "postalcodeIT", function( value, element ) {
  return this.optional( element ) || /^\d{5}$/.test( value );
}, "Please specify a valid postal code" );

$.validator.addMethod( "postalcodeNL", function( value, element ) {
  return this.optional( element ) || /^[1-9][0-9]{3}\s?[a-zA-Z]{2}$/.test( value );
}, "Please specify a valid postal code" );

// Matches UK postcode. Does not match to UK Channel Islands that have their own postcodes (non standard UK)
$.validator.addMethod( "postcodeUK", function( value, element ) {
  return this.optional( element ) || /^((([A-PR-UWYZ][0-9])|([A-PR-UWYZ][0-9][0-9])|([A-PR-UWYZ][A-HK-Y][0-9])|([A-PR-UWYZ][A-HK-Y][0-9][0-9])|([A-PR-UWYZ][0-9][A-HJKSTUW])|([A-PR-UWYZ][A-HK-Y][0-9][ABEHMNPRVWXY]))\s?([0-9][ABD-HJLNP-UW-Z]{2})|(GIR)\s?(0AA))$/i.test( value );
}, "Please specify a valid UK postcode" );

/*
 * Lets you say "at least X inputs that match selector Y must be filled."
 *
 * The end result is that neither of these inputs:
 *
 *  <input class="productinfo" name="partnumber">
 *  <input class="productinfo" name="description">
 *
 *  ...will validate unless at least one of them is filled.
 *
 * partnumber:  {require_from_group: [1,".productinfo"]},
 * description: {require_from_group: [1,".productinfo"]}
 *
 * options[0]: number of fields that must be filled in the group
 * options[1]: CSS selector that defines the group of conditionally required fields
 */
$.validator.addMethod( "require_from_group", function( value, element, options ) {
  var $fields = $( options[ 1 ], element.form ),
    $fieldsFirst = $fields.eq( 0 ),
    validator = $fieldsFirst.data( "valid_req_grp" ) ? $fieldsFirst.data( "valid_req_grp" ) : $.extend( {}, this ),
    isValid = $fields.filter( function() {
      return validator.elementValue( this );
    } ).length >= options[ 0 ];

  // Store the cloned validator for future validation
  $fieldsFirst.data( "valid_req_grp", validator );

  // If element isn't being validated, run each require_from_group field's validation rules
  if ( !$( element ).data( "being_validated" ) ) {
    $fields.data( "being_validated", true );
    $fields.each( function() {
      validator.element( this );
    } );
    $fields.data( "being_validated", false );
  }
  return isValid;
}, $.validator.format( "Please fill at least {0} of these fields." ) );

/*
 * Lets you say "either at least X inputs that match selector Y must be filled,
 * OR they must all be skipped (left blank)."
 *
 * The end result, is that none of these inputs:
 *
 *  <input class="productinfo" name="partnumber">
 *  <input class="productinfo" name="description">
 *  <input class="productinfo" name="color">
 *
 *  ...will validate unless either at least two of them are filled,
 *  OR none of them are.
 *
 * partnumber:  {skip_or_fill_minimum: [2,".productinfo"]},
 * description: {skip_or_fill_minimum: [2,".productinfo"]},
 * color:   {skip_or_fill_minimum: [2,".productinfo"]}
 *
 * options[0]: number of fields that must be filled in the group
 * options[1]: CSS selector that defines the group of conditionally required fields
 *
 */
$.validator.addMethod( "skip_or_fill_minimum", function( value, element, options ) {
  var $fields = $( options[ 1 ], element.form ),
    $fieldsFirst = $fields.eq( 0 ),
    validator = $fieldsFirst.data( "valid_skip" ) ? $fieldsFirst.data( "valid_skip" ) : $.extend( {}, this ),
    numberFilled = $fields.filter( function() {
      return validator.elementValue( this );
    } ).length,
    isValid = numberFilled === 0 || numberFilled >= options[ 0 ];

  // Store the cloned validator for future validation
  $fieldsFirst.data( "valid_skip", validator );

  // If element isn't being validated, run each skip_or_fill_minimum field's validation rules
  if ( !$( element ).data( "being_validated" ) ) {
    $fields.data( "being_validated", true );
    $fields.each( function() {
      validator.element( this );
    } );
    $fields.data( "being_validated", false );
  }
  return isValid;
}, $.validator.format( "Please either skip these fields or fill at least {0} of them." ) );

/* Validates US States and/or Territories by @jdforsythe
 * Can be case insensitive or require capitalization - default is case insensitive
 * Can include US Territories or not - default does not
 * Can include US Military postal abbreviations (AA, AE, AP) - default does not
 *
 * Note: "States" always includes DC (District of Colombia)
 *
 * Usage examples:
 *
 *  This is the default - case insensitive, no territories, no military zones
 *  stateInput: {
 *     caseSensitive: false,
 *     includeTerritories: false,
 *     includeMilitary: false
 *  }
 *
 *  Only allow capital letters, no territories, no military zones
 *  stateInput: {
 *     caseSensitive: false
 *  }
 *
 *  Case insensitive, include territories but not military zones
 *  stateInput: {
 *     includeTerritories: true
 *  }
 *
 *  Only allow capital letters, include territories and military zones
 *  stateInput: {
 *     caseSensitive: true,
 *     includeTerritories: true,
 *     includeMilitary: true
 *  }
 *
 */
$.validator.addMethod( "stateUS", function( value, element, options ) {
  var isDefault = typeof options === "undefined",
    caseSensitive = ( isDefault || typeof options.caseSensitive === "undefined" ) ? false : options.caseSensitive,
    includeTerritories = ( isDefault || typeof options.includeTerritories === "undefined" ) ? false : options.includeTerritories,
    includeMilitary = ( isDefault || typeof options.includeMilitary === "undefined" ) ? false : options.includeMilitary,
    regex;

  if ( !includeTerritories && !includeMilitary ) {
    regex = "^(A[KLRZ]|C[AOT]|D[CE]|FL|GA|HI|I[ADLN]|K[SY]|LA|M[ADEINOST]|N[CDEHJMVY]|O[HKR]|PA|RI|S[CD]|T[NX]|UT|V[AT]|W[AIVY])$";
  } else if ( includeTerritories && includeMilitary ) {
    regex = "^(A[AEKLPRSZ]|C[AOT]|D[CE]|FL|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ADEINOPST]|N[CDEHJMVY]|O[HKR]|P[AR]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY])$";
  } else if ( includeTerritories ) {
    regex = "^(A[KLRSZ]|C[AOT]|D[CE]|FL|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ADEINOPST]|N[CDEHJMVY]|O[HKR]|P[AR]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY])$";
  } else {
    regex = "^(A[AEKLPRZ]|C[AOT]|D[CE]|FL|GA|HI|I[ADLN]|K[SY]|LA|M[ADEINOST]|N[CDEHJMVY]|O[HKR]|PA|RI|S[CD]|T[NX]|UT|V[AT]|W[AIVY])$";
  }

  regex = caseSensitive ? new RegExp( regex ) : new RegExp( regex, "i" );
  return this.optional( element ) || regex.test( value );
}, "Please specify a valid state" );

// TODO check if value starts with <, otherwise don't try stripping anything
$.validator.addMethod( "strippedminlength", function( value, element, param ) {
  return $( value ).text().length >= param;
}, $.validator.format( "Please enter at least {0} characters" ) );

$.validator.addMethod( "time", function( value, element ) {
  return this.optional( element ) || /^([01]\d|2[0-3]|[0-9])(:[0-5]\d){1,2}$/.test( value );
}, "Please enter a valid time, between 00:00 and 23:59" );

$.validator.addMethod( "time12h", function( value, element ) {
  return this.optional( element ) || /^((0?[1-9]|1[012])(:[0-5]\d){1,2}(\ ?[AP]M))$/i.test( value );
}, "Please enter a valid time in 12-hour am/pm format" );

// Same as url, but TLD is optional
$.validator.addMethod( "url2", function( value, element ) {
  return this.optional( element ) || /^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)*(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test( value );
}, $.validator.messages.url );

/**
 * Return true, if the value is a valid vehicle identification number (VIN).
 *
 * Works with all kind of text inputs.
 *
 * @example <input type="text" size="20" name="VehicleID" class="{required:true,vinUS:true}" />
 * @desc Declares a required input element whose value must be a valid vehicle identification number.
 *
 * @name $.validator.methods.vinUS
 * @type Boolean
 * @cat Plugins/Validate/Methods
 */
$.validator.addMethod( "vinUS", function( v ) {
  if ( v.length !== 17 ) {
    return false;
  }

  var LL = [ "A", "B", "C", "D", "E", "F", "G", "H", "J", "K", "L", "M", "N", "P", "R", "S", "T", "U", "V", "W", "X", "Y", "Z" ],
    VL = [ 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 7, 9, 2, 3, 4, 5, 6, 7, 8, 9 ],
    FL = [ 8, 7, 6, 5, 4, 3, 2, 10, 0, 9, 8, 7, 6, 5, 4, 3, 2 ],
    rs = 0,
    i, n, d, f, cd, cdv;

  for ( i = 0; i < 17; i++ ) {
    f = FL[ i ];
    d = v.slice( i, i + 1 );
    if ( i === 8 ) {
      cdv = d;
    }
    if ( !isNaN( d ) ) {
      d *= f;
    } else {
      for ( n = 0; n < LL.length; n++ ) {
        if ( d.toUpperCase() === LL[ n ] ) {
          d = VL[ n ];
          d *= f;
          if ( isNaN( cdv ) && n === 8 ) {
            cdv = LL[ n ];
          }
          break;
        }
      }
    }
    rs += d;
  }
  cd = rs % 11;
  if ( cd === 10 ) {
    cd = "X";
  }
  if ( cd === cdv ) {
    return true;
  }
  return false;
}, "The specified vehicle identification number (VIN) is invalid." );

$.validator.addMethod( "zipcodeUS", function( value, element ) {
  return this.optional( element ) || /^\d{5}(-\d{4})?$/.test( value );
}, "The specified US ZIP Code is invalid" );

$.validator.addMethod( "ziprange", function( value, element ) {
  return this.optional( element ) || /^90[2-5]\d\{2\}-\d{4}$/.test( value );
}, "Your ZIP-code must be in the range 902xx-xxxx to 905xx-xxxx" );

}));

}.call(window));

/***/ }),

/***/ 2979:
/***/ (function(module, exports) {

/*** IMPORTS FROM imports-loader ***/
var define = undefined;
var require = undefined;
var module = undefined;
var exports = undefined;
(function() {

/*
 * CAUTION: This file (and everything in this directory) is marked as noParse
 * in our Webpack configuration. This means it cannot import modules, and that
 * it will not be transpiled to ES5. Do *NOT* use any ES6 features that our
 * supported browsers don't support natively (i.e., IE11 does not support arrow
 * functions).
 */

/*!
	PURE Unobtrusive Rendering Engine for HTML

	Licensed under the MIT licenses.
	More information at: http://www.opensource.org

	Copyright (c) 2010 Michael Cvilic - BeeBole.com

	Thanks to Rog Peppe for the functional JS jump
	revision: 2.45
*/

// clint.tseng@socrata.com 18/05/2010
// Fixed a bug with context carrying over after looping into children
// Add a space before pre- or ap- pending to a class

// clint.tseng@socrata.com 21/06/2010
// Added syntax to data selector: "object.property!" or "something #{variable!}"
// The ! indicates that the contents should be html escaped.

// corey.ford@socrata.com 02/09/2015
// Allow title text to wrap

var $p, pure = $p = function(){
	var sel = arguments[0], 
		ctxt = false;

	if(typeof sel === 'string'){
		ctxt = arguments[1] || false;
	}
	return $p.core(sel, ctxt);
};

$p.core = function(sel, ctxt, plugins){
	//get an instance of the plugins
	var plugins = getPlugins(),
		templates = [];

	//search for the template node(s)
	switch(typeof sel){
		case 'string':
			templates = plugins.find(ctxt || document, sel);
			if(templates.length === 0) {
				error('The template "' + sel + '" was not found');
			}
		break;
		case 'undefined':
			error('The template root is undefined, check your selector');
		break;
		default:
			templates = [sel];
	}
	
	for(var i = 0, ii = templates.length; i < ii; i++){
		plugins[i] = templates[i];
	}
	plugins.length = ii;

	// set the signature string that will be replaced at render time
	var Sig = '_s' + Math.floor( Math.random() * 1000000 ) + '_',
		// another signature to prepend to attributes and avoid checks: style, height, on[events]...
		attPfx = '_a' + Math.floor( Math.random() * 1000000 ) + '_',
		// rx to parse selectors, e.g. "+tr.foo[class]"
		selRx = /^(\+)?([^\@\+]+)?\@?([^\+]+)?(\+)?$/,
		// set automatically attributes for some tags
		autoAttr = {
			IMG:'src',
			INPUT:'value'
		},
		// check if the argument is an array - thanks salty-horse (Ori Avtalion)
		isArray = Array.isArray ?
			function(o) {
				return Array.isArray(o);
			} :
			function(o) {
				return Object.prototype.toString.call(o) === "[object Array]";
			};
	
	return plugins;


	/* * * * * * * * * * * * * * * * * * * * * * * * * *
		core functions
	 * * * * * * * * * * * * * * * * * * * * * * * * * */


	// error utility
	function error(e){
		if(typeof console !== 'undefined'){
			console.log(e);
		}else{ alert(e); }
		throw('pure error: ' + e);
	}
	
	//return a new instance of plugins
	function getPlugins(){
		var plugins = $p.plugins,
			f = function(){};
		f.prototype = plugins;

		// do not overwrite functions if external definition
		f.prototype.compile    = plugins.compile || compile;
		f.prototype.render     = plugins.render || render;
		f.prototype.autoRender = plugins.autoRender || autoRender;
		f.prototype.find       = plugins.find || find;
		
		// give the compiler and the error handling to the plugin context
		f.prototype._compiler  = compiler;
		f.prototype._error     = error;
 
		return new f();
	}
	
	// returns the outer HTML of a node
	function outerHTML(node){
		// if IE take the internal method otherwise build one
		return node.outerHTML || (
			function(n){
        		var div = document.createElement('div'), h;
	        	div.appendChild( n.cloneNode(true) );
				h = div.innerHTML;
				div = null;
				return h;
			})(node);
	}
	
	// returns the string generator function
	function wrapquote(qfn, f){
		return function(ctxt){
			return qfn('' + f.call(ctxt.context, ctxt));
		};
	}

	// default find using querySelector when available on the browser
	function find(n, sel){
		if(typeof n === 'string'){
			sel = n;
			n = false;
		}
		if(typeof document.querySelectorAll !== 'undefined'){
			return (n||document).querySelectorAll( sel );
		}else{
			error('You can test PURE standalone with: iPhone, FF3.5+, Safari4+ and IE8+\n\nTo run PURE on your browser, you need a JS library/framework with a CSS selector engine');
		}
	}
	
	// create a function that concatenates constant string
	// sections (given in parts) and the results of called
	// functions to fill in the gaps between parts (fns).
	// fns[n] fills in the gap between parts[n-1] and parts[n];
	// fns[0] is unused.
	// this is the inner template evaluation loop.
	function concatenator(parts, fns){
		return function(ctxt){
			var strs = [ parts[ 0 ] ],
				n = parts.length,
				fnVal, pVal, attLine, pos;

			for(var i = 1; i < n; i++){
				fnVal = fns[i]( ctxt );
				pVal = parts[i];
				
				// if the value is empty and attribute, remove it
				if(fnVal === ''){
					attLine = strs[ strs.length - 1 ];
					if( ( pos = attLine.search( /[\w]+=\"?$/ ) ) > -1){
						strs[ strs.length - 1 ] = attLine.substring( 0, pos );
						pVal = pVal.substr( 1 );
					}
				}
				
				strs[ strs.length ] = fnVal;
				strs[ strs.length ] = pVal;
			}
			return strs.join('');
		};
	}

	// parse and check the loop directive
	function parseloopspec(p){
		var m = p.match( /^(\w+)\s*<-\s*(\S+)?$/ );
		if(m === null){
			error('bad loop spec: "' + p + '"');
		}
		if(m[1] === 'item'){
			error('"item<-..." is a reserved word for the current running iteration.\n\nPlease choose another name for your loop.');
		}
		if( !m[2] || (m[2] && (/context/i).test(m[2]))){ //undefined or space(IE) 
			m[2] = function(ctxt){return ctxt.context;};
		}
		return {name: m[1], sel: m[2]};
	}

	// parse a data selector and return a function that
	// can traverse the data accordingly, given a context.
	function dataselectfn(sel){
		if(typeof(sel) === 'function'){
			return sel;
		}
		//check for a valid js variable name with hyphen(for properties only), $, _ and :
		var m = sel.match(/^[a-zA-Z\$_][\w\$:-]*(\.[\w\$:-]*[^\.])*!?$/);
		if(m === null){
			var found = false, s = sel, parts = [], pfns = [], i = 0, retStr;
			// check if literal
			if(/\'|\"/.test( s.charAt(0) )){
				if(/\'|\"/.test( s.charAt(s.length-1) )){
					retStr = s.substring(1, s.length-1);
					return function(){ return retStr; };
				}
			}else{
				// check if literal + #{var}
				while((m = s.match(/#\{([^{}]+)\}/)) !== null){
					found = true;
					parts[i++] = s.slice(0, m.index);
					pfns[i] = dataselectfn(m[1]);
					s = s.slice(m.index + m[0].length, s.length);
				}
			}
			if(!found){
				error('bad data selector syntax: ' + sel);
			}
			parts[i] = s;
			return concatenator(parts, pfns);
		}
		m = sel.split('.');
		var sanitize = sel.endsWith('!');
		if (sanitize){
		    // take out the ! so it doesn't confuse the data walker
		    m[m.length - 1] = m[m.length - 1].substring(0, m[m.length - 1].length - 1);
		}
		return function(ctxt){
			var data = ctxt.context;
			if(!data){
				return '';
			}
			var	v = ctxt[m[0]],
				i = 0;
			if(v && v.item){
				data = v.item;
				i += 1;
			}
			var n = m.length;
			for(; i < n; i++){
				if(!data){break;}
				data = data[m[i]];
			}
			return (!data && data !== 0) ? '': (sanitize ? $.htmlEscape(data) : data);
		};
	}

	// wrap in an object the target node/attr and their properties
	function gettarget(dom, sel, isloop){
		var osel, prepend, selector, attr, append, target = [];
		if( typeof sel === 'string' ){
			osel = sel;
			var m = sel.match(selRx);
			if( !m ){
				error( 'bad selector syntax: ' + sel );
			}
			
			prepend = m[1];
			selector = m[2];
			attr = m[3];
			append = m[4];
			
			if(selector === '.' || ( !selector && attr ) ){
				target[0] = dom;
			}else{
				target = plugins.find(dom, selector);
			}
			if(!target || target.length === 0){
				return error('The node "' + sel + '" was not found in the template');
			}
		}else{
			// autoRender node
			prepend = sel.prepend;
			attr = sel.attr;
			append = sel.append;
			target = [dom];
		}
		
		if( prepend || append ){
			if( prepend && append ){
				error('append/prepend cannot take place at the same time');
			}else if( isloop ){
				error('no append/prepend/replace modifiers allowed for loop target');
			}else if( append && isloop ){
				error('cannot append with loop (sel: ' + osel + ')');
			}
		}
		var setstr, getstr, quotefn, isStyle, isClass, attName, setfn;
		if(attr){
			isStyle = (/^style$/i).test(attr);
			isClass = (/^class$/i).test(attr);
			attName = isClass ? 'className' : attr;
			setstr = function(node, s) {
				node.setAttribute(attPfx + attr, s);
				if (attName in node && !isStyle) {
					node[attName] = '';
				}
				if (node.nodeType === 1) {
					node.removeAttribute(attr);
					isClass && node.removeAttribute(attName);
				}
			};
			if (isStyle || isClass) {//IE no quotes special care
				if(isStyle){
					getstr = function(n){ return n.style.cssText; };
				}else{
					getstr = function(n){ return n.className;	};
				}
			}else {
				getstr = function(n){ return n.getAttribute(attr); };
			}

			// corey.ford@socrata.com 02/09/2015
			// Allow title text to wrap
			// Backported from upstream:
			// https://github.com/pure/pure/commit/e126045ff629f18b973e4675654dae62097119d6
			// https://github.com/pure/pure/commit/3715281a6657d86bc0f8eb6482a6e4e64c7ee69f
			quotefn = function(s){ return s.replace(/\"/g, '&quot;'); };

			// clint.tseng@socrata.com 18/05/2010
			// Add a space in between existing content and new content
			// if the attr to be set is a class.
			if(prepend){
				setfn = function(node, s)
				{
				    if (isClass)
				    { setstr( node, s + ' ' + getstr( node )); }
				    else
				    { setstr( node, s + getstr( node )); }
				};
			}else if(append){
				setfn = function(node, s)
				{
				    if (isClass)
				    { setstr( node, getstr( node ) + ' ' + s); }
				    else
				    { setstr( node, getstr( node ) + s); }
				};
			}else{
				setfn = function(node, s){ setstr( node, s ); };
			}
		}else{
			if (isloop) {
				setfn = function(node, s) {
					var pn = node.parentNode;
					if (pn) {
						//replace node with s
						pn.insertBefore(document.createTextNode(s), node.nextSibling);
						pn.removeChild(node);
					}
				};
			} else {
				if (prepend) {
					setfn = function(node, s) { node.insertBefore(document.createTextNode(s), node.firstChild);	};
				} else if (append) {
					setfn = function(node, s) { node.appendChild(document.createTextNode(s));};
				} else {
					setfn = function(node, s) {
						while (node.firstChild) { node.removeChild(node.firstChild); }
						node.appendChild(document.createTextNode(s));
					};
				}
			}
			quotefn = function(s) { return s; };
		}

		return { attr: attr, nodes: target, set: setfn, sel: osel, quotefn: quotefn };
	}

	function setsig(target, n){
		var sig = Sig + n + ':';
		for(var i = 0; i < target.nodes.length; i++){
			// could check for overlapping targets here.
			target.set( target.nodes[i], sig );
		}
	}

	// read de loop data, and pass it to the inner rendering function
	function loopfn(name, dselect, inner, sorter, filter){
		return function(ctxt){
			var a = dselect(ctxt),
				old = ctxt[name],
				temp = { items : a },
				filtered = 0,
				length,
				strs = [],
				buildArg = function(idx, temp, ftr, len){
				    // clint.tseng@socrata.com 18/05/2010:
				    // Fix a context loop bug. Yes, this adds a jQuery dependence,
				    // but I think it's a tiny bit too late too turn back on that anyway.
				    var ctxtNew = $.extend({}, ctxt);
					ctxtNew.pos = temp.pos = idx;
					ctxtNew.item = temp.item = a[ idx ];
					ctxtNew.items = a;
					//if array, set a length property - filtered items
					typeof len !== 'undefined' &&  (ctxtNew.length = len);
					//if filter directive
					if(typeof ftr === 'function' && ftr(ctxtNew) === false){
						filtered++;
						return;
					}
					strs.push( inner.call(temp, ctxtNew ) );
				};
			ctxt[name] = temp;
			if( isArray(a) ){
				length = a.length || 0;
				// if sort directive
				if(typeof sorter === 'function'){
					a.sort(sorter);
				}
				//loop on array
				for(var i = 0, ii = length; i < ii; i++){
					buildArg(i, temp, filter, length - filtered);
				}
			}else{
				if(a && typeof sorter !== 'undefined'){
					error('sort is only available on arrays, not objects');
				}
				//loop on collections
				for(var prop in a){
					a.hasOwnProperty( prop ) && buildArg(prop, temp, filter);
				}
			}

			typeof old !== 'undefined' ? ctxt[name] = old : delete ctxt[name];
			return strs.join('');
		};
	}
	// generate the template for a loop node
	function loopgen(dom, sel, loop, fns){
		var already = false, ls, sorter, filter, prop;
		for(prop in loop){
			if(loop.hasOwnProperty(prop)){
				if(prop === 'sort'){
					sorter = loop.sort;
					continue;
				}else if(prop === 'filter'){
					filter = loop.filter;
					continue;
				}
				if(already){
					error('cannot have more than one loop on a target');
				}
				ls = prop;
				already = true;
			}
		}
		if(!ls){
			error('Error in the selector: ' + sel + '\nA directive action must be a string, a function or a loop(<-)');
		}
		var dsel = loop[ls];
		// if it's a simple data selector then we default to contents, not replacement.
		if(typeof(dsel) === 'string' || typeof(dsel) === 'function'){
			loop = {};
			loop[ls] = {root: dsel};
			return loopgen(dom, sel, loop, fns);
		}
		var spec = parseloopspec(ls),
			itersel = dataselectfn(spec.sel),
			target = gettarget(dom, sel, true),
			nodes = target.nodes;
			
		for(i = 0; i < nodes.length; i++){
			var node = nodes[i],
				inner = compiler(node, dsel);
			fns[fns.length] = wrapquote(target.quotefn, loopfn(spec.name, itersel, inner, sorter, filter));
			target.nodes = [node];		// N.B. side effect on target.
			setsig(target, fns.length - 1);
		}
	}
	
	function getAutoNodes(n, data){
		var ns = n.getElementsByTagName('*'),
			an = [],
			openLoops = {a:[],l:{}},
			cspec,
			isNodeValue,
			i, ii, j, jj, ni, cs, cj;
		//for each node found in the template
		for(i = -1, ii = ns.length; i < ii; i++){
			ni = i > -1 ?ns[i]:n;
			if(ni.nodeType === 1 && ni.className !== ''){
				//when a className is found
				cs = ni.className.split(' ');
				// for each className 
				for(j = 0, jj=cs.length;j<jj;j++){
					cj = cs[j];
					// check if it is related to a context property
					cspec = checkClass(cj, ni.tagName);
					// if so, store the node, plus the type of data
					if(cspec !== false){
						isNodeValue = (/nodevalue/i).test(cspec.attr);
						if(cspec.sel.indexOf('@') > -1 || isNodeValue){
							ni.className = ni.className.replace('@'+cspec.attr, '');
							if(isNodeValue){
								cspec.attr = false;
							} 
						}
						an.push({n:ni, cspec:cspec});
					}
				}
			}
		}
		return an;
		
		function checkClass(c, tagName){
			// read the class
			var ca = c.match(selRx),
				attr = ca[3] || autoAttr[tagName],
				cspec = {prepend:!!ca[1], prop:ca[2], attr:attr, append:!!ca[4], sel:c},
				i, ii, loopi, loopil, val;
			// check in existing open loops
			for(i = openLoops.a.length-1; i >= 0; i--){
				loopi = openLoops.a[i];
				loopil = loopi.l[0];
				val = loopil && loopil[cspec.prop];
				if(typeof val !== 'undefined'){
					cspec.prop = loopi.p + '.' + cspec.prop;
					if(openLoops.l[cspec.prop] === true){
						val = val[0];
					}
					break;
				}
			}
			// not found check first level of data
			if(typeof val === 'undefined'){
				val = isArray(data) ? data[0][cspec.prop] : data[cspec.prop];
				// nothing found return
				if(typeof val === 'undefined'){
					return false;
				}
			}
			// set the spec for autoNode
			if(isArray(val)){
				openLoops.a.push( {l:val, p:cspec.prop} );
				openLoops.l[cspec.prop] = true;
				cspec.t = 'loop';
			}else{
				cspec.t = 'str';
			}
			return cspec;
		}
	}

	// returns a function that, given a context argument,
	// will render the template defined by dom and directive.
	function compiler(dom, directive, data, ans){
		var fns = [];
		// autoRendering nodes parsing -> auto-nodes
		ans = ans || data && getAutoNodes(dom, data);
		if(data){
			var j, jj, cspec, n, target, nodes, itersel, node, inner;
			// for each auto-nodes
			while(ans.length > 0){
				cspec = ans[0].cspec;
				n = ans[0].n;
				ans.splice(0, 1);
				if(cspec.t === 'str'){
					// if the target is a value
					target = gettarget(n, cspec, false);
					setsig(target, fns.length);
					fns[fns.length] = wrapquote(target.quotefn, dataselectfn(cspec.prop));
				}else{
					// if the target is a loop
					itersel = dataselectfn(cspec.sel);
					target = gettarget(n, cspec, true);
					nodes = target.nodes;
					for(j = 0, jj = nodes.length; j < jj; j++){
						node = nodes[j];
						inner = compiler(node, false, data, ans);
						fns[fns.length] = wrapquote(target.quotefn, loopfn(cspec.sel, itersel, inner));
						target.nodes = [node];
						setsig(target, fns.length - 1);
					}
				}
			}
		}
		// read directives
		var target, dsel;
		for(var sel in directive){
			if(directive.hasOwnProperty(sel)){
				dsel = directive[sel];
				if(typeof(dsel) === 'function' || typeof(dsel) === 'string'){
					// set the value for the node/attr
					target = gettarget(dom, sel, false);
					setsig(target, fns.length);
					fns[fns.length] = wrapquote(target.quotefn, dataselectfn(dsel));
				}else{
					// loop on node
					loopgen(dom, sel, dsel, fns);
				}
			}
		}
        // convert node to a string 
        var h = outerHTML(dom), pfns = [];
		// IE adds an unremovable "selected, value" attribute
		// hard replace while waiting for a better solution
        h = h.replace(/<([^>]+)\s(value\=""|selected)\s?([^>]*)>/ig, "<$1 $3>");
		
        // remove attribute prefix
        h = h.split(attPfx).join('');

		// slice the html string at "Sig"
		var parts = h.split( Sig ), p;
		// for each slice add the return string of 
		for(var i = 1; i < parts.length; i++){
			p = parts[i];
			// part is of the form "fn-number:..." as placed there by setsig.
			pfns[i] = fns[ parseInt(p, 10) ];
			parts[i] = p.substring( p.indexOf(':') + 1 );
		}
		return concatenator(parts, pfns);
	}
	// compile the template with directive
	// if a context is passed, the autoRendering is triggered automatically
	// return a function waiting the data as argument
	function compile(directive, ctxt, template){
		var rfn = compiler( ( template || this[0] ).cloneNode(true), directive, ctxt);
		return function(context){
			return rfn({context:context});
		};
	}
	//compile with the directive as argument
	// run the template function on the context argument
	// return an HTML string 
	// should replace the template and return this
	function render(ctxt, directive){
		var fn = typeof directive === 'function' ? directive : plugins.compile( directive, false, this[0] );
		for(var i = 0, ii = this.length; i < ii; i++){
			this[i] = replaceWith( this[i], fn( ctxt, false ));
		}
		context = null;
		return this;
	}

	// compile the template with autoRender
	// run the template function on the context argument
	// return an HTML string 
	function autoRender(ctxt, directive){
		var fn = plugins.compile( directive, ctxt, this[0] );
		for(var i = 0, ii = this.length; i < ii; i++){
			this[i] = replaceWith( this[i], fn( ctxt, false));
		}
		context = null;
		return this;
	}
	
	function replaceWith(elm, html) {
		var ne,
			ep = elm.parentNode,
			depth = 0;
		switch (elm.tagName) {
			case 'TBODY': case 'THEAD': case 'TFOOT':
				html = '<TABLE>' + html + '</TABLE>';
				depth = 1;
			break;
			case 'TR':
				html = '<TABLE><TBODY>' + html + '</TBODY></TABLE>';
				depth = 2;
			break;
			case 'TD': case 'TH':
				html = '<TABLE><TBODY><TR>' + html + '</TR></TBODY></TABLE>';
				depth = 3;
			break;
		}
		tmp = document.createElement('SPAN');
		tmp.style.display = 'none';
		document.body.appendChild(tmp);
		tmp.innerHTML = html;
		ne = tmp.firstChild;
		while (depth--) {
			ne = ne.firstChild;
		}
		ep.insertBefore(ne, elm);
		ep.removeChild(elm);
		document.body.removeChild(tmp);
		elm = ne;

		ne = ep = null;
		return elm;
	}
};

$p.plugins = {};

$p.libs = {
	dojo:function(){
		if(typeof document.querySelector === 'undefined'){
			$p.plugins.find = function(n, sel){
				return dojo.query(sel, n);
			};
		}
	},
	domassistant:function(){
		if(typeof document.querySelector === 'undefined'){
			$p.plugins.find = function(n, sel){
				return $(n).cssSelect(sel);
			};
		}
		DOMAssistant.attach({ 
			publicMethods : [ 'compile', 'render', 'autoRender'],
			compile:function(directive, ctxt){ return $p(this).compile(directive, ctxt); },
			render:function(ctxt, directive){ return $( $p(this).render(ctxt, directive) )[0]; },
			autoRender:function(ctxt, directive){ return $( $p(this).autoRender(ctxt, directive) )[0]; }
		});
	},
	jquery:function(){
		if(typeof document.querySelector === 'undefined'){
			$p.plugins.find = function(n, sel){
				return $(n).find(sel);
			};
		}
		jQuery.fn.extend({
			compile:function(directive, ctxt){ return $p(this[0]).compile(directive, ctxt); },
			render:function(ctxt, directive){ return $p( this[0] ).render( ctxt, directive ); },
			autoRender:function(ctxt, directive){ return jQuery( $p( this[0] ).autoRender( ctxt, directive ) ); }
		});
	},
	mootools:function(){
		if(typeof document.querySelector === 'undefined'){
			$p.plugins.find = function(n, sel){
				return $(n).getElements(sel);
			};
		}
		Element.implement({
			compile:function(directive, ctxt){ return $p(this).compile(directive, ctxt); },
			render:function(ctxt, directive){ return $p(this).render(ctxt, directive); },
			autoRender:function(ctxt, directive){ return $p(this).autoRender(ctxt, directive); }
		});
	},
	prototype:function(){
		if(typeof document.querySelector === 'undefined'){
			$p.plugins.find = function(n, sel){
				n = n === document ? n.body : n;
				return typeof n === 'string' ? $$(n) : $(n).select(sel);
			};
		}
		Element.addMethods({
			compile:function(element, directive, ctxt){ return $p(element).compile(directive, ctxt); }, 
			render:function(element, ctxt, directive){ return $p(element).render(ctxt, directive); }, 
			autoRender:function(element, ctxt, directive){ return $p(element).autoRender(ctxt, directive); }
		});
	},
	sizzle:function(){
		if(typeof document.querySelector === 'undefined'){
			$p.plugins.find = function(n, sel){
				return Sizzle(sel, n);
			};
		}
	},
	sly:function(){
		if(typeof document.querySelector === 'undefined'){  
			$p.plugins.find = function(n, sel){
				return Sly(sel, n);
			};
		}
	}
};

// get lib specifics if available
(function(){
	var libkey = 
		typeof dojo         !== 'undefined' && 'dojo' || 
		typeof DOMAssistant !== 'undefined' && 'domassistant' ||
		typeof jQuery       !== 'undefined' && 'jquery' || 
		typeof MooTools     !== 'undefined' && 'mootools' ||
		typeof Prototype    !== 'undefined' && 'prototype' || 
		typeof Sizzle       !== 'undefined' && 'sizzle' ||
		typeof Sly          !== 'undefined' && 'sly';
		
	libkey && $p.libs[libkey]();
})();


}.call(window));

/***/ }),

/***/ 2980:
/***/ (function(module, exports) {

/*** IMPORTS FROM imports-loader ***/
var define = undefined;
var require = undefined;
var module = undefined;
var exports = undefined;
(function() {

/*
 * CAUTION: This file (and everything in this directory) is marked as noParse
 * in our Webpack configuration. This means it cannot import modules, and that
 * it will not be transpiled to ES5. Do *NOT* use any ES6 features that our
 * supported browsers don't support natively (i.e., IE11 does not support arrow
 * functions).
 */

/*!
 * jQuery UI 1.8.23
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI
 */

 /**
	* Updated July 2019 to support jquery 3.4.1
	* - bind/unbind is deprecated: https://jquery.com/upgrade-guide/3.0/#deprecated-bind-and-delegate
	* - jQuery.expr[":"] is deprecated: https://jquery.com/upgrade-guide/3.0/#deprecated-jquery-expr-quot-quot-and-jquery-expr-filters
	* - event shorthands (like .click()) are deprecated: https://github.com/jquery/jquery-migrate/blob/master/warnings.md#jqmigrate-jqueryfnclick-event-shorthand-is-deprecated
	* - replace removed function andSelf with addBack: https://jquery.com/upgrade-guide/3.0/#breaking-change-andself-removed-use-addback
	* - offset is not always supported
	*/

// Adds back the old jquery default where if invalid elements
// returned the top left corner of the page
function safeOffset($elem) {
	var docElem = ( $elem.ownerDocument || window.document ).documentElement;
	return $.contains(docElem, $elem[0]) ? $elem.offset() : { top: 0, left: 0 };
};

(function( $, undefined ) {
// prevent duplicate loading
// this is only a problem because we proxy existing functions
// and we don't want to double proxy them
$.ui = $.ui || {};
if ( $.ui.version ) {
	return;
}

$.extend( $.ui, {
	version: "1.8.23",

	keyCode: {
		ALT: 18,
		BACKSPACE: 8,
		CAPS_LOCK: 20,
		COMMA: 188,
		COMMAND: 91,
		COMMAND_LEFT: 91, // COMMAND
		COMMAND_RIGHT: 93,
		CONTROL: 17,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		INSERT: 45,
		LEFT: 37,
		MENU: 93, // COMMAND_RIGHT
		NUMPAD_ADD: 107,
		NUMPAD_DECIMAL: 110,
		NUMPAD_DIVIDE: 111,
		NUMPAD_ENTER: 108,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_SUBTRACT: 109,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SHIFT: 16,
		SPACE: 32,
		TAB: 9,
		UP: 38,
		WINDOWS: 91 // COMMAND
	}
});

// plugins
$.fn.extend({
	propAttr: $.fn.prop || $.fn.attr,

	_focus: function() { return $.fn.trigger('focus') },
	focus: function( delay, fn ) {
		return typeof delay === "number" ?
			this.each(function() {
				var elem = this;
				setTimeout(function() {
					$( elem ).trigger('focus');
					if ( fn ) {
						fn.call( elem );
					}
				}, delay );
			}) :
			this._focus.apply( this, arguments );
	},

	scrollParent: function() {
		var scrollParent;
		if (($.browser.msie && (/(static|relative)/).test(this.css('position'))) || (/absolute/).test(this.css('position'))) {
			scrollParent = this.parents().filter(function() {
				return (/(relative|absolute|fixed)/).test($.curCSS(this,'position',1)) && (/(auto|scroll)/).test($.curCSS(this,'overflow',1)+$.curCSS(this,'overflow-y',1)+$.curCSS(this,'overflow-x',1));
			}).eq(0);
		} else {
			scrollParent = this.parents().filter(function() {
				return (/(auto|scroll)/).test($.curCSS(this,'overflow',1)+$.curCSS(this,'overflow-y',1)+$.curCSS(this,'overflow-x',1));
			}).eq(0);
		}

		return (/fixed/).test(this.css('position')) || !scrollParent.length ? $(document) : scrollParent;
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( "zIndex", zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length && elem[ 0 ] !== document ) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css( "position" );
				if ( position === "absolute" || position === "relative" || position === "fixed" ) {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
					value = parseInt( elem.css( "zIndex" ), 10 );
					if ( !isNaN( value ) && value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	},

	disableSelection: function() {
		return this.on( ( $.support.selectstart ? "selectstart" : "mousedown" ) +
			".ui-disableSelection", function( event ) {
				event.preventDefault();
			});
	},

	enableSelection: function() {
		return this.off( ".ui-disableSelection" );
	}
});

// support: jQuery <1.8
if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
	$.each( [ "Width", "Height" ], function( i, name ) {
		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.curCSS( elem, "padding" + this, true) ) || 0;
				if ( border ) {
					size -= parseFloat( $.curCSS( elem, "border" + this + "Width", true) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.curCSS( elem, "margin" + this, true) ) || 0;
				}
			});
			return size;
		}

		$.fn[ "inner" + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ "inner" + name ].call( this );
			}

			return this.each(function() {
				$( this ).css( type, reduce( this, size ) + "px" );
			});
		};

		$.fn[ "outer" + name] = function( size, margin ) {
			if ( typeof size !== "number" ) {
				return orig[ "outer" + name ].call( this, size );
			}

			return this.each(function() {
				$( this).css( type, reduce( this, size, true, margin ) + "px" );
			});
		};
	});
}

// selectors
function focusable( element, isTabIndexNotNaN ) {
	var nodeName = element.nodeName.toLowerCase();
	if ( "area" === nodeName ) {
		var map = element.parentNode,
			mapName = map.name,
			img;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
			return false;
		}
		img = $( "img[usemap=#" + mapName + "]" )[0];
		return !!img && visible( img );
	}
	return ( /input|select|textarea|button|object/.test( nodeName )
		? !element.disabled
		: "a" == nodeName
			? element.href || isTabIndexNotNaN
			: isTabIndexNotNaN)
		// the element and all of its ancestors must be visible
		&& visible( element );
}

function visible( element ) {
	return !$( element ).parents().addBack().filter(function() {
		return $.curCSS( this, "visibility" ) === "hidden" ||
			$.expr.pseudos.hidden( this );
	}).length;
}

$.extend( $.expr.pseudos, {
	data: $.expr.createPseudo ?
		$.expr.createPseudo(function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		}) :
		// support: jQuery <1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		},

	focusable: function( element ) {
		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" ),
			isTabIndexNaN = isNaN( tabIndex );
		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
	}
});

// support
$(function() {
	var body = document.body,
		div = body.appendChild( div = document.createElement( "div" ) );

	// access offsetHeight before setting the style to prevent a layout bug
	// in IE 9 which causes the elemnt to continue to take up space even
	// after it is removed from the DOM (#8026)
	div.offsetHeight;

	$.extend( div.style, {
		minHeight: "100px",
		height: "auto",
		padding: 0,
		borderWidth: 0
	});

	$.support.minHeight = div.offsetHeight === 100;
	$.support.selectstart = "onselectstart" in div;

	// set display to none to avoid a layout bug in IE
	// http://dev.jquery.com/ticket/4014
	body.removeChild( div ).style.display = "none";
});

// jQuery <1.4.3 uses curCSS, in 1.4.3 - 1.7.2 curCSS = css, 1.8+ only has css
if ( !$.curCSS ) {
	$.curCSS = $.css;
}





// deprecated
$.extend( $.ui, {
	// $.ui.plugin is deprecated.  Use the proxy pattern instead.
	plugin: {
		add: function( module, option, set ) {
			var proto = $.ui[ module ].prototype;
			for ( var i in set ) {
				proto.plugins[ i ] = proto.plugins[ i ] || [];
				proto.plugins[ i ].push( [ option, set[ i ] ] );
			}
		},
		call: function( instance, name, args ) {
			var set = instance.plugins[ name ];
			if ( !set || !instance.element[ 0 ].parentNode ) {
				return;
			}

			for ( var i = 0; i < set.length; i++ ) {
				if ( instance.options[ set[ i ][ 0 ] ] ) {
					set[ i ][ 1 ].apply( instance.element, args );
				}
			}
		}
	},

	// will be deprecated when we switch to jQuery 1.4 - use jQuery.contains()
	contains: function( a, b ) {
		return document.compareDocumentPosition ?
			a.compareDocumentPosition( b ) & 16 :
			a !== b && a.contains( b );
	},

	// only used by resizable
	hasScroll: function( el, a ) {

		//If overflow is hidden, the element might have extra content, but the user wants to hide it
		if ( $( el ).css( "overflow" ) === "hidden") {
			return false;
		}

		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
			has = false;

		if ( el[ scroll ] > 0 ) {
			return true;
		}

		// TODO: determine which cases actually cause this to happen
		// if the element doesn't have the scroll set, see if it's possible to
		// set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] > 0 );
		el[ scroll ] = 0;
		return has;
	},

	// these are odd functions, fix the API or move into individual plugins
	isOverAxis: function( x, reference, size ) {
		//Determines when x coordinate is over "b" element axis
		return ( x > reference ) && ( x < ( reference + size ) );
	},
	isOver: function( y, x, top, left, height, width ) {
		//Determines when x, y coordinates is over "b" element
		return $.ui.isOverAxis( y, top, height ) && $.ui.isOverAxis( x, left, width );
	}
});

})( jQuery );
/*!
 * jQuery UI Widget 1.8.23
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Widget
 */
(function( $, undefined ) {

// jQuery 1.4+
if ( $.cleanData ) {
	var _cleanData = $.cleanData;
	$.cleanData = function( elems ) {
		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			try {
				$( elem ).triggerHandler( "remove" );
			// http://bugs.jquery.com/ticket/8235
			} catch( e ) {}
		}
		_cleanData( elems );
	};
} else {
	var _remove = $.fn.remove;
	$.fn.remove = function( selector, keepData ) {
		return this.each(function() {
			if ( !keepData ) {
				if ( !selector || $.filter( selector, [ this ] ).length ) {
					$( "*", this ).add( [ this ] ).each(function() {
						try {
							$( this ).triggerHandler( "remove" );
						// http://bugs.jquery.com/ticket/8235
						} catch( e ) {}
					});
				}
			}
			return _remove.call( $(this), selector, keepData );
		});
	};
}

$.widget = function( name, base, prototype ) {
	var namespace = name.split( "." )[ 0 ],
		fullName;
	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr.pseudos[ fullName ] = function( elem ) {
		return !!$.data( elem, name );
	};

	$[ namespace ] = $[ namespace ] || {};
	$[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without initializing for simple inheritance
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};

	var basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
//	$.each( basePrototype, function( key, val ) {
//		if ( $.isPlainObject(val) ) {
//			basePrototype[ key ] = $.extend( {}, val );
//		}
//	});
	basePrototype.options = $.extend( true, {}, basePrototype.options );
	$[ namespace ][ name ].prototype = $.extend( true, basePrototype, {
		namespace: namespace,
		widgetName: name,
		widgetEventPrefix: $[ namespace ][ name ].prototype.widgetEventPrefix || name,
		widgetBaseClass: fullName
	}, prototype );

	$.widget.bridge( name, $[ namespace ][ name ] );
};

$.widget.bridge = function( name, object ) {
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = Array.prototype.slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall && args.length ?
			$.extend.apply( null, [ true, options ].concat(args) ) :
			options;

		// prevent calls to internal methods
		if ( isMethodCall && options.charAt( 0 ) === "_" ) {
			return returnValue;
		}

		if ( isMethodCall ) {
			this.each(function() {
				var instance = $.data( this, name ),
					methodValue = instance && $.isFunction( instance[options] ) ?
						instance[ options ].apply( instance, args ) :
						instance;
				// TODO: add this back in 1.9 and use $.error() (see #5972)
//				if ( !instance ) {
//					throw "cannot call methods on " + name + " prior to initialization; " +
//						"attempted to call method '" + options + "'";
//				}
//				if ( !$.isFunction( instance[options] ) ) {
//					throw "no such method '" + options + "' for " + name + " widget instance";
//				}
//				var methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, name );
				if ( instance ) {
					instance.option( options || {} )._init();
				} else {
					$.data( this, name, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( options, element ) {
	// allow instantiation without initializing for simple inheritance
	if ( arguments.length ) {
		this._createWidget( options, element );
	}
};

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	options: {
		disabled: false
	},
	_createWidget: function( options, element ) {
		// $.widget.bridge stores the plugin instance, but we do it anyway
		// so that it's stored even before the _create function runs
		$.data( element, this.widgetName, this );
		this.element = $( element );
		this.options = $.extend( true, {},
			this.options,
			this._getCreateOptions(),
			options );

		var self = this;
		this.element.on( "remove." + this.widgetName, function() {
			self.destroy();
		});

		this._create();
		this._trigger( "create" );
		this._init();
	},
	_getCreateOptions: function() {
		return $.metadata && $.metadata.get( this.element[0] )[ this.widgetName ];
	},
	_create: function() {},
	_init: function() {},

	destroy: function() {
		this.element
			.off( "." + this.widgetName )
			.removeData( this.widgetName );
		this.widget()
			.off( "." + this.widgetName )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetBaseClass + "-disabled " +
				"ui-state-disabled" );
	},

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.extend( {}, this.options );
		}

		if  (typeof key === "string" ) {
			if ( value === undefined ) {
				return this.options[ key ];
			}
			options = {};
			options[ key ] = value;
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var self = this;
		$.each( options, function( key, value ) {
			self._setOption( key, value );
		});

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				[ value ? "addClass" : "removeClass"](
					this.widgetBaseClass + "-disabled" + " " +
					"ui-state-disabled" )
				.attr( "aria-disabled", value );
		}

		return this;
	},

	enable: function() {
		return this._setOption( "disabled", false );
	},
	disable: function() {
		return this._setOption( "disabled", true );
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );

		return !( $.isFunction(callback) &&
			callback.call( this.element[0], event, data ) === false ||
			event.isDefaultPrevented() );
	}
};

})( jQuery );
/*!
 * jQuery UI Mouse 1.8.23
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Mouse
 *
 * Depends:
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

var mouseHandled = false;
$( document ).on('mouseup', function( e ) {
	mouseHandled = false;
});

$.widget("ui.mouse", {
	options: {
		cancel: ':input,option',
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var self = this;

		this.element
			.on('mousedown.'+this.widgetName, function(event) {
				return self._mouseDown(event);
			})
			.on('click.'+this.widgetName, function(event) {
				if (true === $.data(event.target, self.widgetName + '.preventClickEvent')) {
				    $.removeData(event.target, self.widgetName + '.preventClickEvent');
					event.stopImmediatePropagation();
					return false;
				}
			});

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.off('.'+this.widgetName);
		if ( this._mouseMoveDelegate ) {
			$(document)
				.off('mousemove.'+this.widgetName, this._mouseMoveDelegate)
				.off('mouseup.'+this.widgetName, this._mouseUpDelegate);
		}
	},

	_mouseDown: function(event) {
		// don't let more than one widget handle mouseStart
		if( mouseHandled ) { return };

		// we may have missed mouseup (out of window)
		(this._mouseStarted && this._mouseUp(event));

		this._mouseDownEvent = event;

		var self = this,
			btnIsLeft = (event.which == 1),
			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = (typeof this.options.cancel == "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if (!this.mouseDelayMet) {
			this._mouseDelayTimer = setTimeout(function() {
				self.mouseDelayMet = true;
			}, this.options.delay);
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted = (this._mouseStart(event) !== false);
			if (!this._mouseStarted) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko & Opera)
		if (true === $.data(event.target, this.widgetName + '.preventClickEvent')) {
			$.removeData(event.target, this.widgetName + '.preventClickEvent');
		}

		// these delegates are required to keep context
		this._mouseMoveDelegate = function(event) {
			return self._mouseMove(event);
		};
		this._mouseUpDelegate = function(event) {
			return self._mouseUp(event);
		};
		$(document)
			.on('mousemove.'+this.widgetName, this._mouseMoveDelegate)
			.on('mouseup.'+this.widgetName, this._mouseUpDelegate);

		event.preventDefault();

		mouseHandled = true;
		return true;
	},

	_mouseMove: function(event) {
		// IE mouseup check - mouseup happened when mouse was out of window
		if ($.browser.msie && !(document.documentMode >= 9) && !event.button) {
			return this._mouseUp(event);
		}

		if (this._mouseStarted) {
			this._mouseDrag(event);
			return event.preventDefault();
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted =
				(this._mouseStart(this._mouseDownEvent, event) !== false);
			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
		}

		return !this._mouseStarted;
	},

	_mouseUp: function(event) {
		$(document)
			.off('mousemove.'+this.widgetName, this._mouseMoveDelegate)
			.off('mouseup.'+this.widgetName, this._mouseUpDelegate);

		if (this._mouseStarted) {
			this._mouseStarted = false;

			if (event.target == this._mouseDownEvent.target) {
			    $.data(event.target, this.widgetName + '.preventClickEvent', true);
			}

			this._mouseStop(event);
		}

		return false;
	},

	_mouseDistanceMet: function(event) {
		return (Math.max(
				Math.abs(this._mouseDownEvent.pageX - event.pageX),
				Math.abs(this._mouseDownEvent.pageY - event.pageY)
			) >= this.options.distance
		);
	},

	_mouseDelayMet: function(event) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function(event) {},
	_mouseDrag: function(event) {},
	_mouseStop: function(event) {},
	_mouseCapture: function(event) { return true; }
});

})(jQuery);
/*!
 * jQuery UI Position 1.8.23
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Position
 */
(function( $, undefined ) {

$.ui = $.ui || {};

var horizontalPositions = /left|center|right/,
	verticalPositions = /top|center|bottom/,
	center = "center",
	support = {},
	_position = $.fn.position,
	_offset = $.fn.offset;

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var target = $( options.of ),
		targetElem = target[0],
		collision = ( options.collision || "flip" ).split( " " ),
		offset = options.offset ? options.offset.split( " " ) : [ 0, 0 ],
		targetWidth,
		targetHeight,
		basePosition;

	if ( targetElem.nodeType === 9 ) {
		targetWidth = target.width();
		targetHeight = target.height();
		basePosition = { top: 0, left: 0 };
	// TODO: use $.isWindow() in 1.9
	} else if ( targetElem.setTimeout ) {
		targetWidth = target.width();
		targetHeight = target.height();
		basePosition = { top: target.scrollTop(), left: target.scrollLeft() };
	} else if ( targetElem.preventDefault ) {
		// force left top to allow flipping
		options.at = "left top";
		targetWidth = targetHeight = 0;
		basePosition = { top: options.of.pageY, left: options.of.pageX };
	} else {
		targetWidth = target.outerWidth();
		targetHeight = target.outerHeight();
		basePosition = target.offset();
	}

	// force my and at to have valid horizontal and veritcal positions
	// if a value is missing or invalid, it will be converted to center
	$.each( [ "my", "at" ], function() {
		var pos = ( options[this] || "" ).split( " " );
		if ( pos.length === 1) {
			pos = horizontalPositions.test( pos[0] ) ?
				pos.concat( [center] ) :
				verticalPositions.test( pos[0] ) ?
					[ center ].concat( pos ) :
					[ center, center ];
		}
		pos[ 0 ] = horizontalPositions.test( pos[0] ) ? pos[ 0 ] : center;
		pos[ 1 ] = verticalPositions.test( pos[1] ) ? pos[ 1 ] : center;
		options[ this ] = pos;
	});

	// normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	// normalize offset option
	offset[ 0 ] = parseInt( offset[0], 10 ) || 0;
	if ( offset.length === 1 ) {
		offset[ 1 ] = offset[ 0 ];
	}
	offset[ 1 ] = parseInt( offset[1], 10 ) || 0;

	if ( options.at[0] === "right" ) {
		basePosition.left += targetWidth;
	} else if ( options.at[0] === center ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[1] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[1] === center ) {
		basePosition.top += targetHeight / 2;
	}

	basePosition.left += offset[ 0 ];
	basePosition.top += offset[ 1 ];

	return this.each(function() {
		var elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseInt( $.curCSS( this, "marginLeft", true ) ) || 0,
			marginTop = parseInt( $.curCSS( this, "marginTop", true ) ) || 0,
			collisionWidth = elemWidth + marginLeft +
				( parseInt( $.curCSS( this, "marginRight", true ) ) || 0 ),
			collisionHeight = elemHeight + marginTop +
				( parseInt( $.curCSS( this, "marginBottom", true ) ) || 0 ),
			position = $.extend( {}, basePosition ),
			collisionPosition;

		if ( options.my[0] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[0] === center ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[1] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[1] === center ) {
			position.top -= elemHeight / 2;
		}

		// prevent fractions if jQuery version doesn't support them (see #5280)
		if ( !support.fractions ) {
			position.left = Math.round( position.left );
			position.top = Math.round( position.top );
		}

		collisionPosition = {
			left: position.left - marginLeft,
			top: position.top - marginTop
		};

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[i] ] ) {
				$.ui.position[ collision[i] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: offset,
					my: options.my,
					at: options.at
				});
			}
		});

		if ( $.fn.bgiframe ) {
			elem.bgiframe();
		}
		elem.offset( $.extend( position, { using: options.using } ) );
	});
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var win = $( window ),
				over = data.collisionPosition.left + data.collisionWidth - win.width() - win.scrollLeft();
			position.left = over > 0 ? position.left - over : Math.max( position.left - data.collisionPosition.left, position.left );
		},
		top: function( position, data ) {
			var win = $( window ),
				over = data.collisionPosition.top + data.collisionHeight - win.height() - win.scrollTop();
			position.top = over > 0 ? position.top - over : Math.max( position.top - data.collisionPosition.top, position.top );
		}
	},

	flip: {
		left: function( position, data ) {
			if ( data.at[0] === center ) {
				return;
			}
			var win = $( window ),
				over = data.collisionPosition.left + data.collisionWidth - win.width() - win.scrollLeft(),
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === "left" ?
					data.targetWidth :
					-data.targetWidth,
				offset = -2 * data.offset[ 0 ];
			position.left += data.collisionPosition.left < 0 ?
				myOffset + atOffset + offset :
				over > 0 ?
					myOffset + atOffset + offset :
					0;
		},
		top: function( position, data ) {
			if ( data.at[1] === center ) {
				return;
			}
			var win = $( window ),
				over = data.collisionPosition.top + data.collisionHeight - win.height() - win.scrollTop(),
				myOffset = data.my[ 1 ] === "top" ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					-data.targetHeight,
				offset = -2 * data.offset[ 1 ];
			position.top += data.collisionPosition.top < 0 ?
				myOffset + atOffset + offset :
				over > 0 ?
					myOffset + atOffset + offset :
					0;
		}
	}
};

// offset setter from jQuery 1.4
if ( !$.offset.setOffset ) {
	$.offset.setOffset = function( elem, options ) {
		// set position first, in-case top/left are set even on static elem
		if ( /static/.test( $.curCSS( elem, "position" ) ) ) {
			elem.style.position = "relative";
		}
		var curElem   = $( elem ),
			curOffset = curElem.offset(),
			curTop    = parseInt( $.curCSS( elem, "top",  true ), 10 ) || 0,
			curLeft   = parseInt( $.curCSS( elem, "left", true ), 10)  || 0,
			props     = {
				top:  (options.top  - curOffset.top)  + curTop,
				left: (options.left - curOffset.left) + curLeft
			};

		if ( 'using' in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	};

	$.fn.offset = function( options ) {
		var elem = this[ 0 ];
		if ( !elem || !elem.ownerDocument ) { return null; }
		if ( options ) {
			if ( $.isFunction( options ) ) {
				return this.each(function( i ) {
					$( this ).offset( options.call( this, i, $( this ).offset() ) );
				});
			}
			return this.each(function() {
				$.offset.setOffset( this, options );
			});
		}
		return _offset.call( this );
	};
}

// jQuery <1.4.3 uses curCSS, in 1.4.3 - 1.7.2 curCSS = css, 1.8+ only has css
if ( !$.curCSS ) {
	$.curCSS = $.css;
}

// fraction support test (older versions of jQuery don't support fractions)
(function () {
	var body = document.getElementsByTagName( "body" )[ 0 ],
		div = document.createElement( "div" ),
		testElement, testElementParent, testElementStyle, offset, offsetTotal;

	//Create a "fake body" for testing based on method used in jQuery.support
	testElement = document.createElement( body ? "div" : "body" );
	testElementStyle = {
		visibility: "hidden",
		width: 0,
		height: 0,
		border: 0,
		margin: 0,
		background: "none"
	};
	if ( body ) {
		$.extend( testElementStyle, {
			position: "absolute",
			left: "-1000px",
			top: "-1000px"
		});
	}
	for ( var i in testElementStyle ) {
		testElement.style[ i ] = testElementStyle[ i ];
	}
	testElement.appendChild( div );
	testElementParent = body || document.documentElement;
	testElementParent.insertBefore( testElement, testElementParent.firstChild );

	div.style.cssText = "position: absolute; left: 10.7432222px; top: 10.432325px; height: 30px; width: 201px;";

	offset = $( div ).offset( function( _, offset ) {
		return offset;
	}).offset();

	testElement.innerHTML = "";
	testElementParent.removeChild( testElement );

	offsetTotal = offset.top + offset.left + ( body ? 2000 : 0 );
	support.fractions = offsetTotal > 21 && offsetTotal < 22;
})();

}( jQuery ));
/*!
 * jQuery UI Draggable 1.8.23
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Draggables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget("ui.draggable", $.ui.mouse, {
	widgetEventPrefix: "drag",
	options: {
		addClasses: true,
		appendTo: "parent",
		axis: false,
		connectToSortable: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		grid: false,
		handle: false,
		helper: "original",
		iframeFix: false,
		opacity: false,
		refreshPositions: false,
		revert: false,
		revertDuration: 500,
		scope: "default",
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		snap: false,
		snapMode: "both",
		snapTolerance: 20,
		stack: false,
		zIndex: false
	},
	_create: function() {

		if (this.options.helper == 'original' && !(/^(?:r|a|f)/).test(this.element.css("position")))
			this.element[0].style.position = 'relative';

		(this.options.addClasses && this.element.addClass("ui-draggable"));
		(this.options.disabled && this.element.addClass("ui-draggable-disabled"));

		this._mouseInit();

	},

	destroy: function() {
		if(!this.element.data('draggable')) return;
		this.element
			.removeData("draggable")
			.off(".draggable")
			.removeClass("ui-draggable"
				+ " ui-draggable-dragging"
				+ " ui-draggable-disabled");
		this._mouseDestroy();

		return this;
	},

	_mouseCapture: function(event) {

		var o = this.options;

		// among others, prevent a drag on a resizable-handle
		if (this.helper || o.disabled || $(event.target).is('.ui-resizable-handle'))
			return false;

		//Quit if we're not on a valid handle
		this.handle = this._getHandle(event);
		if (!this.handle)
			return false;

		if ( o.iframeFix ) {
			$(o.iframeFix === true ? "iframe" : o.iframeFix).each(function() {
				$('<div class="ui-draggable-iframeFix" style="background: #fff;"></div>')
				.css({
					width: this.offsetWidth+"px", height: this.offsetHeight+"px",
					position: "absolute", opacity: "0.001", zIndex: 1000
				})
				.css($(this).offset())
				.appendTo("body");
			});
		}

		return true;

	},

	_mouseStart: function(event) {

		var o = this.options;

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		this.helper.addClass("ui-draggable-dragging");

		//Cache the helper size
		this._cacheHelperProportions();

		//If ddmanager is used for droppables, set the global draggable
		if($.ui.ddmanager)
			$.ui.ddmanager.current = this;

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Store the helper's css position
		this.cssPosition = this.helper.css("position");
		this.scrollParent = this.helper.scrollParent();

		//The element's absolute position on the page minus margins
		this.offset = this.positionAbs = this.element.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		//Generate the original position
		this.originalPosition = this.position = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if 'cursorAt' is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Set a containment if given in the options
		if(o.containment)
			this._setContainment();

		//Trigger event + callbacks
		if(this._trigger("start", event) === false) {
			this._clear();
			return false;
		}

		//Recache the helper size
		this._cacheHelperProportions();

		//Prepare the droppable offsets
		if ($.ui.ddmanager && !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(this, event);


		this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position

		//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
		if ( $.ui.ddmanager ) $.ui.ddmanager.dragStart(this, event);

		return true;
	},

	_mouseDrag: function(event, noPropagation) {

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo("absolute");

		//Call plugins and callbacks and use the resulting position if something is returned
		if (!noPropagation) {
			var ui = this._uiHash();
			if(this._trigger('drag', event, ui) === false) {
				this._mouseUp({});
				return false;
			}
			this.position = ui.position;
		}

		if(!this.options.axis || this.options.axis != "y") this.helper[0].style.left = this.position.left+'px';
		if(!this.options.axis || this.options.axis != "x") this.helper[0].style.top = this.position.top+'px';
		if($.ui.ddmanager) $.ui.ddmanager.drag(this, event);

		return false;
	},

	_mouseStop: function(event) {

		//If we are using droppables, inform the manager about the drop
		var dropped = false;
		if ($.ui.ddmanager && !this.options.dropBehaviour)
			dropped = $.ui.ddmanager.drop(this, event);

		//if a drop comes from outside (a sortable)
		if(this.dropped) {
			dropped = this.dropped;
			this.dropped = false;
		}

		//if the original element is no longer in the DOM don't bother to continue (see #8269)
		var element = this.element[0], elementInDom = false;
		while ( element && (element = element.parentNode) ) {
			if (element == document ) {
				elementInDom = true;
			}
		}
		if ( !elementInDom && this.options.helper === "original" )
			return false;

		if((this.options.revert == "invalid" && !dropped) || (this.options.revert == "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
			var self = this;
			$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
				if(self._trigger("stop", event) !== false) {
					self._clear();
				}
			});
		} else {
			if(this._trigger("stop", event) !== false) {
				this._clear();
			}
		}

		return false;
	},

	_mouseUp: function(event) {
		if (this.options.iframeFix === true) {
			$("div.ui-draggable-iframeFix").each(function() {
				this.parentNode.removeChild(this);
			}); //Remove frame helpers
		}

		//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
		if( $.ui.ddmanager ) $.ui.ddmanager.dragStop(this, event);

		return $.ui.mouse.prototype._mouseUp.call(this, event);
	},

	cancel: function() {

		if(this.helper.is(".ui-draggable-dragging")) {
			this._mouseUp({});
		} else {
			this._clear();
		}

		return this;

	},

	_getHandle: function(event) {

		var handle = !this.options.handle || !$(this.options.handle, this.element).length ? true : false;
		$(this.options.handle, this.element)
			.find("*")
			.addBack()
			.each(function() {
				if(this == event.target) handle = true;
			});

		return handle;

	},

	_createHelper: function(event) {

		var o = this.options;
		var helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper == 'clone' ? this.element.clone().removeAttr('id') : this.element);

		if(!helper.parents('body').length)
			helper.appendTo((o.appendTo == 'parent' ? this.element[0].parentNode : o.appendTo));

		if(helper[0] != this.element[0] && !(/(fixed|absolute)/).test(helper.css("position")))
			helper.css("position", "absolute");

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj == 'string') {
			obj = obj.split(' ');
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if ('left' in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ('right' in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ('top' in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ('bottom' in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition == 'absolute' && this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if((this.offsetParent[0] == document.body) //This needs to be actually done for all browsers, since pageX/pageY includes this information
		|| (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() == 'html' && $.browser.msie)) //Ugly IE fix
			po = { top: 0, left: 0 };

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition == "relative") {
			var p = this.element.position();
			return {
				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.element.css("marginLeft"),10) || 0),
			top: (parseInt(this.element.css("marginTop"),10) || 0),
			right: (parseInt(this.element.css("marginRight"),10) || 0),
			bottom: (parseInt(this.element.css("marginBottom"),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var o = this.options;
		if(o.containment == 'parent') o.containment = this.helper[0].parentNode;
		if(o.containment == 'document' || o.containment == 'window') this.containment = [
			o.containment == 'document' ? 0 : $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
			o.containment == 'document' ? 0 : $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top,
			(o.containment == 'document' ? 0 : $(window).scrollLeft()) + $(o.containment == 'document' ? document : window).width() - this.helperProportions.width - this.margins.left,
			(o.containment == 'document' ? 0 : $(window).scrollTop()) + ($(o.containment == 'document' ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
		];

		if(!(/^(document|window|parent)$/).test(o.containment) && o.containment.constructor != Array) {
		        var c = $(o.containment);
			var ce = c[0]; if(!ce) return;
			var co = c.offset();
			var over = ($(ce).css("overflow") != 'hidden');

			this.containment = [
				(parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0),
				(parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0),
				(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right,
				(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top  - this.margins.bottom
			];
			this.relative_container = c;

		} else if(o.containment.constructor == Array) {
			this.containment = o.containment;
		}

	},

	_convertPositionTo: function(d, pos) {

		if(!pos) pos = this.position;
		var mod = d == "absolute" ? 1 : -1;
		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		return {
			top: (
				pos.top																	// The absolute mouse position
				+ this.offset.relative.top * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.top * mod											// The offsetParent's offset without borders (offset + border)
				- ($.browser.safari && $.browser.version < 526 && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
			),
			left: (
				pos.left																// The absolute mouse position
				+ this.offset.relative.left * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.left * mod											// The offsetParent's offset without borders (offset + border)
				- ($.browser.safari && $.browser.version < 526 && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
			)
		};

	},

	_generatePosition: function(event) {

		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);
		var pageX = event.pageX;
		var pageY = event.pageY;

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		if(this.originalPosition) { //If we are not dragging yet, we won't check for options
		         var containment;
		         if(this.containment) {
				 if (this.relative_container){
				     var co = this.relative_container.offset();
				     containment = [ this.containment[0] + co.left,
						     this.containment[1] + co.top,
						     this.containment[2] + co.left,
						     this.containment[3] + co.top ];
				 }
				 else {
				     containment = this.containment;
				 }

				if(event.pageX - this.offset.click.left < containment[0]) pageX = containment[0] + this.offset.click.left;
				if(event.pageY - this.offset.click.top < containment[1]) pageY = containment[1] + this.offset.click.top;
				if(event.pageX - this.offset.click.left > containment[2]) pageX = containment[2] + this.offset.click.left;
				if(event.pageY - this.offset.click.top > containment[3]) pageY = containment[3] + this.offset.click.top;
			}

			if(o.grid) {
				//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
				var top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
				pageY = containment ? (!(top - this.offset.click.top < containment[1] || top - this.offset.click.top > containment[3]) ? top : (!(top - this.offset.click.top < containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				var left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
				pageX = containment ? (!(left - this.offset.click.left < containment[0] || left - this.offset.click.left > containment[2]) ? left : (!(left - this.offset.click.left < containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY																// The absolute mouse position
				- this.offset.click.top													// Click offset (relative to the element)
				- this.offset.relative.top												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.top												// The offsetParent's offset without borders (offset + border)
				+ ($.browser.safari && $.browser.version < 526 && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
			),
			left: (
				pageX																// The absolute mouse position
				- this.offset.click.left												// Click offset (relative to the element)
				- this.offset.relative.left												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.left												// The offsetParent's offset without borders (offset + border)
				+ ($.browser.safari && $.browser.version < 526 && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
			)
		};

	},

	_clear: function() {
		this.helper.removeClass("ui-draggable-dragging");
		if(this.helper[0] != this.element[0] && !this.cancelHelperRemoval) this.helper.remove();
		//if($.ui.ddmanager) $.ui.ddmanager.current = null;
		this.helper = null;
		this.cancelHelperRemoval = false;
	},

	// From now on bulk stuff - mainly helpers

	_trigger: function(type, event, ui) {
		ui = ui || this._uiHash();
		$.ui.plugin.call(this, type, [event, ui]);
		if(type == "drag") this.positionAbs = this._convertPositionTo("absolute"); //The absolute position has to be recalculated after plugins
		return $.Widget.prototype._trigger.call(this, type, event, ui);
	},

	plugins: {},

	_uiHash: function(event) {
		return {
			helper: this.helper,
			position: this.position,
			originalPosition: this.originalPosition,
			offset: this.positionAbs
		};
	}

});

$.extend($.ui.draggable, {
	version: "1.8.23"
});

$.ui.plugin.add("draggable", "connectToSortable", {
	start: function(event, ui) {

		var inst = $(this).data("draggable"), o = inst.options,
			uiSortable = $.extend({}, ui, { item: inst.element });
		inst.sortables = [];
		$(o.connectToSortable).each(function() {
			var sortable = $.data(this, 'sortable');
			if (sortable && !sortable.options.disabled) {
				inst.sortables.push({
					instance: sortable,
					shouldRevert: sortable.options.revert
				});
				sortable.refreshPositions();	// Call the sortable's refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it's initialised as well as being kept in step with any changes that might have happened on the page).
				sortable._trigger("activate", event, uiSortable);
			}
		});

	},
	stop: function(event, ui) {

		//If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
		var inst = $(this).data("draggable"),
			uiSortable = $.extend({}, ui, { item: inst.element });

		$.each(inst.sortables, function() {
			if(this.instance.isOver) {

				this.instance.isOver = 0;

				inst.cancelHelperRemoval = true; //Don't remove the helper in the draggable instance
				this.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)

				//The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: 'valid/invalid'
				if(this.shouldRevert) this.instance.options.revert = true;

				//Trigger the stop of the sortable
				this.instance._mouseStop(event);

				this.instance.options.helper = this.instance.options._helper;

				//If the helper has been the original item, restore properties in the sortable
				if(inst.options.helper == 'original')
					this.instance.currentItem.css({ top: 'auto', left: 'auto' });

			} else {
				this.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance
				this.instance._trigger("deactivate", event, uiSortable);
			}

		});

	},
	drag: function(event, ui) {

		var inst = $(this).data("draggable"), self = this;

		var checkPos = function(o) {
			var dyClick = this.offset.click.top, dxClick = this.offset.click.left;
			var helperTop = this.positionAbs.top, helperLeft = this.positionAbs.left;
			var itemHeight = o.height, itemWidth = o.width;
			var itemTop = o.top, itemLeft = o.left;

			return $.ui.isOver(helperTop + dyClick, helperLeft + dxClick, itemTop, itemLeft, itemHeight, itemWidth);
		};

		$.each(inst.sortables, function(i) {

			//Copy over some variables to allow calling the sortable's native _intersectsWith
			this.instance.positionAbs = inst.positionAbs;
			this.instance.helperProportions = inst.helperProportions;
			this.instance.offset.click = inst.offset.click;

			if(this.instance._intersectsWith(this.instance.containerCache)) {

				//If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
				if(!this.instance.isOver) {

					this.instance.isOver = 1;
					//Now we fake the start of dragging for the sortable instance,
					//by cloning the list group item, appending it to the sortable and using it as inst.currentItem
					//We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn't create a new one)
					this.instance.currentItem = $(self).clone().removeAttr('id').appendTo(this.instance.element).data("sortable-item", true);
					this.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it
					this.instance.options.helper = function() { return ui.helper[0]; };

					event.target = this.instance.currentItem[0];
					this.instance._mouseCapture(event, true);
					this.instance._mouseStart(event, true, true);

					//Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
					this.instance.offset.click.top = inst.offset.click.top;
					this.instance.offset.click.left = inst.offset.click.left;
					this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
					this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;

					inst._trigger("toSortable", event);
					inst.dropped = this.instance.element; //draggable revert needs that
					//hack so receive/update callbacks work (mostly)
					inst.currentItem = inst.element;
					this.instance.fromOutside = inst;

				}

				//Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
				if(this.instance.currentItem) this.instance._mouseDrag(event);

			} else {

				//If it doesn't intersect with the sortable, and it intersected before,
				//we fake the drag stop of the sortable, but make sure it doesn't remove the helper by using cancelHelperRemoval
				if(this.instance.isOver) {

					this.instance.isOver = 0;
					this.instance.cancelHelperRemoval = true;

					//Prevent reverting on this forced stop
					this.instance.options.revert = false;

					// The out event needs to be triggered independently
					this.instance._trigger('out', event, this.instance._uiHash(this.instance));

					this.instance._mouseStop(event, true);
					this.instance.options.helper = this.instance.options._helper;

					//Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it's original size
					this.instance.currentItem.remove();
					if(this.instance.placeholder) this.instance.placeholder.remove();

					inst._trigger("fromSortable", event);
					inst.dropped = false; //draggable revert needs that
				}

			};

		});

	}
});

$.ui.plugin.add("draggable", "cursor", {
	start: function(event, ui) {
		var t = $('body'), o = $(this).data('draggable').options;
		if (t.css("cursor")) o._cursor = t.css("cursor");
		t.css("cursor", o.cursor);
	},
	stop: function(event, ui) {
		var o = $(this).data('draggable').options;
		if (o._cursor) $('body').css("cursor", o._cursor);
	}
});

$.ui.plugin.add("draggable", "opacity", {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data('draggable').options;
		if(t.css("opacity")) o._opacity = t.css("opacity");
		t.css('opacity', o.opacity);
	},
	stop: function(event, ui) {
		var o = $(this).data('draggable').options;
		if(o._opacity) $(ui.helper).css('opacity', o._opacity);
	}
});

$.ui.plugin.add("draggable", "scroll", {
	start: function(event, ui) {
		var i = $(this).data("draggable");
		if(i.scrollParent[0] != document && i.scrollParent[0].tagName != 'HTML') i.overflowOffset = i.scrollParent.offset();
	},
	drag: function(event, ui) {

		var i = $(this).data("draggable"), o = i.options, scrolled = false;

		if(i.scrollParent[0] != document && i.scrollParent[0].tagName != 'HTML') {

			if(!o.axis || o.axis != 'x') {
				if((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity)
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
				else if(event.pageY - i.overflowOffset.top < o.scrollSensitivity)
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
			}

			if(!o.axis || o.axis != 'y') {
				if((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity)
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
				else if(event.pageX - i.overflowOffset.left < o.scrollSensitivity)
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
			}

		} else {

			if(!o.axis || o.axis != 'x') {
				if(event.pageY - $(document).scrollTop() < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
			}

			if(!o.axis || o.axis != 'y') {
				if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
			}

		}

		if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(i, event);

	}
});

$.ui.plugin.add("draggable", "snap", {
	start: function(event, ui) {

		var i = $(this).data("draggable"), o = i.options;
		i.snapElements = [];

		$(o.snap.constructor != String ? ( o.snap.items || ':data(draggable)' ) : o.snap).each(function() {
			var $t = $(this); var $o = $t.offset();
			if(this != i.element[0]) i.snapElements.push({
				item: this,
				width: $t.outerWidth(), height: $t.outerHeight(),
				top: $o.top, left: $o.left
			});
		});

	},
	drag: function(event, ui) {

		var inst = $(this).data("draggable"), o = inst.options;
		var d = o.snapTolerance;

		var x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

		for (var i = inst.snapElements.length - 1; i >= 0; i--){

			var l = inst.snapElements[i].left, r = l + inst.snapElements[i].width,
				t = inst.snapElements[i].top, b = t + inst.snapElements[i].height;

			//Yes, I know, this is insane ;)
			if(!((l-d < x1 && x1 < r+d && t-d < y1 && y1 < b+d) || (l-d < x1 && x1 < r+d && t-d < y2 && y2 < b+d) || (l-d < x2 && x2 < r+d && t-d < y1 && y1 < b+d) || (l-d < x2 && x2 < r+d && t-d < y2 && y2 < b+d))) {
				if(inst.snapElements[i].snapping) (inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
				inst.snapElements[i].snapping = false;
				continue;
			}

			if(o.snapMode != 'inner') {
				var ts = Math.abs(t - y2) <= d;
				var bs = Math.abs(b - y1) <= d;
				var ls = Math.abs(l - x2) <= d;
				var rs = Math.abs(r - x1) <= d;
				if(ts) ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				if(bs) ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top - inst.margins.top;
				if(ls) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left;
				if(rs) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left - inst.margins.left;
			}

			var first = (ts || bs || ls || rs);

			if(o.snapMode != 'outer') {
				var ts = Math.abs(t - y1) <= d;
				var bs = Math.abs(b - y2) <= d;
				var ls = Math.abs(l - x1) <= d;
				var rs = Math.abs(r - x2) <= d;
				if(ts) ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top - inst.margins.top;
				if(bs) ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				if(ls) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left - inst.margins.left;
				if(rs) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left;
			}

			if(!inst.snapElements[i].snapping && (ts || bs || ls || rs || first))
				(inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
			inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

		};

	}
});

$.ui.plugin.add("draggable", "stack", {
	start: function(event, ui) {

		var o = $(this).data("draggable").options;

		var group = $.makeArray($(o.stack)).sort(function(a,b) {
			return (parseInt($(a).css("zIndex"),10) || 0) - (parseInt($(b).css("zIndex"),10) || 0);
		});
		if (!group.length) { return; }

		var min = parseInt(group[0].style.zIndex) || 0;
		$(group).each(function(i) {
			this.style.zIndex = min + i;
		});

		this[0].style.zIndex = min + group.length;

	}
});

$.ui.plugin.add("draggable", "zIndex", {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data("draggable").options;
		if(t.css("zIndex")) o._zIndex = t.css("zIndex");
		t.css('zIndex', o.zIndex);
	},
	stop: function(event, ui) {
		var o = $(this).data("draggable").options;
		if(o._zIndex) $(ui.helper).css('zIndex', o._zIndex);
	}
});

})(jQuery);
/*!
 * jQuery UI Droppable 1.8.23
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Droppables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *	jquery.ui.mouse.js
 *	jquery.ui.draggable.js
 */
(function( $, undefined ) {

$.widget("ui.droppable", {
	widgetEventPrefix: "drop",
	options: {
		accept: '*',
		activeClass: false,
		addClasses: true,
		greedy: false,
		hoverClass: false,
		scope: 'default',
		tolerance: 'intersect'
	},
	_create: function() {

		var o = this.options, accept = o.accept;
		this.isover = 0; this.isout = 1;

		this.accept = $.isFunction(accept) ? accept : function(d) {
			return d.is(accept);
		};

		//Store the droppable's proportions
		this.proportions = { width: this.element[0].offsetWidth, height: this.element[0].offsetHeight };

		// Add the reference and positions to the manager
		$.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [];
		$.ui.ddmanager.droppables[o.scope].push(this);

		(o.addClasses && this.element.addClass("ui-droppable"));

	},

	destroy: function() {
		var drop = $.ui.ddmanager.droppables[this.options.scope];
		for ( var i = 0; i < drop.length; i++ )
			if ( drop[i] == this )
				drop.splice(i, 1);

		this.element
			.removeClass("ui-droppable ui-droppable-disabled")
			.removeData("droppable")
			.off(".droppable");

		return this;
	},

	_setOption: function(key, value) {

		if(key == 'accept') {
			this.accept = $.isFunction(value) ? value : function(d) {
				return d.is(value);
			};
		}
		$.Widget.prototype._setOption.apply(this, arguments);
	},

	_activate: function(event) {
		var draggable = $.ui.ddmanager.current;
		if(this.options.activeClass) this.element.addClass(this.options.activeClass);
		(draggable && this._trigger('activate', event, this.ui(draggable)));
	},

	_deactivate: function(event) {
		var draggable = $.ui.ddmanager.current;
		if(this.options.activeClass) this.element.removeClass(this.options.activeClass);
		(draggable && this._trigger('deactivate', event, this.ui(draggable)));
	},

	_over: function(event) {

		var draggable = $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return; // Bail if draggable and droppable are same element

		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.hoverClass) this.element.addClass(this.options.hoverClass);
			this._trigger('over', event, this.ui(draggable));
		}

	},

	_out: function(event) {

		var draggable = $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return; // Bail if draggable and droppable are same element

		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.hoverClass) this.element.removeClass(this.options.hoverClass);
			this._trigger('out', event, this.ui(draggable));
		}

	},

	_drop: function(event,custom) {

		var draggable = custom || $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return false; // Bail if draggable and droppable are same element

		var childrenIntersection = false;
		this.element.find(":data(droppable)").not(".ui-draggable-dragging").each(function() {
			var inst = $.data(this, 'droppable');
			if(
				inst.options.greedy
				&& !inst.options.disabled
				&& inst.options.scope == draggable.options.scope
				&& inst.accept.call(inst.element[0], (draggable.currentItem || draggable.element))
				&& $.ui.intersect(draggable, $.extend(inst, { offset: inst.element.offset() }), inst.options.tolerance)
			) { childrenIntersection = true; return false; }
		});
		if(childrenIntersection) return false;

		if(this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.activeClass) this.element.removeClass(this.options.activeClass);
			if(this.options.hoverClass) this.element.removeClass(this.options.hoverClass);
			this._trigger('drop', event, this.ui(draggable));
			return this.element;
		}

		return false;

	},

	ui: function(c) {
		return {
			draggable: (c.currentItem || c.element),
			helper: c.helper,
			position: c.position,
			offset: c.positionAbs
		};
	}

});

$.extend($.ui.droppable, {
	version: "1.8.23"
});

$.ui.intersect = function(draggable, droppable, toleranceMode) {

	if (!droppable.offset) return false;

	var x1 = (draggable.positionAbs || draggable.position.absolute).left, x2 = x1 + draggable.helperProportions.width,
		y1 = (draggable.positionAbs || draggable.position.absolute).top, y2 = y1 + draggable.helperProportions.height;
	var l = droppable.offset.left, r = l + droppable.proportions.width,
		t = droppable.offset.top, b = t + droppable.proportions.height;

	switch (toleranceMode) {
		case 'fit':
			return (l <= x1 && x2 <= r
				&& t <= y1 && y2 <= b);
			break;
		case 'intersect':
			return (l < x1 + (draggable.helperProportions.width / 2) // Right Half
				&& x2 - (draggable.helperProportions.width / 2) < r // Left Half
				&& t < y1 + (draggable.helperProportions.height / 2) // Bottom Half
				&& y2 - (draggable.helperProportions.height / 2) < b ); // Top Half
			break;
		case 'pointer':
			var draggableLeft = ((draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left),
				draggableTop = ((draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top),
				isOver = $.ui.isOver(draggableTop, draggableLeft, t, l, droppable.proportions.height, droppable.proportions.width);
			return isOver;
			break;
		case 'touch':
			return (
					(y1 >= t && y1 <= b) ||	// Top edge touching
					(y2 >= t && y2 <= b) ||	// Bottom edge touching
					(y1 < t && y2 > b)		// Surrounded vertically
				) && (
					(x1 >= l && x1 <= r) ||	// Left edge touching
					(x2 >= l && x2 <= r) ||	// Right edge touching
					(x1 < l && x2 > r)		// Surrounded horizontally
				);
			break;
		default:
			return false;
			break;
		}

};

/*
	This manager tracks offsets of draggables and droppables
*/
$.ui.ddmanager = {
	current: null,
	droppables: { 'default': [] },
	prepareOffsets: function(t, event) {

		var m = $.ui.ddmanager.droppables[t.options.scope] || [];
		var type = event ? event.type : null; // workaround for #2317
		var list = (t.currentItem || t.element).find(":data(droppable)").addBack();

		droppablesLoop: for (var i = 0; i < m.length; i++) {

			if(m[i].options.disabled || (t && !m[i].accept.call(m[i].element[0],(t.currentItem || t.element)))) continue;	//No disabled and non-accepted
			for (var j=0; j < list.length; j++) { if(list[j] == m[i].element[0]) { m[i].proportions.height = 0; continue droppablesLoop; } }; //Filter out elements in the current dragged item
			m[i].visible = m[i].element.css("display") != "none"; if(!m[i].visible) continue; 									//If the element is not visible, continue

			if(type == "mousedown") m[i]._activate.call(m[i], event); //Activate the droppable if used directly from draggables

			m[i].offset = m[i].element.offset();
			m[i].proportions = { width: m[i].element[0].offsetWidth, height: m[i].element[0].offsetHeight };

		}

	},
	drop: function(draggable, event) {

		var dropped = false;
		$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

			if(!this.options) return;
			if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance))
				dropped = this._drop.call(this, event) || dropped;

			if (!this.options.disabled && this.visible && this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
				this.isout = 1; this.isover = 0;
				this._deactivate.call(this, event);
			}

		});
		return dropped;

	},
	dragStart: function( draggable, event ) {
		//Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
		draggable.element.parents( ":not(body,html)" ).on( "scroll.droppable", function() {
			if( !draggable.options.refreshPositions ) $.ui.ddmanager.prepareOffsets( draggable, event );
		});
	},
	drag: function(draggable, event) {

		//If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
		if(draggable.options.refreshPositions) $.ui.ddmanager.prepareOffsets(draggable, event);

		//Run through all droppables and check their positions based on specific tolerance options
		$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

			if(this.options.disabled || this.greedyChild || !this.visible) return;
			var intersects = $.ui.intersect(draggable, this, this.options.tolerance);

			var c = !intersects && this.isover == 1 ? 'isout' : (intersects && this.isover == 0 ? 'isover' : null);
			if(!c) return;

			var parentInstance;
			if (this.options.greedy) {
				var parent = this.element.parents(':data(droppable):eq(0)');
				if (parent.length) {
					parentInstance = $.data(parent[0], 'droppable');
					parentInstance.greedyChild = (c == 'isover' ? 1 : 0);
				}
			}

			// we just moved into a greedy child
			if (parentInstance && c == 'isover') {
				parentInstance['isover'] = 0;
				parentInstance['isout'] = 1;
				parentInstance._out.call(parentInstance, event);
			}

			this[c] = 1; this[c == 'isout' ? 'isover' : 'isout'] = 0;
			this[c == "isover" ? "_over" : "_out"].call(this, event);

			// we just moved out of a greedy child
			if (parentInstance && c == 'isout') {
				parentInstance['isout'] = 0;
				parentInstance['isover'] = 1;
				parentInstance._over.call(parentInstance, event);
			}
		});

	},
	dragStop: function( draggable, event ) {
		draggable.element.parents( ":not(body,html)" ).off( "scroll.droppable" );
		//Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
		if( !draggable.options.refreshPositions ) $.ui.ddmanager.prepareOffsets( draggable, event );
	}
};

})(jQuery);
/*!
 * jQuery UI Resizable 1.8.23
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Resizables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget("ui.resizable", $.ui.mouse, {
	widgetEventPrefix: "resize",
	options: {
		alsoResize: false,
		animate: false,
		animateDuration: "slow",
		animateEasing: "swing",
		aspectRatio: false,
		autoHide: false,
		containment: false,
		ghost: false,
		grid: false,
		handles: "e,s,se",
		helper: false,
		maxHeight: null,
		maxWidth: null,
		minHeight: 10,
		minWidth: 10,
		zIndex: 1000
	},
	_create: function() {

		var self = this, o = this.options;
		this.element.addClass("ui-resizable");

		$.extend(this, {
			_aspectRatio: !!(o.aspectRatio),
			aspectRatio: o.aspectRatio,
			originalElement: this.element,
			_proportionallyResizeElements: [],
			_helper: o.helper || o.ghost || o.animate ? o.helper || 'ui-resizable-helper' : null
		});

		//Wrap the element if it cannot hold child nodes
		if(this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {

			//Create a wrapper element and set the wrapper to the new current internal element
			this.element.wrap(
				$('<div class="ui-wrapper" style="overflow: hidden;"></div>').css({
					position: this.element.css('position'),
					width: this.element.outerWidth(),
					height: this.element.outerHeight(),
					top: this.element.css('top'),
					left: this.element.css('left')
				})
			);

			//Overwrite the original this.element
			this.element = this.element.parent().data(
				"resizable", this.element.data('resizable')
			);

			this.elementIsWrapper = true;

			//Move margins to the wrapper
			this.element.css({ marginLeft: this.originalElement.css("marginLeft"), marginTop: this.originalElement.css("marginTop"), marginRight: this.originalElement.css("marginRight"), marginBottom: this.originalElement.css("marginBottom") });
			this.originalElement.css({ marginLeft: 0, marginTop: 0, marginRight: 0, marginBottom: 0});

			//Prevent Safari textarea resize
			this.originalResizeStyle = this.originalElement.css('resize');
			this.originalElement.css('resize', 'none');

			//Push the actual element to our proportionallyResize internal array
			this._proportionallyResizeElements.push(this.originalElement.css({ position: 'static', zoom: 1, display: 'block' }));

			// avoid IE jump (hard set the margin)
			this.originalElement.css({ margin: this.originalElement.css('margin') });

			// fix handlers offset
			this._proportionallyResize();

		}

		this.handles = o.handles || (!$('.ui-resizable-handle', this.element).length ? "e,s,se" : { n: '.ui-resizable-n', e: '.ui-resizable-e', s: '.ui-resizable-s', w: '.ui-resizable-w', se: '.ui-resizable-se', sw: '.ui-resizable-sw', ne: '.ui-resizable-ne', nw: '.ui-resizable-nw' });
		if(this.handles.constructor == String) {

			if(this.handles == 'all') this.handles = 'n,e,s,w,se,sw,ne,nw';
			var n = this.handles.split(","); this.handles = {};

			for(var i = 0; i < n.length; i++) {

				var handle = $.trim(n[i]), hname = 'ui-resizable-'+handle;
				var axis = $('<div class="ui-resizable-handle ' + hname + '"></div>');

				// Apply zIndex to all handles - see #7960
				axis.css({ zIndex: o.zIndex });

				//TODO : What's going on here?
				if ('se' == handle) {
					axis.addClass('ui-icon ui-icon-gripsmall-diagonal-se');
				};

				//Insert into internal handles object and append to element
				this.handles[handle] = '.ui-resizable-'+handle;
				this.element.append(axis);
			}

		}

		this._renderAxis = function(target) {

			target = target || this.element;

			for(var i in this.handles) {

				if(this.handles[i].constructor == String)
					this.handles[i] = $(this.handles[i], this.element).show();

				//Apply pad to wrapper element, needed to fix axis position (textarea, inputs, scrolls)
				if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {

					var axis = $(this.handles[i], this.element), padWrapper = 0;

					//Checking the correct pad and border
					padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();

					//The padding type i have to apply...
					var padPos = [ 'padding',
						/ne|nw|n/.test(i) ? 'Top' :
						/se|sw|s/.test(i) ? 'Bottom' :
						/^e$/.test(i) ? 'Right' : 'Left' ].join("");

					target.css(padPos, padWrapper);

					this._proportionallyResize();

				}

				//TODO: What's that good for? There's not anything to be executed left
				if(!$(this.handles[i]).length)
					continue;

			}
		};

		//TODO: make renderAxis a prototype function
		this._renderAxis(this.element);

		this._handles = $('.ui-resizable-handle', this.element)
			.disableSelection();

		//Matching axis name
		this._handles.on('mouseover', function() {
			if (!self.resizing) {
				if (this.className)
					var axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
				//Axis, default = se
				self.axis = axis && axis[1] ? axis[1] : 'se';
			}
		});

		//If we want to auto hide the elements
		if (o.autoHide) {
			this._handles.hide();
			$(this.element)
				.addClass("ui-resizable-autohide")
				.on('mouseenter', function() {
					if (o.disabled) return;
					$(this).removeClass("ui-resizable-autohide");
					self._handles.show();
				})
				.on('mouseout', function() {
					if (o.disabled) return;
					if (!self.resizing) {
						$(this).addClass("ui-resizable-autohide");
						self._handles.hide();
					}
				});
		}

		//Initialize the mouse interaction
		this._mouseInit();

	},

	destroy: function() {

		this._mouseDestroy();

		var _destroy = function(exp) {
			$(exp).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing")
				.removeData("resizable").off(".resizable").find('.ui-resizable-handle').remove();
		};

		//TODO: Unwrap at same DOM position
		if (this.elementIsWrapper) {
			_destroy(this.element);
			var wrapper = this.element;
			wrapper.after(
				this.originalElement.css({
					position: wrapper.css('position'),
					width: wrapper.outerWidth(),
					height: wrapper.outerHeight(),
					top: wrapper.css('top'),
					left: wrapper.css('left')
				})
			).remove();
		}

		this.originalElement.css('resize', this.originalResizeStyle);
		_destroy(this.originalElement);

		return this;
	},

	_mouseCapture: function(event) {
		var handle = false;
		for (var i in this.handles) {
			if ($(this.handles[i])[0] == event.target) {
				handle = true;
			}
		}

		return !this.options.disabled && handle;
	},

	_mouseStart: function(event) {

		var o = this.options, iniPos = this.element.position(), el = this.element;

		this.resizing = true;
		this.documentScroll = { top: $(document).scrollTop(), left: $(document).scrollLeft() };

		// bugfix for http://dev.jquery.com/ticket/1749
		if (el.is('.ui-draggable') || (/absolute/).test(el.css('position'))) {
			el.css({ position: 'absolute', top: iniPos.top, left: iniPos.left });
		}

		this._renderProxy();

		var curleft = num(this.helper.css('left')), curtop = num(this.helper.css('top'));

		if (o.containment) {
			curleft += $(o.containment).scrollLeft() || 0;
			curtop += $(o.containment).scrollTop() || 0;
		}

		//Store needed variables
		this.offset = this.helper.offset();
		this.position = { left: curleft, top: curtop };
		this.size = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalSize = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalPosition = { left: curleft, top: curtop };
		this.sizeDiff = { width: el.outerWidth() - el.width(), height: el.outerHeight() - el.height() };
		this.originalMousePosition = { left: event.pageX, top: event.pageY };

		//Aspect Ratio
		this.aspectRatio = (typeof o.aspectRatio == 'number') ? o.aspectRatio : ((this.originalSize.width / this.originalSize.height) || 1);

	    var cursor = $('.ui-resizable-' + this.axis).css('cursor');
	    $('body').css('cursor', cursor == 'auto' ? this.axis + '-resize' : cursor);

		el.addClass("ui-resizable-resizing");
		this._propagate("start", event);
		return true;
	},

	_mouseDrag: function(event) {

		//Increase performance, avoid regex
		var el = this.helper, o = this.options, props = {},
			self = this, smp = this.originalMousePosition, a = this.axis;

		var dx = (event.pageX-smp.left)||0, dy = (event.pageY-smp.top)||0;
		var trigger = this._change[a];
		if (!trigger) return false;

		// Calculate the attrs that will be change
		var data = trigger.apply(this, [event, dx, dy]), ie6 = $.browser.msie && $.browser.version < 7, csdif = this.sizeDiff;

		// Put this in the mouseDrag handler since the user can start pressing shift while resizing
		this._updateVirtualBoundaries(event.shiftKey);
		if (this._aspectRatio || event.shiftKey)
			data = this._updateRatio(data, event);

		data = this._respectSize(data, event);

		// plugins callbacks need to be called first
		this._propagate("resize", event);

		el.css({
			top: this.position.top + "px", left: this.position.left + "px",
			width: this.size.width + "px", height: this.size.height + "px"
		});

		if (!this._helper && this._proportionallyResizeElements.length)
			this._proportionallyResize();

		this._updateCache(data);

		// calling the user callback at the end
		this._trigger('resize', event, this.ui());

		return false;
	},

	_mouseStop: function(event) {

		this.resizing = false;
		var o = this.options, self = this;

		if(this._helper) {
			var pr = this._proportionallyResizeElements, ista = pr.length && (/textarea/i).test(pr[0].nodeName),
				soffseth = ista && $.ui.hasScroll(pr[0], 'left') /* TODO - jump height */ ? 0 : self.sizeDiff.height,
				soffsetw = ista ? 0 : self.sizeDiff.width;

			var s = { width: (self.helper.width()  - soffsetw), height: (self.helper.height() - soffseth) },
				left = (parseInt(self.element.css('left'), 10) + (self.position.left - self.originalPosition.left)) || null,
				top = (parseInt(self.element.css('top'), 10) + (self.position.top - self.originalPosition.top)) || null;

			if (!o.animate)
				this.element.css($.extend(s, { top: top, left: left }));

			self.helper.height(self.size.height);
			self.helper.width(self.size.width);

			if (this._helper && !o.animate) this._proportionallyResize();
		}

		$('body').css('cursor', 'auto');

		this.element.removeClass("ui-resizable-resizing");

		this._propagate("stop", event);

		if (this._helper) this.helper.remove();
		return false;

	},

    _updateVirtualBoundaries: function(forceAspectRatio) {
        var o = this.options, pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b;

        b = {
            minWidth: isNumber(o.minWidth) ? o.minWidth : 0,
            maxWidth: isNumber(o.maxWidth) ? o.maxWidth : Infinity,
            minHeight: isNumber(o.minHeight) ? o.minHeight : 0,
            maxHeight: isNumber(o.maxHeight) ? o.maxHeight : Infinity
        };

        if(this._aspectRatio || forceAspectRatio) {
            // We want to create an enclosing box whose aspect ration is the requested one
            // First, compute the "projected" size for each dimension based on the aspect ratio and other dimension
            pMinWidth = b.minHeight * this.aspectRatio;
            pMinHeight = b.minWidth / this.aspectRatio;
            pMaxWidth = b.maxHeight * this.aspectRatio;
            pMaxHeight = b.maxWidth / this.aspectRatio;

            if(pMinWidth > b.minWidth) b.minWidth = pMinWidth;
            if(pMinHeight > b.minHeight) b.minHeight = pMinHeight;
            if(pMaxWidth < b.maxWidth) b.maxWidth = pMaxWidth;
            if(pMaxHeight < b.maxHeight) b.maxHeight = pMaxHeight;
        }
        this._vBoundaries = b;
    },

	_updateCache: function(data) {
		var o = this.options;
		this.offset = this.helper.offset();
		if (isNumber(data.left)) this.position.left = data.left;
		if (isNumber(data.top)) this.position.top = data.top;
		if (isNumber(data.height)) this.size.height = data.height;
		if (isNumber(data.width)) this.size.width = data.width;
	},

	_updateRatio: function(data, event) {

		var o = this.options, cpos = this.position, csize = this.size, a = this.axis;

		if (isNumber(data.height)) data.width = (data.height * this.aspectRatio);
		else if (isNumber(data.width)) data.height = (data.width / this.aspectRatio);

		if (a == 'sw') {
			data.left = cpos.left + (csize.width - data.width);
			data.top = null;
		}
		if (a == 'nw') {
			data.top = cpos.top + (csize.height - data.height);
			data.left = cpos.left + (csize.width - data.width);
		}

		return data;
	},

	_respectSize: function(data, event) {

		var el = this.helper, o = this._vBoundaries, pRatio = this._aspectRatio || event.shiftKey, a = this.axis,
				ismaxw = isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width), ismaxh = isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
					isminw = isNumber(data.width) && o.minWidth && (o.minWidth > data.width), isminh = isNumber(data.height) && o.minHeight && (o.minHeight > data.height);

		if (isminw) data.width = o.minWidth;
		if (isminh) data.height = o.minHeight;
		if (ismaxw) data.width = o.maxWidth;
		if (ismaxh) data.height = o.maxHeight;

		var dw = this.originalPosition.left + this.originalSize.width, dh = this.position.top + this.size.height;
		var cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);

		if (isminw && cw) data.left = dw - o.minWidth;
		if (ismaxw && cw) data.left = dw - o.maxWidth;
		if (isminh && ch)	data.top = dh - o.minHeight;
		if (ismaxh && ch)	data.top = dh - o.maxHeight;

		// fixing jump error on top/left - bug #2330
		var isNotwh = !data.width && !data.height;
		if (isNotwh && !data.left && data.top) data.top = null;
		else if (isNotwh && !data.top && data.left) data.left = null;

		return data;
	},

	_proportionallyResize: function() {

		var o = this.options;
		if (!this._proportionallyResizeElements.length) return;
		var element = this.helper || this.element;

		for (var i=0; i < this._proportionallyResizeElements.length; i++) {

			var prel = this._proportionallyResizeElements[i];

			if (!this.borderDif) {
				var b = [prel.css('borderTopWidth'), prel.css('borderRightWidth'), prel.css('borderBottomWidth'), prel.css('borderLeftWidth')],
					p = [prel.css('paddingTop'), prel.css('paddingRight'), prel.css('paddingBottom'), prel.css('paddingLeft')];

				this.borderDif = $.map(b, function(v, i) {
					var border = parseInt(v,10)||0, padding = parseInt(p[i],10)||0;
					return border + padding;
				});
			}

			if ($.browser.msie && !(!($(element).is(':hidden') || $(element).parents(':hidden').length)))
				continue;

			prel.css({
				height: (element.height() - this.borderDif[0] - this.borderDif[2]) || 0,
				width: (element.width() - this.borderDif[1] - this.borderDif[3]) || 0
			});

		};

	},

	_renderProxy: function() {

		var el = this.element, o = this.options;
		this.elementOffset = el.offset();

		if(this._helper) {

			this.helper = this.helper || $('<div style="overflow:hidden;"></div>');

			// fix ie6 offset TODO: This seems broken
			var ie6 = $.browser.msie && $.browser.version < 7, ie6offset = (ie6 ? 1 : 0),
			pxyoffset = ( ie6 ? 2 : -1 );

			this.helper.addClass(this._helper).css({
				width: this.element.outerWidth() + pxyoffset,
				height: this.element.outerHeight() + pxyoffset,
				position: 'absolute',
				left: this.elementOffset.left - ie6offset +'px',
				top: this.elementOffset.top - ie6offset +'px',
				zIndex: ++o.zIndex //TODO: Don't modify option
			});

			this.helper
				.appendTo("body")
				.disableSelection();

		} else {
			this.helper = this.element;
		}

	},

	_change: {
		e: function(event, dx, dy) {
			return { width: this.originalSize.width + dx };
		},
		w: function(event, dx, dy) {
			var o = this.options, cs = this.originalSize, sp = this.originalPosition;
			return { left: sp.left + dx, width: cs.width - dx };
		},
		n: function(event, dx, dy) {
			var o = this.options, cs = this.originalSize, sp = this.originalPosition;
			return { top: sp.top + dy, height: cs.height - dy };
		},
		s: function(event, dx, dy) {
			return { height: this.originalSize.height + dy };
		},
		se: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		sw: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		},
		ne: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		nw: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		}
	},

	_propagate: function(n, event) {
		$.ui.plugin.call(this, n, [event, this.ui()]);
		(n != "resize" && this._trigger(n, event, this.ui()));
	},

	plugins: {},

	ui: function() {
		return {
			originalElement: this.originalElement,
			element: this.element,
			helper: this.helper,
			position: this.position,
			size: this.size,
			originalSize: this.originalSize,
			originalPosition: this.originalPosition
		};
	}

});

$.extend($.ui.resizable, {
	version: "1.8.23"
});

/*
 * Resizable Extensions
 */

$.ui.plugin.add("resizable", "alsoResize", {

	start: function (event, ui) {
		var self = $(this).data("resizable"), o = self.options;

		var _store = function (exp) {
			$(exp).each(function() {
				var el = $(this);
				el.data("resizable-alsoresize", {
					width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
					left: parseInt(el.css('left'), 10), top: parseInt(el.css('top'), 10)
				});
			});
		};

		if (typeof(o.alsoResize) == 'object' && !o.alsoResize.parentNode) {
			if (o.alsoResize.length) { o.alsoResize = o.alsoResize[0]; _store(o.alsoResize); }
			else { $.each(o.alsoResize, function (exp) { _store(exp); }); }
		}else{
			_store(o.alsoResize);
		}
	},

	resize: function (event, ui) {
		var self = $(this).data("resizable"), o = self.options, os = self.originalSize, op = self.originalPosition;

		var delta = {
			height: (self.size.height - os.height) || 0, width: (self.size.width - os.width) || 0,
			top: (self.position.top - op.top) || 0, left: (self.position.left - op.left) || 0
		},

		_alsoResize = function (exp, c) {
			$(exp).each(function() {
				var el = $(this), start = $(this).data("resizable-alsoresize"), style = {},
					css = c && c.length ? c : el.parents(ui.originalElement[0]).length ? ['width', 'height'] : ['width', 'height', 'top', 'left'];

				$.each(css, function (i, prop) {
					var sum = (start[prop]||0) + (delta[prop]||0);
					if (sum && sum >= 0)
						style[prop] = sum || null;
				});

				el.css(style);
			});
		};

		if (typeof(o.alsoResize) == 'object' && !o.alsoResize.nodeType) {
			$.each(o.alsoResize, function (exp, c) { _alsoResize(exp, c); });
		}else{
			_alsoResize(o.alsoResize);
		}
	},

	stop: function (event, ui) {
		$(this).removeData("resizable-alsoresize");
	}
});

$.ui.plugin.add("resizable", "animate", {

	stop: function(event, ui) {
		var self = $(this).data("resizable"), o = self.options;

		var pr = self._proportionallyResizeElements, ista = pr.length && (/textarea/i).test(pr[0].nodeName),
					soffseth = ista && $.ui.hasScroll(pr[0], 'left') /* TODO - jump height */ ? 0 : self.sizeDiff.height,
						soffsetw = ista ? 0 : self.sizeDiff.width;

		var style = { width: (self.size.width - soffsetw), height: (self.size.height - soffseth) },
					left = (parseInt(self.element.css('left'), 10) + (self.position.left - self.originalPosition.left)) || null,
						top = (parseInt(self.element.css('top'), 10) + (self.position.top - self.originalPosition.top)) || null;

		self.element.animate(
			$.extend(style, top && left ? { top: top, left: left } : {}), {
				duration: o.animateDuration,
				easing: o.animateEasing,
				step: function() {

					var data = {
						width: parseInt(self.element.css('width'), 10),
						height: parseInt(self.element.css('height'), 10),
						top: parseInt(self.element.css('top'), 10),
						left: parseInt(self.element.css('left'), 10)
					};

					if (pr && pr.length) $(pr[0]).css({ width: data.width, height: data.height });

					// propagating resize, and updating values for each animation step
					self._updateCache(data);
					self._propagate("resize", event);

				}
			}
		);
	}

});

$.ui.plugin.add("resizable", "containment", {

	start: function(event, ui) {
		var self = $(this).data("resizable"), o = self.options, el = self.element;
		var oc = o.containment,	ce = (oc instanceof $) ? oc.get(0) : (/parent/.test(oc)) ? el.parent().get(0) : oc;
		if (!ce) return;

		self.containerElement = $(ce);

		if (/document/.test(oc) || oc == document) {
			self.containerOffset = { left: 0, top: 0 };
			self.containerPosition = { left: 0, top: 0 };

			self.parentData = {
				element: $(document), left: 0, top: 0,
				width: $(document).width(), height: $(document).height() || document.body.parentNode.scrollHeight
			};
		}

		// i'm a node, so compute top, left, right, bottom
		else {
			var element = $(ce), p = [];
			$([ "Top", "Right", "Left", "Bottom" ]).each(function(i, name) { p[i] = num(element.css("padding" + name)); });

			self.containerOffset = element.offset();
			self.containerPosition = element.position();
			self.containerSize = { height: (element.innerHeight() - p[3]), width: (element.innerWidth() - p[1]) };

			var co = self.containerOffset, ch = self.containerSize.height,	cw = self.containerSize.width,
						width = ($.ui.hasScroll(ce, "left") ? ce.scrollWidth : cw ), height = ($.ui.hasScroll(ce) ? ce.scrollHeight : ch);

			self.parentData = {
				element: ce, left: co.left, top: co.top, width: width, height: height
			};
		}
	},

	resize: function(event, ui) {
		var self = $(this).data("resizable"), o = self.options,
				ps = self.containerSize, co = self.containerOffset, cs = self.size, cp = self.position,
				pRatio = self._aspectRatio || event.shiftKey, cop = { top:0, left:0 }, ce = self.containerElement;

		if (ce[0] != document && (/static/).test(ce.css('position'))) cop = co;

		if (cp.left < (self._helper ? co.left : 0)) {
			self.size.width = self.size.width + (self._helper ? (self.position.left - co.left) : (self.position.left - cop.left));
			if (pRatio) self.size.height = self.size.width / self.aspectRatio;
			self.position.left = o.helper ? co.left : 0;
		}

		if (cp.top < (self._helper ? co.top : 0)) {
			self.size.height = self.size.height + (self._helper ? (self.position.top - co.top) : self.position.top);
			if (pRatio) self.size.width = self.size.height * self.aspectRatio;
			self.position.top = self._helper ? co.top : 0;
		}

		self.offset.left = self.parentData.left+self.position.left;
		self.offset.top = self.parentData.top+self.position.top;

		var woset = Math.abs( (self._helper ? self.offset.left - cop.left : (self.offset.left - cop.left)) + self.sizeDiff.width ),
					hoset = Math.abs( (self._helper ? self.offset.top - cop.top : (self.offset.top - co.top)) + self.sizeDiff.height );

		var isParent = self.containerElement.get(0) == self.element.parent().get(0),
		    isOffsetRelative = /relative|absolute/.test(self.containerElement.css('position'));

		if(isParent && isOffsetRelative) woset -= self.parentData.left;

		if (woset + self.size.width >= self.parentData.width) {
			self.size.width = self.parentData.width - woset;
			if (pRatio) self.size.height = self.size.width / self.aspectRatio;
		}

		if (hoset + self.size.height >= self.parentData.height) {
			self.size.height = self.parentData.height - hoset;
			if (pRatio) self.size.width = self.size.height * self.aspectRatio;
		}
	},

	stop: function(event, ui){
		var self = $(this).data("resizable"), o = self.options, cp = self.position,
				co = self.containerOffset, cop = self.containerPosition, ce = self.containerElement;

		var helper = $(self.helper), ho = helper.offset(), w = helper.outerWidth() - self.sizeDiff.width, h = helper.outerHeight() - self.sizeDiff.height;

		if (self._helper && !o.animate && (/relative/).test(ce.css('position')))
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });

		if (self._helper && !o.animate && (/static/).test(ce.css('position')))
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });

	}
});

$.ui.plugin.add("resizable", "ghost", {

	start: function(event, ui) {

		var self = $(this).data("resizable"), o = self.options, cs = self.size;

		self.ghost = self.originalElement.clone();
		self.ghost
			.css({ opacity: .25, display: 'block', position: 'relative', height: cs.height, width: cs.width, margin: 0, left: 0, top: 0 })
			.addClass('ui-resizable-ghost')
			.addClass(typeof o.ghost == 'string' ? o.ghost : '');

		self.ghost.appendTo(self.helper);

	},

	resize: function(event, ui){
		var self = $(this).data("resizable"), o = self.options;
		if (self.ghost) self.ghost.css({ position: 'relative', height: self.size.height, width: self.size.width });
	},

	stop: function(event, ui){
		var self = $(this).data("resizable"), o = self.options;
		if (self.ghost && self.helper) self.helper.get(0).removeChild(self.ghost.get(0));
	}

});

$.ui.plugin.add("resizable", "grid", {

	resize: function(event, ui) {
		var self = $(this).data("resizable"), o = self.options, cs = self.size, os = self.originalSize, op = self.originalPosition, a = self.axis, ratio = o._aspectRatio || event.shiftKey;
		o.grid = typeof o.grid == "number" ? [o.grid, o.grid] : o.grid;
		var ox = Math.round((cs.width - os.width) / (o.grid[0]||1)) * (o.grid[0]||1), oy = Math.round((cs.height - os.height) / (o.grid[1]||1)) * (o.grid[1]||1);

		if (/^(se|s|e)$/.test(a)) {
			self.size.width = os.width + ox;
			self.size.height = os.height + oy;
		}
		else if (/^(ne)$/.test(a)) {
			self.size.width = os.width + ox;
			self.size.height = os.height + oy;
			self.position.top = op.top - oy;
		}
		else if (/^(sw)$/.test(a)) {
			self.size.width = os.width + ox;
			self.size.height = os.height + oy;
			self.position.left = op.left - ox;
		}
		else {
			self.size.width = os.width + ox;
			self.size.height = os.height + oy;
			self.position.top = op.top - oy;
			self.position.left = op.left - ox;
		}
	}

});

var num = function(v) {
	return parseInt(v, 10) || 0;
};

var isNumber = function(value) {
	return !isNaN(parseInt(value, 10));
};

})(jQuery);
/*!
 * jQuery UI Sortable 1.8.23
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Sortables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget("ui.sortable", $.ui.mouse, {
	widgetEventPrefix: "sort",
	ready: false,
	options: {
		appendTo: "parent",
		axis: false,
		connectWith: false,
		containment: false,
		cursor: 'auto',
		cursorAt: false,
		dropOnEmpty: true,
		forcePlaceholderSize: false,
		forceHelperSize: false,
		grid: false,
		handle: false,
		helper: "original",
		items: '> *',
		opacity: false,
		placeholder: false,
		revert: false,
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		scope: "default",
		tolerance: "intersect",
		zIndex: 1000
	},
	_create: function() {

		var o = this.options;
		this.containerCache = {};
		this.element.addClass("ui-sortable");

		//Get the items
		this.refresh();

		//Let's determine if the items are being displayed horizontally
		this.floating = this.items.length ? o.axis === 'x' || (/left|right/).test(this.items[0].item.css('float')) || (/inline|table-cell/).test(this.items[0].item.css('display')) : false;

		//Let's determine the parent's offset
		this.offset = safeOffset(this.element);

		//Initialize mouse events for interaction
		this._mouseInit();

		//We're ready to go
		this.ready = true

	},

	destroy: function() {
		$.Widget.prototype.destroy.call( this );
		this.element
			.removeClass("ui-sortable ui-sortable-disabled");
		this._mouseDestroy();

		for ( var i = this.items.length - 1; i >= 0; i-- )
			this.items[i].item.removeData(this.widgetName + "-item");

		return this;
	},

	_setOption: function(key, value){
		if ( key === "disabled" ) {
			this.options[ key ] = value;

			this.widget()
				[ value ? "addClass" : "removeClass"]( "ui-sortable-disabled" );
		} else {
			// Don't call widget base _setOption for disable as it adds ui-state-disabled class
			$.Widget.prototype._setOption.apply(this, arguments);
		}
	},

	_mouseCapture: function(event, overrideHandle) {
		var that = this;

		if (this.reverting) {
			return false;
		}

		if(this.options.disabled || this.options.type == 'static') return false;

		//We have to refresh the items data once first
		this._refreshItems(event);

		//Find out if the clicked node (or one of its parents) is a actual item in this.items
		var currentItem = null, self = this, nodes = $(event.target).parents().each(function() {
			if($.data(this, that.widgetName + '-item') == self) {
				currentItem = $(this);
				return false;
			}
		});
		if($.data(event.target, that.widgetName + '-item') == self) currentItem = $(event.target);

		if(!currentItem) return false;
		if(this.options.handle && !overrideHandle) {
			var validHandle = false;

			$(this.options.handle, currentItem).find("*").addBack().each(function() { if(this == event.target) validHandle = true; });
			if(!validHandle) return false;
		}

		this.currentItem = currentItem;
		this._removeCurrentsFromItems();
		return true;

	},

	_mouseStart: function(event, overrideHandle, noActivation) {

		var o = this.options, self = this;
		this.currentContainer = this;

		//We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
		this.refreshPositions();

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		//Cache the helper size
		this._cacheHelperProportions();

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Get the next scrolling parent
		this.scrollParent = this.helper.scrollParent();

		//The element's absolute position on the page minus margins
		this.offset = this.currentItem.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		// Only after we got the offset, we can change the helper's position to absolute
		// TODO: Still need to figure out a way to make relative sorting possible
		this.helper.css("position", "absolute");
		this.cssPosition = this.helper.css("position");

		//Generate the original position
		this.originalPosition = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if 'cursorAt' is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Cache the former DOM position
		this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };

		//If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
		if(this.helper[0] != this.currentItem[0]) {
			this.currentItem.hide();
		}

		//Create the placeholder
		this._createPlaceholder();

		//Set a containment if given in the options
		if(o.containment)
			this._setContainment();

		if(o.cursor) { // cursor option
			if ($('body').css("cursor")) this._storedCursor = $('body').css("cursor");
			$('body').css("cursor", o.cursor);
		}

		if(o.opacity) { // opacity option
			if (this.helper.css("opacity")) this._storedOpacity = this.helper.css("opacity");
			this.helper.css("opacity", o.opacity);
		}

		if(o.zIndex) { // zIndex option
			if (this.helper.css("zIndex")) this._storedZIndex = this.helper.css("zIndex");
			this.helper.css("zIndex", o.zIndex);
		}

		//Prepare scrolling
		if(this.scrollParent[0] != document && this.scrollParent[0].tagName != 'HTML')
			this.overflowOffset = this.scrollParent.offset();

		//Call callbacks
		this._trigger("start", event, this._uiHash());

		//Recache the helper size
		if(!this._preserveHelperProportions)
			this._cacheHelperProportions();


		//Post 'activate' events to possible containers
		if(!noActivation) {
			 for (var i = this.containers.length - 1; i >= 0; i--) { this.containers[i]._trigger("activate", event, self._uiHash(this)); }
		}

		//Prepare possible droppables
		if($.ui.ddmanager)
			$.ui.ddmanager.current = this;

		if ($.ui.ddmanager && !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(this, event);

		this.dragging = true;

		this.helper.addClass("ui-sortable-helper");
		this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
		return true;

	},

	_mouseDrag: function(event) {

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo("absolute");

		if (!this.lastPositionAbs) {
			this.lastPositionAbs = this.positionAbs;
		}

		//Do scrolling
		if(this.options.scroll) {
			var o = this.options, scrolled = false;
			if(this.scrollParent[0] != document && this.scrollParent[0].tagName != 'HTML') {

				if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity)
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
				else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity)
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;

				if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity)
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
				else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity)
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;

			} else {

				if(event.pageY - $(document).scrollTop() < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);

				if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);

			}

			if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour)
				$.ui.ddmanager.prepareOffsets(this, event);
		}

		//Regenerate the absolute position used for position checks
		this.positionAbs = this._convertPositionTo("absolute");

		//Set the helper position
		if(!this.options.axis || this.options.axis != "y") this.helper[0].style.left = this.position.left+'px';
		if(!this.options.axis || this.options.axis != "x") this.helper[0].style.top = this.position.top+'px';

		//Rearrange
		for (var i = this.items.length - 1; i >= 0; i--) {

			//Cache variables and intersection, continue if no intersection
			var item = this.items[i], itemElement = item.item[0], intersection = this._intersectsWithPointer(item);
			if (!intersection) continue;

			if(itemElement != this.currentItem[0] //cannot intersect with itself
				&&	this.placeholder[intersection == 1 ? "next" : "prev"]()[0] != itemElement //no useless actions that have been done before
				&&	!$.ui.contains(this.placeholder[0], itemElement) //no action if the item moved is the parent of the item checked
				&& (this.options.type == 'semi-dynamic' ? !$.ui.contains(this.element[0], itemElement) : true)
				//&& itemElement.parentNode == this.placeholder[0].parentNode // only rearrange items within the same container
			) {

				this.direction = intersection == 1 ? "down" : "up";

				if (this.options.tolerance == "pointer" || this._intersectsWithSides(item)) {
					this._rearrange(event, item);
				} else {
					break;
				}

				this._trigger("change", event, this._uiHash());
				break;
			}
		}

		//Post events to containers
		this._contactContainers(event);

		//Interconnect with droppables
		if($.ui.ddmanager) $.ui.ddmanager.drag(this, event);

		//Call callbacks
		this._trigger('sort', event, this._uiHash());

		this.lastPositionAbs = this.positionAbs;
		return false;

	},

	_mouseStop: function(event, noPropagation) {

		if(!event) return;

		//If we are using droppables, inform the manager about the drop
		if ($.ui.ddmanager && !this.options.dropBehaviour)
			$.ui.ddmanager.drop(this, event);

		if(this.options.revert) {
			var self = this;
			var cur = self.placeholder.offset();

			self.reverting = true;

			$(this.helper).animate({
				left: cur.left - this.offset.parent.left - self.margins.left + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollLeft),
				top: cur.top - this.offset.parent.top - self.margins.top + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollTop)
			}, parseInt(this.options.revert, 10) || 500, function() {
				self._clear(event);
			});
		} else {
			this._clear(event, noPropagation);
		}

		return false;

	},

	cancel: function() {

		var self = this;

		if(this.dragging) {

			this._mouseUp({ target: null });

			if(this.options.helper == "original")
				this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
			else
				this.currentItem.show();

			//Post deactivating events to containers
			for (var i = this.containers.length - 1; i >= 0; i--){
				this.containers[i]._trigger("deactivate", null, self._uiHash(this));
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger("out", null, self._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}

		if (this.placeholder) {
			//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
			if(this.placeholder[0].parentNode) this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
			if(this.options.helper != "original" && this.helper && this.helper[0].parentNode) this.helper.remove();

			$.extend(this, {
				helper: null,
				dragging: false,
				reverting: false,
				_noFinalSort: null
			});

			if(this.domPosition.prev) {
				$(this.domPosition.prev).after(this.currentItem);
			} else {
				$(this.domPosition.parent).prepend(this.currentItem);
			}
		}

		return this;

	},

	serialize: function(o) {

		var items = this._getItemsAsjQuery(o && o.connected);
		var str = []; o = o || {};

		$(items).each(function() {
			var res = ($(o.item || this).attr(o.attribute || 'id') || '').match(o.expression || (/(.+)[-=_](.+)/));
			if(res) str.push((o.key || res[1]+'[]')+'='+(o.key && o.expression ? res[1] : res[2]));
		});

		if(!str.length && o.key) {
			str.push(o.key + '=');
		}

		return str.join('&');

	},

	toArray: function(o) {

		var items = this._getItemsAsjQuery(o && o.connected);
		var ret = []; o = o || {};

		items.each(function() { ret.push($(o.item || this).attr(o.attribute || 'id') || ''); });
		return ret;

	},

	/* Be careful with the following core functions */
	_intersectsWith: function(item) {

		var x1 = this.positionAbs.left,
			x2 = x1 + this.helperProportions.width,
			y1 = this.positionAbs.top,
			y2 = y1 + this.helperProportions.height;

		var l = item.left,
			r = l + item.width,
			t = item.top,
			b = t + item.height;

		var dyClick = this.offset.click.top,
			dxClick = this.offset.click.left;

		var isOverElement = (y1 + dyClick) > t && (y1 + dyClick) < b && (x1 + dxClick) > l && (x1 + dxClick) < r;

		if(	   this.options.tolerance == "pointer"
			|| this.options.forcePointerForContainers
			|| (this.options.tolerance != "pointer" && this.helperProportions[this.floating ? 'width' : 'height'] > item[this.floating ? 'width' : 'height'])
		) {
			return isOverElement;
		} else {

			return (l < x1 + (this.helperProportions.width / 2) // Right Half
				&& x2 - (this.helperProportions.width / 2) < r // Left Half
				&& t < y1 + (this.helperProportions.height / 2) // Bottom Half
				&& y2 - (this.helperProportions.height / 2) < b ); // Top Half

		}
	},

	_intersectsWithPointer: function(item) {

		var isOverElementHeight = (this.options.axis === 'x') || $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
			isOverElementWidth = (this.options.axis === 'y') || $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
			isOverElement = isOverElementHeight && isOverElementWidth,
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (!isOverElement)
			return false;

		return this.floating ?
			( ((horizontalDirection && horizontalDirection == "right") || verticalDirection == "down") ? 2 : 1 )
			: ( verticalDirection && (verticalDirection == "down" ? 2 : 1) );

	},

	_intersectsWithSides: function(item) {

		var isOverBottomHalf = $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),
			isOverRightHalf = $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (this.floating && horizontalDirection) {
			return ((horizontalDirection == "right" && isOverRightHalf) || (horizontalDirection == "left" && !isOverRightHalf));
		} else {
			return verticalDirection && ((verticalDirection == "down" && isOverBottomHalf) || (verticalDirection == "up" && !isOverBottomHalf));
		}

	},

	_getDragVerticalDirection: function() {
		var delta = this.positionAbs.top - this.lastPositionAbs.top;
		return delta != 0 && (delta > 0 ? "down" : "up");
	},

	_getDragHorizontalDirection: function() {
		var delta = this.positionAbs.left - this.lastPositionAbs.left;
		return delta != 0 && (delta > 0 ? "right" : "left");
	},

	refresh: function(event) {
		this._refreshItems(event);
		this.refreshPositions();
		return this;
	},

	_connectWith: function() {
		var options = this.options;
		return options.connectWith.constructor == String
			? [options.connectWith]
			: options.connectWith;
	},

	_getItemsAsjQuery: function(connected) {

		var self = this;
		var items = [];
		var queries = [];
		var connectWith = this._connectWith();

		if(connectWith && connected) {
			for (var i = connectWith.length - 1; i >= 0; i--){
				var cur = $(connectWith[i]);
				for (var j = cur.length - 1; j >= 0; j--){
					var inst = $.data(cur[j], this.widgetName);
					if(inst && inst != this && !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not('.ui-sortable-placeholder'), inst]);
					}
				};
			};
		}

		queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not('.ui-sortable-placeholder'), this]);

		for (var i = queries.length - 1; i >= 0; i--){
			queries[i][0].each(function() {
				items.push(this);
			});
		};

		return $(items);

	},

	_removeCurrentsFromItems: function() {

		var list = this.currentItem.find(":data(" + this.widgetName + "-item)");

		for (var i=0; i < this.items.length; i++) {

			for (var j=0; j < list.length; j++) {
				if(list[j] == this.items[i].item[0])
					this.items.splice(i,1);
			};

		};

	},

	_refreshItems: function(event) {

		this.items = [];
		this.containers = [this];
		var items = this.items;
		var self = this;
		var queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]];
		var connectWith = this._connectWith();

		if(connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down
			for (var i = connectWith.length - 1; i >= 0; i--){
				var cur = $(connectWith[i]);
				for (var j = cur.length - 1; j >= 0; j--){
					var inst = $.data(cur[j], this.widgetName);
					if(inst && inst != this && !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
						this.containers.push(inst);
					}
				};
			};
		}

		for (var i = queries.length - 1; i >= 0; i--) {
			var targetData = queries[i][1];
			var _queries = queries[i][0];

			for (var j=0, queriesLength = _queries.length; j < queriesLength; j++) {
				var item = $(_queries[j]);

				item.data(this.widgetName + '-item', targetData); // Data for target checking (mouse manager)

				items.push({
					item: item,
					instance: targetData,
					width: 0, height: 0,
					left: 0, top: 0
				});
			};
		};

	},

	refreshPositions: function(fast) {

		//This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
		if(this.offsetParent && this.helper) {
			this.offset.parent = this._getParentOffset();
		}

		for (var i = this.items.length - 1; i >= 0; i--){
			var item = this.items[i];

			//We ignore calculating positions of all connected containers when we're not over them
			if(item.instance != this.currentContainer && this.currentContainer && item.item[0] != this.currentItem[0])
				continue;

			var t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;

			if (!fast) {
				item.width = t.outerWidth();
				item.height = t.outerHeight();
			}
			var p = safeOffset(t);
			item.left = p.left;
			item.top = p.top;
		};

		if(this.options.custom && this.options.custom.refreshContainers) {
			this.options.custom.refreshContainers.call(this);
		} else {
			for (var i = this.containers.length - 1; i >= 0; i--){
				var p = safeOffset(this.containers[i].element);
				this.containers[i].containerCache.left = p.left;
				this.containers[i].containerCache.top = p.top;
				this.containers[i].containerCache.width	= this.containers[i].element.outerWidth();
				this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
			};
		}

		return this;
	},

	_createPlaceholder: function(that) {

		var self = that || this, o = self.options;

		if(!o.placeholder || o.placeholder.constructor == String) {
			var className = o.placeholder;
			o.placeholder = {
				element: function() {

					var el = $(document.createElement(self.currentItem[0].nodeName))
						.addClass(className || self.currentItem[0].className+" ui-sortable-placeholder")
						.removeClass("ui-sortable-helper")[0];

					if(!className)
						el.style.visibility = "hidden";

					return el;
				},
				update: function(container, p) {

					// 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
					// 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
					if(className && !o.forcePlaceholderSize) return;

					//If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
					if(!p.height()) { p.height(self.currentItem.innerHeight() - parseInt(self.currentItem.css('paddingTop')||0, 10) - parseInt(self.currentItem.css('paddingBottom')||0, 10)); };
					if(!p.width()) { p.width(self.currentItem.innerWidth() - parseInt(self.currentItem.css('paddingLeft')||0, 10) - parseInt(self.currentItem.css('paddingRight')||0, 10)); };
				}
			};
		}

		//Create the placeholder
		self.placeholder = $(o.placeholder.element.call(self.element, self.currentItem));

		//Append it after the actual current item
		self.currentItem.after(self.placeholder);

		//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
		o.placeholder.update(self, self.placeholder);

	},

	_contactContainers: function(event) {

		// get innermost container that intersects with item
		var innermostContainer = null, innermostIndex = null;


		for (var i = this.containers.length - 1; i >= 0; i--){

			// never consider a container that's located within the item itself
			if($.ui.contains(this.currentItem[0], this.containers[i].element[0]))
				continue;

			if(this._intersectsWith(this.containers[i].containerCache)) {

				// if we've already found a container and it's more "inner" than this, then continue
				if(innermostContainer && $.ui.contains(this.containers[i].element[0], innermostContainer.element[0]))
					continue;

				innermostContainer = this.containers[i];
				innermostIndex = i;

			} else {
				// container doesn't intersect. trigger "out" event if necessary
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger("out", event, this._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}

		// if no intersecting containers found, return
		if(!innermostContainer) return;

		// move the item into the container if it's not there already
		if(this.containers.length === 1) {
			this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
			this.containers[innermostIndex].containerCache.over = 1;
		} else if(this.currentContainer != this.containers[innermostIndex]) {

			//When entering a new container, we will find the item with the least distance and append our item near it
			var dist = 10000; var itemWithLeastDistance = null; var base = this.positionAbs[this.containers[innermostIndex].floating ? 'left' : 'top'];
			for (var j = this.items.length - 1; j >= 0; j--) {
				if(!$.ui.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) continue;
				var cur = this.containers[innermostIndex].floating ? this.items[j].item.offset().left : this.items[j].item.offset().top;
				if(Math.abs(cur - base) < dist) {
					dist = Math.abs(cur - base); itemWithLeastDistance = this.items[j];
					this.direction = (cur - base > 0) ? 'down' : 'up';
				}
			}

			if(!itemWithLeastDistance && !this.options.dropOnEmpty) //Check if dropOnEmpty is enabled
				return;

			this.currentContainer = this.containers[innermostIndex];
			itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
			this._trigger("change", event, this._uiHash());
			this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));

			//Update the placeholder
			this.options.placeholder.update(this.currentContainer, this.placeholder);

			this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
			this.containers[innermostIndex].containerCache.over = 1;
		}


	},

	_createHelper: function(event) {

		var o = this.options;
		var helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper == 'clone' ? this.currentItem.clone() : this.currentItem);

		if(!helper.parents('body').length) //Add the helper to the DOM if that didn't happen already
			$(o.appendTo != 'parent' ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);

		if(helper[0] == this.currentItem[0])
			this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") };

		if(helper[0].style.width == '' || o.forceHelperSize) helper.width(this.currentItem.width());
		if(helper[0].style.height == '' || o.forceHelperSize) helper.height(this.currentItem.height());

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj == 'string') {
			obj = obj.split(' ');
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if ('left' in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ('right' in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ('top' in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ('bottom' in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {


		//Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po;

		// Socrata modification: if the offsetParent is the <body> or <html> tag,
		// hardcode a 0/0 offset because the jQuery 3 migrate script gets antsy
		// about calling offset() on tags that aren't contained within the document
		if((this.offsetParent[0] == document.body) //This needs to be actually done for all browsers, since pageX/pageY includes this information
		|| (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() == 'html')) {
			po = { top: 0, left: 0 };
		} else {
			po = this.offsetParent.offset();
		}

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition == 'absolute' && this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}


		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition == "relative") {
			var p = this.currentItem.position();
			return {
				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.currentItem.css("marginLeft"),10) || 0),
			top: (parseInt(this.currentItem.css("marginTop"),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var o = this.options;
		if(o.containment == 'parent') o.containment = this.helper[0].parentNode;
		if(o.containment == 'document' || o.containment == 'window') this.containment = [
			0 - this.offset.relative.left - this.offset.parent.left,
			0 - this.offset.relative.top - this.offset.parent.top,
			$(o.containment == 'document' ? document : window).width() - this.helperProportions.width - this.margins.left,
			($(o.containment == 'document' ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
		];

		if(!(/^(document|window|parent)$/).test(o.containment)) {
			var ce = $(o.containment)[0];
			var co = $(o.containment).offset();
			var over = ($(ce).css("overflow") != 'hidden');

			this.containment = [
				co.left + (parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0) - this.margins.left,
				co.top + (parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0) - this.margins.top,
				co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left,
				co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top
			];
		}

	},

	_convertPositionTo: function(d, pos) {

		if(!pos) pos = this.position;
		var mod = d == "absolute" ? 1 : -1;
		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		return {
			top: (
				pos.top																	// The absolute mouse position
				+ this.offset.relative.top * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.top * mod											// The offsetParent's offset without borders (offset + border)
				- ($.browser.safari && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
			),
			left: (
				pos.left																// The absolute mouse position
				+ this.offset.relative.left * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.left * mod											// The offsetParent's offset without borders (offset + border)
				- ($.browser.safari && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
			)
		};

	},

	_generatePosition: function(event) {

		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		// This is another very weird special case that only happens for relative elements:
		// 1. If the css position is relative
		// 2. and the scroll parent is the document or similar to the offset parent
		// we have to refresh the relative offset during the scroll so there are no jumps
		if(this.cssPosition == 'relative' && !(this.scrollParent[0] != document && this.scrollParent[0] != this.offsetParent[0])) {
			this.offset.relative = this._getRelativeOffset();
		}

		var pageX = event.pageX;
		var pageY = event.pageY;

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		if(this.originalPosition) { //If we are not dragging yet, we won't check for options

			if(this.containment) {
				if(event.pageX - this.offset.click.left < this.containment[0]) pageX = this.containment[0] + this.offset.click.left;
				if(event.pageY - this.offset.click.top < this.containment[1]) pageY = this.containment[1] + this.offset.click.top;
				if(event.pageX - this.offset.click.left > this.containment[2]) pageX = this.containment[2] + this.offset.click.left;
				if(event.pageY - this.offset.click.top > this.containment[3]) pageY = this.containment[3] + this.offset.click.top;
			}

			if(o.grid) {
				var top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
				pageY = this.containment ? (!(top - this.offset.click.top < this.containment[1] || top - this.offset.click.top > this.containment[3]) ? top : (!(top - this.offset.click.top < this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				var left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
				pageX = this.containment ? (!(left - this.offset.click.left < this.containment[0] || left - this.offset.click.left > this.containment[2]) ? left : (!(left - this.offset.click.left < this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY																// The absolute mouse position
				- this.offset.click.top													// Click offset (relative to the element)
				- this.offset.relative.top												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.top												// The offsetParent's offset without borders (offset + border)
				+ ($.browser.safari && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
			),
			left: (
				pageX																// The absolute mouse position
				- this.offset.click.left												// Click offset (relative to the element)
				- this.offset.relative.left												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.left												// The offsetParent's offset without borders (offset + border)
				+ ($.browser.safari && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
			)
		};

	},

	_rearrange: function(event, i, a, hardRefresh) {

		a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction == 'down' ? i.item[0] : i.item[0].nextSibling));

		//Various things done here to improve the performance:
		// 1. we create a setTimeout, that calls refreshPositions
		// 2. on the instance, we have a counter variable, that get's higher after every append
		// 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
		// 4. this lets only the last addition to the timeout stack through
		this.counter = this.counter ? ++this.counter : 1;
		var self = this, counter = this.counter;

		window.setTimeout(function() {
			if(counter == self.counter) self.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
		},0);

	},

	_clear: function(event, noPropagation) {

		this.reverting = false;
		// We delay all events that have to be triggered to after the point where the placeholder has been removed and
		// everything else normalized again
		var delayedTriggers = [], self = this;

		// We first have to update the dom position of the actual currentItem
		// Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
		if(!this._noFinalSort && this.currentItem.parent().length) this.placeholder.before(this.currentItem);
		this._noFinalSort = null;

		if(this.helper[0] == this.currentItem[0]) {
			for(var i in this._storedCSS) {
				if(this._storedCSS[i] == 'auto' || this._storedCSS[i] == 'static') this._storedCSS[i] = '';
			}
			this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
		} else {
			this.currentItem.show();
		}

		if(this.fromOutside && !noPropagation) delayedTriggers.push(function(event) { this._trigger("receive", event, this._uiHash(this.fromOutside)); });
		if((this.fromOutside || this.domPosition.prev != this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent != this.currentItem.parent()[0]) && !noPropagation) delayedTriggers.push(function(event) { this._trigger("update", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed
		if(!$.ui.contains(this.element[0], this.currentItem[0])) { //Node was moved out of the current element
			if(!noPropagation) delayedTriggers.push(function(event) { this._trigger("remove", event, this._uiHash()); });
			for (var i = this.containers.length - 1; i >= 0; i--){
				if($.ui.contains(this.containers[i].element[0], this.currentItem[0]) && !noPropagation) {
					delayedTriggers.push((function(c) { return function(event) { c._trigger("receive", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
					delayedTriggers.push((function(c) { return function(event) { c._trigger("update", event, this._uiHash(this));  }; }).call(this, this.containers[i]));
				}
			};
		};

		//Post events to containers
		for (var i = this.containers.length - 1; i >= 0; i--){
			if(!noPropagation) delayedTriggers.push((function(c) { return function(event) { c._trigger("deactivate", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
			if(this.containers[i].containerCache.over) {
				delayedTriggers.push((function(c) { return function(event) { c._trigger("out", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
				this.containers[i].containerCache.over = 0;
			}
		}

		//Do what was originally in plugins
		if(this._storedCursor) $('body').css("cursor", this._storedCursor); //Reset cursor
		if(this._storedOpacity) this.helper.css("opacity", this._storedOpacity); //Reset opacity
		if(this._storedZIndex) this.helper.css("zIndex", this._storedZIndex == 'auto' ? '' : this._storedZIndex); //Reset z-index

		this.dragging = false;
		if(this.cancelHelperRemoval) {
			if(!noPropagation) {
				this._trigger("beforeStop", event, this._uiHash());
				for (var i=0; i < delayedTriggers.length; i++) { delayedTriggers[i].call(this, event); }; //Trigger all delayed events
				this._trigger("stop", event, this._uiHash());
			}

			this.fromOutside = false;
			return false;
		}

		if(!noPropagation) this._trigger("beforeStop", event, this._uiHash());

		//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
		this.placeholder[0].parentNode.removeChild(this.placeholder[0]);

		if(this.helper[0] != this.currentItem[0]) this.helper.remove(); this.helper = null;

		if(!noPropagation) {
			for (var i=0; i < delayedTriggers.length; i++) { delayedTriggers[i].call(this, event); }; //Trigger all delayed events
			this._trigger("stop", event, this._uiHash());
		}

		this.fromOutside = false;
		return true;

	},

	_trigger: function() {
		if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
			this.cancel();
		}
	},

	_uiHash: function(inst) {
		var self = inst || this;
		return {
			helper: self.helper,
			placeholder: self.placeholder || $([]),
			position: self.position,
			originalPosition: self.originalPosition,
			offset: self.positionAbs,
			item: self.currentItem,
			sender: inst ? inst.element : null
		};
	}

});

$.extend($.ui.sortable, {
	version: "1.8.23"
});

})(jQuery);
/*!
 * jQuery UI Accordion 1.8.23
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Accordion
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget( "ui.accordion", {
	options: {
		active: 0,
		animated: "slide",
		autoHeight: true,
		clearStyle: false,
		collapsible: false,
		event: "click",
		fillSpace: false,
		header: "> li > :first-child,> :not(li):even",
		icons: {
			header: "ui-icon-triangle-1-e",
			headerSelected: "ui-icon-triangle-1-s"
		},
		navigation: false,
		navigationFilter: function() {
			return this.href.toLowerCase() === location.href.toLowerCase();
		}
	},

	_create: function() {
		var self = this,
			options = self.options;

		self.running = 0;

		self.element
			.addClass( "ui-accordion ui-widget ui-helper-reset" )
			// in lack of child-selectors in CSS
			// we need to mark top-LIs in a UL-accordion for some IE-fix
			.children( "li" )
				.addClass( "ui-accordion-li-fix" );

		self.headers = self.element.find( options.header )
			.addClass( "ui-accordion-header ui-helper-reset ui-state-default ui-corner-all" )
			.on( "mouseenter.accordion", function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).addClass( "ui-state-hover" );
			})
			.on( "mouseleave.accordion", function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).removeClass( "ui-state-hover" );
			})
			.on( "focus.accordion", function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).addClass( "ui-state-focus" );
			})
			.on( "blur.accordion", function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).removeClass( "ui-state-focus" );
			});

		self.headers.next()
			.addClass( "ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom" );

		if ( options.navigation ) {
			var current = self.element.find( "a" ).filter( options.navigationFilter ).eq( 0 );
			if ( current.length ) {
				var header = current.closest( ".ui-accordion-header" );
				if ( header.length ) {
					// anchor within header
					self.active = header;
				} else {
					// anchor within content
					self.active = current.closest( ".ui-accordion-content" ).prev();
				}
			}
		}

		self.active = self._findActive( self.active || options.active )
			.addClass( "ui-state-default ui-state-active" )
			.toggleClass( "ui-corner-all" )
			.toggleClass( "ui-corner-top" );
		self.active.next().addClass( "ui-accordion-content-active" );

		self._createIcons();
		self.resize();

		// ARIA
		self.element.attr( "role", "tablist" );

		self.headers
			.attr( "role", "tab" )
			.on( "keydown.accordion", function( event ) {
				return self._keydown( event );
			})
			.next()
				.attr( "role", "tabpanel" );

		self.headers
			.not( self.active || "" )
			.attr({
				"aria-expanded": "false",
				"aria-selected": "false",
				tabIndex: -1
			})
			.next()
				.hide();

		// make sure at least one header is in the tab order
		if ( !self.active.length ) {
			self.headers.eq( 0 ).attr( "tabIndex", 0 );
		} else {
			self.active
				.attr({
					"aria-expanded": "true",
					"aria-selected": "true",
					tabIndex: 0
				});
		}

		// only need links in tab order for Safari
		if ( !$.browser.safari ) {
			self.headers.find( "a" ).attr( "tabIndex", -1 );
		}

		if ( options.event ) {
			self.headers.on( options.event.split(" ").join(".accordion ") + ".accordion", function(event) {
				self._clickHandler.call( self, event, this );
				event.preventDefault();
			});
		}
	},

	_createIcons: function() {
		var options = this.options;
		if ( options.icons ) {
			$( "<span></span>" )
				.addClass( "ui-icon " + options.icons.header )
				.prependTo( this.headers );
			this.active.children( ".ui-icon" )
				.toggleClass(options.icons.header)
				.toggleClass(options.icons.headerSelected);
			this.element.addClass( "ui-accordion-icons" );
		}
	},

	_destroyIcons: function() {
		this.headers.children( ".ui-icon" ).remove();
		this.element.removeClass( "ui-accordion-icons" );
	},

	destroy: function() {
		var options = this.options;

		this.element
			.removeClass( "ui-accordion ui-widget ui-helper-reset" )
			.removeAttr( "role" );

		this.headers
			.off( ".accordion" )
			.removeClass( "ui-accordion-header ui-accordion-disabled ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top" )
			.removeAttr( "role" )
			.removeAttr( "aria-expanded" )
			.removeAttr( "aria-selected" )
			.removeAttr( "tabIndex" );

		this.headers.find( "a" ).removeAttr( "tabIndex" );
		this._destroyIcons();
		var contents = this.headers.next()
			.css( "display", "" )
			.removeAttr( "role" )
			.removeClass( "ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-accordion-disabled ui-state-disabled" );
		if ( options.autoHeight || options.fillHeight ) {
			contents.css( "height", "" );
		}

		return $.Widget.prototype.destroy.call( this );
	},

	_setOption: function( key, value ) {
		$.Widget.prototype._setOption.apply( this, arguments );

		if ( key == "active" ) {
			this.activate( value );
		}
		if ( key == "icons" ) {
			this._destroyIcons();
			if ( value ) {
				this._createIcons();
			}
		}
		// #5332 - opacity doesn't cascade to positioned elements in IE
		// so we need to add the disabled class to the headers and panels
		if ( key == "disabled" ) {
			this.headers.add(this.headers.next())
				[ value ? "addClass" : "removeClass" ](
					"ui-accordion-disabled ui-state-disabled" );
		}
	},

	_keydown: function( event ) {
		if ( this.options.disabled || event.altKey || event.ctrlKey ) {
			return;
		}

		var keyCode = $.ui.keyCode,
			length = this.headers.length,
			currentIndex = this.headers.index( event.target ),
			toFocus = false;

		switch ( event.keyCode ) {
			case keyCode.RIGHT:
			case keyCode.DOWN:
				toFocus = this.headers[ ( currentIndex + 1 ) % length ];
				break;
			case keyCode.LEFT:
			case keyCode.UP:
				toFocus = this.headers[ ( currentIndex - 1 + length ) % length ];
				break;
			case keyCode.SPACE:
			case keyCode.ENTER:
				this._clickHandler( { target: event.target }, event.target );
				event.preventDefault();
		}

		if ( toFocus ) {
			$( event.target ).attr( "tabIndex", -1 );
			$( toFocus ).attr( "tabIndex", 0 );
			toFocus.trigger('focus');
			return false;
		}

		return true;
	},

	resize: function() {
		var options = this.options,
			maxHeight;

		if ( options.fillSpace ) {
			if ( $.browser.msie ) {
				var defOverflow = this.element.parent().css( "overflow" );
				this.element.parent().css( "overflow", "hidden");
			}
			maxHeight = this.element.parent().height();
			if ($.browser.msie) {
				this.element.parent().css( "overflow", defOverflow );
			}

			this.headers.each(function() {
				maxHeight -= $( this ).outerHeight( true );
			});

			this.headers.next()
				.each(function() {
					$( this ).height( Math.max( 0, maxHeight -
						$( this ).innerHeight() + $( this ).height() ) );
				})
				.css( "overflow", "auto" );
		} else if ( options.autoHeight ) {
			maxHeight = 0;
			this.headers.next()
				.each(function() {
					maxHeight = Math.max( maxHeight, $( this ).height( "" ).height() );
				})
				.height( maxHeight );
		}

		return this;
	},

	activate: function( index ) {
		// TODO this gets called on init, changing the option without an explicit call for that
		this.options.active = index;
		// call clickHandler with custom event
		var active = this._findActive( index )[ 0 ];
		this._clickHandler( { target: active }, active );

		return this;
	},

	_findActive: function( selector ) {
		return selector
			? typeof selector === "number"
				? this.headers.filter( ":eq(" + selector + ")" )
				: this.headers.not( this.headers.not( selector ) )
			: selector === false
				? $( [] )
				: this.headers.filter( ":eq(0)" );
	},

	// TODO isn't event.target enough? why the separate target argument?
	_clickHandler: function( event, target ) {
		var options = this.options;
		if ( options.disabled ) {
			return;
		}

		// called only when using activate(false) to close all parts programmatically
		if ( !event.target ) {
			if ( !options.collapsible ) {
				return;
			}
			this.active
				.removeClass( "ui-state-active ui-corner-top" )
				.addClass( "ui-state-default ui-corner-all" )
				.children( ".ui-icon" )
					.removeClass( options.icons.headerSelected )
					.addClass( options.icons.header );
			this.active.next().addClass( "ui-accordion-content-active" );
			var toHide = this.active.next(),
				data = {
					options: options,
					newHeader: $( [] ),
					oldHeader: options.active,
					newContent: $( [] ),
					oldContent: toHide
				},
				toShow = ( this.active = $( [] ) );
			this._toggle( toShow, toHide, data );
			return;
		}

		// get the click target
		var clicked = $( event.currentTarget || target ),
			clickedIsActive = clicked[0] === this.active[0];

		// TODO the option is changed, is that correct?
		// TODO if it is correct, shouldn't that happen after determining that the click is valid?
		options.active = options.collapsible && clickedIsActive ?
			false :
			this.headers.index( clicked );

		// if animations are still active, or the active header is the target, ignore click
		if ( this.running || ( !options.collapsible && clickedIsActive ) ) {
			return;
		}

		// find elements to show and hide
		var active = this.active,
			toShow = clicked.next(),
			toHide = this.active.next(),
			data = {
				options: options,
				newHeader: clickedIsActive && options.collapsible ? $([]) : clicked,
				oldHeader: this.active,
				newContent: clickedIsActive && options.collapsible ? $([]) : toShow,
				oldContent: toHide
			},
			down = this.headers.index( this.active[0] ) > this.headers.index( clicked[0] );

		// when the call to ._toggle() comes after the class changes
		// it causes a very odd bug in IE 8 (see #6720)
		this.active = clickedIsActive ? $([]) : clicked;
		this._toggle( toShow, toHide, data, clickedIsActive, down );

		// switch classes
		active
			.removeClass( "ui-state-active ui-corner-top" )
			.addClass( "ui-state-default ui-corner-all" )
			.children( ".ui-icon" )
				.removeClass( options.icons.headerSelected )
				.addClass( options.icons.header );
		if ( !clickedIsActive ) {
			clicked
				.removeClass( "ui-state-default ui-corner-all" )
				.addClass( "ui-state-active ui-corner-top" )
				.children( ".ui-icon" )
					.removeClass( options.icons.header )
					.addClass( options.icons.headerSelected );
			clicked
				.next()
				.addClass( "ui-accordion-content-active" );
		}

		return;
	},

	_toggle: function( toShow, toHide, data, clickedIsActive, down ) {
		var self = this,
			options = self.options;

		self.toShow = toShow;
		self.toHide = toHide;
		self.data = data;

		var complete = function() {
			if ( !self ) {
				return;
			}
			return self._completed.apply( self, arguments );
		};

		// trigger changestart event
		self._trigger( "changestart", null, self.data );

		// count elements to animate
		self.running = toHide.length === 0 ? toShow.length : toHide.length;

		if ( options.animated ) {
			var animOptions = {};

			if ( options.collapsible && clickedIsActive ) {
				animOptions = {
					toShow: $( [] ),
					toHide: toHide,
					complete: complete,
					down: down,
					autoHeight: options.autoHeight || options.fillSpace
				};
			} else {
				animOptions = {
					toShow: toShow,
					toHide: toHide,
					complete: complete,
					down: down,
					autoHeight: options.autoHeight || options.fillSpace
				};
			}

			if ( !options.proxied ) {
				options.proxied = options.animated;
			}

			if ( !options.proxiedDuration ) {
				options.proxiedDuration = options.duration;
			}

			options.animated = $.isFunction( options.proxied ) ?
				options.proxied( animOptions ) :
				options.proxied;

			options.duration = $.isFunction( options.proxiedDuration ) ?
				options.proxiedDuration( animOptions ) :
				options.proxiedDuration;

			var animations = $.ui.accordion.animations,
				duration = options.duration,
				easing = options.animated;

			if ( easing && !animations[ easing ] && !$.easing[ easing ] ) {
				easing = "slide";
			}
			if ( !animations[ easing ] ) {
				animations[ easing ] = function( options ) {
					this.slide( options, {
						easing: easing,
						duration: duration || 700
					});
				};
			}

			animations[ easing ]( animOptions );
		} else {
			if ( options.collapsible && clickedIsActive ) {
				toShow.toggle();
			} else {
				toHide.hide();
				toShow.show();
			}

			complete( true );
		}

		// TODO assert that the blur and focus triggers are really necessary, remove otherwise
		toHide.prev()
			.attr({
				"aria-expanded": "false",
				"aria-selected": "false",
				tabIndex: -1
			})
			.trigger('blur');
		toShow.prev()
			.attr({
				"aria-expanded": "true",
				"aria-selected": "true",
				tabIndex: 0
			})
			.trigger('focus');
	},

	_completed: function( cancel ) {
		this.running = cancel ? 0 : --this.running;
		if ( this.running ) {
			return;
		}

		if ( this.options.clearStyle ) {
			this.toShow.add( this.toHide ).css({
				height: "",
				overflow: ""
			});
		}

		// other classes are removed before the animation; this one needs to stay until completed
		this.toHide.removeClass( "ui-accordion-content-active" );
		// Work around for rendering bug in IE (#5421)
		if ( this.toHide.length ) {
			this.toHide.parent()[0].className = this.toHide.parent()[0].className;
		}

		this._trigger( "change", null, this.data );
	}
});

$.extend( $.ui.accordion, {
	version: "1.8.23",
	animations: {
		slide: function( options, additions ) {
			options = $.extend({
				easing: "swing",
				duration: 300
			}, options, additions );
			if ( !options.toHide.length ) {
				options.toShow.animate({
					height: "show",
					paddingTop: "show",
					paddingBottom: "show"
				}, options );
				return;
			}
			if ( !options.toShow.length ) {
				options.toHide.animate({
					height: "hide",
					paddingTop: "hide",
					paddingBottom: "hide"
				}, options );
				return;
			}
			var overflow = options.toShow.css( "overflow" ),
				percentDone = 0,
				showProps = {},
				hideProps = {},
				fxAttrs = [ "height", "paddingTop", "paddingBottom" ],
				originalWidth;
			// fix width before calculating height of hidden element
			var s = options.toShow;
			originalWidth = s[0].style.width;
			s.width( s.parent().width()
				- parseFloat( s.css( "paddingLeft" ) )
				- parseFloat( s.css( "paddingRight" ) )
				- ( parseFloat( s.css( "borderLeftWidth" ) ) || 0 )
				- ( parseFloat( s.css( "borderRightWidth" ) ) || 0 ) );

			$.each( fxAttrs, function( i, prop ) {
				hideProps[ prop ] = "hide";

				var parts = ( "" + $.css( options.toShow[0], prop ) ).match( /^([\d+-.]+)(.*)$/ );
				showProps[ prop ] = {
					value: parts[ 1 ],
					unit: parts[ 2 ] || "px"
				};
			});
			options.toShow.css({ height: 0, overflow: "hidden" }).show();
			options.toHide
				.filter( ":hidden" )
					.each( options.complete )
				.end()
				.filter( ":visible" )
				.animate( hideProps, {
				step: function( now, settings ) {
					// only calculate the percent when animating height
					// IE gets very inconsistent results when animating elements
					// with small values, which is common for padding
					if ( settings.prop == "height" ) {
						percentDone = ( settings.end - settings.start === 0 ) ? 0 :
							( settings.now - settings.start ) / ( settings.end - settings.start );
					}

					options.toShow[ 0 ].style[ settings.prop ] =
						( percentDone * showProps[ settings.prop ].value )
						+ showProps[ settings.prop ].unit;
				},
				duration: options.duration,
				easing: options.easing,
				complete: function() {
					if ( !options.autoHeight ) {
						options.toShow.css( "height", "" );
					}
					options.toShow.css({
						width: originalWidth,
						overflow: overflow
					});
					options.complete();
				}
			});
		},
		bounceslide: function( options ) {
			this.slide( options, {
				easing: options.down ? "easeOutBounce" : "swing",
				duration: options.down ? 1000 : 200
			});
		}
	}
});

})( jQuery );
/*!
 * jQuery UI Slider 1.8.23
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Slider
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

// number of pages in a slider
// (how many times can you page up/down to go through the whole range)
var numPages = 5;

$.widget( "ui.slider", $.ui.mouse, {

	widgetEventPrefix: "slide",

	options: {
		animate: false,
		distance: 0,
		max: 100,
		min: 0,
		orientation: "horizontal",
		range: false,
		step: 1,
		value: 0,
		values: null
	},

	_create: function() {
		var self = this,
			o = this.options,
			existingHandles = this.element.find( ".ui-slider-handle" ).addClass( "ui-state-default ui-corner-all" ),
			handle = "<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>",
			handleCount = ( o.values && o.values.length ) || 1,
			handles = [];

		this._keySliding = false;
		this._mouseSliding = false;
		this._animateOff = true;
		this._handleIndex = null;
		this._detectOrientation();
		this._mouseInit();

		this.element
			.addClass( "ui-slider" +
				" ui-slider-" + this.orientation +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all" +
				( o.disabled ? " ui-slider-disabled ui-disabled" : "" ) );

		this.range = $([]);

		if ( o.range ) {
			if ( o.range === true ) {
				if ( !o.values ) {
					o.values = [ this._valueMin(), this._valueMin() ];
				}
				if ( o.values.length && o.values.length !== 2 ) {
					o.values = [ o.values[0], o.values[0] ];
				}
			}

			this.range = $( "<div></div>" )
				.appendTo( this.element )
				.addClass( "ui-slider-range" +
				// note: this isn't the most fittingly semantic framework class for this element,
				// but worked best visually with a variety of themes
				" ui-widget-header" +
				( ( o.range === "min" || o.range === "max" ) ? " ui-slider-range-" + o.range : "" ) );
		}

		for ( var i = existingHandles.length; i < handleCount; i += 1 ) {
			handles.push( handle );
		}

		this.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( self.element ) );

		this.handle = this.handles.eq( 0 );

		this.handles.add( this.range ).filter( "a" )
			.on('click', function( event ) {
				event.preventDefault();
			})
			.on('mouseenter', function() {
				if ( !o.disabled ) {
					$( this ).addClass( "ui-state-hover" );
				}
			})
			.on('mouseout', function() {
				$( this ).removeClass( "ui-state-hover" );
			})
			.on('focus', function() {
				if ( !o.disabled ) {
					$( ".ui-slider .ui-state-focus" ).removeClass( "ui-state-focus" );
					$( this ).addClass( "ui-state-focus" );
				} else {
					$( this ).trigger('blur');
				}
			})
			.on('blur', function() {
				$( this ).removeClass( "ui-state-focus" );
			});

		this.handles.each(function( i ) {
			$( this ).data( "index.ui-slider-handle", i );
		});

		this.handles
			.on('keydown', function( event ) {
				var index = $( this ).data( "index.ui-slider-handle" ),
					allowed,
					curVal,
					newVal,
					step;

				if ( self.options.disabled ) {
					return;
				}

				switch ( event.keyCode ) {
					case $.ui.keyCode.HOME:
					case $.ui.keyCode.END:
					case $.ui.keyCode.PAGE_UP:
					case $.ui.keyCode.PAGE_DOWN:
					case $.ui.keyCode.UP:
					case $.ui.keyCode.RIGHT:
					case $.ui.keyCode.DOWN:
					case $.ui.keyCode.LEFT:
						event.preventDefault();
						if ( !self._keySliding ) {
							self._keySliding = true;
							$( this ).addClass( "ui-state-active" );
							allowed = self._start( event, index );
							if ( allowed === false ) {
								return;
							}
						}
						break;
				}

				step = self.options.step;
				if ( self.options.values && self.options.values.length ) {
					curVal = newVal = self.values( index );
				} else {
					curVal = newVal = self.value();
				}

				switch ( event.keyCode ) {
					case $.ui.keyCode.HOME:
						newVal = self._valueMin();
						break;
					case $.ui.keyCode.END:
						newVal = self._valueMax();
						break;
					case $.ui.keyCode.PAGE_UP:
						newVal = self._trimAlignValue( curVal + ( (self._valueMax() - self._valueMin()) / numPages ) );
						break;
					case $.ui.keyCode.PAGE_DOWN:
						newVal = self._trimAlignValue( curVal - ( (self._valueMax() - self._valueMin()) / numPages ) );
						break;
					case $.ui.keyCode.UP:
					case $.ui.keyCode.RIGHT:
						if ( curVal === self._valueMax() ) {
							return;
						}
						newVal = self._trimAlignValue( curVal + step );
						break;
					case $.ui.keyCode.DOWN:
					case $.ui.keyCode.LEFT:
						if ( curVal === self._valueMin() ) {
							return;
						}
						newVal = self._trimAlignValue( curVal - step );
						break;
				}

				self._slide( event, index, newVal );
			})
			.on('keyup', function( event ) {
				var index = $( this ).data( "index.ui-slider-handle" );

				if ( self._keySliding ) {
					self._keySliding = false;
					self._stop( event, index );
					self._change( event, index );
					$( this ).removeClass( "ui-state-active" );
				}

			});

		this._refreshValue();

		this._animateOff = false;
	},

	destroy: function() {
		this.handles.remove();
		this.range.remove();

		this.element
			.removeClass( "ui-slider" +
				" ui-slider-horizontal" +
				" ui-slider-vertical" +
				" ui-slider-disabled" +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all" )
			.removeData( "slider" )
			.off( ".slider" );

		this._mouseDestroy();

		return this;
	},

	_mouseCapture: function( event ) {
		var o = this.options,
			position,
			normValue,
			distance,
			closestHandle,
			self,
			index,
			allowed,
			offset,
			mouseOverHandle;

		if ( o.disabled ) {
			return false;
		}

		this.elementSize = {
			width: this.element.outerWidth(),
			height: this.element.outerHeight()
		};
		this.elementOffset = this.element.offset();

		position = { x: event.pageX, y: event.pageY };
		normValue = this._normValueFromMouse( position );
		distance = this._valueMax() - this._valueMin() + 1;
		self = this;
		this.handles.each(function( i ) {
			var thisDistance = Math.abs( normValue - self.values(i) );
			if ( distance > thisDistance ) {
				distance = thisDistance;
				closestHandle = $( this );
				index = i;
			}
		});

		// workaround for bug #3736 (if both handles of a range are at 0,
		// the first is always used as the one with least distance,
		// and moving it is obviously prevented by preventing negative ranges)
		if( o.range === true && this.values(1) === o.min ) {
			index += 1;
			closestHandle = $( this.handles[index] );
		}

		allowed = this._start( event, index );
		if ( allowed === false ) {
			return false;
		}
		this._mouseSliding = true;

		self._handleIndex = index;

		closestHandle
			.addClass( "ui-state-active" )
			.trigger('focus');

		offset = closestHandle.offset();
		mouseOverHandle = !$( event.target ).parents().addBack().is( ".ui-slider-handle" );
		this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
			left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
			top: event.pageY - offset.top -
				( closestHandle.height() / 2 ) -
				( parseInt( closestHandle.css("borderTopWidth"), 10 ) || 0 ) -
				( parseInt( closestHandle.css("borderBottomWidth"), 10 ) || 0) +
				( parseInt( closestHandle.css("marginTop"), 10 ) || 0)
		};

		if ( !this.handles.hasClass( "ui-state-hover" ) ) {
			this._slide( event, index, normValue );
		}
		this._animateOff = true;
		return true;
	},

	_mouseStart: function( event ) {
		return true;
	},

	_mouseDrag: function( event ) {
		var position = { x: event.pageX, y: event.pageY },
			normValue = this._normValueFromMouse( position );

		this._slide( event, this._handleIndex, normValue );

		return false;
	},

	_mouseStop: function( event ) {
		this.handles.removeClass( "ui-state-active" );
		this._mouseSliding = false;

		this._stop( event, this._handleIndex );
		this._change( event, this._handleIndex );

		this._handleIndex = null;
		this._clickOffset = null;
		this._animateOff = false;

		return false;
	},

	_detectOrientation: function() {
		this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";
	},

	_normValueFromMouse: function( position ) {
		var pixelTotal,
			pixelMouse,
			percentMouse,
			valueTotal,
			valueMouse;

		if ( this.orientation === "horizontal" ) {
			pixelTotal = this.elementSize.width;
			pixelMouse = position.x - this.elementOffset.left - ( this._clickOffset ? this._clickOffset.left : 0 );
		} else {
			pixelTotal = this.elementSize.height;
			pixelMouse = position.y - this.elementOffset.top - ( this._clickOffset ? this._clickOffset.top : 0 );
		}

		percentMouse = ( pixelMouse / pixelTotal );
		if ( percentMouse > 1 ) {
			percentMouse = 1;
		}
		if ( percentMouse < 0 ) {
			percentMouse = 0;
		}
		if ( this.orientation === "vertical" ) {
			percentMouse = 1 - percentMouse;
		}

		valueTotal = this._valueMax() - this._valueMin();
		valueMouse = this._valueMin() + percentMouse * valueTotal;

		return this._trimAlignValue( valueMouse );
	},

	_start: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}
		return this._trigger( "start", event, uiHash );
	},

	_slide: function( event, index, newVal ) {
		var otherVal,
			newValues,
			allowed;

		if ( this.options.values && this.options.values.length ) {
			otherVal = this.values( index ? 0 : 1 );

			if ( ( this.options.values.length === 2 && this.options.range === true ) &&
					( ( index === 0 && newVal > otherVal) || ( index === 1 && newVal < otherVal ) )
				) {
				newVal = otherVal;
			}

			if ( newVal !== this.values( index ) ) {
				newValues = this.values();
				newValues[ index ] = newVal;
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal,
					values: newValues
				} );
				otherVal = this.values( index ? 0 : 1 );
				if ( allowed !== false ) {
					this.values( index, newVal, true );
				}
			}
		} else {
			if ( newVal !== this.value() ) {
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal
				} );
				if ( allowed !== false ) {
					this.value( newVal );
				}
			}
		}
	},

	_stop: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}

		this._trigger( "stop", event, uiHash );
	},

	_change: function( event, index ) {
		if ( !this._keySliding && !this._mouseSliding ) {
			var uiHash = {
				handle: this.handles[ index ],
				value: this.value()
			};
			if ( this.options.values && this.options.values.length ) {
				uiHash.value = this.values( index );
				uiHash.values = this.values();
			}

			this._trigger( "change", event, uiHash );
		}
	},

	value: function( newValue ) {
		if ( arguments.length ) {
			this.options.value = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, 0 );
			return;
		}

		return this._value();
	},

	values: function( index, newValue ) {
		var vals,
			newValues,
			i;

		if ( arguments.length > 1 ) {
			this.options.values[ index ] = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, index );
			return;
		}

		if ( arguments.length ) {
			if ( $.isArray( arguments[ 0 ] ) ) {
				vals = this.options.values;
				newValues = arguments[ 0 ];
				for ( i = 0; i < vals.length; i += 1 ) {
					vals[ i ] = this._trimAlignValue( newValues[ i ] );
					this._change( null, i );
				}
				this._refreshValue();
			} else {
				if ( this.options.values && this.options.values.length ) {
					return this._values( index );
				} else {
					return this.value();
				}
			}
		} else {
			return this._values();
		}
	},

	_setOption: function( key, value ) {
		var i,
			valsLength = 0;

		if ( $.isArray( this.options.values ) ) {
			valsLength = this.options.values.length;
		}

		$.Widget.prototype._setOption.apply( this, arguments );

		switch ( key ) {
			case "disabled":
				if ( value ) {
					this.handles.filter( ".ui-state-focus" ).trigger('blur');
					this.handles.removeClass( "ui-state-hover" );
					this.handles.propAttr( "disabled", true );
					this.element.addClass( "ui-disabled" );
				} else {
					this.handles.propAttr( "disabled", false );
					this.element.removeClass( "ui-disabled" );
				}
				break;
			case "orientation":
				this._detectOrientation();
				this.element
					.removeClass( "ui-slider-horizontal ui-slider-vertical" )
					.addClass( "ui-slider-" + this.orientation );
				this._refreshValue();
				break;
			case "value":
				this._animateOff = true;
				this._refreshValue();
				this._change( null, 0 );
				this._animateOff = false;
				break;
			case "values":
				this._animateOff = true;
				this._refreshValue();
				for ( i = 0; i < valsLength; i += 1 ) {
					this._change( null, i );
				}
				this._animateOff = false;
				break;
		}
	},

	//internal value getter
	// _value() returns value trimmed by min and max, aligned by step
	_value: function() {
		var val = this.options.value;
		val = this._trimAlignValue( val );

		return val;
	},

	//internal values getter
	// _values() returns array of values trimmed by min and max, aligned by step
	// _values( index ) returns single value trimmed by min and max, aligned by step
	_values: function( index ) {
		var val,
			vals,
			i;

		if ( arguments.length ) {
			val = this.options.values[ index ];
			val = this._trimAlignValue( val );

			return val;
		} else {
			// .slice() creates a copy of the array
			// this copy gets trimmed by min and max and then returned
			vals = this.options.values.slice();
			for ( i = 0; i < vals.length; i+= 1) {
				vals[ i ] = this._trimAlignValue( vals[ i ] );
			}

			return vals;
		}
	},

	// returns the step-aligned value that val is closest to, between (inclusive) min and max
	_trimAlignValue: function( val ) {
		if ( val <= this._valueMin() ) {
			return this._valueMin();
		}
		if ( val >= this._valueMax() ) {
			return this._valueMax();
		}
		var step = ( this.options.step > 0 ) ? this.options.step : 1,
			valModStep = (val - this._valueMin()) % step,
			alignValue = val - valModStep;

		if ( Math.abs(valModStep) * 2 >= step ) {
			alignValue += ( valModStep > 0 ) ? step : ( -step );
		}

		// Since JavaScript has problems with large floats, round
		// the final value to 5 digits after the decimal point (see #4124)
		return parseFloat( alignValue.toFixed(5) );
	},

	_valueMin: function() {
		return this.options.min;
	},

	_valueMax: function() {
		return this.options.max;
	},

	_refreshValue: function() {
		var oRange = this.options.range,
			o = this.options,
			self = this,
			animate = ( !this._animateOff ) ? o.animate : false,
			valPercent,
			_set = {},
			lastValPercent,
			value,
			valueMin,
			valueMax;

		if ( this.options.values && this.options.values.length ) {
			this.handles.each(function( i, j ) {
				valPercent = ( self.values(i) - self._valueMin() ) / ( self._valueMax() - self._valueMin() ) * 100;
				_set[ self.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
				$( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
				if ( self.options.range === true ) {
					if ( self.orientation === "horizontal" ) {
						if ( i === 0 ) {
							self.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { left: valPercent + "%" }, o.animate );
						}
						if ( i === 1 ) {
							self.range[ animate ? "animate" : "css" ]( { width: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					} else {
						if ( i === 0 ) {
							self.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { bottom: ( valPercent ) + "%" }, o.animate );
						}
						if ( i === 1 ) {
							self.range[ animate ? "animate" : "css" ]( { height: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					}
				}
				lastValPercent = valPercent;
			});
		} else {
			value = this.value();
			valueMin = this._valueMin();
			valueMax = this._valueMax();
			valPercent = ( valueMax !== valueMin ) ?
					( value - valueMin ) / ( valueMax - valueMin ) * 100 :
					0;
			_set[ self.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
			this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );

			if ( oRange === "min" && this.orientation === "horizontal" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { width: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "horizontal" ) {
				this.range[ animate ? "animate" : "css" ]( { width: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
			if ( oRange === "min" && this.orientation === "vertical" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { height: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "vertical" ) {
				this.range[ animate ? "animate" : "css" ]( { height: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
		}
	}

});

$.extend( $.ui.slider, {
	version: "1.8.23"
});

}(jQuery));
/*!
 * jQuery UI Tabs 1.8.23
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Tabs
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

var tabId = 0,
	listId = 0;

function getNextTabId() {
	return ++tabId;
}

function getNextListId() {
	return ++listId;
}

$.widget( "ui.tabs", {
	options: {
		add: null,
		ajaxOptions: null,
		cache: false,
		cookie: null, // e.g. { expires: 7, path: '/', domain: 'jquery.com', secure: true }
		collapsible: false,
		disable: null,
		disabled: [],
		enable: null,
		event: "click",
		fx: null, // e.g. { height: 'toggle', opacity: 'toggle', duration: 200 }
		idPrefix: "ui-tabs-",
		load: null,
		panelTemplate: "<div></div>",
		remove: null,
		select: null,
		show: null,
		spinner: "<em>Loading&#8230;</em>",
		tabTemplate: "<li><a href='#{href}'><span>#{label}</span></a></li>"
	},

	_create: function() {
		this._tabify( true );
	},

	_setOption: function( key, value ) {
		if ( key == "selected" ) {
			if (this.options.collapsible && value == this.options.selected ) {
				return;
			}
			this.select( value );
		} else {
			this.options[ key ] = value;
			this._tabify();
		}
	},

	_tabId: function( a ) {
		return a.title && a.title.replace( /\s/g, "_" ).replace( /[^\w\u00c0-\uFFFF-]/g, "" ) ||
			this.options.idPrefix + getNextTabId();
	},

	_sanitizeSelector: function( hash ) {
		// we need this because an id may contain a ":"
		return hash.replace( /:/g, "\\:" );
	},

	_cookie: function() {
		var cookie = this.cookie ||
			( this.cookie = this.options.cookie.name || "ui-tabs-" + getNextListId() );
		return $.cookie.apply( null, [ cookie ].concat( $.makeArray( arguments ) ) );
	},

	_ui: function( tab, panel ) {
		return {
			tab: tab,
			panel: panel,
			index: this.anchors.index( tab )
		};
	},

	_cleanup: function() {
		// restore all former loading tabs labels
		this.lis.filter( ".ui-state-processing" )
			.removeClass( "ui-state-processing" )
			.find( "span:data(label.tabs)" )
				.each(function() {
					var el = $( this );
					el.html( el.data( "label.tabs" ) ).removeData( "label.tabs" );
				});
	},

	_tabify: function( init ) {
		var self = this,
			o = this.options,
			fragmentId = /^#.+/; // Safari 2 reports '#' for an empty hash

		this.list = this.element.find( "ol,ul" ).eq( 0 );
		this.lis = $( " > li:has(a[href])", this.list );
		this.anchors = this.lis.map(function() {
			return $( "a", this )[ 0 ];
		});
		this.panels = $( [] );

		this.anchors.each(function( i, a ) {
			var href = $( a ).attr( "href" );
			// For dynamically created HTML that contains a hash as href IE < 8 expands
			// such href to the full page url with hash and then misinterprets tab as ajax.
			// Same consideration applies for an added tab with a fragment identifier
			// since a[href=#fragment-identifier] does unexpectedly not match.
			// Thus normalize href attribute...
			var hrefBase = href.split( "#" )[ 0 ],
				baseEl;
			if ( hrefBase && ( hrefBase === location.toString().split( "#" )[ 0 ] ||
					( baseEl = $( "base" )[ 0 ]) && hrefBase === baseEl.href ) ) {
				href = a.hash;
				a.href = href;
			}

			// inline tab
			if ( fragmentId.test( href ) ) {
				self.panels = self.panels.add( self.element.find( self._sanitizeSelector( href ) ) );
			// remote tab
			// prevent loading the page itself if href is just "#"
			} else if ( href && href !== "#" ) {
				// required for restore on destroy
				$.data( a, "href.tabs", href );

				// TODO until #3808 is fixed strip fragment identifier from url
				// (IE fails to load from such url)
				$.data( a, "load.tabs", href.replace( /#.*$/, "" ) );

				var id = self._tabId( a );
				a.href = "#" + id;
				var $panel = self.element.find( "#" + id );
				if ( !$panel.length ) {
					$panel = $( o.panelTemplate )
						.attr( "id", id )
						.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
						.insertAfter( self.panels[ i - 1 ] || self.list );
					$panel.data( "destroy.tabs", true );
				}
				self.panels = self.panels.add( $panel );
			// invalid tab href
			} else {
				o.disabled.push( i );
			}
		});

		// initialization from scratch
		if ( init ) {
			// attach necessary classes for styling
			this.element.addClass( "ui-tabs ui-widget ui-widget-content ui-corner-all" );
			this.list.addClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" );
			this.lis.addClass( "ui-state-default ui-corner-top" );
			this.panels.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" );

			// Selected tab
			// use "selected" option or try to retrieve:
			// 1. from fragment identifier in url
			// 2. from cookie
			// 3. from selected class attribute on <li>
			if ( o.selected === undefined ) {
				if ( location.hash ) {
					this.anchors.each(function( i, a ) {
						if ( a.hash == location.hash ) {
							o.selected = i;
							return false;
						}
					});
				}
				if ( typeof o.selected !== "number" && o.cookie ) {
					o.selected = parseInt( self._cookie(), 10 );
				}
				if ( typeof o.selected !== "number" && this.lis.filter( ".ui-tabs-selected" ).length ) {
					o.selected = this.lis.index( this.lis.filter( ".ui-tabs-selected" ) );
				}
				o.selected = o.selected || ( this.lis.length ? 0 : -1 );
			} else if ( o.selected === null ) { // usage of null is deprecated, TODO remove in next release
				o.selected = -1;
			}

			// sanity check - default to first tab...
			o.selected = ( ( o.selected >= 0 && this.anchors[ o.selected ] ) || o.selected < 0 )
				? o.selected
				: 0;

			// Take disabling tabs via class attribute from HTML
			// into account and update option properly.
			// A selected tab cannot become disabled.
			o.disabled = $.unique( o.disabled.concat(
				$.map( this.lis.filter( ".ui-state-disabled" ), function( n, i ) {
					return self.lis.index( n );
				})
			) ).sort();

			if ( $.inArray( o.selected, o.disabled ) != -1 ) {
				o.disabled.splice( $.inArray( o.selected, o.disabled ), 1 );
			}

			// highlight selected tab
			this.panels.addClass( "ui-tabs-hide" );
			this.lis.removeClass( "ui-tabs-selected ui-state-active" );
			// check for length avoids error when initializing empty list
			if ( o.selected >= 0 && this.anchors.length ) {
				self.element.find( self._sanitizeSelector( self.anchors[ o.selected ].hash ) ).removeClass( "ui-tabs-hide" );
				this.lis.eq( o.selected ).addClass( "ui-tabs-selected ui-state-active" );

				// seems to be expected behavior that the show callback is fired
				self.element.queue( "tabs", function() {
					self._trigger( "show", null,
						self._ui( self.anchors[ o.selected ], self.element.find( self._sanitizeSelector( self.anchors[ o.selected ].hash ) )[ 0 ] ) );
				});

				this.load( o.selected );
			}

			// clean up to avoid memory leaks in certain versions of IE 6
			// TODO: namespace this event
			$( window ).on( "unload", function() {
				self.lis.add( self.anchors ).off( ".tabs" );
				self.lis = self.anchors = self.panels = null;
			});
		// update selected after add/remove
		} else {
			o.selected = this.lis.index( this.lis.filter( ".ui-tabs-selected" ) );
		}

		// update collapsible
		// TODO: use .toggleClass()
		this.element[ o.collapsible ? "addClass" : "removeClass" ]( "ui-tabs-collapsible" );

		// set or update cookie after init and add/remove respectively
		if ( o.cookie ) {
			this._cookie( o.selected, o.cookie );
		}

		// disable tabs
		for ( var i = 0, li; ( li = this.lis[ i ] ); i++ ) {
			$( li )[ $.inArray( i, o.disabled ) != -1 &&
				// TODO: use .toggleClass()
				!$( li ).hasClass( "ui-tabs-selected" ) ? "addClass" : "removeClass" ]( "ui-state-disabled" );
		}

		// reset cache if switching from cached to not cached
		if ( o.cache === false ) {
			this.anchors.removeData( "cache.tabs" );
		}

		// remove all handlers before, tabify may run on existing tabs after add or option change
		this.lis.add( this.anchors ).off( ".tabs" );

		if ( o.event !== "mouseover" ) {
			var addState = function( state, el ) {
				if ( el.is( ":not(.ui-state-disabled)" ) ) {
					el.addClass( "ui-state-" + state );
				}
			};
			var removeState = function( state, el ) {
				el.removeClass( "ui-state-" + state );
			};
			this.lis.on( "mouseover.tabs" , function() {
				addState( "hover", $( this ) );
			});
			this.lis.on( "mouseout.tabs", function() {
				removeState( "hover", $( this ) );
			});
			this.anchors.on( "focus.tabs", function() {
				addState( "focus", $( this ).closest( "li" ) );
			});
			this.anchors.on( "blur.tabs", function() {
				removeState( "focus", $( this ).closest( "li" ) );
			});
		}

		// set up animations
		var hideFx, showFx;
		if ( o.fx ) {
			if ( $.isArray( o.fx ) ) {
				hideFx = o.fx[ 0 ];
				showFx = o.fx[ 1 ];
			} else {
				hideFx = showFx = o.fx;
			}
		}

		// Reset certain styles left over from animation
		// and prevent IE's ClearType bug...
		function resetStyle( $el, fx ) {
			$el.css( "display", "" );
			if ( !$.support.opacity && fx.opacity ) {
				$el[ 0 ].style.removeAttribute( "filter" );
			}
		}

		// Show a tab...
		var showTab = showFx
			? function( clicked, $show ) {
				$( clicked ).closest( "li" ).addClass( "ui-tabs-selected ui-state-active" );
				$show.hide().removeClass( "ui-tabs-hide" ) // avoid flicker that way
					.animate( showFx, showFx.duration || "normal", function() {
						resetStyle( $show, showFx );
						self._trigger( "show", null, self._ui( clicked, $show[ 0 ] ) );
					});
			}
			: function( clicked, $show ) {
				$( clicked ).closest( "li" ).addClass( "ui-tabs-selected ui-state-active" );
				$show.removeClass( "ui-tabs-hide" );
				self._trigger( "show", null, self._ui( clicked, $show[ 0 ] ) );
			};

		// Hide a tab, $show is optional...
		var hideTab = hideFx
			? function( clicked, $hide ) {
				$hide.animate( hideFx, hideFx.duration || "normal", function() {
					self.lis.removeClass( "ui-tabs-selected ui-state-active" );
					$hide.addClass( "ui-tabs-hide" );
					resetStyle( $hide, hideFx );
					self.element.dequeue( "tabs" );
				});
			}
			: function( clicked, $hide, $show ) {
				self.lis.removeClass( "ui-tabs-selected ui-state-active" );
				$hide.addClass( "ui-tabs-hide" );
				self.element.dequeue( "tabs" );
			};

		// attach tab event handler, unbind to avoid duplicates from former tabifying...
		this.anchors.on( o.event + ".tabs", function() {
			var el = this,
				$li = $(el).closest( "li" ),
				$hide = self.panels.filter( ":not(.ui-tabs-hide)" ),
				$show = self.element.find( self._sanitizeSelector( el.hash ) );

			// If tab is already selected and not collapsible or tab disabled or
			// or is already loading or click callback returns false stop here.
			// Check if click handler returns false last so that it is not executed
			// for a disabled or loading tab!
			if ( ( $li.hasClass( "ui-tabs-selected" ) && !o.collapsible) ||
				$li.hasClass( "ui-state-disabled" ) ||
				$li.hasClass( "ui-state-processing" ) ||
				self.panels.filter( ":animated" ).length ||
				self._trigger( "select", null, self._ui( this, $show[ 0 ] ) ) === false ) {
				this.trigger('blur');
				return false;
			}

			o.selected = self.anchors.index( this );

			self.abort();

			// if tab may be closed
			if ( o.collapsible ) {
				if ( $li.hasClass( "ui-tabs-selected" ) ) {
					o.selected = -1;

					if ( o.cookie ) {
						self._cookie( o.selected, o.cookie );
					}

					self.element.queue( "tabs", function() {
						hideTab( el, $hide );
					}).dequeue( "tabs" );

					this.trigger('blur');
					return false;
				} else if ( !$hide.length ) {
					if ( o.cookie ) {
						self._cookie( o.selected, o.cookie );
					}

					self.element.queue( "tabs", function() {
						showTab( el, $show );
					});

					// TODO make passing in node possible, see also http://dev.jqueryui.com/ticket/3171
					self.load( self.anchors.index( this ) );

					this.trigger('blur');
					return false;
				}
			}

			if ( o.cookie ) {
				self._cookie( o.selected, o.cookie );
			}

			// show new tab
			if ( $show.length ) {
				if ( $hide.length ) {
					self.element.queue( "tabs", function() {
						hideTab( el, $hide );
					});
				}
				self.element.queue( "tabs", function() {
					showTab( el, $show );
				});

				self.load( self.anchors.index( this ) );
			} else {
				throw "jQuery UI Tabs: Mismatching fragment identifier.";
			}

			// Prevent IE from keeping other link focussed when using the back button
			// and remove dotted border from clicked link. This is controlled via CSS
			// in modern browsers; trigger('blur') removes focus from address bar in Firefox
			// which can become a usability and annoying problem with tabs('rotate').
			if ( $.browser.msie ) {
				this.trigger('blur');
			}
		});

		// disable click in any case
		this.anchors.on( "click.tabs", function(){
			return false;
		});
	},

    _getIndex: function( index ) {
		// meta-function to give users option to provide a href string instead of a numerical index.
		// also sanitizes numerical indexes to valid values.
		if ( typeof index == "string" ) {
			index = this.anchors.index( this.anchors.filter( "[href$='" + index + "']" ) );
		}

		return index;
	},

	destroy: function() {
		var o = this.options;

		this.abort();

		this.element
			.off( ".tabs" )
			.removeClass( "ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible" )
			.removeData( "tabs" );

		this.list.removeClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" );

		this.anchors.each(function() {
			var href = $.data( this, "href.tabs" );
			if ( href ) {
				this.href = href;
			}
			var $this = $( this ).off( ".tabs" );
			$.each( [ "href", "load", "cache" ], function( i, prefix ) {
				$this.removeData( prefix + ".tabs" );
			});
		});

		this.lis.off( ".tabs" ).add( this.panels ).each(function() {
			if ( $.data( this, "destroy.tabs" ) ) {
				$( this ).remove();
			} else {
				$( this ).removeClass([
					"ui-state-default",
					"ui-corner-top",
					"ui-tabs-selected",
					"ui-state-active",
					"ui-state-hover",
					"ui-state-focus",
					"ui-state-disabled",
					"ui-tabs-panel",
					"ui-widget-content",
					"ui-corner-bottom",
					"ui-tabs-hide"
				].join( " " ) );
			}
		});

		if ( o.cookie ) {
			this._cookie( null, o.cookie );
		}

		return this;
	},

	add: function( url, label, index ) {
		if ( index === undefined ) {
			index = this.anchors.length;
		}

		var self = this,
			o = this.options,
			$li = $( o.tabTemplate.replace( /#\{href\}/g, url ).replace( /#\{label\}/g, label ) ),
			id = !url.indexOf( "#" ) ? url.replace( "#", "" ) : this._tabId( $( "a", $li )[ 0 ] );

		$li.addClass( "ui-state-default ui-corner-top" ).data( "destroy.tabs", true );

		// try to find an existing element before creating a new one
		var $panel = self.element.find( "#" + id );
		if ( !$panel.length ) {
			$panel = $( o.panelTemplate )
				.attr( "id", id )
				.data( "destroy.tabs", true );
		}
		$panel.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom ui-tabs-hide" );

		if ( index >= this.lis.length ) {
			$li.appendTo( this.list );
			$panel.appendTo( this.list[ 0 ].parentNode );
		} else {
			$li.insertBefore( this.lis[ index ] );
			$panel.insertBefore( this.panels[ index ] );
		}

		o.disabled = $.map( o.disabled, function( n, i ) {
			return n >= index ? ++n : n;
		});

		this._tabify();

		if ( this.anchors.length == 1 ) {
			o.selected = 0;
			$li.addClass( "ui-tabs-selected ui-state-active" );
			$panel.removeClass( "ui-tabs-hide" );
			this.element.queue( "tabs", function() {
				self._trigger( "show", null, self._ui( self.anchors[ 0 ], self.panels[ 0 ] ) );
			});

			this.load( 0 );
		}

		this._trigger( "add", null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
		return this;
	},

	remove: function( index ) {
		index = this._getIndex( index );
		var o = this.options,
			$li = this.lis.eq( index ).remove(),
			$panel = this.panels.eq( index ).remove();

		// If selected tab was removed focus tab to the right or
		// in case the last tab was removed the tab to the left.
		if ( $li.hasClass( "ui-tabs-selected" ) && this.anchors.length > 1) {
			this.select( index + ( index + 1 < this.anchors.length ? 1 : -1 ) );
		}

		o.disabled = $.map(
			$.grep( o.disabled, function(n, i) {
				return n != index;
			}),
			function( n, i ) {
				return n >= index ? --n : n;
			});

		this._tabify();

		this._trigger( "remove", null, this._ui( $li.find( "a" )[ 0 ], $panel[ 0 ] ) );
		return this;
	},

	enable: function( index ) {
		index = this._getIndex( index );
		var o = this.options;
		if ( $.inArray( index, o.disabled ) == -1 ) {
			return;
		}

		this.lis.eq( index ).removeClass( "ui-state-disabled" );
		o.disabled = $.grep( o.disabled, function( n, i ) {
			return n != index;
		});

		this._trigger( "enable", null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
		return this;
	},

	disable: function( index ) {
		index = this._getIndex( index );
		var self = this, o = this.options;
		// cannot disable already selected tab
		if ( index != o.selected ) {
			this.lis.eq( index ).addClass( "ui-state-disabled" );

			o.disabled.push( index );
			o.disabled.sort();

			this._trigger( "disable", null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
		}

		return this;
	},

	select: function( index ) {
		index = this._getIndex( index );
		if ( index == -1 ) {
			if ( this.options.collapsible && this.options.selected != -1 ) {
				index = this.options.selected;
			} else {
				return this;
			}
		}
		this.anchors.eq( index ).trigger( this.options.event + ".tabs" );
		return this;
	},

	load: function( index ) {
		index = this._getIndex( index );
		var self = this,
			o = this.options,
			a = this.anchors.eq( index )[ 0 ],
			url = $.data( a, "load.tabs" );

		this.abort();

		// not remote or from cache
		if ( !url || this.element.queue( "tabs" ).length !== 0 && $.data( a, "cache.tabs" ) ) {
			this.element.dequeue( "tabs" );
			return;
		}

		// load remote from here on
		this.lis.eq( index ).addClass( "ui-state-processing" );

		if ( o.spinner ) {
			var span = $( "span", a );
			span.data( "label.tabs", span.html() ).html( o.spinner );
		}

		this.xhr = $.ajax( $.extend( {}, o.ajaxOptions, {
			url: url,
			success: function( r, s ) {
				self.element.find( self._sanitizeSelector( a.hash ) ).html( r );

				// take care of tab labels
				self._cleanup();

				if ( o.cache ) {
					$.data( a, "cache.tabs", true );
				}

				self._trigger( "load", null, self._ui( self.anchors[ index ], self.panels[ index ] ) );
				try {
					o.ajaxOptions.success( r, s );
				}
				catch ( e ) {}
			},
			error: function( xhr, s, e ) {
				// take care of tab labels
				self._cleanup();

				self._trigger( "load", null, self._ui( self.anchors[ index ], self.panels[ index ] ) );
				try {
					// Passing index avoid a race condition when this method is
					// called after the user has selected another tab.
					// Pass the anchor that initiated this request allows
					// loadError to manipulate the tab content panel via $(a.hash)
					o.ajaxOptions.error( xhr, s, index, a );
				}
				catch ( e ) {}
			}
		} ) );

		// last, so that load event is fired before show...
		self.element.dequeue( "tabs" );

		return this;
	},

	abort: function() {
		// stop possibly running animations
		this.element.queue( [] );
		this.panels.stop( false, true );

		// "tabs" queue must not contain more than two elements,
		// which are the callbacks for the latest clicked tab...
		this.element.queue( "tabs", this.element.queue( "tabs" ).splice( -2, 2 ) );

		// terminate pending requests from other tabs
		if ( this.xhr ) {
			this.xhr.abort();
			delete this.xhr;
		}

		// take care of tab labels
		this._cleanup();
		return this;
	},

	url: function( index, url ) {
		this.anchors.eq( index ).removeData( "cache.tabs" ).data( "load.tabs", url );
		return this;
	},

	length: function() {
		return this.anchors.length;
	}
});

$.extend( $.ui.tabs, {
	version: "1.8.23"
});

/*
 * Tabs Extensions
 */

/*
 * Rotate
 */
$.extend( $.ui.tabs.prototype, {
	rotation: null,
	rotate: function( ms, continuing ) {
		var self = this,
			o = this.options;

		var rotate = self._rotate || ( self._rotate = function( e ) {
			clearTimeout( self.rotation );
			self.rotation = setTimeout(function() {
				var t = o.selected;
				self.select( ++t < self.anchors.length ? t : 0 );
			}, ms );

			if ( e ) {
				e.stopPropagation();
			}
		});

		var stop = self._unrotate || ( self._unrotate = !continuing
			? function(e) {
				if (e.clientX) { // in case of a true click
					self.rotate(null);
				}
			}
			: function( e ) {
				rotate();
			});

		// start rotation
		if ( ms ) {
			this.element.on( "tabsshow", rotate );
			this.anchors.on( o.event + ".tabs", stop );
			rotate();
		// stop rotation
		} else {
			clearTimeout( self.rotation );
			this.element.off( "tabsshow", rotate );
			this.anchors.off( o.event + ".tabs", stop );
			delete this._rotate;
			delete this._unrotate;
		}

		return this;
	}
});

})( jQuery );
/*!
 * jQuery UI Datepicker 1.8.23
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Datepicker
 *
 * Depends:
 *	jquery.ui.core.js
 */
(function( $, undefined ) {

$.extend($.ui, { datepicker: { version: "1.8.23" } });

var PROP_NAME = 'datepicker';
var dpuuid = new Date().getTime();
var instActive;

/* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */

function Datepicker() {
	this.debug = false; // Change this to true to start debugging
	this._curInst = null; // The current instance in use
	this._keyEvent = false; // If the last event was a key event
	this._disabledInputs = []; // List of date picker inputs that have been disabled
	this._datepickerShowing = false; // True if the popup picker is showing , false if not
	this._inDialog = false; // True if showing within a "dialog", false if not
	this._mainDivId = 'ui-datepicker-div'; // The ID of the main datepicker division
	this._inlineClass = 'ui-datepicker-inline'; // The name of the inline marker class
	this._appendClass = 'ui-datepicker-append'; // The name of the append marker class
	this._triggerClass = 'ui-datepicker-trigger'; // The name of the trigger marker class
	this._dialogClass = 'ui-datepicker-dialog'; // The name of the dialog marker class
	this._disableClass = 'ui-datepicker-disabled'; // The name of the disabled covering marker class
	this._unselectableClass = 'ui-datepicker-unselectable'; // The name of the unselectable cell marker class
	this._currentClass = 'ui-datepicker-current-day'; // The name of the current day marker class
	this._dayOverClass = 'ui-datepicker-days-cell-over'; // The name of the day hover marker class
	this.regional = []; // Available regional settings, indexed by language code
	this.regional[''] = { // Default regional settings
		closeText: 'Done', // Display text for close link
		prevText: 'Prev', // Display text for previous month link
		nextText: 'Next', // Display text for next month link
		currentText: 'Today', // Display text for current month link
		monthNames: ['January','February','March','April','May','June',
			'July','August','September','October','November','December'], // Names of months for drop-down and formatting
		monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'], // For formatting
		dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], // For formatting
		dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'], // For formatting
		dayNamesMin: ['Su','Mo','Tu','We','Th','Fr','Sa'], // Column headings for days starting at Sunday
		weekHeader: 'Wk', // Column header for week of the year
		dateFormat: 'mm/dd/yy', // See format options on parseDate
		firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
		isRTL: false, // True if right-to-left language, false if left-to-right
		showMonthAfterYear: false, // True if the year select precedes month, false for month then year
		yearSuffix: '' // Additional text to append to the year in the month headers
	};
	this._defaults = { // Global defaults for all the date picker instances
		showOn: 'focus', // 'focus' for popup on focus,
			// 'button' for trigger button, or 'both' for either
		showAnim: 'fadeIn', // Name of jQuery animation for popup
		showOptions: {}, // Options for enhanced animations
		defaultDate: null, // Used when field is blank: actual date,
			// +/-number for offset from today, null for today
		appendText: '', // Display text following the input box, e.g. showing the format
		buttonText: '...', // Text for trigger button
		buttonImage: '', // URL for trigger button image
		buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
		hideIfNoPrevNext: false, // True to hide next/previous month links
			// if not applicable, false to just disable them
		navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
		gotoCurrent: false, // True if today link goes back to current selection instead
		changeMonth: false, // True if month can be selected directly, false if only prev/next
		changeYear: false, // True if year can be selected directly, false if only prev/next
		yearRange: 'c-10:c+10', // Range of years to display in drop-down,
			// either relative to today's year (-nn:+nn), relative to currently displayed year
			// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
		showOtherMonths: false, // True to show dates in other months, false to leave blank
		selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
		showWeek: false, // True to show week of the year, false to not show it
		calculateWeek: this.iso8601Week, // How to calculate the week of the year,
			// takes a Date and returns the number of the week for it
		shortYearCutoff: '+10', // Short year values < this are in the current century,
			// > this are in the previous century,
			// string value starting with '+' for current year + value
		minDate: null, // The earliest selectable date, or null for no limit
		maxDate: null, // The latest selectable date, or null for no limit
		duration: 'fast', // Duration of display/closure
		beforeShowDay: null, // Function that takes a date and returns an array with
			// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or '',
			// [2] = cell title (optional), e.g. $.datepicker.noWeekends
		beforeShow: null, // Function that takes an input field and
			// returns a set of custom settings for the date picker
		onSelect: null, // Define a callback function when a date is selected
		onChangeMonthYear: null, // Define a callback function when the month or year is changed
		onClose: null, // Define a callback function when the datepicker is closed
		numberOfMonths: 1, // Number of months to show at a time
		showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
		stepMonths: 1, // Number of months to step back/forward
		stepBigMonths: 12, // Number of months to step back/forward for the big links
		altField: '', // Selector for an alternate field to store selected dates into
		altFormat: '', // The date format to use for the alternate field
		constrainInput: true, // The input is constrained by the current date format
		showButtonPanel: false, // True to show button panel, false to not show it
		autoSize: false, // True to size the input for the date format, false to leave as is
		disabled: false // The initial disabled state
	};
	$.extend(this._defaults, this.regional['']);
	this.dpDiv = bindHover($('<div id="' + this._mainDivId + '" class="ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>'));
}

$.extend(Datepicker.prototype, {
	/* Class name added to elements to indicate already configured with a date picker. */
	markerClassName: 'hasDatepicker',

	//Keep track of the maximum number of rows displayed (see #7043)
	maxRows: 4,

	/* Debug logging (if enabled). */
	log: function () {
		if (this.debug)
			console.log.apply('', arguments);
	},

	// TODO rename to "widget" when switching to widget factory
	_widgetDatepicker: function() {
		return this.dpDiv;
	},

	/* Override the default settings for all instances of the date picker.
	   @param  settings  object - the new settings to use as defaults (anonymous object)
	   @return the manager object */
	setDefaults: function(settings) {
		extendRemove(this._defaults, settings || {});
		return this;
	},

	/* Attach the date picker to a jQuery selection.
	   @param  target    element - the target input field or division or span
	   @param  settings  object - the new settings to use for this date picker instance (anonymous) */
	_attachDatepicker: function(target, settings) {
		// check for settings on the control itself - in namespace 'date:'
		var inlineSettings = null;
		for (var attrName in this._defaults) {
			var attrValue = target.getAttribute('date:' + attrName);
			if (attrValue) {
				inlineSettings = inlineSettings || {};
				try {
					inlineSettings[attrName] = eval(attrValue);
				} catch (err) {
					inlineSettings[attrName] = attrValue;
				}
			}
		}
		var nodeName = target.nodeName.toLowerCase();
		var inline = (nodeName == 'div' || nodeName == 'span');
		if (!target.id) {
			this.uuid += 1;
			target.id = 'dp' + this.uuid;
		}
		var inst = this._newInst($(target), inline);
		inst.settings = $.extend({}, settings || {}, inlineSettings || {});
		if (nodeName == 'input') {
			this._connectDatepicker(target, inst);
		} else if (inline) {
			this._inlineDatepicker(target, inst);
		}
	},

	/* Create a new instance object. */
	_newInst: function(target, inline) {
		var id = target[0].id.replace(/([^A-Za-z0-9_-])/g, '\\\\$1'); // escape jQuery meta chars
		return {id: id, input: target, // associated target
			selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
			drawMonth: 0, drawYear: 0, // month being drawn
			inline: inline, // is datepicker inline or not
			dpDiv: (!inline ? this.dpDiv : // presentation div
			bindHover($('<div class="' + this._inlineClass + ' ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>')))};
	},

	/* Attach the date picker to an input field. */
	_connectDatepicker: function(target, inst) {
		var input = $(target);
		inst.append = $([]);
		inst.trigger = $([]);
		if (input.hasClass(this.markerClassName))
			return;
		this._attachments(input, inst);
		input.addClass(this.markerClassName).on('keydown', this._doKeyDown).
			on('keypress', this._doKeyPress).on('keyup', this._doKeyUp).
			on("setData.datepicker", function(event, key, value) {
				inst.settings[key] = value;
			}).on("getData.datepicker", function(event, key) {
				return this._get(inst, key);
			});
		this._autoSize(inst);
		$.data(target, PROP_NAME, inst);
		//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
	},

	/* Make attachments based on settings. */
	_attachments: function(input, inst) {
		var appendText = this._get(inst, 'appendText');
		var isRTL = this._get(inst, 'isRTL');
		if (inst.append)
			inst.append.remove();
		if (appendText) {
			inst.append = $('<span class="' + this._appendClass + '">' + appendText + '</span>');
			input[isRTL ? 'before' : 'after'](inst.append);
		}
		input.off('focus', this._showDatepicker);
		if (inst.trigger)
			inst.trigger.remove();
		var showOn = this._get(inst, 'showOn');
		if (showOn == 'focus' || showOn == 'both') // pop-up date picker when in the marked field
			input.on('focus', this._showDatepicker);
		if (showOn == 'button' || showOn == 'both') { // pop-up date picker when button clicked
			var buttonText = this._get(inst, 'buttonText');
			var buttonImage = this._get(inst, 'buttonImage');
			inst.trigger = $(this._get(inst, 'buttonImageOnly') ?
				$('<img/>').addClass(this._triggerClass).
					attr({ src: buttonImage, alt: buttonText, title: buttonText }) :
				$('<button type="button"></button>').addClass(this._triggerClass).
					html(buttonImage == '' ? buttonText : $('<img/>').attr(
					{ src:buttonImage, alt:buttonText, title:buttonText })));
			input[isRTL ? 'before' : 'after'](inst.trigger);
			inst.trigger.on('click', function() {
				if ($.datepicker._datepickerShowing && $.datepicker._lastInput == input[0])
					$.datepicker._hideDatepicker();
				else if ($.datepicker._datepickerShowing && $.datepicker._lastInput != input[0]) {
					$.datepicker._hideDatepicker();
					$.datepicker._showDatepicker(input[0]);
				} else
					$.datepicker._showDatepicker(input[0]);
				return false;
			});
		}
	},

	/* Apply the maximum length for the date format. */
	_autoSize: function(inst) {
		if (this._get(inst, 'autoSize') && !inst.inline) {
			var date = new Date(2009, 12 - 1, 20); // Ensure double digits
			var dateFormat = this._get(inst, 'dateFormat');
			if (dateFormat.match(/[DM]/)) {
				var findMax = function(names) {
					var max = 0;
					var maxI = 0;
					for (var i = 0; i < names.length; i++) {
						if (names[i].length > max) {
							max = names[i].length;
							maxI = i;
						}
					}
					return maxI;
				};
				date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
					'monthNames' : 'monthNamesShort'))));
				date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
					'dayNames' : 'dayNamesShort'))) + 20 - date.getDay());
			}
			inst.input.attr('size', this._formatDate(inst, date).length);
		}
	},

	/* Attach an inline date picker to a div. */
	_inlineDatepicker: function(target, inst) {
		var divSpan = $(target);
		if (divSpan.hasClass(this.markerClassName))
			return;
		divSpan.addClass(this.markerClassName).append(inst.dpDiv).
			on("setData.datepicker", function(event, key, value){
				inst.settings[key] = value;
			}).on("getData.datepicker", function(event, key){
				return this._get(inst, key);
			});
		$.data(target, PROP_NAME, inst);
		this._setDate(inst, this._getDefaultDate(inst), true);
		this._updateDatepicker(inst);
		this._updateAlternate(inst);
		//If disabled option is true, disable the datepicker before showing it (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
		// Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
		// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
		inst.dpDiv.css( "display", "block" );
	},

	/* Pop-up the date picker in a "dialog" box.
	   @param  input     element - ignored
	   @param  date      string or Date - the initial date to display
	   @param  onSelect  function - the function to call when a date is selected
	   @param  settings  object - update the dialog date picker instance's settings (anonymous object)
	   @param  pos       int[2] - coordinates for the dialog's position within the screen or
	                     event - with x/y coordinates or
	                     leave empty for default (screen centre)
	   @return the manager object */
	_dialogDatepicker: function(input, date, onSelect, settings, pos) {
		var inst = this._dialogInst; // internal instance
		if (!inst) {
			this.uuid += 1;
			var id = 'dp' + this.uuid;
			this._dialogInput = $('<input type="text" id="' + id +
				'" style="position: absolute; top: -100px; width: 0px;"/>');
			this._dialogInput.on('keydown', this._doKeyDown);
			$('body').append(this._dialogInput);
			inst = this._dialogInst = this._newInst(this._dialogInput, false);
			inst.settings = {};
			$.data(this._dialogInput[0], PROP_NAME, inst);
		}
		extendRemove(inst.settings, settings || {});
		date = (date && date.constructor == Date ? this._formatDate(inst, date) : date);
		this._dialogInput.val(date);

		this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
		if (!this._pos) {
			var browserWidth = document.documentElement.clientWidth;
			var browserHeight = document.documentElement.clientHeight;
			var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
			var scrollY = document.documentElement.scrollTop || document.body.scrollTop;
			this._pos = // should use actual width/height below
				[(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
		}

		// move input on screen for focus, but hidden behind dialog
		this._dialogInput.css('left', (this._pos[0] + 20) + 'px').css('top', this._pos[1] + 'px');
		inst.settings.onSelect = onSelect;
		this._inDialog = true;
		this.dpDiv.addClass(this._dialogClass);
		this._showDatepicker(this._dialogInput[0]);
		if ($.blockUI)
			$.blockUI(this.dpDiv);
		$.data(this._dialogInput[0], PROP_NAME, inst);
		return this;
	},

	/* Detach a datepicker from its control.
	   @param  target    element - the target input field or division or span */
	_destroyDatepicker: function(target) {
		var $target = $(target);
		var inst = $.data(target, PROP_NAME);
		if (!$target.hasClass(this.markerClassName)) {
			return;
		}
		var nodeName = target.nodeName.toLowerCase();
		$.removeData(target, PROP_NAME);
		if (nodeName == 'input') {
			inst.append.remove();
			inst.trigger.remove();
			$target.removeClass(this.markerClassName).
				off('focus', this._showDatepicker).
				off('keydown', this._doKeyDown).
				off('keypress', this._doKeyPress).
				off('keyup', this._doKeyUp);
		} else if (nodeName == 'div' || nodeName == 'span')
			$target.removeClass(this.markerClassName).empty();
	},

	/* Enable the date picker to a jQuery selection.
	   @param  target    element - the target input field or division or span */
	_enableDatepicker: function(target) {
		var $target = $(target);
		var inst = $.data(target, PROP_NAME);
		if (!$target.hasClass(this.markerClassName)) {
			return;
		}
		var nodeName = target.nodeName.toLowerCase();
		if (nodeName == 'input') {
			target.disabled = false;
			inst.trigger.filter('button').
				each(function() { this.disabled = false; }).end().
				filter('img').css({opacity: '1.0', cursor: ''});
		}
		else if (nodeName == 'div' || nodeName == 'span') {
			var inline = $target.children('.' + this._inlineClass);
			inline.children().removeClass('ui-state-disabled');
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
				removeAttr("disabled");
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value == target ? null : value); }); // delete entry
	},

	/* Disable the date picker to a jQuery selection.
	   @param  target    element - the target input field or division or span */
	_disableDatepicker: function(target) {
		var $target = $(target);
		var inst = $.data(target, PROP_NAME);
		if (!$target.hasClass(this.markerClassName)) {
			return;
		}
		var nodeName = target.nodeName.toLowerCase();
		if (nodeName == 'input') {
			target.disabled = true;
			inst.trigger.filter('button').
				each(function() { this.disabled = true; }).end().
				filter('img').css({opacity: '0.5', cursor: 'default'});
		}
		else if (nodeName == 'div' || nodeName == 'span') {
			var inline = $target.children('.' + this._inlineClass);
			inline.children().addClass('ui-state-disabled');
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
				attr("disabled", "disabled");
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value == target ? null : value); }); // delete entry
		this._disabledInputs[this._disabledInputs.length] = target;
	},

	/* Is the first field in a jQuery collection disabled as a datepicker?
	   @param  target    element - the target input field or division or span
	   @return boolean - true if disabled, false if enabled */
	_isDisabledDatepicker: function(target) {
		if (!target) {
			return false;
		}
		for (var i = 0; i < this._disabledInputs.length; i++) {
			if (this._disabledInputs[i] == target)
				return true;
		}
		return false;
	},

	/* Retrieve the instance data for the target control.
	   @param  target  element - the target input field or division or span
	   @return  object - the associated instance data
	   @throws  error if a jQuery problem getting data */
	_getInst: function(target) {
		try {
			return $.data(target, PROP_NAME);
		}
		catch (err) {
			throw 'Missing instance data for this datepicker';
		}
	},

	/* Update or retrieve the settings for a date picker attached to an input field or division.
	   @param  target  element - the target input field or division or span
	   @param  name    object - the new settings to update or
	                   string - the name of the setting to change or retrieve,
	                   when retrieving also 'all' for all instance settings or
	                   'defaults' for all global defaults
	   @param  value   any - the new value for the setting
	                   (omit if above is an object or to retrieve a value) */
	_optionDatepicker: function(target, name, value) {
		var inst = this._getInst(target);
		if (arguments.length == 2 && typeof name == 'string') {
			return (name == 'defaults' ? $.extend({}, $.datepicker._defaults) :
				(inst ? (name == 'all' ? $.extend({}, inst.settings) :
				this._get(inst, name)) : null));
		}
		var settings = name || {};
		if (typeof name == 'string') {
			settings = {};
			settings[name] = value;
		}
		if (inst) {
			if (this._curInst == inst) {
				this._hideDatepicker();
			}
			var date = this._getDateDatepicker(target, true);
			var minDate = this._getMinMaxDate(inst, 'min');
			var maxDate = this._getMinMaxDate(inst, 'max');
			extendRemove(inst.settings, settings);
			// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
			if (minDate !== null && settings['dateFormat'] !== undefined && settings['minDate'] === undefined)
				inst.settings.minDate = this._formatDate(inst, minDate);
			if (maxDate !== null && settings['dateFormat'] !== undefined && settings['maxDate'] === undefined)
				inst.settings.maxDate = this._formatDate(inst, maxDate);
			this._attachments($(target), inst);
			this._autoSize(inst);
			this._setDate(inst, date);
			this._updateAlternate(inst);
			this._updateDatepicker(inst);
		}
	},

	// change method deprecated
	_changeDatepicker: function(target, name, value) {
		this._optionDatepicker(target, name, value);
	},

	/* Redraw the date picker attached to an input field or division.
	   @param  target  element - the target input field or division or span */
	_refreshDatepicker: function(target) {
		var inst = this._getInst(target);
		if (inst) {
			this._updateDatepicker(inst);
		}
	},

	/* Set the dates for a jQuery selection.
	   @param  target   element - the target input field or division or span
	   @param  date     Date - the new date */
	_setDateDatepicker: function(target, date) {
		var inst = this._getInst(target);
		if (inst) {
			this._setDate(inst, date);
			this._updateDatepicker(inst);
			this._updateAlternate(inst);
		}
	},

	/* Get the date(s) for the first entry in a jQuery selection.
	   @param  target     element - the target input field or division or span
	   @param  noDefault  boolean - true if no default date is to be used
	   @return Date - the current date */
	_getDateDatepicker: function(target, noDefault) {
		var inst = this._getInst(target);
		if (inst && !inst.inline)
			this._setDateFromField(inst, noDefault);
		return (inst ? this._getDate(inst) : null);
	},

	/* Handle keystrokes. */
	_doKeyDown: function(event) {
		var inst = $.datepicker._getInst(event.target);
		var handled = true;
		var isRTL = inst.dpDiv.is('.ui-datepicker-rtl');
		inst._keyEvent = true;
		if ($.datepicker._datepickerShowing)
			switch (event.keyCode) {
				case 9: $.datepicker._hideDatepicker();
						handled = false;
						break; // hide on tab out
				case 13: var sel = $('td.' + $.datepicker._dayOverClass + ':not(.' +
									$.datepicker._currentClass + ')', inst.dpDiv);
						if (sel[0])
							$.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
							var onSelect = $.datepicker._get(inst, 'onSelect');
							if (onSelect) {
								var dateStr = $.datepicker._formatDate(inst);

								// trigger custom callback
								onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
							}
						else
							$.datepicker._hideDatepicker();
						return false; // don't submit the form
						break; // select the value on enter
				case 27: $.datepicker._hideDatepicker();
						break; // hide on escape
				case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							-$.datepicker._get(inst, 'stepBigMonths') :
							-$.datepicker._get(inst, 'stepMonths')), 'M');
						break; // previous month/year on page up/+ ctrl
				case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							+$.datepicker._get(inst, 'stepBigMonths') :
							+$.datepicker._get(inst, 'stepMonths')), 'M');
						break; // next month/year on page down/+ ctrl
				case 35: if (event.ctrlKey || event.metaKey) $.datepicker._clearDate(event.target);
						handled = event.ctrlKey || event.metaKey;
						break; // clear on ctrl or command +end
				case 36: if (event.ctrlKey || event.metaKey) $.datepicker._gotoToday(event.target);
						handled = event.ctrlKey || event.metaKey;
						break; // current on ctrl or command +home
				case 37: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), 'D');
						handled = event.ctrlKey || event.metaKey;
						// -1 day on ctrl or command +left
						if (event.originalEvent.altKey) $.datepicker._adjustDate(event.target, (event.ctrlKey ?
									-$.datepicker._get(inst, 'stepBigMonths') :
									-$.datepicker._get(inst, 'stepMonths')), 'M');
						// next month/year on alt +left on Mac
						break;
				case 38: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, -7, 'D');
						handled = event.ctrlKey || event.metaKey;
						break; // -1 week on ctrl or command +up
				case 39: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), 'D');
						handled = event.ctrlKey || event.metaKey;
						// +1 day on ctrl or command +right
						if (event.originalEvent.altKey) $.datepicker._adjustDate(event.target, (event.ctrlKey ?
									+$.datepicker._get(inst, 'stepBigMonths') :
									+$.datepicker._get(inst, 'stepMonths')), 'M');
						// next month/year on alt +right
						break;
				case 40: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, +7, 'D');
						handled = event.ctrlKey || event.metaKey;
						break; // +1 week on ctrl or command +down
				default: handled = false;
			}
		else if (event.keyCode == 36 && event.ctrlKey) // display the date picker on ctrl+home
			$.datepicker._showDatepicker(this);
		else {
			handled = false;
		}
		if (handled) {
			event.preventDefault();
			event.stopPropagation();
		}
	},

	/* Filter entered characters - based on date format. */
	_doKeyPress: function(event) {
		var inst = $.datepicker._getInst(event.target);
		if ($.datepicker._get(inst, 'constrainInput')) {
			var chars = $.datepicker._possibleChars($.datepicker._get(inst, 'dateFormat'));
			var chr = String.fromCharCode(event.charCode == undefined ? event.keyCode : event.charCode);
			return event.ctrlKey || event.metaKey || (chr < ' ' || !chars || chars.indexOf(chr) > -1);
		}
	},

	/* Synchronise manual entry and field/alternate field. */
	_doKeyUp: function(event) {
		var inst = $.datepicker._getInst(event.target);
		if (inst.input.val() != inst.lastVal) {
			try {
				var date = $.datepicker.parseDate($.datepicker._get(inst, 'dateFormat'),
					(inst.input ? inst.input.val() : null),
					$.datepicker._getFormatConfig(inst));
				if (date) { // only if valid
					$.datepicker._setDateFromField(inst);
					$.datepicker._updateAlternate(inst);
					$.datepicker._updateDatepicker(inst);
				}
			}
			catch (err) {
				$.datepicker.log(err);
			}
		}
		return true;
	},

	/* Pop-up the date picker for a given input field.
       If false returned from beforeShow event handler do not show.
	   @param  input  element - the input field attached to the date picker or
	                  event - if triggered by focus */
	_showDatepicker: function(input) {
		input = input.target || input;
		if (input.nodeName.toLowerCase() != 'input') // find from button/image trigger
			input = $('input', input.parentNode)[0];
		if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput == input) // already here
			return;
		var inst = $.datepicker._getInst(input);
		if ($.datepicker._curInst && $.datepicker._curInst != inst) {
			$.datepicker._curInst.dpDiv.stop(true, true);
			if ( inst && $.datepicker._datepickerShowing ) {
				$.datepicker._hideDatepicker( $.datepicker._curInst.input[0] );
			}
		}
		var beforeShow = $.datepicker._get(inst, 'beforeShow');
		var beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
		if(beforeShowSettings === false){
            //false
			return;
		}
		extendRemove(inst.settings, beforeShowSettings);
		inst.lastVal = null;
		$.datepicker._lastInput = input;
		$.datepicker._setDateFromField(inst);
		if ($.datepicker._inDialog) // hide cursor
			input.value = '';
		if (!$.datepicker._pos) { // position below input
			$.datepicker._pos = $.datepicker._findPos(input);
			$.datepicker._pos[1] += input.offsetHeight; // add the height
		}
		var isFixed = false;
		$(input).parents().each(function() {
			isFixed |= $(this).css('position') == 'fixed';
			return !isFixed;
		});
		if (isFixed && $.browser.opera) { // correction for Opera when fixed and scrolled
			$.datepicker._pos[0] -= document.documentElement.scrollLeft;
			$.datepicker._pos[1] -= document.documentElement.scrollTop;
		}
		var offset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};
		$.datepicker._pos = null;
		//to avoid flashes on Firefox
		inst.dpDiv.empty();
		// determine sizing offscreen
		inst.dpDiv.css({position: 'absolute', display: 'block', top: '-1000px'});
		$.datepicker._updateDatepicker(inst);
		// fix width for dynamic number of date pickers
		// and adjust position before showing
		offset = $.datepicker._checkOffset(inst, offset, isFixed);
		inst.dpDiv.css({position: ($.datepicker._inDialog && $.blockUI ?
			'static' : (isFixed ? 'fixed' : 'absolute')), display: 'none',
			left: offset.left + 'px', top: offset.top + 'px'});
		if (!inst.inline) {
			var showAnim = $.datepicker._get(inst, 'showAnim');
			var duration = $.datepicker._get(inst, 'duration');
			var postProcess = function() {
				var cover = inst.dpDiv.find('iframe.ui-datepicker-cover'); // IE6- only
				if( !! cover.length ){
					var borders = $.datepicker._getBorders(inst.dpDiv);
					cover.css({left: -borders[0], top: -borders[1],
						width: inst.dpDiv.outerWidth(), height: inst.dpDiv.outerHeight()});
				}
			};
			inst.dpDiv.zIndex($(input).zIndex()+1);
			$.datepicker._datepickerShowing = true;
			if ($.effects && $.effects[showAnim])
				inst.dpDiv.show(showAnim, $.datepicker._get(inst, 'showOptions'), duration, postProcess);
			else
				inst.dpDiv[showAnim || 'show']((showAnim ? duration : null), postProcess);
			if (!showAnim || !duration)
				postProcess();
			if (inst.input.is(':visible') && !inst.input.is(':disabled'))
				inst.input.trigger('focus');
			$.datepicker._curInst = inst;
		}
	},

	/* Generate the date picker content. */
	_updateDatepicker: function(inst) {
		var self = this;
		self.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
		var borders = $.datepicker._getBorders(inst.dpDiv);
		instActive = inst; // for delegate hover events
		inst.dpDiv.empty().append(this._generateHTML(inst));
		this._attachHandlers(inst);
		var cover = inst.dpDiv.find('iframe.ui-datepicker-cover'); // IE6- only
		if( !!cover.length ){ //avoid call to outerXXXX() when not in IE6
			cover.css({left: -borders[0], top: -borders[1], width: inst.dpDiv.outerWidth(), height: inst.dpDiv.outerHeight()})
		}
		inst.dpDiv.find('.' + this._dayOverClass + ' a').trigger('mouseover');
		var numMonths = this._getNumberOfMonths(inst);
		var cols = numMonths[1];
		var width = 17;
		inst.dpDiv.removeClass('ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4').width('');
		if (cols > 1)
			inst.dpDiv.addClass('ui-datepicker-multi-' + cols).css('width', (width * cols) + 'em');
		inst.dpDiv[(numMonths[0] != 1 || numMonths[1] != 1 ? 'add' : 'remove') +
			'Class']('ui-datepicker-multi');
		inst.dpDiv[(this._get(inst, 'isRTL') ? 'add' : 'remove') +
			'Class']('ui-datepicker-rtl');
		if (inst == $.datepicker._curInst && $.datepicker._datepickerShowing && inst.input &&
				// #6694 - don't focus the input if it's already focused
				// this breaks the change event in IE
				inst.input.is(':visible') && !inst.input.is(':disabled') && inst.input[0] != document.activeElement)
			inst.input.trigger('focus');
		// deffered render of the years select (to avoid flashes on Firefox)
		if( inst.yearshtml ){
			var origyearshtml = inst.yearshtml;
			setTimeout(function(){
				//assure that inst.yearshtml didn't change.
				if( origyearshtml === inst.yearshtml && inst.yearshtml ){
					inst.dpDiv.find('select.ui-datepicker-year:first').replaceWith(inst.yearshtml);
				}
				origyearshtml = inst.yearshtml = null;
			}, 0);
		}
	},

	/* Retrieve the size of left and top borders for an element.
	   @param  elem  (jQuery object) the element of interest
	   @return  (number[2]) the left and top borders */
	_getBorders: function(elem) {
		var convert = function(value) {
			return {thin: 1, medium: 2, thick: 3}[value] || value;
		};
		return [parseFloat(convert(elem.css('border-left-width'))),
			parseFloat(convert(elem.css('border-top-width')))];
	},

	/* Check positioning to remain on screen. */
	_checkOffset: function(inst, offset, isFixed) {
		var dpWidth = inst.dpDiv.outerWidth();
		var dpHeight = inst.dpDiv.outerHeight();
		var inputWidth = inst.input ? inst.input.outerWidth() : 0;
		var inputHeight = inst.input ? inst.input.outerHeight() : 0;
		var viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft());
		var viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());

		offset.left -= (this._get(inst, 'isRTL') ? (dpWidth - inputWidth) : 0);
		offset.left -= (isFixed && offset.left == inst.input.offset().left) ? $(document).scrollLeft() : 0;
		offset.top -= (isFixed && offset.top == (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;

		// now check if datepicker is showing outside window viewport - move to a better place if so.
		offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
			Math.abs(offset.left + dpWidth - viewWidth) : 0);
		offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
			Math.abs(dpHeight + inputHeight) : 0);

		return offset;
	},

	/* Find an object's position on the screen. */
	_findPos: function(obj) {
		var inst = this._getInst(obj);
		var isRTL = this._get(inst, 'isRTL');
        while (obj && (obj.type == 'hidden' || obj.nodeType != 1 || $.expr.pseudos.hidden(obj))) {
            obj = obj[isRTL ? 'previousSibling' : 'nextSibling'];
        }
        var position = $(obj).offset();
	    return [position.left, position.top];
	},

	/* Hide the date picker from view.
	   @param  input  element - the input field attached to the date picker */
	_hideDatepicker: function(input) {
		var inst = this._curInst;
		if (!inst || (input && inst != $.data(input, PROP_NAME)))
			return;
		if (this._datepickerShowing) {
			var showAnim = this._get(inst, 'showAnim');
			var duration = this._get(inst, 'duration');
			var postProcess = function() {
				$.datepicker._tidyDialog(inst);
			};
			if ($.effects && $.effects[showAnim])
				inst.dpDiv.hide(showAnim, $.datepicker._get(inst, 'showOptions'), duration, postProcess);
			else
				inst.dpDiv[(showAnim == 'slideDown' ? 'slideUp' :
					(showAnim == 'fadeIn' ? 'fadeOut' : 'hide'))]((showAnim ? duration : null), postProcess);
			if (!showAnim)
				postProcess();
			this._datepickerShowing = false;
			var onClose = this._get(inst, 'onClose');
			if (onClose)
				onClose.apply((inst.input ? inst.input[0] : null),
					[(inst.input ? inst.input.val() : ''), inst]);
			this._lastInput = null;
			if (this._inDialog) {
				this._dialogInput.css({ position: 'absolute', left: '0', top: '-100px' });
				if ($.blockUI) {
					$.unblockUI();
					$('body').append(this.dpDiv);
				}
			}
			this._inDialog = false;
		}
	},

	/* Tidy up after a dialog display. */
	_tidyDialog: function(inst) {
		inst.dpDiv.removeClass(this._dialogClass).off('.ui-datepicker-calendar');
	},

	/* Close date picker if clicked elsewhere. */
	_checkExternalClick: function(event) {
		if (!$.datepicker._curInst)
			return;

		var $target = $(event.target),
			inst = $.datepicker._getInst($target[0]);

		if ( ( ( $target[0].id != $.datepicker._mainDivId &&
				$target.parents('#' + $.datepicker._mainDivId).length == 0 &&
				!$target.hasClass($.datepicker.markerClassName) &&
				!$target.closest("." + $.datepicker._triggerClass).length &&
				$.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) ) ) ||
			( $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst != inst ) )
			$.datepicker._hideDatepicker();
	},

	/* Adjust one of the date sub-fields. */
	_adjustDate: function(id, offset, period) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		if (this._isDisabledDatepicker(target[0])) {
			return;
		}
		this._adjustInstDate(inst, offset +
			(period == 'M' ? this._get(inst, 'showCurrentAtPos') : 0), // undo positioning
			period);
		this._updateDatepicker(inst);
	},

	/* Action for current link. */
	_gotoToday: function(id) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		if (this._get(inst, 'gotoCurrent') && inst.currentDay) {
			inst.selectedDay = inst.currentDay;
			inst.drawMonth = inst.selectedMonth = inst.currentMonth;
			inst.drawYear = inst.selectedYear = inst.currentYear;
		}
		else {
			var date = new Date();
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
		}
		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a new month/year. */
	_selectMonthYear: function(id, select, period) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		inst['selected' + (period == 'M' ? 'Month' : 'Year')] =
		inst['draw' + (period == 'M' ? 'Month' : 'Year')] =
			parseInt(select.options[select.selectedIndex].value,10);
		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a day. */
	_selectDay: function(id, month, year, td) {
		var target = $(id);
		if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
			return;
		}
		var inst = this._getInst(target[0]);
		inst.selectedDay = inst.currentDay = $('a', td).html();
		inst.selectedMonth = inst.currentMonth = month;
		inst.selectedYear = inst.currentYear = year;
		this._selectDate(id, this._formatDate(inst,
			inst.currentDay, inst.currentMonth, inst.currentYear));
	},

	/* Erase the input field and hide the date picker. */
	_clearDate: function(id) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		this._selectDate(target, '');
	},

	/* Update the input field with the selected date. */
	_selectDate: function(id, dateStr) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
		if (inst.input)
			inst.input.val(dateStr);
		this._updateAlternate(inst);
		var onSelect = this._get(inst, 'onSelect');
		if (onSelect)
			onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback
		else if (inst.input)
			inst.input.trigger('change'); // fire the change event
		if (inst.inline)
			this._updateDatepicker(inst);
		else {
			this._hideDatepicker();
			this._lastInput = inst.input[0];
			if (typeof(inst.input[0]) != 'object')
				inst.input.trigger('focus'); // restore focus
			this._lastInput = null;
		}
	},

	/* Update any alternate field to synchronise with the main field. */
	_updateAlternate: function(inst) {
		var altField = this._get(inst, 'altField');
		if (altField) { // update alternate field too
			var altFormat = this._get(inst, 'altFormat') || this._get(inst, 'dateFormat');
			var date = this._getDate(inst);
			var dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
			$(altField).each(function() { $(this).val(dateStr); });
		}
	},

	/* Set as beforeShowDay function to prevent selection of weekends.
	   @param  date  Date - the date to customise
	   @return [boolean, string] - is this date selectable?, what is its CSS class? */
	noWeekends: function(date) {
		var day = date.getDay();
		return [(day > 0 && day < 6), ''];
	},

	/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
	   @param  date  Date - the date to get the week for
	   @return  number - the number of the week within the year that contains this date */
	iso8601Week: function(date) {
		var checkDate = new Date(date.getTime());
		// Find Thursday of this week starting on Monday
		checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
		var time = checkDate.getTime();
		checkDate.setMonth(0); // Compare with Jan 1
		checkDate.setDate(1);
		return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
	},

	/* Parse a string value into a date object.
	   See formatDate below for the possible formats.

	   @param  format    string - the expected format of the date
	   @param  value     string - the date in the above format
	   @param  settings  Object - attributes include:
	                     shortYearCutoff  number - the cutoff year for determining the century (optional)
	                     dayNamesShort    string[7] - abbreviated names of the days from Sunday (optional)
	                     dayNames         string[7] - names of the days from Sunday (optional)
	                     monthNamesShort  string[12] - abbreviated names of the months (optional)
	                     monthNames       string[12] - names of the months (optional)
	   @return  Date - the extracted date value or null if value is blank */
	parseDate: function (format, value, settings) {
		if (format == null || value == null)
			throw 'Invalid arguments';
		value = (typeof value == 'object' ? value.toString() : value + '');
		if (value == '')
			return null;
		var shortYearCutoff = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff;
		shortYearCutoff = (typeof shortYearCutoff != 'string' ? shortYearCutoff :
				new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
		var dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort;
		var dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames;
		var monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort;
		var monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames;
		var year = -1;
		var month = -1;
		var day = -1;
		var doy = -1;
		var literal = false;
		// Check whether a format character is doubled
		var lookAhead = function(match) {
			var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);
			if (matches)
				iFormat++;
			return matches;
		};
		// Extract a number from the string value
		var getNumber = function(match) {
			var isDoubled = lookAhead(match);
			var size = (match == '@' ? 14 : (match == '!' ? 20 :
				(match == 'y' && isDoubled ? 4 : (match == 'o' ? 3 : 2))));
			var digits = new RegExp('^\\d{1,' + size + '}');
			var num = value.substring(iValue).match(digits);
			if (!num)
				throw 'Missing number at position ' + iValue;
			iValue += num[0].length;
			return parseInt(num[0], 10);
		};
		// Extract a name from the string value and convert to an index
		var getName = function(match, shortNames, longNames) {
			var names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
				return [ [k, v] ];
			}).sort(function (a, b) {
				return -(a[1].length - b[1].length);
			});
			var index = -1;
			$.each(names, function (i, pair) {
				var name = pair[1];
				if (value.substr(iValue, name.length).toLowerCase() == name.toLowerCase()) {
					index = pair[0];
					iValue += name.length;
					return false;
				}
			});
			if (index != -1)
				return index + 1;
			else
				throw 'Unknown name at position ' + iValue;
		};
		// Confirm that a literal character matches the string value
		var checkLiteral = function() {
			if (value.charAt(iValue) != format.charAt(iFormat))
				throw 'Unexpected literal at position ' + iValue;
			iValue++;
		};
		var iValue = 0;
		for (var iFormat = 0; iFormat < format.length; iFormat++) {
			if (literal)
				if (format.charAt(iFormat) == "'" && !lookAhead("'"))
					literal = false;
				else
					checkLiteral();
			else
				switch (format.charAt(iFormat)) {
					case 'd':
						day = getNumber('d');
						break;
					case 'D':
						getName('D', dayNamesShort, dayNames);
						break;
					case 'o':
						doy = getNumber('o');
						break;
					case 'm':
						month = getNumber('m');
						break;
					case 'M':
						month = getName('M', monthNamesShort, monthNames);
						break;
					case 'y':
						year = getNumber('y');
						break;
					case '@':
						var date = new Date(getNumber('@'));
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case '!':
						var date = new Date((getNumber('!') - this._ticksTo1970) / 10000);
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "'":
						if (lookAhead("'"))
							checkLiteral();
						else
							literal = true;
						break;
					default:
						checkLiteral();
				}
		}
		if (iValue < value.length){
			throw "Extra/unparsed characters found in date: " + value.substring(iValue);
		}
		if (year == -1)
			year = new Date().getFullYear();
		else if (year < 100)
			year += new Date().getFullYear() - new Date().getFullYear() % 100 +
				(year <= shortYearCutoff ? 0 : -100);
		if (doy > -1) {
			month = 1;
			day = doy;
			do {
				var dim = this._getDaysInMonth(year, month - 1);
				if (day <= dim)
					break;
				month++;
				day -= dim;
			} while (true);
		}
		var date = this._daylightSavingAdjust(new Date(year, month - 1, day));
		if (date.getFullYear() != year || date.getMonth() + 1 != month || date.getDate() != day)
			throw 'Invalid date'; // E.g. 31/02/00
		return date;
	},

	/* Standard date formats. */
	ATOM: 'yy-mm-dd', // RFC 3339 (ISO 8601)
	COOKIE: 'D, dd M yy',
	ISO_8601: 'yy-mm-dd',
	RFC_822: 'D, d M y',
	RFC_850: 'DD, dd-M-y',
	RFC_1036: 'D, d M y',
	RFC_1123: 'D, d M yy',
	RFC_2822: 'D, d M yy',
	RSS: 'D, d M y', // RFC 822
	TICKS: '!',
	TIMESTAMP: '@',
	W3C: 'yy-mm-dd', // ISO 8601

	_ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
		Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),

	/* Format a date object into a string value.
	   The format can be combinations of the following:
	   d  - day of month (no leading zero)
	   dd - day of month (two digit)
	   o  - day of year (no leading zeros)
	   oo - day of year (three digit)
	   D  - day name short
	   DD - day name long
	   m  - month of year (no leading zero)
	   mm - month of year (two digit)
	   M  - month name short
	   MM - month name long
	   y  - year (two digit)
	   yy - year (four digit)
	   @ - Unix timestamp (ms since 01/01/1970)
	   ! - Windows ticks (100ns since 01/01/0001)
	   '...' - literal text
	   '' - single quote

	   @param  format    string - the desired format of the date
	   @param  date      Date - the date value to format
	   @param  settings  Object - attributes include:
	                     dayNamesShort    string[7] - abbreviated names of the days from Sunday (optional)
	                     dayNames         string[7] - names of the days from Sunday (optional)
	                     monthNamesShort  string[12] - abbreviated names of the months (optional)
	                     monthNames       string[12] - names of the months (optional)
	   @return  string - the date in the above format */
	formatDate: function (format, date, settings) {
		if (!date)
			return '';
		var dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort;
		var dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames;
		var monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort;
		var monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames;
		// Check whether a format character is doubled
		var lookAhead = function(match) {
			var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);
			if (matches)
				iFormat++;
			return matches;
		};
		// Format a number, with leading zero if necessary
		var formatNumber = function(match, value, len) {
			var num = '' + value;
			if (lookAhead(match))
				while (num.length < len)
					num = '0' + num;
			return num;
		};
		// Format a name, short or long as requested
		var formatName = function(match, value, shortNames, longNames) {
			return (lookAhead(match) ? longNames[value] : shortNames[value]);
		};
		var output = '';
		var literal = false;
		if (date)
			for (var iFormat = 0; iFormat < format.length; iFormat++) {
				if (literal)
					if (format.charAt(iFormat) == "'" && !lookAhead("'"))
						literal = false;
					else
						output += format.charAt(iFormat);
				else
					switch (format.charAt(iFormat)) {
						case 'd':
							output += formatNumber('d', date.getDate(), 2);
							break;
						case 'D':
							output += formatName('D', date.getDay(), dayNamesShort, dayNames);
							break;
						case 'o':
							output += formatNumber('o',
								Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
							break;
						case 'm':
							output += formatNumber('m', date.getMonth() + 1, 2);
							break;
						case 'M':
							output += formatName('M', date.getMonth(), monthNamesShort, monthNames);
							break;
						case 'y':
							output += (lookAhead('y') ? date.getFullYear() :
								(date.getYear() % 100 < 10 ? '0' : '') + date.getYear() % 100);
							break;
						case '@':
							output += date.getTime();
							break;
						case '!':
							output += date.getTime() * 10000 + this._ticksTo1970;
							break;
						case "'":
							if (lookAhead("'"))
								output += "'";
							else
								literal = true;
							break;
						default:
							output += format.charAt(iFormat);
					}
			}
		return output;
	},

	/* Extract all possible characters from the date format. */
	_possibleChars: function (format) {
		var chars = '';
		var literal = false;
		// Check whether a format character is doubled
		var lookAhead = function(match) {
			var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);
			if (matches)
				iFormat++;
			return matches;
		};
		for (var iFormat = 0; iFormat < format.length; iFormat++)
			if (literal)
				if (format.charAt(iFormat) == "'" && !lookAhead("'"))
					literal = false;
				else
					chars += format.charAt(iFormat);
			else
				switch (format.charAt(iFormat)) {
					case 'd': case 'm': case 'y': case '@':
						chars += '0123456789';
						break;
					case 'D': case 'M':
						return null; // Accept anything
					case "'":
						if (lookAhead("'"))
							chars += "'";
						else
							literal = true;
						break;
					default:
						chars += format.charAt(iFormat);
				}
		return chars;
	},

	/* Get a setting value, defaulting if necessary. */
	_get: function(inst, name) {
		return inst.settings[name] !== undefined ?
			inst.settings[name] : this._defaults[name];
	},

	/* Parse existing date and initialise date picker. */
	_setDateFromField: function(inst, noDefault) {
		if (inst.input.val() == inst.lastVal) {
			return;
		}
		var dateFormat = this._get(inst, 'dateFormat');
		var dates = inst.lastVal = inst.input ? inst.input.val() : null;
		var date, defaultDate;
		date = defaultDate = this._getDefaultDate(inst);
		var settings = this._getFormatConfig(inst);
		try {
			date = this.parseDate(dateFormat, dates, settings) || defaultDate;
		} catch (event) {
			this.log(event);
			dates = (noDefault ? '' : dates);
		}
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		inst.currentDay = (dates ? date.getDate() : 0);
		inst.currentMonth = (dates ? date.getMonth() : 0);
		inst.currentYear = (dates ? date.getFullYear() : 0);
		this._adjustInstDate(inst);
	},

	/* Retrieve the default date shown on opening. */
	_getDefaultDate: function(inst) {
		return this._restrictMinMax(inst,
			this._determineDate(inst, this._get(inst, 'defaultDate'), new Date()));
	},

	/* A date may be specified as an exact value or a relative one. */
	_determineDate: function(inst, date, defaultDate) {
		var offsetNumeric = function(offset) {
			var date = new Date();
			date.setDate(date.getDate() + offset);
			return date;
		};
		var offsetString = function(offset) {
			try {
				return $.datepicker.parseDate($.datepicker._get(inst, 'dateFormat'),
					offset, $.datepicker._getFormatConfig(inst));
			}
			catch (e) {
				// Ignore
			}
			var date = (offset.toLowerCase().match(/^c/) ?
				$.datepicker._getDate(inst) : null) || new Date();
			var year = date.getFullYear();
			var month = date.getMonth();
			var day = date.getDate();
			var pattern = /([+-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g;
			var matches = pattern.exec(offset);
			while (matches) {
				switch (matches[2] || 'd') {
					case 'd' : case 'D' :
						day += parseInt(matches[1],10); break;
					case 'w' : case 'W' :
						day += parseInt(matches[1],10) * 7; break;
					case 'm' : case 'M' :
						month += parseInt(matches[1],10);
						day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
						break;
					case 'y': case 'Y' :
						year += parseInt(matches[1],10);
						day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
						break;
				}
				matches = pattern.exec(offset);
			}
			return new Date(year, month, day);
		};
		var newDate = (date == null || date === '' ? defaultDate : (typeof date == 'string' ? offsetString(date) :
			(typeof date == 'number' ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));
		newDate = (newDate && newDate.toString() == 'Invalid Date' ? defaultDate : newDate);
		if (newDate) {
			newDate.setHours(0);
			newDate.setMinutes(0);
			newDate.setSeconds(0);
			newDate.setMilliseconds(0);
		}
		return this._daylightSavingAdjust(newDate);
	},

	/* Handle switch to/from daylight saving.
	   Hours may be non-zero on daylight saving cut-over:
	   > 12 when midnight changeover, but then cannot generate
	   midnight datetime, so jump to 1AM, otherwise reset.
	   @param  date  (Date) the date to check
	   @return  (Date) the corrected date */
	_daylightSavingAdjust: function(date) {
		if (!date) return null;
		date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
		return date;
	},

	/* Set the date(s) directly. */
	_setDate: function(inst, date, noChange) {
		var clear = !date;
		var origMonth = inst.selectedMonth;
		var origYear = inst.selectedYear;
		var newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
		inst.selectedDay = inst.currentDay = newDate.getDate();
		inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
		inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
		if ((origMonth != inst.selectedMonth || origYear != inst.selectedYear) && !noChange)
			this._notifyChange(inst);
		this._adjustInstDate(inst);
		if (inst.input) {
			inst.input.val(clear ? '' : this._formatDate(inst));
		}
	},

	/* Retrieve the date(s) directly. */
	_getDate: function(inst) {
		var startDate = (!inst.currentYear || (inst.input && inst.input.val() == '') ? null :
			this._daylightSavingAdjust(new Date(
			inst.currentYear, inst.currentMonth, inst.currentDay)));
			return startDate;
	},

	/* Attach the onxxx handlers.  These are declared statically so
	 * they work with static code transformers like Caja.
	 */
	_attachHandlers: function(inst) {
		var stepMonths = this._get(inst, 'stepMonths');
		var id = '#' + inst.id.replace( /\\\\/g, "\\" );
		inst.dpDiv.find('[data-handler]').map(function () {
			var handler = {
				prev: function () {
					window['DP_jQuery_' + dpuuid].datepicker._adjustDate(id, -stepMonths, 'M');
				},
				next: function () {
					window['DP_jQuery_' + dpuuid].datepicker._adjustDate(id, +stepMonths, 'M');
				},
				hide: function () {
					window['DP_jQuery_' + dpuuid].datepicker._hideDatepicker();
				},
				today: function () {
					window['DP_jQuery_' + dpuuid].datepicker._gotoToday(id);
				},
				selectDay: function () {
					window['DP_jQuery_' + dpuuid].datepicker._selectDay(id, +this.getAttribute('data-month'), +this.getAttribute('data-year'), this);
					return false;
				},
				selectMonth: function () {
					window['DP_jQuery_' + dpuuid].datepicker._selectMonthYear(id, this, 'M');
					return false;
				},
				selectYear: function () {
					window['DP_jQuery_' + dpuuid].datepicker._selectMonthYear(id, this, 'Y');
					return false;
				}
			};
			$(this).on(this.getAttribute('data-event'), handler[this.getAttribute('data-handler')]);
		});
	},

	/* Generate the HTML for the current state of the date picker. */
	_generateHTML: function(inst) {
		var today = new Date();
		today = this._daylightSavingAdjust(
			new Date(today.getFullYear(), today.getMonth(), today.getDate())); // clear time
		var isRTL = this._get(inst, 'isRTL');
		var showButtonPanel = this._get(inst, 'showButtonPanel');
		var hideIfNoPrevNext = this._get(inst, 'hideIfNoPrevNext');
		var navigationAsDateFormat = this._get(inst, 'navigationAsDateFormat');
		var numMonths = this._getNumberOfMonths(inst);
		var showCurrentAtPos = this._get(inst, 'showCurrentAtPos');
		var stepMonths = this._get(inst, 'stepMonths');
		var isMultiMonth = (numMonths[0] != 1 || numMonths[1] != 1);
		var currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
			new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
		var minDate = this._getMinMaxDate(inst, 'min');
		var maxDate = this._getMinMaxDate(inst, 'max');
		var drawMonth = inst.drawMonth - showCurrentAtPos;
		var drawYear = inst.drawYear;
		if (drawMonth < 0) {
			drawMonth += 12;
			drawYear--;
		}
		if (maxDate) {
			var maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
				maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
			maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
			while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
				drawMonth--;
				if (drawMonth < 0) {
					drawMonth = 11;
					drawYear--;
				}
			}
		}
		inst.drawMonth = drawMonth;
		inst.drawYear = drawYear;
		var prevText = this._get(inst, 'prevText');
		prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
			this._getFormatConfig(inst)));
		var prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
			'<a class="ui-datepicker-prev ui-corner-all" data-handler="prev" data-event="click"' +
			' title="' + prevText + '"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'e' : 'w') + '">' + prevText + '</span></a>' :
			(hideIfNoPrevNext ? '' : '<a class="ui-datepicker-prev ui-corner-all ui-state-disabled" title="'+ prevText +'"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'e' : 'w') + '">' + prevText + '</span></a>'));
		var nextText = this._get(inst, 'nextText');
		nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
			this._getFormatConfig(inst)));
		var next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
			'<a class="ui-datepicker-next ui-corner-all" data-handler="next" data-event="click"' +
			' title="' + nextText + '"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'w' : 'e') + '">' + nextText + '</span></a>' :
			(hideIfNoPrevNext ? '' : '<a class="ui-datepicker-next ui-corner-all ui-state-disabled" title="'+ nextText + '"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'w' : 'e') + '">' + nextText + '</span></a>'));
		var currentText = this._get(inst, 'currentText');
		var gotoDate = (this._get(inst, 'gotoCurrent') && inst.currentDay ? currentDate : today);
		currentText = (!navigationAsDateFormat ? currentText :
			this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));
		var controls = (!inst.inline ? '<button type="button" class="ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all" data-handler="hide" data-event="click">' +
			this._get(inst, 'closeText') + '</button>' : '');
		var buttonPanel = (showButtonPanel) ? '<div class="ui-datepicker-buttonpane ui-widget-content">' + (isRTL ? controls : '') +
			(this._isInRange(inst, gotoDate) ? '<button type="button" class="ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all" data-handler="today" data-event="click"' +
			'>' + currentText + '</button>' : '') + (isRTL ? '' : controls) + '</div>' : '';
		var firstDay = parseInt(this._get(inst, 'firstDay'),10);
		firstDay = (isNaN(firstDay) ? 0 : firstDay);
		var showWeek = this._get(inst, 'showWeek');
		var dayNames = this._get(inst, 'dayNames');
		var dayNamesShort = this._get(inst, 'dayNamesShort');
		var dayNamesMin = this._get(inst, 'dayNamesMin');
		var monthNames = this._get(inst, 'monthNames');
		var monthNamesShort = this._get(inst, 'monthNamesShort');
		var beforeShowDay = this._get(inst, 'beforeShowDay');
		var showOtherMonths = this._get(inst, 'showOtherMonths');
		var selectOtherMonths = this._get(inst, 'selectOtherMonths');
		var calculateWeek = this._get(inst, 'calculateWeek') || this.iso8601Week;
		var defaultDate = this._getDefaultDate(inst);
		var html = '';
		for (var row = 0; row < numMonths[0]; row++) {
			var group = '';
			this.maxRows = 4;
			for (var col = 0; col < numMonths[1]; col++) {
				var selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
				var cornerClass = ' ui-corner-all';
				var calender = '';
				if (isMultiMonth) {
					calender += '<div class="ui-datepicker-group';
					if (numMonths[1] > 1)
						switch (col) {
							case 0: calender += ' ui-datepicker-group-first';
								cornerClass = ' ui-corner-' + (isRTL ? 'right' : 'left'); break;
							case numMonths[1]-1: calender += ' ui-datepicker-group-last';
								cornerClass = ' ui-corner-' + (isRTL ? 'left' : 'right'); break;
							default: calender += ' ui-datepicker-group-middle'; cornerClass = ''; break;
						}
					calender += '">';
				}
				calender += '<div class="ui-datepicker-header ui-widget-header ui-helper-clearfix' + cornerClass + '">' +
					(/all|left/.test(cornerClass) && row == 0 ? (isRTL ? next : prev) : '') +
					(/all|right/.test(cornerClass) && row == 0 ? (isRTL ? prev : next) : '') +
					this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
					row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
					'</div><table class="ui-datepicker-calendar"><thead>' +
					'<tr>';
				var thead = (showWeek ? '<th class="ui-datepicker-week-col">' + this._get(inst, 'weekHeader') + '</th>' : '');
				for (var dow = 0; dow < 7; dow++) { // days of the week
					var day = (dow + firstDay) % 7;
					thead += '<th' + ((dow + firstDay + 6) % 7 >= 5 ? ' class="ui-datepicker-week-end"' : '') + '>' +
						'<span title="' + dayNames[day] + '">' + dayNamesMin[day] + '</span></th>';
				}
				calender += thead + '</tr></thead><tbody>';
				var daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
				if (drawYear == inst.selectedYear && drawMonth == inst.selectedMonth)
					inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
				var leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
				var curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
				var numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)
				this.maxRows = numRows;
				var printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
				for (var dRow = 0; dRow < numRows; dRow++) { // create date picker rows
					calender += '<tr>';
					var tbody = (!showWeek ? '' : '<td class="ui-datepicker-week-col">' +
						this._get(inst, 'calculateWeek')(printDate) + '</td>');
					for (var dow = 0; dow < 7; dow++) { // create date picker days
						var daySettings = (beforeShowDay ?
							beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, '']);
						var otherMonth = (printDate.getMonth() != drawMonth);
						var unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||
							(minDate && printDate < minDate) || (maxDate && printDate > maxDate);
						tbody += '<td class="' +
							((dow + firstDay + 6) % 7 >= 5 ? ' ui-datepicker-week-end' : '') + // highlight weekends
							(otherMonth ? ' ui-datepicker-other-month' : '') + // highlight days from other months
							((printDate.getTime() == selectedDate.getTime() && drawMonth == inst.selectedMonth && inst._keyEvent) || // user pressed key
							(defaultDate.getTime() == printDate.getTime() && defaultDate.getTime() == selectedDate.getTime()) ?
							// or defaultDate is current printedDate and defaultDate is selectedDate
							' ' + this._dayOverClass : '') + // highlight selected day
							(unselectable ? ' ' + this._unselectableClass + ' ui-state-disabled': '') +  // highlight unselectable days
							(otherMonth && !showOtherMonths ? '' : ' ' + daySettings[1] + // highlight custom dates
							(printDate.getTime() == currentDate.getTime() ? ' ' + this._currentClass : '') + // highlight selected day
							(printDate.getTime() == today.getTime() ? ' ui-datepicker-today' : '')) + '"' + // highlight today (if different)
							((!otherMonth || showOtherMonths) && daySettings[2] ? ' title="' + daySettings[2] + '"' : '') + // cell title
							(unselectable ? '' : ' data-handler="selectDay" data-event="click" data-month="' + printDate.getMonth() + '" data-year="' + printDate.getFullYear() + '"') + '>' + // actions
							(otherMonth && !showOtherMonths ? '&#xa0;' : // display for other months
							(unselectable ? '<span class="ui-state-default">' + printDate.getDate() + '</span>' : '<a class="ui-state-default' +
							(printDate.getTime() == today.getTime() ? ' ui-state-highlight' : '') +
							(printDate.getTime() == currentDate.getTime() ? ' ui-state-active' : '') + // highlight selected day
							(otherMonth ? ' ui-priority-secondary' : '') + // distinguish dates from other months
							'" href="#">' + printDate.getDate() + '</a>')) + '</td>'; // display selectable date
						printDate.setDate(printDate.getDate() + 1);
						printDate = this._daylightSavingAdjust(printDate);
					}
					calender += tbody + '</tr>';
				}
				drawMonth++;
				if (drawMonth > 11) {
					drawMonth = 0;
					drawYear++;
				}
				calender += '</tbody></table>' + (isMultiMonth ? '</div>' +
							((numMonths[0] > 0 && col == numMonths[1]-1) ? '<div class="ui-datepicker-row-break"></div>' : '') : '');
				group += calender;
			}
			html += group;
		}
		html += buttonPanel + ($.browser.msie && parseInt($.browser.version,10) < 7 && !inst.inline ?
			'<iframe src="javascript:false;" class="ui-datepicker-cover" frameborder="0"></iframe>' : '');
		inst._keyEvent = false;
		return html;
	},

	/* Generate the month and year header. */
	_generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,
			secondary, monthNames, monthNamesShort) {
		var changeMonth = this._get(inst, 'changeMonth');
		var changeYear = this._get(inst, 'changeYear');
		var showMonthAfterYear = this._get(inst, 'showMonthAfterYear');
		var html = '<div class="ui-datepicker-title">';
		var monthHtml = '';
		// month selection
		if (secondary || !changeMonth)
			monthHtml += '<span class="ui-datepicker-month">' + monthNames[drawMonth] + '</span>';
		else {
			var inMinYear = (minDate && minDate.getFullYear() == drawYear);
			var inMaxYear = (maxDate && maxDate.getFullYear() == drawYear);
			monthHtml += '<select class="ui-datepicker-month" data-handler="selectMonth" data-event="change">';
			for (var month = 0; month < 12; month++) {
				if ((!inMinYear || month >= minDate.getMonth()) &&
						(!inMaxYear || month <= maxDate.getMonth()))
					monthHtml += '<option value="' + month + '"' +
						(month == drawMonth ? ' selected="selected"' : '') +
						'>' + monthNamesShort[month] + '</option>';
			}
			monthHtml += '</select>';
		}
		if (!showMonthAfterYear)
			html += monthHtml + (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '');
		// year selection
		if ( !inst.yearshtml ) {
			inst.yearshtml = '';
			if (secondary || !changeYear)
				html += '<span class="ui-datepicker-year">' + drawYear + '</span>';
			else {
				// determine range of years to display
				var years = this._get(inst, 'yearRange').split(':');
				var thisYear = new Date().getFullYear();
				var determineYear = function(value) {
					var year = (value.match(/c[+-].*/) ? drawYear + parseInt(value.substring(1), 10) :
						(value.match(/[+-].*/) ? thisYear + parseInt(value, 10) :
						parseInt(value, 10)));
					return (isNaN(year) ? thisYear : year);
				};
				var year = determineYear(years[0]);
				var endYear = Math.max(year, determineYear(years[1] || ''));
				year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
				endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
				inst.yearshtml += '<select class="ui-datepicker-year" data-handler="selectYear" data-event="change">';
				for (; year <= endYear; year++) {
					inst.yearshtml += '<option value="' + year + '"' +
						(year == drawYear ? ' selected="selected"' : '') +
						'>' + year + '</option>';
				}
				inst.yearshtml += '</select>';

				html += inst.yearshtml;
				inst.yearshtml = null;
			}
		}
		html += this._get(inst, 'yearSuffix');
		if (showMonthAfterYear)
			html += (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '') + monthHtml;
		html += '</div>'; // Close datepicker_header
		return html;
	},

	/* Adjust one of the date sub-fields. */
	_adjustInstDate: function(inst, offset, period) {
		var year = inst.drawYear + (period == 'Y' ? offset : 0);
		var month = inst.drawMonth + (period == 'M' ? offset : 0);
		var day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) +
			(period == 'D' ? offset : 0);
		var date = this._restrictMinMax(inst,
			this._daylightSavingAdjust(new Date(year, month, day)));
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		if (period == 'M' || period == 'Y')
			this._notifyChange(inst);
	},

	/* Ensure a date is within any min/max bounds. */
	_restrictMinMax: function(inst, date) {
		var minDate = this._getMinMaxDate(inst, 'min');
		var maxDate = this._getMinMaxDate(inst, 'max');
		var newDate = (minDate && date < minDate ? minDate : date);
		newDate = (maxDate && newDate > maxDate ? maxDate : newDate);
		return newDate;
	},

	/* Notify change of month/year. */
	_notifyChange: function(inst) {
		var onChange = this._get(inst, 'onChangeMonthYear');
		if (onChange)
			onChange.apply((inst.input ? inst.input[0] : null),
				[inst.selectedYear, inst.selectedMonth + 1, inst]);
	},

	/* Determine the number of months to show. */
	_getNumberOfMonths: function(inst) {
		var numMonths = this._get(inst, 'numberOfMonths');
		return (numMonths == null ? [1, 1] : (typeof numMonths == 'number' ? [1, numMonths] : numMonths));
	},

	/* Determine the current maximum date - ensure no time components are set. */
	_getMinMaxDate: function(inst, minMax) {
		return this._determineDate(inst, this._get(inst, minMax + 'Date'), null);
	},

	/* Find the number of days in a given month. */
	_getDaysInMonth: function(year, month) {
		return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
	},

	/* Find the day of the week of the first of a month. */
	_getFirstDayOfMonth: function(year, month) {
		return new Date(year, month, 1).getDay();
	},

	/* Determines if we should allow a "next/prev" month display change. */
	_canAdjustMonth: function(inst, offset, curYear, curMonth) {
		var numMonths = this._getNumberOfMonths(inst);
		var date = this._daylightSavingAdjust(new Date(curYear,
			curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));
		if (offset < 0)
			date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
		return this._isInRange(inst, date);
	},

	/* Is the given date in the accepted range? */
	_isInRange: function(inst, date) {
		var minDate = this._getMinMaxDate(inst, 'min');
		var maxDate = this._getMinMaxDate(inst, 'max');
		return ((!minDate || date.getTime() >= minDate.getTime()) &&
			(!maxDate || date.getTime() <= maxDate.getTime()));
	},

	/* Provide the configuration settings for formatting/parsing. */
	_getFormatConfig: function(inst) {
		var shortYearCutoff = this._get(inst, 'shortYearCutoff');
		shortYearCutoff = (typeof shortYearCutoff != 'string' ? shortYearCutoff :
			new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
		return {shortYearCutoff: shortYearCutoff,
			dayNamesShort: this._get(inst, 'dayNamesShort'), dayNames: this._get(inst, 'dayNames'),
			monthNamesShort: this._get(inst, 'monthNamesShort'), monthNames: this._get(inst, 'monthNames')};
	},

	/* Format the given date for display. */
	_formatDate: function(inst, day, month, year) {
		if (!day) {
			inst.currentDay = inst.selectedDay;
			inst.currentMonth = inst.selectedMonth;
			inst.currentYear = inst.selectedYear;
		}
		var date = (day ? (typeof day == 'object' ? day :
			this._daylightSavingAdjust(new Date(year, month, day))) :
			this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
		return this.formatDate(this._get(inst, 'dateFormat'), date, this._getFormatConfig(inst));
	}
});

/*
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 */
function bindHover(dpDiv) {
	var selector = 'button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a';
	return dpDiv.on('mouseout', function(event) {
			var elem = $( event.target ).closest( selector );
			if ( !elem.length ) {
				return;
			}
			elem.removeClass( "ui-state-hover ui-datepicker-prev-hover ui-datepicker-next-hover" );
		})
		.on('mouseover', function(event) {
			var elem = $( event.target ).closest( selector );
			if ($.datepicker._isDisabledDatepicker( instActive.inline ? dpDiv.parent()[0] : instActive.input[0]) ||
					!elem.length ) {
				return;
			}
			elem.parents('.ui-datepicker-calendar').find('a').removeClass('ui-state-hover');
			elem.addClass('ui-state-hover');
			if (elem.hasClass('ui-datepicker-prev')) elem.addClass('ui-datepicker-prev-hover');
			if (elem.hasClass('ui-datepicker-next')) elem.addClass('ui-datepicker-next-hover');
		});
}

/* jQuery extend now ignores nulls! */
function extendRemove(target, props) {
	$.extend(target, props);
	for (var name in props)
		if (props[name] == null || props[name] == undefined)
			target[name] = props[name];
	return target;
};

/* Determine whether an object is an array. */
function isArray(a) {
	return (a && (($.browser.safari && typeof a == 'object' && a.length) ||
		(a.constructor && a.constructor.toString().match(/\Array\(\)/))));
};

/* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
                    Object - settings for attaching new datepicker functionality
   @return  jQuery object */
$.fn.datepicker = function(options){

	/* Verify an empty collection wasn't passed - Fixes #6976 */
	if ( !this.length ) {
		return this;
	}

	/* Initialise the date picker. */
	if (!$.datepicker.initialized) {
		$(document).on('mousedown', $.datepicker._checkExternalClick).
			find('body').append($.datepicker.dpDiv);
		$.datepicker.initialized = true;
	}

	var otherArgs = Array.prototype.slice.call(arguments, 1);
	if (typeof options == 'string' && (options == 'isDisabled' || options == 'getDate' || options == 'widget'))
		return $.datepicker['_' + options + 'Datepicker'].
			apply($.datepicker, [this[0]].concat(otherArgs));
	if (options == 'option' && arguments.length == 2 && typeof arguments[1] == 'string')
		return $.datepicker['_' + options + 'Datepicker'].
			apply($.datepicker, [this[0]].concat(otherArgs));
	return this.each(function() {
		typeof options == 'string' ?
			$.datepicker['_' + options + 'Datepicker'].
				apply($.datepicker, [this].concat(otherArgs)) :
			$.datepicker._attachDatepicker(this, options);
	});
};

$.datepicker = new Datepicker(); // singleton instance
$.datepicker.initialized = false;
$.datepicker.uuid = new Date().getTime();
$.datepicker.version = "1.8.23";

// Workaround for #4055
// Add another global to avoid noConflict issues with inline event handlers
window['DP_jQuery_' + dpuuid] = $;

})(jQuery);
/*!
 * jQuery UI Progressbar 1.8.23
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Progressbar
 *
 * Depends:
 *   jquery.ui.core.js
 *   jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget( "ui.progressbar", {
	options: {
		value: 0,
		max: 100
	},

	min: 0,

	_create: function() {
		this.element
			.addClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
			.attr({
				role: "progressbar",
				"aria-valuemin": this.min,
				"aria-valuemax": this.options.max,
				"aria-valuenow": this._value()
			});

		this.valueDiv = $( "<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>" )
			.appendTo( this.element );

		this.oldValue = this._value();
		this._refreshValue();
	},

	destroy: function() {
		this.element
			.removeClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
			.removeAttr( "role" )
			.removeAttr( "aria-valuemin" )
			.removeAttr( "aria-valuemax" )
			.removeAttr( "aria-valuenow" );

		this.valueDiv.remove();

		$.Widget.prototype.destroy.apply( this, arguments );
	},

	value: function( newValue ) {
		if ( newValue === undefined ) {
			return this._value();
		}

		this._setOption( "value", newValue );
		return this;
	},

	_setOption: function( key, value ) {
		if ( key === "value" ) {
			this.options.value = value;
			this._refreshValue();
			if ( this._value() === this.options.max ) {
				this._trigger( "complete" );
			}
		}

		$.Widget.prototype._setOption.apply( this, arguments );
	},

	_value: function() {
		var val = this.options.value;
		// normalize invalid value
		if ( typeof val !== "number" ) {
			val = 0;
		}
		return Math.min( this.options.max, Math.max( this.min, val ) );
	},

	_percentage: function() {
		return 100 * this._value() / this.options.max;
	},

	_refreshValue: function() {
		var value = this.value();
		var percentage = this._percentage();

		if ( this.oldValue !== value ) {
			this.oldValue = value;
			this._trigger( "change" );
		}

		this.valueDiv
			.toggle( value > this.min )
			.toggleClass( "ui-corner-right", value === this.options.max )
			.width( percentage.toFixed(0) + "%" );
		this.element.attr( "aria-valuenow", value );
	}
});

$.extend( $.ui.progressbar, {
	version: "1.8.23"
});

})( jQuery );
/*!
 * jQuery UI Effects 1.8.23
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/
 */
;jQuery.effects || (function($, undefined) {

$.effects = {};



/******************************************************************************/
/****************************** COLOR ANIMATIONS ******************************/
/******************************************************************************/

// override the animation for color styles
$.each(['backgroundColor', 'borderBottomColor', 'borderLeftColor',
	'borderRightColor', 'borderTopColor', 'borderColor', 'color', 'outlineColor'],
function(i, attr) {
	$.fx.step[attr] = function(fx) {
		if (!fx.colorInit) {
			fx.start = getColor(fx.elem, attr);
			fx.end = getRGB(fx.end);
			fx.colorInit = true;
		}

		fx.elem.style[attr] = 'rgb(' +
			Math.max(Math.min(parseInt((fx.pos * (fx.end[0] - fx.start[0])) + fx.start[0], 10), 255), 0) + ',' +
			Math.max(Math.min(parseInt((fx.pos * (fx.end[1] - fx.start[1])) + fx.start[1], 10), 255), 0) + ',' +
			Math.max(Math.min(parseInt((fx.pos * (fx.end[2] - fx.start[2])) + fx.start[2], 10), 255), 0) + ')';
	};
});

// Color Conversion functions from highlightFade
// By Blair Mitchelmore
// http://jquery.offput.ca/highlightFade/

// Parse strings looking for color tuples [255,255,255]
function getRGB(color) {
		var result;

		// Check if we're already dealing with an array of colors
		if ( color && color.constructor == Array && color.length == 3 )
				return color;

		// Look for rgb(num,num,num)
		if (result = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(color))
				return [parseInt(result[1],10), parseInt(result[2],10), parseInt(result[3],10)];

		// Look for rgb(num%,num%,num%)
		if (result = /rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(color))
				return [parseFloat(result[1])*2.55, parseFloat(result[2])*2.55, parseFloat(result[3])*2.55];

		// Look for #a0b1c2
		if (result = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(color))
				return [parseInt(result[1],16), parseInt(result[2],16), parseInt(result[3],16)];

		// Look for #fff
		if (result = /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(color))
				return [parseInt(result[1]+result[1],16), parseInt(result[2]+result[2],16), parseInt(result[3]+result[3],16)];

		// Look for rgba(0, 0, 0, 0) == transparent in Safari 3
		if (result = /rgba\(0, 0, 0, 0\)/.exec(color))
				return colors['transparent'];

		// Otherwise, we're most likely dealing with a named color
		return colors[$.trim(color).toLowerCase()];
}

function getColor(elem, attr) {
		var color;

		do {
				// jQuery <1.4.3 uses curCSS, in 1.4.3 - 1.7.2 curCSS = css, 1.8+ only has css
				color = ($.curCSS || $.css)(elem, attr);

				// Keep going until we find an element that has color, or we hit the body
				if ( color != '' && color != 'transparent' || $.nodeName(elem, "body") )
						break;

				attr = "backgroundColor";
		} while ( elem = elem.parentNode );

		return getRGB(color);
};

// Some named colors to work with
// From Interface by Stefan Petre
// http://interface.eyecon.ro/

var colors = {
	aqua:[0,255,255],
	azure:[240,255,255],
	beige:[245,245,220],
	black:[0,0,0],
	blue:[0,0,255],
	brown:[165,42,42],
	cyan:[0,255,255],
	darkblue:[0,0,139],
	darkcyan:[0,139,139],
	darkgrey:[169,169,169],
	darkgreen:[0,100,0],
	darkkhaki:[189,183,107],
	darkmagenta:[139,0,139],
	darkolivegreen:[85,107,47],
	darkorange:[255,140,0],
	darkorchid:[153,50,204],
	darkred:[139,0,0],
	darksalmon:[233,150,122],
	darkviolet:[148,0,211],
	fuchsia:[255,0,255],
	gold:[255,215,0],
	green:[0,128,0],
	indigo:[75,0,130],
	khaki:[240,230,140],
	lightblue:[173,216,230],
	lightcyan:[224,255,255],
	lightgreen:[144,238,144],
	lightgrey:[211,211,211],
	lightpink:[255,182,193],
	lightyellow:[255,255,224],
	lime:[0,255,0],
	magenta:[255,0,255],
	maroon:[128,0,0],
	navy:[0,0,128],
	olive:[128,128,0],
	orange:[255,165,0],
	pink:[255,192,203],
	purple:[128,0,128],
	violet:[128,0,128],
	red:[255,0,0],
	silver:[192,192,192],
	white:[255,255,255],
	yellow:[255,255,0],
	transparent: [255,255,255]
};



/******************************************************************************/
/****************************** CLASS ANIMATIONS ******************************/
/******************************************************************************/

var classAnimationActions = ['add', 'remove', 'toggle'],
	shorthandStyles = {
		border: 1,
		borderBottom: 1,
		borderColor: 1,
		borderLeft: 1,
		borderRight: 1,
		borderTop: 1,
		borderWidth: 1,
		margin: 1,
		padding: 1
	};

function getElementStyles() {
	var style = document.defaultView
			? document.defaultView.getComputedStyle(this, null)
			: this.currentStyle,
		newStyle = {},
		key,
		camelCase;

	// webkit enumerates style porperties
	if (style && style.length && style[0] && style[style[0]]) {
		var len = style.length;
		while (len--) {
			key = style[len];
			if (typeof style[key] == 'string') {
				camelCase = key.replace(/\-(\w)/g, function(all, letter){
					return letter.toUpperCase();
				});
				newStyle[camelCase] = style[key];
			}
		}
	} else {
		for (key in style) {
			if (typeof style[key] === 'string') {
				newStyle[key] = style[key];
			}
		}
	}

	return newStyle;
}

function filterStyles(styles) {
	var name, value;
	for (name in styles) {
		value = styles[name];
		if (
			// ignore null and undefined values
			value == null ||
			// ignore functions (when does this occur?)
			$.isFunction(value) ||
			// shorthand styles that need to be expanded
			name in shorthandStyles ||
			// ignore scrollbars (break in IE)
			(/scrollbar/).test(name) ||

			// only colors or values that can be converted to numbers
			(!(/color/i).test(name) && isNaN(parseFloat(value)))
		) {
			delete styles[name];
		}
	}

	return styles;
}

function styleDifference(oldStyle, newStyle) {
	var diff = { _: 0 }, // http://dev.jquery.com/ticket/5459
		name;

	for (name in newStyle) {
		if (oldStyle[name] != newStyle[name]) {
			diff[name] = newStyle[name];
		}
	}

	return diff;
}

$.effects.animateClass = function(value, duration, easing, callback) {
	if ($.isFunction(easing)) {
		callback = easing;
		easing = null;
	}

	return this.queue(function() {
		var that = $(this),
			originalStyleAttr = that.attr('style') || ' ',
			originalStyle = filterStyles(getElementStyles.call(this)),
			newStyle,
			className = that.attr('class') || "";

		$.each(classAnimationActions, function(i, action) {
			if (value[action]) {
				that[action + 'Class'](value[action]);
			}
		});
		newStyle = filterStyles(getElementStyles.call(this));
		that.attr('class', className);

		that.animate(styleDifference(originalStyle, newStyle), {
			queue: false,
			duration: duration,
			easing: easing,
			complete: function() {
				$.each(classAnimationActions, function(i, action) {
					if (value[action]) { that[action + 'Class'](value[action]); }
				});
				// work around bug in IE by clearing the cssText before setting it
				if (typeof that.attr('style') == 'object') {
					that.attr('style').cssText = '';
					that.attr('style').cssText = originalStyleAttr;
				} else {
					that.attr('style', originalStyleAttr);
				}
				if (callback) { callback.apply(this, arguments); }
				$.dequeue( this );
			}
		});
	});
};

$.fn.extend({
	_addClass: $.fn.addClass,
	addClass: function(classNames, speed, easing, callback) {
		return speed ? $.effects.animateClass.apply(this, [{ add: classNames },speed,easing,callback]) : this._addClass(classNames);
	},

	_removeClass: $.fn.removeClass,
	removeClass: function(classNames,speed,easing,callback) {
		return speed ? $.effects.animateClass.apply(this, [{ remove: classNames },speed,easing,callback]) : this._removeClass(classNames);
	},

	_toggleClass: $.fn.toggleClass,
	toggleClass: function(classNames, force, speed, easing, callback) {
		if ( typeof force == "boolean" || force === undefined ) {
			if ( !speed ) {
				// without speed parameter;
				return this._toggleClass(classNames, force);
			} else {
				return $.effects.animateClass.apply(this, [(force?{add:classNames}:{remove:classNames}),speed,easing,callback]);
			}
		} else {
			// without switch parameter;
			return $.effects.animateClass.apply(this, [{ toggle: classNames },force,speed,easing]);
		}
	},

	switchClass: function(remove,add,speed,easing,callback) {
		return $.effects.animateClass.apply(this, [{ add: add, remove: remove },speed,easing,callback]);
	}
});



/******************************************************************************/
/*********************************** EFFECTS **********************************/
/******************************************************************************/

$.extend($.effects, {
	version: "1.8.23",

	// Saves a set of properties in a data storage
	save: function(element, set) {
		for(var i=0; i < set.length; i++) {
			if(set[i] !== null) element.data("ec.storage."+set[i], element[0].style[set[i]]);
		}
	},

	// Restores a set of previously saved properties from a data storage
	restore: function(element, set) {
		for(var i=0; i < set.length; i++) {
			if(set[i] !== null) element.css(set[i], element.data("ec.storage."+set[i]));
		}
	},

	setMode: function(el, mode) {
		if (mode == 'toggle') mode = el.is(':hidden') ? 'show' : 'hide'; // Set for toggle
		return mode;
	},

	getBaseline: function(origin, original) { // Translates a [top,left] array into a baseline value
		// this should be a little more flexible in the future to handle a string & hash
		var y, x;
		switch (origin[0]) {
			case 'top': y = 0; break;
			case 'middle': y = 0.5; break;
			case 'bottom': y = 1; break;
			default: y = origin[0] / original.height;
		};
		switch (origin[1]) {
			case 'left': x = 0; break;
			case 'center': x = 0.5; break;
			case 'right': x = 1; break;
			default: x = origin[1] / original.width;
		};
		return {x: x, y: y};
	},

	// Wraps the element around a wrapper that copies position properties
	createWrapper: function(element) {

		// if the element is already wrapped, return it
		if (element.parent().is('.ui-effects-wrapper')) {
			return element.parent();
		}

		// wrap the element
		var props = {
				width: element.outerWidth(true),
				height: element.outerHeight(true),
				'float': element.css('float')
			},
			wrapper = $('<div></div>')
				.addClass('ui-effects-wrapper')
				.css({
					fontSize: '100%',
					background: 'transparent',
					border: 'none',
					margin: 0,
					padding: 0
				}),
			active = document.activeElement;

		// support: Firefox
		// Firefox incorrectly exposes anonymous content
		// https://bugzilla.mozilla.org/show_bug.cgi?id=561664
		try {
			active.id;
		} catch( e ) {
			active = document.body;
		}

		element.wrap( wrapper );

		// Fixes #7595 - Elements lose focus when wrapped.
		if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
			$( active ).trigger('focus');
		}

		wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually loose the reference to the wrapped element

		// transfer positioning properties to the wrapper
		if (element.css('position') == 'static') {
			wrapper.css({ position: 'relative' });
			element.css({ position: 'relative' });
		} else {
			$.extend(props, {
				position: element.css('position'),
				zIndex: element.css('z-index')
			});
			$.each(['top', 'left', 'bottom', 'right'], function(i, pos) {
				props[pos] = element.css(pos);
				if (isNaN(parseInt(props[pos], 10))) {
					props[pos] = 'auto';
				}
			});
			element.css({position: 'relative', top: 0, left: 0, right: 'auto', bottom: 'auto' });
		}

		return wrapper.css(props).show();
	},

	removeWrapper: function(element) {
		var parent,
			active = document.activeElement;

		if (element.parent().is('.ui-effects-wrapper')) {
			parent = element.parent().replaceWith(element);
			// Fixes #7595 - Elements lose focus when wrapped.
			if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
				$( active ).trigger('focus');
			}
			return parent;
		}

		return element;
	},

	setTransition: function(element, list, factor, value) {
		value = value || {};
		$.each(list, function(i, x){
			var unit = element.cssUnit(x);
			if (unit[0] > 0) value[x] = unit[0] * factor + unit[1];
		});
		return value;
	}
});


function _normalizeArguments(effect, options, speed, callback) {
	// shift params for method overloading
	if (typeof effect == 'object') {
		callback = options;
		speed = null;
		options = effect;
		effect = options.effect;
	}
	if ($.isFunction(options)) {
		callback = options;
		speed = null;
		options = {};
	}
        if (typeof options == 'number' || $.fx.speeds[options]) {
		callback = speed;
		speed = options;
		options = {};
	}
	if ($.isFunction(speed)) {
		callback = speed;
		speed = null;
	}

	options = options || {};

	speed = speed || options.duration;
	speed = $.fx.off ? 0 : typeof speed == 'number'
		? speed : speed in $.fx.speeds ? $.fx.speeds[speed] : $.fx.speeds._default;

	callback = callback || options.complete;

	return [effect, options, speed, callback];
}

function standardSpeed( speed ) {
	// valid standard speeds
	if ( !speed || typeof speed === "number" || $.fx.speeds[ speed ] ) {
		return true;
	}

	// invalid strings - treat as "normal" speed
	if ( typeof speed === "string" && !$.effects[ speed ] ) {
		return true;
	}

	return false;
}

$.fn.extend({
	effect: function(effect, options, speed, callback) {
		var args = _normalizeArguments.apply(this, arguments),
			// TODO: make effects take actual parameters instead of a hash
			args2 = {
				options: args[1],
				duration: args[2],
				callback: args[3]
			},
			mode = args2.options.mode,
			effectMethod = $.effects[effect];

		if ( $.fx.off || !effectMethod ) {
			// delegate to the original method (e.g., .show()) if possible
			if ( mode ) {
				return this[ mode ]( args2.duration, args2.callback );
			} else {
				return this.each(function() {
					if ( args2.callback ) {
						args2.callback.call( this );
					}
				});
			}
		}

		return effectMethod.call(this, args2);
	},

	_show: $.fn.show,
	show: function(speed) {
		if ( standardSpeed( speed ) ) {
			return this._show.apply(this, arguments);
		} else {
			var args = _normalizeArguments.apply(this, arguments);
			args[1].mode = 'show';
			return this.effect.apply(this, args);
		}
	},

	_hide: $.fn.hide,
	hide: function(speed) {
		if ( standardSpeed( speed ) ) {
			return this._hide.apply(this, arguments);
		} else {
			var args = _normalizeArguments.apply(this, arguments);
			args[1].mode = 'hide';
			return this.effect.apply(this, args);
		}
	},

	// jQuery core overloads toggle and creates _toggle
	__toggle: $.fn.toggle,
	toggle: function(speed) {
		if ( standardSpeed( speed ) || typeof speed === "boolean" || $.isFunction( speed ) ) {
			return this.__toggle.apply(this, arguments);
		} else {
			var args = _normalizeArguments.apply(this, arguments);
			args[1].mode = 'toggle';
			return this.effect.apply(this, args);
		}
	},

	// helper functions
	cssUnit: function(key) {
		var style = this.css(key), val = [];
		$.each( ['em','px','%','pt'], function(i, unit){
			if(style.indexOf(unit) > 0)
				val = [parseFloat(style), unit];
		});
		return val;
	}
});



/******************************************************************************/
/*********************************** EASING ***********************************/
/******************************************************************************/

// based on easing equations from Robert Penner (http://www.robertpenner.com/easing)

var baseEasings = {};

$.each( [ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function( i, name ) {
	baseEasings[ name ] = function( p ) {
		return Math.pow( p, i + 2 );
	};
});

$.extend( baseEasings, {
	Sine: function ( p ) {
		return 1 - Math.cos( p * Math.PI / 2 );
	},
	Circ: function ( p ) {
		return 1 - Math.sqrt( 1 - p * p );
	},
	Elastic: function( p ) {
		return p === 0 || p === 1 ? p :
			-Math.pow( 2, 8 * (p - 1) ) * Math.sin( ( (p - 1) * 80 - 7.5 ) * Math.PI / 15 );
	},
	Back: function( p ) {
		return p * p * ( 3 * p - 2 );
	},
	Bounce: function ( p ) {
		var pow2,
			bounce = 4;

		while ( p < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}
		return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 );
	}
});

$.each( baseEasings, function( name, easeIn ) {
	$.easing[ "easeIn" + name ] = easeIn;
	$.easing[ "easeOut" + name ] = function( p ) {
		return 1 - easeIn( 1 - p );
	};
	$.easing[ "easeInOut" + name ] = function( p ) {
		return p < .5 ?
			easeIn( p * 2 ) / 2 :
			easeIn( p * -2 + 2 ) / -2 + 1;
	};
});

})(jQuery);
/*!
 * jQuery UI Effects Blind 1.8.23
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Blind
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.blind = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this), props = ['position','top','bottom','left','right'];

		// Set options
		var mode = $.effects.setMode(el, o.options.mode || 'hide'); // Set Mode
		var direction = o.options.direction || 'vertical'; // Default direction

		// Adjust
		$.effects.save(el, props); el.show(); // Save & Show
		var wrapper = $.effects.createWrapper(el).css({overflow:'hidden'}); // Create Wrapper
		var ref = (direction == 'vertical') ? 'height' : 'width';
		var distance = (direction == 'vertical') ? wrapper.height() : wrapper.width();
		if(mode == 'show') wrapper.css(ref, 0); // Shift

		// Animation
		var animation = {};
		animation[ref] = mode == 'show' ? distance : 0;

		// Animate
		wrapper.animate(animation, o.duration, o.options.easing, function() {
			if(mode == 'hide') el.hide(); // Hide
			$.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
			if(o.callback) o.callback.apply(el[0], arguments); // Callback
			el.dequeue();
		});

	});

};

})(jQuery);
/*!
 * jQuery UI Effects Clip 1.8.23
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Clip
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.clip = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this), props = ['position','top','bottom','left','right','height','width'];

		// Set options
		var mode = $.effects.setMode(el, o.options.mode || 'hide'); // Set Mode
		var direction = o.options.direction || 'vertical'; // Default direction

		// Adjust
		$.effects.save(el, props); el.show(); // Save & Show
		var wrapper = $.effects.createWrapper(el).css({overflow:'hidden'}); // Create Wrapper
		var animate = el[0].tagName == 'IMG' ? wrapper : el;
		var ref = {
			size: (direction == 'vertical') ? 'height' : 'width',
			position: (direction == 'vertical') ? 'top' : 'left'
		};
		var distance = (direction == 'vertical') ? animate.height() : animate.width();
		if(mode == 'show') { animate.css(ref.size, 0); animate.css(ref.position, distance / 2); } // Shift

		// Animation
		var animation = {};
		animation[ref.size] = mode == 'show' ? distance : 0;
		animation[ref.position] = mode == 'show' ? 0 : distance / 2;

		// Animate
		animate.animate(animation, { queue: false, duration: o.duration, easing: o.options.easing, complete: function() {
			if(mode == 'hide') el.hide(); // Hide
			$.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
			if(o.callback) o.callback.apply(el[0], arguments); // Callback
			el.dequeue();
		}});

	});

};

})(jQuery);
/*!
 * jQuery UI Effects Drop 1.8.23
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Drop
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.drop = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this), props = ['position','top','bottom','left','right','opacity'];

		// Set options
		var mode = $.effects.setMode(el, o.options.mode || 'hide'); // Set Mode
		var direction = o.options.direction || 'left'; // Default Direction

		// Adjust
		$.effects.save(el, props); el.show(); // Save & Show
		$.effects.createWrapper(el); // Create Wrapper
		var ref = (direction == 'up' || direction == 'down') ? 'top' : 'left';
		var motion = (direction == 'up' || direction == 'left') ? 'pos' : 'neg';
		var distance = o.options.distance || (ref == 'top' ? el.outerHeight( true ) / 2 : el.outerWidth( true ) / 2);
		if (mode == 'show') el.css('opacity', 0).css(ref, motion == 'pos' ? -distance : distance); // Shift

		// Animation
		var animation = {opacity: mode == 'show' ? 1 : 0};
		animation[ref] = (mode == 'show' ? (motion == 'pos' ? '+=' : '-=') : (motion == 'pos' ? '-=' : '+=')) + distance;

		// Animate
		el.animate(animation, { queue: false, duration: o.duration, easing: o.options.easing, complete: function() {
			if(mode == 'hide') el.hide(); // Hide
			$.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
			if(o.callback) o.callback.apply(this, arguments); // Callback
			el.dequeue();
		}});

	});

};

})(jQuery);
/*!
 * jQuery UI Effects Fade 1.8.23
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Fade
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.fade = function(o) {
	return this.queue(function() {
		var elem = $(this),
			mode = $.effects.setMode(elem, o.options.mode || 'hide');

		elem.animate({ opacity: mode }, {
			queue: false,
			duration: o.duration,
			easing: o.options.easing,
			complete: function() {
				(o.callback && o.callback.apply(this, arguments));
				elem.dequeue();
			}
		});
	});
};

})(jQuery);
/*!
 * jQuery UI Effects Highlight 1.8.23
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Highlight
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.highlight = function(o) {
	return this.queue(function() {
		var elem = $(this),
			props = ['backgroundImage', 'backgroundColor', 'opacity'],
			mode = $.effects.setMode(elem, o.options.mode || 'show'),
			animation = {
				backgroundColor: elem.css('backgroundColor')
			};

		if (mode == 'hide') {
			animation.opacity = 0;
		}

		$.effects.save(elem, props);
		elem
			.show()
			.css({
				backgroundImage: 'none',
				backgroundColor: o.options.color || '#ffff99'
			})
			.animate(animation, {
				queue: false,
				duration: o.duration,
				easing: o.options.easing,
				complete: function() {
					(mode == 'hide' && elem.hide());
					$.effects.restore(elem, props);
					(mode == 'show' && !$.support.opacity && this.style.removeAttribute('filter'));
					(o.callback && o.callback.apply(this, arguments));
					elem.dequeue();
				}
			});
	});
};

})(jQuery);
/*!
 * jQuery UI Effects Pulsate 1.8.23
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Pulsate
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.pulsate = function(o) {
	return this.queue(function() {
		var elem = $(this),
			mode = $.effects.setMode(elem, o.options.mode || 'show'),
			times = ((o.options.times || 5) * 2) - 1,
			duration = o.duration ? o.duration / 2 : $.fx.speeds._default / 2,
			isVisible = elem.is(':visible'),
			animateTo = 0;

		if (!isVisible) {
			elem.css('opacity', 0).show();
			animateTo = 1;
		}

		if ((mode == 'hide' && isVisible) || (mode == 'show' && !isVisible)) {
			times--;
		}

		for (var i = 0; i < times; i++) {
			elem.animate({ opacity: animateTo }, duration, o.options.easing);
			animateTo = (animateTo + 1) % 2;
		}

		elem.animate({ opacity: animateTo }, duration, o.options.easing, function() {
			if (animateTo == 0) {
				elem.hide();
			}
			(o.callback && o.callback.apply(this, arguments));
		});

		elem
			.queue('fx', function() { elem.dequeue(); })
			.dequeue();
	});
};

})(jQuery);
/*!
 * jQuery UI Effects Scale 1.8.23
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Scale
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.puff = function(o) {
	return this.queue(function() {
		var elem = $(this),
			mode = $.effects.setMode(elem, o.options.mode || 'hide'),
			percent = parseInt(o.options.percent, 10) || 150,
			factor = percent / 100,
			original = { height: elem.height(), width: elem.width() };

		$.extend(o.options, {
			fade: true,
			mode: mode,
			percent: mode == 'hide' ? percent : 100,
			from: mode == 'hide'
				? original
				: {
					height: original.height * factor,
					width: original.width * factor
				}
		});

		elem.effect('scale', o.options, o.duration, o.callback);
		elem.dequeue();
	});
};

$.effects.scale = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this);

		// Set options
		var options = $.extend(true, {}, o.options);
		var mode = $.effects.setMode(el, o.options.mode || 'effect'); // Set Mode
		var percent = parseInt(o.options.percent,10) || (parseInt(o.options.percent,10) == 0 ? 0 : (mode == 'hide' ? 0 : 100)); // Set default scaling percent
		var direction = o.options.direction || 'both'; // Set default axis
		var origin = o.options.origin; // The origin of the scaling
		if (mode != 'effect') { // Set default origin and restore for show/hide
			options.origin = origin || ['middle','center'];
			options.restore = true;
		}
		var original = {height: el.height(), width: el.width()}; // Save original
		el.from = o.options.from || (mode == 'show' ? {height: 0, width: 0} : original); // Default from state

		// Adjust
		var factor = { // Set scaling factor
			y: direction != 'horizontal' ? (percent / 100) : 1,
			x: direction != 'vertical' ? (percent / 100) : 1
		};
		el.to = {height: original.height * factor.y, width: original.width * factor.x}; // Set to state

		if (o.options.fade) { // Fade option to support puff
			if (mode == 'show') {el.from.opacity = 0; el.to.opacity = 1;};
			if (mode == 'hide') {el.from.opacity = 1; el.to.opacity = 0;};
		};

		// Animation
		options.from = el.from; options.to = el.to; options.mode = mode;

		// Animate
		el.effect('size', options, o.duration, o.callback);
		el.dequeue();
	});

};

$.effects.size = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this), props = ['position','top','bottom','left','right','width','height','overflow','opacity'];
		var props1 = ['position','top','bottom','left','right','overflow','opacity']; // Always restore
		var props2 = ['width','height','overflow']; // Copy for children
		var cProps = ['fontSize'];
		var vProps = ['borderTopWidth', 'borderBottomWidth', 'paddingTop', 'paddingBottom'];
		var hProps = ['borderLeftWidth', 'borderRightWidth', 'paddingLeft', 'paddingRight'];

		// Set options
		var mode = $.effects.setMode(el, o.options.mode || 'effect'); // Set Mode
		var restore = o.options.restore || false; // Default restore
		var scale = o.options.scale || 'both'; // Default scale mode
		var origin = o.options.origin; // The origin of the sizing
		var original = {height: el.height(), width: el.width()}; // Save original
		el.from = o.options.from || original; // Default from state
		el.to = o.options.to || original; // Default to state
		// Adjust
		if (origin) { // Calculate baseline shifts
			var baseline = $.effects.getBaseline(origin, original);
			el.from.top = (original.height - el.from.height) * baseline.y;
			el.from.left = (original.width - el.from.width) * baseline.x;
			el.to.top = (original.height - el.to.height) * baseline.y;
			el.to.left = (original.width - el.to.width) * baseline.x;
		};
		var factor = { // Set scaling factor
			from: {y: el.from.height / original.height, x: el.from.width / original.width},
			to: {y: el.to.height / original.height, x: el.to.width / original.width}
		};
		if (scale == 'box' || scale == 'both') { // Scale the css box
			if (factor.from.y != factor.to.y) { // Vertical props scaling
				props = props.concat(vProps);
				el.from = $.effects.setTransition(el, vProps, factor.from.y, el.from);
				el.to = $.effects.setTransition(el, vProps, factor.to.y, el.to);
			};
			if (factor.from.x != factor.to.x) { // Horizontal props scaling
				props = props.concat(hProps);
				el.from = $.effects.setTransition(el, hProps, factor.from.x, el.from);
				el.to = $.effects.setTransition(el, hProps, factor.to.x, el.to);
			};
		};
		if (scale == 'content' || scale == 'both') { // Scale the content
			if (factor.from.y != factor.to.y) { // Vertical props scaling
				props = props.concat(cProps);
				el.from = $.effects.setTransition(el, cProps, factor.from.y, el.from);
				el.to = $.effects.setTransition(el, cProps, factor.to.y, el.to);
			};
		};
		$.effects.save(el, restore ? props : props1); el.show(); // Save & Show
		$.effects.createWrapper(el); // Create Wrapper
		el.css('overflow','hidden').css(el.from); // Shift

		// Animate
		if (scale == 'content' || scale == 'both') { // Scale the children
			vProps = vProps.concat(['marginTop','marginBottom']).concat(cProps); // Add margins/font-size
			hProps = hProps.concat(['marginLeft','marginRight']); // Add margins
			props2 = props.concat(vProps).concat(hProps); // Concat
			el.find("*[width]").each(function(){
				var child = $(this);
				if (restore) $.effects.save(child, props2);
				var c_original = {height: child.height(), width: child.width()}; // Save original
				child.from = {height: c_original.height * factor.from.y, width: c_original.width * factor.from.x};
				child.to = {height: c_original.height * factor.to.y, width: c_original.width * factor.to.x};
				if (factor.from.y != factor.to.y) { // Vertical props scaling
					child.from = $.effects.setTransition(child, vProps, factor.from.y, child.from);
					child.to = $.effects.setTransition(child, vProps, factor.to.y, child.to);
				};
				if (factor.from.x != factor.to.x) { // Horizontal props scaling
					child.from = $.effects.setTransition(child, hProps, factor.from.x, child.from);
					child.to = $.effects.setTransition(child, hProps, factor.to.x, child.to);
				};
				child.css(child.from); // Shift children
				child.animate(child.to, o.duration, o.options.easing, function(){
					if (restore) $.effects.restore(child, props2); // Restore children
				}); // Animate children
			});
		};

		// Animate
		el.animate(el.to, { queue: false, duration: o.duration, easing: o.options.easing, complete: function() {
			if (el.to.opacity === 0) {
				el.css('opacity', el.from.opacity);
			}
			if(mode == 'hide') el.hide(); // Hide
			$.effects.restore(el, restore ? props : props1); $.effects.removeWrapper(el); // Restore
			if(o.callback) o.callback.apply(this, arguments); // Callback
			el.dequeue();
		}});

	});

};

})(jQuery);
/*!
 * jQuery UI Effects Shake 1.8.23
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Shake
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.shake = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this), props = ['position','top','bottom','left','right'];

		// Set options
		var mode = $.effects.setMode(el, o.options.mode || 'effect'); // Set Mode
		var direction = o.options.direction || 'left'; // Default direction
		var distance = o.options.distance || 20; // Default distance
		var times = o.options.times || 3; // Default # of times
		var speed = o.duration || o.options.duration || 140; // Default speed per shake

		// Adjust
		$.effects.save(el, props); el.show(); // Save & Show
		$.effects.createWrapper(el); // Create Wrapper
		var ref = (direction == 'up' || direction == 'down') ? 'top' : 'left';
		var motion = (direction == 'up' || direction == 'left') ? 'pos' : 'neg';

		// Animation
		var animation = {}, animation1 = {}, animation2 = {};
		animation[ref] = (motion == 'pos' ? '-=' : '+=')  + distance;
		animation1[ref] = (motion == 'pos' ? '+=' : '-=')  + distance * 2;
		animation2[ref] = (motion == 'pos' ? '-=' : '+=')  + distance * 2;

		// Animate
		el.animate(animation, speed, o.options.easing);
		for (var i = 1; i < times; i++) { // Shakes
			el.animate(animation1, speed, o.options.easing).animate(animation2, speed, o.options.easing);
		};
		el.animate(animation1, speed, o.options.easing).
		animate(animation, speed / 2, o.options.easing, function(){ // Last shake
			$.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
			if(o.callback) o.callback.apply(this, arguments); // Callback
		});
		el.queue('fx', function() { el.dequeue(); });
		el.dequeue();
	});

};

})(jQuery);
/*!
 * jQuery UI Effects Slide 1.8.23
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Slide
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.slide = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this), props = ['position','top','bottom','left','right'];

		// Set options
		var mode = $.effects.setMode(el, o.options.mode || 'show'); // Set Mode
		var direction = o.options.direction || 'left'; // Default Direction

		// Adjust
		$.effects.save(el, props); el.show(); // Save & Show
		$.effects.createWrapper(el).css({overflow:'hidden'}); // Create Wrapper
		var ref = (direction == 'up' || direction == 'down') ? 'top' : 'left';
		var motion = (direction == 'up' || direction == 'left') ? 'pos' : 'neg';
		var distance = o.options.distance || (ref == 'top' ? el.outerHeight( true ) : el.outerWidth( true ));
		if (mode == 'show') el.css(ref, motion == 'pos' ? (isNaN(distance) ? "-" + distance : -distance) : distance); // Shift

		// Animation
		var animation = {};
		animation[ref] = (mode == 'show' ? (motion == 'pos' ? '+=' : '-=') : (motion == 'pos' ? '-=' : '+=')) + distance;

		// Animate
		el.animate(animation, { queue: false, duration: o.duration, easing: o.options.easing, complete: function() {
			if(mode == 'hide') el.hide(); // Hide
			$.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
			if(o.callback) o.callback.apply(this, arguments); // Callback
			el.dequeue();
		}});

	});

};

})(jQuery);
/*!
 * jQuery UI Effects Transfer 1.8.23
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Transfer
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.transfer = function(o) {
	return this.queue(function() {
		var elem = $(this),
			target = $(o.options.to),
			endPosition = target.offset(),
			animation = {
				top: endPosition.top,
				left: endPosition.left,
				height: target.innerHeight(),
				width: target.innerWidth()
			},
			startPosition = elem.offset(),
			transfer = $('<div class="ui-effects-transfer"></div>')
				.appendTo(document.body)
				.addClass(o.options.className)
				.css({
					top: startPosition.top,
					left: startPosition.left,
					height: elem.innerHeight(),
					width: elem.innerWidth(),
					position: 'absolute'
				})
				.animate(animation, o.duration, o.options.easing, function() {
					transfer.remove();
					(o.callback && o.callback.apply(elem[0], arguments));
					elem.dequeue();
				});
	});
};

})(jQuery);

}.call(window));

/***/ }),

/***/ 2981:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
// Our usage of lodash vastly predates our use of JS modules (and webpack/babel). As such,
// a large number of older JS files assume that _ is always present on the root object (window).
// Additionally, due to a particular customer injecting an old version of underscore, we have
// to do some extra workarounds.

window._ = lodash__WEBPACK_IMPORTED_MODULE_0___default.a;
window.socrataLodash = lodash__WEBPACK_IMPORTED_MODULE_0___default.a;

/***/ }),

/***/ 2982:
/***/ (function(module, exports) {

/*** IMPORTS FROM imports-loader ***/
var define = undefined;
var require = undefined;
var module = undefined;
var exports = undefined;
(function() {

/*
 * CAUTION: This file (and everything in this directory) is marked as noParse
 * in our Webpack configuration. This means it cannot import modules, and that
 * it will not be transpiled to ES5. Do *NOT* use any ES6 features that our
 * supported browsers don't support natively (i.e., IE11 does not support arrow
 * functions).
 */

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

var hookCallback;

function hooks () {
    return hookCallback.apply(null, arguments);
}

// This is done to register the method called with moment()
// without creating circular dependencies.
function setHookCallback (callback) {
    hookCallback = callback;
}

function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
}

function isObject(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return input != null && Object.prototype.toString.call(input) === '[object Object]';
}

function isObjectEmpty(obj) {
    var k;
    for (k in obj) {
        // even if its not own property I'd still call it non-empty
        return false;
    }
    return true;
}

function isUndefined(input) {
    return input === void 0;
}

function isNumber(input) {
    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
}

function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
}

function map(arr, fn) {
    var res = [], i;
    for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
    }
    return res;
}

function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
}

function extend(a, b) {
    for (var i in b) {
        if (hasOwnProp(b, i)) {
            a[i] = b[i];
        }
    }

    if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
    }

    if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
    }

    return a;
}

function createUTC (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
}

function defaultParsingFlags() {
    // We need to deep clone this object.
    return {
        empty           : false,
        unusedTokens    : [],
        unusedInput     : [],
        overflow        : -2,
        charsLeftOver   : 0,
        nullInput       : false,
        invalidMonth    : null,
        invalidFormat   : false,
        userInvalidated : false,
        iso             : false,
        parsedDateParts : [],
        meridiem        : null,
        rfc2822         : false,
        weekdayMismatch : false
    };
}

function getParsingFlags(m) {
    if (m._pf == null) {
        m._pf = defaultParsingFlags();
    }
    return m._pf;
}

var some;
if (Array.prototype.some) {
    some = Array.prototype.some;
} else {
    some = function (fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
                return true;
            }
        }

        return false;
    };
}

var some$1 = some;

function isValid(m) {
    if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some$1.call(flags.parsedDateParts, function (i) {
            return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) &&
            flags.overflow < 0 &&
            !flags.empty &&
            !flags.invalidMonth &&
            !flags.invalidWeekday &&
            !flags.nullInput &&
            !flags.invalidFormat &&
            !flags.userInvalidated &&
            (!flags.meridiem || (flags.meridiem && parsedParts));

        if (m._strict) {
            isNowValid = isNowValid &&
                flags.charsLeftOver === 0 &&
                flags.unusedTokens.length === 0 &&
                flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
        }
        else {
            return isNowValid;
        }
    }
    return m._isValid;
}

function createInvalid (flags) {
    var m = createUTC(NaN);
    if (flags != null) {
        extend(getParsingFlags(m), flags);
    }
    else {
        getParsingFlags(m).userInvalidated = true;
    }

    return m;
}

// Plugins that add properties should also add the key here (null value),
// so we can properly clone ourselves.
var momentProperties = hooks.momentProperties = [];

function copyConfig(to, from) {
    var i, prop, val;

    if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
    }
    if (!isUndefined(from._i)) {
        to._i = from._i;
    }
    if (!isUndefined(from._f)) {
        to._f = from._f;
    }
    if (!isUndefined(from._l)) {
        to._l = from._l;
    }
    if (!isUndefined(from._strict)) {
        to._strict = from._strict;
    }
    if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
    }
    if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
    }
    if (!isUndefined(from._offset)) {
        to._offset = from._offset;
    }
    if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
    }
    if (!isUndefined(from._locale)) {
        to._locale = from._locale;
    }

    if (momentProperties.length > 0) {
        for (i = 0; i < momentProperties.length; i++) {
            prop = momentProperties[i];
            val = from[prop];
            if (!isUndefined(val)) {
                to[prop] = val;
            }
        }
    }

    return to;
}

var updateInProgress = false;

// Moment prototype object
function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (!this.isValid()) {
        this._d = new Date(NaN);
    }
    // Prevent infinite loop in case updateOffset creates new moment
    // objects.
    if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
    }
}

function isMoment (obj) {
    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
}

function absFloor (number) {
    if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
    } else {
        return Math.floor(number);
    }
}

function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
        value = 0;

    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
    }

    return value;
}

// compare two arrays, return the number of differences
function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0,
        i;
    for (i = 0; i < len; i++) {
        if ((dontConvert && array1[i] !== array2[i]) ||
            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
            diffs++;
        }
    }
    return diffs + lengthDiff;
}

function warn(msg) {
    if (hooks.suppressDeprecationWarnings === false &&
            (typeof console !==  'undefined') && console.warn) {
        console.warn('Deprecation warning: ' + msg);
    }
}

function deprecate(msg, fn) {
    var firstTime = true;

    return extend(function () {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
            var args = [];
            var arg;
            for (var i = 0; i < arguments.length; i++) {
                arg = '';
                if (typeof arguments[i] === 'object') {
                    arg += '\n[' + i + '] ';
                    for (var key in arguments[0]) {
                        arg += key + ': ' + arguments[0][key] + ', ';
                    }
                    arg = arg.slice(0, -2); // Remove trailing comma and space
                } else {
                    arg = arguments[i];
                }
                args.push(arg);
            }
            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
            firstTime = false;
        }
        return fn.apply(this, arguments);
    }, fn);
}

var deprecations = {};

function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
    }
}

hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;

function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
}

function set (config) {
    var prop, i;
    for (i in config) {
        prop = config[i];
        if (isFunction(prop)) {
            this[i] = prop;
        } else {
            this['_' + i] = prop;
        }
    }
    this._config = config;
    // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
    // TODO: Remove "ordinalParse" fallback in next major release.
    this._dayOfMonthOrdinalParseLenient = new RegExp(
        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
            '|' + (/\d{1,2}/).source);
}

function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig), prop;
    for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
            } else {
                delete res[prop];
            }
        }
    }
    for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])) {
            // make sure changes to properties don't modify parent config
            res[prop] = extend({}, res[prop]);
        }
    }
    return res;
}

function Locale(config) {
    if (config != null) {
        this.set(config);
    }
}

var keys;

if (Object.keys) {
    keys = Object.keys;
} else {
    keys = function (obj) {
        var i, res = [];
        for (i in obj) {
            if (hasOwnProp(obj, i)) {
                res.push(i);
            }
        }
        return res;
    };
}

var keys$1 = keys;

var defaultCalendar = {
    sameDay : '[Today at] LT',
    nextDay : '[Tomorrow at] LT',
    nextWeek : 'dddd [at] LT',
    lastDay : '[Yesterday at] LT',
    lastWeek : '[Last] dddd [at] LT',
    sameElse : 'L'
};

function calendar (key, mom, now) {
    var output = this._calendar[key] || this._calendar['sameElse'];
    return isFunction(output) ? output.call(mom, now) : output;
}

var defaultLongDateFormat = {
    LTS  : 'h:mm:ss A',
    LT   : 'h:mm A',
    L    : 'MM/DD/YYYY',
    LL   : 'MMMM D, YYYY',
    LLL  : 'MMMM D, YYYY h:mm A',
    LLLL : 'dddd, MMMM D, YYYY h:mm A'
};

function longDateFormat (key) {
    var format = this._longDateFormat[key],
        formatUpper = this._longDateFormat[key.toUpperCase()];

    if (format || !formatUpper) {
        return format;
    }

    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
    });

    return this._longDateFormat[key];
}

var defaultInvalidDate = 'Invalid date';

function invalidDate () {
    return this._invalidDate;
}

var defaultOrdinal = '%d';
var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

function ordinal (number) {
    return this._ordinal.replace('%d', number);
}

var defaultRelativeTime = {
    future : 'in %s',
    past   : '%s ago',
    s  : 'a few seconds',
    ss : '%d seconds',
    m  : 'a minute',
    mm : '%d minutes',
    h  : 'an hour',
    hh : '%d hours',
    d  : 'a day',
    dd : '%d days',
    M  : 'a month',
    MM : '%d months',
    y  : 'a year',
    yy : '%d years'
};

function relativeTime (number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return (isFunction(output)) ?
        output(number, withoutSuffix, string, isFuture) :
        output.replace(/%d/i, number);
}

function pastFuture (diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
}

var aliases = {};

function addUnitAlias (unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
}

function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
}

function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
        normalizedProp,
        prop;

    for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
            }
        }
    }

    return normalizedInput;
}

var priorities = {};

function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
}

function getPrioritizedUnits(unitsObj) {
    var units = [];
    for (var u in unitsObj) {
        units.push({unit: u, priority: priorities[u]});
    }
    units.sort(function (a, b) {
        return a.priority - b.priority;
    });
    return units;
}

function makeGetSet (unit, keepTime) {
    return function (value) {
        if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
        } else {
            return get(this, unit);
        }
    };
}

function get (mom, unit) {
    return mom.isValid() ?
        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
}

function set$1 (mom, unit, value) {
    if (mom.isValid()) {
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
    }
}

// MOMENTS

function stringGet (units) {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
        return this[units]();
    }
    return this;
}


function stringSet (units, value) {
    if (typeof units === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);
        for (var i = 0; i < prioritized.length; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
        }
    } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units](value);
        }
    }
    return this;
}

function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length,
        sign = number >= 0;
    return (sign ? (forceSign ? '+' : '') : '-') +
        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}

var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

var formatFunctions = {};

var formatTokenFunctions = {};

// token:    'M'
// padded:   ['MM', 2]
// ordinal:  'Mo'
// callback: function () { this.month() + 1 }
function addFormatToken (token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === 'string') {
        func = function () {
            return this[callback]();
        };
    }
    if (token) {
        formatTokenFunctions[token] = func;
    }
    if (padded) {
        formatTokenFunctions[padded[0]] = function () {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
    }
    if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
            return this.localeData().ordinal(func.apply(this, arguments), token);
        };
    }
}

function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
    }
    return input.replace(/\\/g, '');
}

function makeFormatFunction(format) {
    var array = format.match(formattingTokens), i, length;

    for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
        } else {
            array[i] = removeFormattingTokens(array[i]);
        }
    }

    return function (mom) {
        var output = '', i;
        for (i = 0; i < length; i++) {
            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
        }
        return output;
    };
}

// format date using native date object
function formatMoment(m, format) {
    if (!m.isValid()) {
        return m.localeData().invalidDate();
    }

    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

    return formatFunctions[format](m);
}

function expandFormat(format, locale) {
    var i = 5;

    function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
    }

    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
    }

    return format;
}

var match1         = /\d/;            //       0 - 9
var match2         = /\d\d/;          //      00 - 99
var match3         = /\d{3}/;         //     000 - 999
var match4         = /\d{4}/;         //    0000 - 9999
var match6         = /[+-]?\d{6}/;    // -999999 - 999999
var match1to2      = /\d\d?/;         //       0 - 99
var match3to4      = /\d\d\d\d?/;     //     999 - 9999
var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
var match1to3      = /\d{1,3}/;       //       0 - 999
var match1to4      = /\d{1,4}/;       //       0 - 9999
var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

var matchUnsigned  = /\d+/;           //       0 - inf
var matchSigned    = /[+-]?\d+/;      //    -inf - inf

var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

// any word (or two) characters or numbers including two/three word month in arabic.
// includes scottish gaelic two word and hyphenated months
var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


var regexes = {};

function addRegexToken (token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return (isStrict && strictRegex) ? strictRegex : regex;
    };
}

function getParseRegexForToken (token, config) {
    if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
    }

    return regexes[token](config._strict, config._locale);
}

// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
    }));
}

function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}

var tokens = {};

function addParseToken (token, callback) {
    var i, func = callback;
    if (typeof token === 'string') {
        token = [token];
    }
    if (isNumber(callback)) {
        func = function (input, array) {
            array[callback] = toInt(input);
        };
    }
    for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
    }
}

function addWeekParseToken (token, callback) {
    addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
    });
}

function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
    }
}

var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;

var indexOf;

if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
} else {
    indexOf = function (o) {
        // I know
        var i;
        for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
                return i;
            }
        }
        return -1;
    };
}

var indexOf$1 = indexOf;

function daysInMonth(year, month) {
    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
}

// FORMATTING

addFormatToken('M', ['MM', 2], 'Mo', function () {
    return this.month() + 1;
});

addFormatToken('MMM', 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
});

addFormatToken('MMMM', 0, 0, function (format) {
    return this.localeData().months(this, format);
});

// ALIASES

addUnitAlias('month', 'M');

// PRIORITY

addUnitPriority('month', 8);

// PARSING

addRegexToken('M',    match1to2);
addRegexToken('MM',   match1to2, match2);
addRegexToken('MMM',  function (isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
});
addRegexToken('MMMM', function (isStrict, locale) {
    return locale.monthsRegex(isStrict);
});

addParseToken(['M', 'MM'], function (input, array) {
    array[MONTH] = toInt(input) - 1;
});

addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    // if we didn't find a month name, mark the date as invalid.
    if (month != null) {
        array[MONTH] = month;
    } else {
        getParsingFlags(config).invalidMonth = input;
    }
});

// LOCALES

var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
function localeMonths (m, format) {
    if (!m) {
        return isArray(this._months) ? this._months :
            this._months['standalone'];
    }
    return isArray(this._months) ? this._months[m.month()] :
        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
}

var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
function localeMonthsShort (m, format) {
    if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort :
            this._monthsShort['standalone'];
    }
    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
}

function handleStrictParse(monthName, format, strict) {
    var i, ii, mom, llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
            mom = createUTC([2000, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'MMM') {
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'MMM') {
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._longMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeMonthsParse (monthName, format, strict) {
    var i, mom, regex;

    if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
    }

    if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
    }

    // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }
        if (!strict && !this._monthsParse[i]) {
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
            return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
            return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
        }
    }
}

// MOMENTS

function setMonth (mom, value) {
    var dayOfMonth;

    if (!mom.isValid()) {
        // No op
        return mom;
    }

    if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
            value = toInt(value);
        } else {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (!isNumber(value)) {
                return mom;
            }
        }
    }

    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
}

function getSetMonth (value) {
    if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
    } else {
        return get(this, 'Month');
    }
}

function getDaysInMonth () {
    return daysInMonth(this.year(), this.month());
}

var defaultMonthsShortRegex = matchWord;
function monthsShortRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsShortStrictRegex;
        } else {
            return this._monthsShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
            this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ?
            this._monthsShortStrictRegex : this._monthsShortRegex;
    }
}

var defaultMonthsRegex = matchWord;
function monthsRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsStrictRegex;
        } else {
            return this._monthsRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
            this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ?
            this._monthsStrictRegex : this._monthsRegex;
    }
}

function computeMonthsParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom;
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
    }
    // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
}

// FORMATTING

addFormatToken('Y', 0, 0, function () {
    var y = this.year();
    return y <= 9999 ? '' + y : '+' + y;
});

addFormatToken(0, ['YY', 2], 0, function () {
    return this.year() % 100;
});

addFormatToken(0, ['YYYY',   4],       0, 'year');
addFormatToken(0, ['YYYYY',  5],       0, 'year');
addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

// ALIASES

addUnitAlias('year', 'y');

// PRIORITIES

addUnitPriority('year', 1);

// PARSING

addRegexToken('Y',      matchSigned);
addRegexToken('YY',     match1to2, match2);
addRegexToken('YYYY',   match1to4, match4);
addRegexToken('YYYYY',  match1to6, match6);
addRegexToken('YYYYYY', match1to6, match6);

addParseToken(['YYYYY', 'YYYYYY'], YEAR);
addParseToken('YYYY', function (input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken('YY', function (input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken('Y', function (input, array) {
    array[YEAR] = parseInt(input, 10);
});

// HELPERS

function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
}

function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
}

// HOOKS

hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
};

// MOMENTS

var getSetYear = makeGetSet('FullYear', true);

function getIsLeapYear () {
    return isLeapYear(this.year());
}

function createDate (y, m, d, h, M, s, ms) {
    // can't just apply() to create a date:
    // https://stackoverflow.com/q/181348
    var date = new Date(y, m, d, h, M, s, ms);

    // the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
        date.setFullYear(y);
    }
    return date;
}

function createUTCDate (y) {
    var date = new Date(Date.UTC.apply(null, arguments));

    // the Date.UTC function remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y);
    }
    return date;
}

// start-of-first-week - start-of-year
function firstWeekOffset(year, dow, doy) {
    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
        fwd = 7 + dow - doy,
        // first-week day local weekday -- which local weekday is fwd
        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

    return -fwdlw + fwd - 1;
}

// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
        weekOffset = firstWeekOffset(year, dow, doy),
        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
        resYear, resDayOfYear;

    if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
    } else {
        resYear = year;
        resDayOfYear = dayOfYear;
    }

    return {
        year: resYear,
        dayOfYear: resDayOfYear
    };
}

function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
        resWeek, resYear;

    if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
    } else {
        resYear = mom.year();
        resWeek = week;
    }

    return {
        week: resWeek,
        year: resYear
    };
}

function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}

// FORMATTING

addFormatToken('w', ['ww', 2], 'wo', 'week');
addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

// ALIASES

addUnitAlias('week', 'w');
addUnitAlias('isoWeek', 'W');

// PRIORITIES

addUnitPriority('week', 5);
addUnitPriority('isoWeek', 5);

// PARSING

addRegexToken('w',  match1to2);
addRegexToken('ww', match1to2, match2);
addRegexToken('W',  match1to2);
addRegexToken('WW', match1to2, match2);

addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
});

// HELPERS

// LOCALES

function localeWeek (mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
}

var defaultLocaleWeek = {
    dow : 0, // Sunday is the first day of the week.
    doy : 6  // The week that contains Jan 1st is the first week of the year.
};

function localeFirstDayOfWeek () {
    return this._week.dow;
}

function localeFirstDayOfYear () {
    return this._week.doy;
}

// MOMENTS

function getSetWeek (input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
}

function getSetISOWeek (input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
}

// FORMATTING

addFormatToken('d', 0, 'do', 'day');

addFormatToken('dd', 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
});

addFormatToken('ddd', 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
});

addFormatToken('dddd', 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
});

addFormatToken('e', 0, 0, 'weekday');
addFormatToken('E', 0, 0, 'isoWeekday');

// ALIASES

addUnitAlias('day', 'd');
addUnitAlias('weekday', 'e');
addUnitAlias('isoWeekday', 'E');

// PRIORITY
addUnitPriority('day', 11);
addUnitPriority('weekday', 11);
addUnitPriority('isoWeekday', 11);

// PARSING

addRegexToken('d',    match1to2);
addRegexToken('e',    match1to2);
addRegexToken('E',    match1to2);
addRegexToken('dd',   function (isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
});
addRegexToken('ddd',   function (isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
});
addRegexToken('dddd',   function (isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
});

addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    // if we didn't get a weekday name, mark the date as invalid
    if (weekday != null) {
        week.d = weekday;
    } else {
        getParsingFlags(config).invalidWeekday = input;
    }
});

addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
    week[token] = toInt(input);
});

// HELPERS

function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
        return input;
    }

    if (!isNaN(input)) {
        return parseInt(input, 10);
    }

    input = locale.weekdaysParse(input);
    if (typeof input === 'number') {
        return input;
    }

    return null;
}

function parseIsoWeekday(input, locale) {
    if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
}

// LOCALES

var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
function localeWeekdays (m, format) {
    if (!m) {
        return isArray(this._weekdays) ? this._weekdays :
            this._weekdays['standalone'];
    }
    return isArray(this._weekdays) ? this._weekdays[m.day()] :
        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
}

var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
function localeWeekdaysShort (m) {
    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}

var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
function localeWeekdaysMin (m) {
    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}

function handleStrictParse$1(weekdayName, format, strict) {
    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
            mom = createUTC([2000, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'dddd') {
            ii = indexOf$1.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'dddd') {
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeWeekdaysParse (weekdayName, format, strict) {
    var i, mom, regex;

    if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
    }

    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
    }

    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already

        mom = createUTC([2000, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
        }
        if (!this._weekdaysParse[i]) {
            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
        }
    }
}

// MOMENTS

function getSetDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
    } else {
        return day;
    }
}

function getSetLocaleDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
}

function getSetISODayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }

    // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.

    if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
        return this.day() || 7;
    }
}

var defaultWeekdaysRegex = matchWord;
function weekdaysRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysStrictRegex;
        } else {
            return this._weekdaysRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ?
            this._weekdaysStrictRegex : this._weekdaysRegex;
    }
}

var defaultWeekdaysShortRegex = matchWord;
function weekdaysShortRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysShortStrictRegex;
        } else {
            return this._weekdaysShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ?
            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
}

var defaultWeekdaysMinRegex = matchWord;
function weekdaysMinRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysMinStrictRegex;
        } else {
            return this._weekdaysMinRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ?
            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
}


function computeWeekdaysParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom, minp, shortp, longp;
    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
    }
    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
    // will match the longer piece.
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;

    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
}

// FORMATTING

function hFormat() {
    return this.hours() % 12 || 12;
}

function kFormat() {
    return this.hours() || 24;
}

addFormatToken('H', ['HH', 2], 0, 'hour');
addFormatToken('h', ['hh', 2], 0, hFormat);
addFormatToken('k', ['kk', 2], 0, kFormat);

addFormatToken('hmm', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});

addFormatToken('hmmss', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

addFormatToken('Hmm', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
});

addFormatToken('Hmmss', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

function meridiem (token, lowercase) {
    addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
}

meridiem('a', true);
meridiem('A', false);

// ALIASES

addUnitAlias('hour', 'h');

// PRIORITY
addUnitPriority('hour', 13);

// PARSING

function matchMeridiem (isStrict, locale) {
    return locale._meridiemParse;
}

addRegexToken('a',  matchMeridiem);
addRegexToken('A',  matchMeridiem);
addRegexToken('H',  match1to2);
addRegexToken('h',  match1to2);
addRegexToken('k',  match1to2);
addRegexToken('HH', match1to2, match2);
addRegexToken('hh', match1to2, match2);
addRegexToken('kk', match1to2, match2);

addRegexToken('hmm', match3to4);
addRegexToken('hmmss', match5to6);
addRegexToken('Hmm', match3to4);
addRegexToken('Hmmss', match5to6);

addParseToken(['H', 'HH'], HOUR);
addParseToken(['k', 'kk'], function (input, array, config) {
    var kInput = toInt(input);
    array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(['a', 'A'], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
});
addParseToken(['h', 'hh'], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
});
addParseToken('Hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
});
addParseToken('Hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
});

// LOCALES

function localeIsPM (input) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return ((input + '').toLowerCase().charAt(0) === 'p');
}

var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
function localeMeridiem (hours, minutes, isLower) {
    if (hours > 11) {
        return isLower ? 'pm' : 'PM';
    } else {
        return isLower ? 'am' : 'AM';
    }
}


// MOMENTS

// Setting the hour should keep the time, because the user explicitly
// specified which hour he wants. So trying to maintain the same hour (in
// a new timezone) makes sense. Adding/subtracting hours does not follow
// this rule.
var getSetHour = makeGetSet('Hours', true);

// months
// week
// weekdays
// meridiem
var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
    relativeTime: defaultRelativeTime,

    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,

    week: defaultLocaleWeek,

    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,

    meridiemParse: defaultLocaleMeridiemParse
};

// internal storage for locale config files
var locales = {};
var localeFamilies = {};
var globalLocale;

function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
}

// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function chooseLocale(names) {
    var i = 0, j, next, locale, split;

    while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;
        while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));
            if (locale) {
                return locale;
            }
            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                //the next array item is better than a shallower substring of this one
                break;
            }
            j--;
        }
        i++;
    }
    return null;
}

function loadLocale(name) {
    var oldLocale = null;
    // TODO: Find a better way to register and load all the locales in Node
    if (!locales[name] && (typeof module !== 'undefined') &&
            module && module.exports) {
        try {
            oldLocale = globalLocale._abbr;
            require('./locale/' + name);
            // because defineLocale currently also sets the global locale, we
            // want to undo that for lazy loaded locales
            getSetGlobalLocale(oldLocale);
        } catch (e) { }
    }
    return locales[name];
}

// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
function getSetGlobalLocale (key, values) {
    var data;
    if (key) {
        if (isUndefined(values)) {
            data = getLocale(key);
        }
        else {
            data = defineLocale(key, values);
        }

        if (data) {
            // moment.duration._locale = moment._locale = data;
            globalLocale = data;
        }
    }

    return globalLocale._abbr;
}

function defineLocale (name, config) {
    if (config !== null) {
        var parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
            deprecateSimple('defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                    'an existing locale. moment.defineLocale(localeName, ' +
                    'config) should only be used for creating a new locale ' +
                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
            parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
            } else {
                if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                    name: name,
                    config: config
                });
                return null;
            }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
            localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
            });
        }

        // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.
        getSetGlobalLocale(name);


        return locales[name];
    } else {
        // useful for testing
        delete locales[name];
        return null;
    }
}

function updateLocale(name, config) {
    if (config != null) {
        var locale, parentConfig = baseConfig;
        // MERGE
        if (locales[name] != null) {
            parentConfig = locales[name]._config;
        }
        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale;

        // backwards compat for now: also set the locale
        getSetGlobalLocale(name);
    } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
            } else if (locales[name] != null) {
                delete locales[name];
            }
        }
    }
    return locales[name];
}

// returns locale data
function getLocale (key) {
    var locale;

    if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
    }

    if (!key) {
        return globalLocale;
    }

    if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);
        if (locale) {
            return locale;
        }
        key = [key];
    }

    return chooseLocale(key);
}

function listLocales() {
    return keys$1(locales);
}

function checkOverflow (m) {
    var overflow;
    var a = m._a;

    if (a && getParsingFlags(m).overflow === -2) {
        overflow =
            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
            -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
    }

    return m;
}

// iso 8601 regex
// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

var isoDates = [
    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
    ['YYYY-DDD', /\d{4}-\d{3}/],
    ['YYYY-MM', /\d{4}-\d\d/, false],
    ['YYYYYYMMDD', /[+-]\d{10}/],
    ['YYYYMMDD', /\d{8}/],
    // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/],
    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
    ['YYYYDDD', /\d{7}/]
];

// iso time formats and regexes
var isoTimes = [
    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
    ['HH:mm', /\d\d:\d\d/],
    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
    ['HHmmss', /\d\d\d\d\d\d/],
    ['HHmm', /\d\d\d\d/],
    ['HH', /\d\d/]
];

var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

// date from iso format
function configFromISO(config) {
    var i, l,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
        allowTime, dateFormat, timeFormat, tzFormat;

    if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
            }
        }
        if (dateFormat == null) {
            config._isValid = false;
            return;
        }
        if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                    // match[2] should be 'T' or space
                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (timeFormat == null) {
                config._isValid = false;
                return;
            }
        }
        if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
        }
        if (match[4]) {
            if (tzRegex.exec(match[4])) {
                tzFormat = 'Z';
            } else {
                config._isValid = false;
                return;
            }
        }
        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
    } else {
        config._isValid = false;
    }
}

// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
var basicRfcRegex = /^((?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d?\d\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(?:\d\d)?\d\d\s)(\d\d:\d\d)(\:\d\d)?(\s(?:UT|GMT|[ECMP][SD]T|[A-IK-Za-ik-z]|[+-]\d{4}))$/;

// date and time from ref 2822 format
function configFromRFC2822(config) {
    var string, match, dayFormat,
        dateFormat, timeFormat, tzFormat;
    var timezones = {
        ' GMT': ' +0000',
        ' EDT': ' -0400',
        ' EST': ' -0500',
        ' CDT': ' -0500',
        ' CST': ' -0600',
        ' MDT': ' -0600',
        ' MST': ' -0700',
        ' PDT': ' -0700',
        ' PST': ' -0800'
    };
    var military = 'YXWVUTSRQPONZABCDEFGHIKLM';
    var timezone, timezoneIndex;

    string = config._i
        .replace(/\([^\)]*\)|[\n\t]/g, ' ') // Remove comments and folding whitespace
        .replace(/(\s\s+)/g, ' ') // Replace multiple-spaces with a single space
        .replace(/^\s|\s$/g, ''); // Remove leading and trailing spaces
    match = basicRfcRegex.exec(string);

    if (match) {
        dayFormat = match[1] ? 'ddd' + ((match[1].length === 5) ? ', ' : ' ') : '';
        dateFormat = 'D MMM ' + ((match[2].length > 10) ? 'YYYY ' : 'YY ');
        timeFormat = 'HH:mm' + (match[4] ? ':ss' : '');

        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
        if (match[1]) { // day of week given
            var momentDate = new Date(match[2]);
            var momentDay = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][momentDate.getDay()];

            if (match[1].substr(0,3) !== momentDay) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return;
            }
        }

        switch (match[5].length) {
            case 2: // military
                if (timezoneIndex === 0) {
                    timezone = ' +0000';
                } else {
                    timezoneIndex = military.indexOf(match[5][1].toUpperCase()) - 12;
                    timezone = ((timezoneIndex < 0) ? ' -' : ' +') +
                        (('' + timezoneIndex).replace(/^-?/, '0')).match(/..$/)[0] + '00';
                }
                break;
            case 4: // Zone
                timezone = timezones[match[5]];
                break;
            default: // UT or +/-9999
                timezone = timezones[' GMT'];
        }
        match[5] = timezone;
        config._i = match.splice(1).join('');
        tzFormat = ' ZZ';
        config._f = dayFormat + dateFormat + timeFormat + tzFormat;
        configFromStringAndFormat(config);
        getParsingFlags(config).rfc2822 = true;
    } else {
        config._isValid = false;
    }
}

// date from iso format or fallback
function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);

    if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
    }

    configFromISO(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    configFromRFC2822(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    // Final attempt, use Input Fallback
    hooks.createFromInputFallback(config);
}

hooks.createFromInputFallback = deprecate(
    'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
    'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
    'discouraged and will be removed in an upcoming major release. Please refer to ' +
    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
    function (config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }
);

// Pick the first defined of two or three arguments.
function defaults(a, b, c) {
    if (a != null) {
        return a;
    }
    if (b != null) {
        return b;
    }
    return c;
}

function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(hooks.now());
    if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}

// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
function configFromArray (config) {
    var i, date, input = [], currentDate, yearToUse;

    if (config._d) {
        return;
    }

    currentDate = currentDateArray(config);

    //compute day of the year from weeks and weekdays
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
    }

    //if the day of the year is set, figure out what it is
    if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
    }

    // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
    }

    // Zero out whatever was not defaulted, including time
    for (; i < 7; i++) {
        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
    }

    // Check for 24:00:00.000
    if (config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
    }

    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.
    if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }

    if (config._nextDay) {
        config._a[HOUR] = 24;
    }
}

function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;

        // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
        if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
        }
    } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;

        var curWeek = weekOfYear(createLocal(), dow, doy);

        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

        // Default to current week.
        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
            // weekday -- low day numbers are considered next week
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
            }
        } else if (w.e != null) {
            // local weekday -- counting starts from begining of week
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
            }
        } else {
            // default to begining of week
            weekday = dow;
        }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
    } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
}

// constant that refers to the ISO standard
hooks.ISO_8601 = function () {};

// constant that refers to the RFC 2822 form
hooks.RFC_2822 = function () {};

// date from string and format string
function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
    }
    if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
    }
    config._a = [];
    getParsingFlags(config).empty = true;

    // This array is used to make a Date, either with `new Date` or `Date.UTC`
    var string = '' + config._i,
        i, parsedInput, tokens, token, skipped,
        stringLength = string.length,
        totalParsedInputLength = 0;

    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

    for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
        // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));
        if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
        }
        // don't parse if it's not a known token
        if (formatTokenFunctions[token]) {
            if (parsedInput) {
                getParsingFlags(config).empty = false;
            }
            else {
                getParsingFlags(config).unusedTokens.push(token);
            }
            addTimeToArrayFromToken(token, parsedInput, config);
        }
        else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token);
        }
    }

    // add remaining unparsed input length to the string
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
    }

    // clear _12h flag if hour is <= 12
    if (config._a[HOUR] <= 12 &&
        getParsingFlags(config).bigHour === true &&
        config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
    }

    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    // handle meridiem
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

    configFromArray(config);
    checkOverflow(config);
}


function meridiemFixWrap (locale, hour, meridiem) {
    var isPm;

    if (meridiem == null) {
        // nothing to do
        return hour;
    }
    if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);
        if (isPm && hour < 12) {
            hour += 12;
        }
        if (!isPm && hour === 12) {
            hour = 0;
        }
        return hour;
    } else {
        // this is not supposed to happen
        return hour;
    }
}

// date from string and array of format strings
function configFromStringAndArray(config) {
    var tempConfig,
        bestMoment,

        scoreToBeat,
        i,
        currentScore;

    if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
    }

    for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
            continue;
        }

        // if there is any input that was not parsed add a penalty for that format
        currentScore += getParsingFlags(tempConfig).charsLeftOver;

        //or tokens
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
        }
    }

    extend(config, bestMoment || tempConfig);
}

function configFromObject(config) {
    if (config._d) {
        return;
    }

    var i = normalizeObjectUnits(config._i);
    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
    });

    configFromArray(config);
}

function createFromConfig (config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
    }

    return res;
}

function prepareConfig (config) {
    var input = config._i,
        format = config._f;

    config._locale = config._locale || getLocale(config._l);

    if (input === null || (format === undefined && input === '')) {
        return createInvalid({nullInput: true});
    }

    if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
    }

    if (isMoment(input)) {
        return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
        config._d = input;
    } else if (isArray(format)) {
        configFromStringAndArray(config);
    } else if (format) {
        configFromStringAndFormat(config);
    }  else {
        configFromInput(config);
    }

    if (!isValid(config)) {
        config._d = null;
    }

    return config;
}

function configFromInput(config) {
    var input = config._i;
    if (isUndefined(input)) {
        config._d = new Date(hooks.now());
    } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
        configFromString(config);
    } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
            return parseInt(obj, 10);
        });
        configFromArray(config);
    } else if (isObject(input)) {
        configFromObject(config);
    } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
    } else {
        hooks.createFromInputFallback(config);
    }
}

function createLocalOrUTC (input, format, locale, strict, isUTC) {
    var c = {};

    if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
    }

    if ((isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)) {
        input = undefined;
    }
    // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;

    return createFromConfig(c);
}

function createLocal (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
}

var prototypeMin = deprecate(
    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

var prototypeMax = deprecate(
    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
    }
    if (!moments.length) {
        return createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
        }
    }
    return res;
}

// TODO: Use [].sort instead?
function min () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isBefore', args);
}

function max () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isAfter', args);
}

var now = function () {
    return Date.now ? Date.now() : +(new Date());
};

var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

function isDurationValid(m) {
    for (var key in m) {
        if (!(ordering.indexOf(key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
        }
    }

    var unitHasDecimal = false;
    for (var i = 0; i < ordering.length; ++i) {
        if (m[ordering[i]]) {
            if (unitHasDecimal) {
                return false; // only allow non-integers for smallest unit
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
            }
        }
    }

    return true;
}

function isValid$1() {
    return this._isValid;
}

function createInvalid$1() {
    return createDuration(NaN);
}

function Duration (duration) {
    var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0;

    this._isValid = isDurationValid(normalizedInput);

    // representation for dateAddRemove
    this._milliseconds = +milliseconds +
        seconds * 1e3 + // 1000
        minutes * 6e4 + // 1000 * 60
        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately
    this._days = +days +
        weeks * 7;
    // It is impossible translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.
    this._months = +months +
        quarters * 3 +
        years * 12;

    this._data = {};

    this._locale = getLocale();

    this._bubble();
}

function isDuration (obj) {
    return obj instanceof Duration;
}

function absRound (number) {
    if (number < 0) {
        return Math.round(-1 * number) * -1;
    } else {
        return Math.round(number);
    }
}

// FORMATTING

function offset (token, separator) {
    addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';
        if (offset < 0) {
            offset = -offset;
            sign = '-';
        }
        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
    });
}

offset('Z', ':');
offset('ZZ', '');

// PARSING

addRegexToken('Z',  matchShortOffset);
addRegexToken('ZZ', matchShortOffset);
addParseToken(['Z', 'ZZ'], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
});

// HELPERS

// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']
var chunkOffset = /([\+\-]|\d\d)/gi;

function offsetFromString(matcher, string) {
    var matches = (string || '').match(matcher);

    if (matches === null) {
        return null;
    }

    var chunk   = matches[matches.length - 1] || [];
    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);

    return minutes === 0 ?
      0 :
      parts[0] === '+' ? minutes : -minutes;
}

// Return a moment from input, that is local/utc/zone equivalent to model.
function cloneWithOffset(input, model) {
    var res, diff;
    if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        // Use low-level api, because this fn is low-level api.
        res._d.setTime(res._d.valueOf() + diff);
        hooks.updateOffset(res, false);
        return res;
    } else {
        return createLocal(input).local();
    }
}

function getDateOffset (m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
}

// HOOKS

// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.
hooks.updateOffset = function () {};

// MOMENTS

// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.
function getSetOffset (input, keepLocalTime, keepMinutes) {
    var offset = this._offset || 0,
        localAdjust;
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    if (input != null) {
        if (typeof input === 'string') {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
                return this;
            }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
            this.add(localAdjust, 'm');
        }
        if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
            } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
            }
        }
        return this;
    } else {
        return this._isUTC ? offset : getDateOffset(this);
    }
}

function getSetZone (input, keepLocalTime) {
    if (input != null) {
        if (typeof input !== 'string') {
            input = -input;
        }

        this.utcOffset(input, keepLocalTime);

        return this;
    } else {
        return -this.utcOffset();
    }
}

function setOffsetToUTC (keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
}

function setOffsetToLocal (keepLocalTime) {
    if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
            this.subtract(getDateOffset(this), 'm');
        }
    }
    return this;
}

function setOffsetToParsedOffset () {
    if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
    } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
            this.utcOffset(tZone);
        }
        else {
            this.utcOffset(0, true);
        }
    }
    return this;
}

function hasAlignedHourOffset (input) {
    if (!this.isValid()) {
        return false;
    }
    input = input ? createLocal(input).utcOffset() : 0;

    return (this.utcOffset() - input) % 60 === 0;
}

function isDaylightSavingTime () {
    return (
        this.utcOffset() > this.clone().month(0).utcOffset() ||
        this.utcOffset() > this.clone().month(5).utcOffset()
    );
}

function isDaylightSavingTimeShifted () {
    if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
    }

    var c = {};

    copyConfig(c, this);
    c = prepareConfig(c);

    if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() &&
            compareArrays(c._a, other.toArray()) > 0;
    } else {
        this._isDSTShifted = false;
    }

    return this._isDSTShifted;
}

function isLocal () {
    return this.isValid() ? !this._isUTC : false;
}

function isUtcOffset () {
    return this.isValid() ? this._isUTC : false;
}

function isUtc () {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
}

// ASP.NET json date format regex
var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
// and further modified to allow for strings containing both week and day
var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

function createDuration (input, key) {
    var duration = input,
        // matching against regexp is expensive, do it on demand
        match = null,
        sign,
        ret,
        diffRes;

    if (isDuration(input)) {
        duration = {
            ms : input._milliseconds,
            d  : input._days,
            M  : input._months
        };
    } else if (isNumber(input)) {
        duration = {};
        if (key) {
            duration[key] = input;
        } else {
            duration.milliseconds = input;
        }
    } else if (!!(match = aspNetRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y  : 0,
            d  : toInt(match[DATE])                         * sign,
            h  : toInt(match[HOUR])                         * sign,
            m  : toInt(match[MINUTE])                       * sign,
            s  : toInt(match[SECOND])                       * sign,
            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
        };
    } else if (!!(match = isoRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y : parseIso(match[2], sign),
            M : parseIso(match[3], sign),
            w : parseIso(match[4], sign),
            d : parseIso(match[5], sign),
            h : parseIso(match[6], sign),
            m : parseIso(match[7], sign),
            s : parseIso(match[8], sign)
        };
    } else if (duration == null) {// checks for null or undefined
        duration = {};
    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
    }

    ret = new Duration(duration);

    if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
    }

    return ret;
}

createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;

function parseIso (inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.'));
    // apply sign while we're at it
    return (isNaN(res) ? 0 : res) * sign;
}

function positiveMomentsDifference(base, other) {
    var res = {milliseconds: 0, months: 0};

    res.months = other.month() - base.month() +
        (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
    }

    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

    return res;
}

function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
        return {milliseconds: 0, months: 0};
    }

    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
    } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
    }

    return res;
}

// TODO: remove 'name' arg after deprecation is removed
function createAdder(direction, name) {
    return function (val, period) {
        var dur, tmp;
        //invert the arguments, but complain about it
        if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
            tmp = val; val = period; period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
    };
}

function addSubtract (mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months);

    if (!mom.isValid()) {
        // No op
        return;
    }

    updateOffset = updateOffset == null ? true : updateOffset;

    if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }
    if (days) {
        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
    }
    if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
    }
    if (updateOffset) {
        hooks.updateOffset(mom, days || months);
    }
}

var add      = createAdder(1, 'add');
var subtract = createAdder(-1, 'subtract');

function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    return diff < -6 ? 'sameElse' :
            diff < -1 ? 'lastWeek' :
            diff < 0 ? 'lastDay' :
            diff < 1 ? 'sameDay' :
            diff < 2 ? 'nextDay' :
            diff < 7 ? 'nextWeek' : 'sameElse';
}

function calendar$1 (time, formats) {
    // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.
    var now = time || createLocal(),
        sod = cloneWithOffset(now, this).startOf('day'),
        format = hooks.calendarFormat(this, sod) || 'sameElse';

    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
}

function clone () {
    return new Moment(this);
}

function isAfter (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
    } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
}

function isBefore (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
    } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
}

function isBetween (from, to, units, inclusivity) {
    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
}

function isSame (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input),
        inputMs;
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
    } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
}

function isSameOrAfter (input, units) {
    return this.isSame(input, units) || this.isAfter(input,units);
}

function isSameOrBefore (input, units) {
    return this.isSame(input, units) || this.isBefore(input,units);
}

function diff (input, units, asFloat) {
    var that,
        zoneDelta,
        delta, output;

    if (!this.isValid()) {
        return NaN;
    }

    that = cloneWithOffset(input, this);

    if (!that.isValid()) {
        return NaN;
    }

    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

    units = normalizeUnits(units);

    if (units === 'year' || units === 'month' || units === 'quarter') {
        output = monthDiff(this, that);
        if (units === 'quarter') {
            output = output / 3;
        } else if (units === 'year') {
            output = output / 12;
        }
    } else {
        delta = this - that;
        output = units === 'second' ? delta / 1e3 : // 1000
            units === 'minute' ? delta / 6e4 : // 1000 * 60
            units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
            units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
            units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
            delta;
    }
    return asFloat ? output : absFloor(output);
}

function monthDiff (a, b) {
    // difference in months
    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
        // b is in (anchor - 1 month, anchor + 1 month)
        anchor = a.clone().add(wholeMonthDiff, 'months'),
        anchor2, adjust;

    if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor - anchor2);
    } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor2 - anchor);
    }

    //check for negative zero, return zero if negative zero
    return -(wholeMonthDiff + adjust) || 0;
}

hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

function toString () {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
}

function toISOString() {
    if (!this.isValid()) {
        return null;
    }
    var m = this.clone().utc();
    if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
    }
    if (isFunction(Date.prototype.toISOString)) {
        // native implementation is ~50x faster, use it when we can
        return this.toDate().toISOString();
    }
    return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
}

/**
 * Return a human readable representation of a moment that can
 * also be evaluated to get a new moment which is the same
 *
 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
 */
function inspect () {
    if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
    }
    var func = 'moment';
    var zone = '';
    if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
    }
    var prefix = '[' + func + '("]';
    var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
    var suffix = zone + '[")]';

    return this.format(prefix + year + datetime + suffix);
}

function format (inputString) {
    if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
}

function from (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function fromNow (withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
}

function to (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function toNow (withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
}

// If passed a locale key, it will set the locale for this
// instance.  Otherwise, it will return the locale configuration
// variables for this instance.
function locale (key) {
    var newLocaleData;

    if (key === undefined) {
        return this._locale._abbr;
    } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
            this._locale = newLocaleData;
        }
        return this;
    }
}

var lang = deprecate(
    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
    function (key) {
        if (key === undefined) {
            return this.localeData();
        } else {
            return this.locale(key);
        }
    }
);

function localeData () {
    return this._locale;
}

function startOf (units) {
    units = normalizeUnits(units);
    // the following switch intentionally omits break keywords
    // to utilize falling through the cases.
    switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
        case 'date':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
    }

    // weeks are a special case
    if (units === 'week') {
        this.weekday(0);
    }
    if (units === 'isoWeek') {
        this.isoWeekday(1);
    }

    // quarters are also special
    if (units === 'quarter') {
        this.month(Math.floor(this.month() / 3) * 3);
    }

    return this;
}

function endOf (units) {
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond') {
        return this;
    }

    // 'date' is an alias for 'day', so it should be considered as such.
    if (units === 'date') {
        units = 'day';
    }

    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
}

function valueOf () {
    return this._d.valueOf() - ((this._offset || 0) * 60000);
}

function unix () {
    return Math.floor(this.valueOf() / 1000);
}

function toDate () {
    return new Date(this.valueOf());
}

function toArray () {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
}

function toObject () {
    var m = this;
    return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
    };
}

function toJSON () {
    // new Date(NaN).toJSON() === null
    return this.isValid() ? this.toISOString() : null;
}

function isValid$2 () {
    return isValid(this);
}

function parsingFlags () {
    return extend({}, getParsingFlags(this));
}

function invalidAt () {
    return getParsingFlags(this).overflow;
}

function creationData() {
    return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
    };
}

// FORMATTING

addFormatToken(0, ['gg', 2], 0, function () {
    return this.weekYear() % 100;
});

addFormatToken(0, ['GG', 2], 0, function () {
    return this.isoWeekYear() % 100;
});

function addWeekYearFormatToken (token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
}

addWeekYearFormatToken('gggg',     'weekYear');
addWeekYearFormatToken('ggggg',    'weekYear');
addWeekYearFormatToken('GGGG',  'isoWeekYear');
addWeekYearFormatToken('GGGGG', 'isoWeekYear');

// ALIASES

addUnitAlias('weekYear', 'gg');
addUnitAlias('isoWeekYear', 'GG');

// PRIORITY

addUnitPriority('weekYear', 1);
addUnitPriority('isoWeekYear', 1);


// PARSING

addRegexToken('G',      matchSigned);
addRegexToken('g',      matchSigned);
addRegexToken('GG',     match1to2, match2);
addRegexToken('gg',     match1to2, match2);
addRegexToken('GGGG',   match1to4, match4);
addRegexToken('gggg',   match1to4, match4);
addRegexToken('GGGGG',  match1to6, match6);
addRegexToken('ggggg',  match1to6, match6);

addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
});

addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
});

// MOMENTS

function getSetWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy);
}

function getSetISOWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input, this.isoWeek(), this.isoWeekday(), 1, 4);
}

function getISOWeeksInYear () {
    return weeksInYear(this.year(), 1, 4);
}

function getWeeksInYear () {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}

function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
        return weekOfYear(this, dow, doy).year;
    } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
            week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
}

function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
}

// FORMATTING

addFormatToken('Q', 0, 'Qo', 'quarter');

// ALIASES

addUnitAlias('quarter', 'Q');

// PRIORITY

addUnitPriority('quarter', 7);

// PARSING

addRegexToken('Q', match1);
addParseToken('Q', function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
});

// MOMENTS

function getSetQuarter (input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}

// FORMATTING

addFormatToken('D', ['DD', 2], 'Do', 'date');

// ALIASES

addUnitAlias('date', 'D');

// PRIOROITY
addUnitPriority('date', 9);

// PARSING

addRegexToken('D',  match1to2);
addRegexToken('DD', match1to2, match2);
addRegexToken('Do', function (isStrict, locale) {
    // TODO: Remove "ordinalParse" fallback in next major release.
    return isStrict ?
      (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
      locale._dayOfMonthOrdinalParseLenient;
});

addParseToken(['D', 'DD'], DATE);
addParseToken('Do', function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0], 10);
});

// MOMENTS

var getSetDayOfMonth = makeGetSet('Date', true);

// FORMATTING

addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

// ALIASES

addUnitAlias('dayOfYear', 'DDD');

// PRIORITY
addUnitPriority('dayOfYear', 4);

// PARSING

addRegexToken('DDD',  match1to3);
addRegexToken('DDDD', match3);
addParseToken(['DDD', 'DDDD'], function (input, array, config) {
    config._dayOfYear = toInt(input);
});

// HELPERS

// MOMENTS

function getSetDayOfYear (input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
}

// FORMATTING

addFormatToken('m', ['mm', 2], 0, 'minute');

// ALIASES

addUnitAlias('minute', 'm');

// PRIORITY

addUnitPriority('minute', 14);

// PARSING

addRegexToken('m',  match1to2);
addRegexToken('mm', match1to2, match2);
addParseToken(['m', 'mm'], MINUTE);

// MOMENTS

var getSetMinute = makeGetSet('Minutes', false);

// FORMATTING

addFormatToken('s', ['ss', 2], 0, 'second');

// ALIASES

addUnitAlias('second', 's');

// PRIORITY

addUnitPriority('second', 15);

// PARSING

addRegexToken('s',  match1to2);
addRegexToken('ss', match1to2, match2);
addParseToken(['s', 'ss'], SECOND);

// MOMENTS

var getSetSecond = makeGetSet('Seconds', false);

// FORMATTING

addFormatToken('S', 0, 0, function () {
    return ~~(this.millisecond() / 100);
});

addFormatToken(0, ['SS', 2], 0, function () {
    return ~~(this.millisecond() / 10);
});

addFormatToken(0, ['SSS', 3], 0, 'millisecond');
addFormatToken(0, ['SSSS', 4], 0, function () {
    return this.millisecond() * 10;
});
addFormatToken(0, ['SSSSS', 5], 0, function () {
    return this.millisecond() * 100;
});
addFormatToken(0, ['SSSSSS', 6], 0, function () {
    return this.millisecond() * 1000;
});
addFormatToken(0, ['SSSSSSS', 7], 0, function () {
    return this.millisecond() * 10000;
});
addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
    return this.millisecond() * 100000;
});
addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
    return this.millisecond() * 1000000;
});


// ALIASES

addUnitAlias('millisecond', 'ms');

// PRIORITY

addUnitPriority('millisecond', 16);

// PARSING

addRegexToken('S',    match1to3, match1);
addRegexToken('SS',   match1to3, match2);
addRegexToken('SSS',  match1to3, match3);

var token;
for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
}

function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
}

for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
}
// MOMENTS

var getSetMillisecond = makeGetSet('Milliseconds', false);

// FORMATTING

addFormatToken('z',  0, 0, 'zoneAbbr');
addFormatToken('zz', 0, 0, 'zoneName');

// MOMENTS

function getZoneAbbr () {
    return this._isUTC ? 'UTC' : '';
}

function getZoneName () {
    return this._isUTC ? 'Coordinated Universal Time' : '';
}

var proto = Moment.prototype;

proto.add               = add;
proto.calendar          = calendar$1;
proto.clone             = clone;
proto.diff              = diff;
proto.endOf             = endOf;
proto.format            = format;
proto.from              = from;
proto.fromNow           = fromNow;
proto.to                = to;
proto.toNow             = toNow;
proto.get               = stringGet;
proto.invalidAt         = invalidAt;
proto.isAfter           = isAfter;
proto.isBefore          = isBefore;
proto.isBetween         = isBetween;
proto.isSame            = isSame;
proto.isSameOrAfter     = isSameOrAfter;
proto.isSameOrBefore    = isSameOrBefore;
proto.isValid           = isValid$2;
proto.lang              = lang;
proto.locale            = locale;
proto.localeData        = localeData;
proto.max               = prototypeMax;
proto.min               = prototypeMin;
proto.parsingFlags      = parsingFlags;
proto.set               = stringSet;
proto.startOf           = startOf;
proto.subtract          = subtract;
proto.toArray           = toArray;
proto.toObject          = toObject;
proto.toDate            = toDate;
proto.toISOString       = toISOString;
proto.inspect           = inspect;
proto.toJSON            = toJSON;
proto.toString          = toString;
proto.unix              = unix;
proto.valueOf           = valueOf;
proto.creationData      = creationData;

// Year
proto.year       = getSetYear;
proto.isLeapYear = getIsLeapYear;

// Week Year
proto.weekYear    = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;

// Quarter
proto.quarter = proto.quarters = getSetQuarter;

// Month
proto.month       = getSetMonth;
proto.daysInMonth = getDaysInMonth;

// Week
proto.week           = proto.weeks        = getSetWeek;
proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
proto.weeksInYear    = getWeeksInYear;
proto.isoWeeksInYear = getISOWeeksInYear;

// Day
proto.date       = getSetDayOfMonth;
proto.day        = proto.days             = getSetDayOfWeek;
proto.weekday    = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear  = getSetDayOfYear;

// Hour
proto.hour = proto.hours = getSetHour;

// Minute
proto.minute = proto.minutes = getSetMinute;

// Second
proto.second = proto.seconds = getSetSecond;

// Millisecond
proto.millisecond = proto.milliseconds = getSetMillisecond;

// Offset
proto.utcOffset            = getSetOffset;
proto.utc                  = setOffsetToUTC;
proto.local                = setOffsetToLocal;
proto.parseZone            = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST                = isDaylightSavingTime;
proto.isLocal              = isLocal;
proto.isUtcOffset          = isUtcOffset;
proto.isUtc                = isUtc;
proto.isUTC                = isUtc;

// Timezone
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;

// Deprecations
proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

function createUnix (input) {
    return createLocal(input * 1000);
}

function createInZone () {
    return createLocal.apply(null, arguments).parseZone();
}

function preParsePostFormat (string) {
    return string;
}

var proto$1 = Locale.prototype;

proto$1.calendar        = calendar;
proto$1.longDateFormat  = longDateFormat;
proto$1.invalidDate     = invalidDate;
proto$1.ordinal         = ordinal;
proto$1.preparse        = preParsePostFormat;
proto$1.postformat      = preParsePostFormat;
proto$1.relativeTime    = relativeTime;
proto$1.pastFuture      = pastFuture;
proto$1.set             = set;

// Month
proto$1.months            =        localeMonths;
proto$1.monthsShort       =        localeMonthsShort;
proto$1.monthsParse       =        localeMonthsParse;
proto$1.monthsRegex       = monthsRegex;
proto$1.monthsShortRegex  = monthsShortRegex;

// Week
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;

// Day of Week
proto$1.weekdays       =        localeWeekdays;
proto$1.weekdaysMin    =        localeWeekdaysMin;
proto$1.weekdaysShort  =        localeWeekdaysShort;
proto$1.weekdaysParse  =        localeWeekdaysParse;

proto$1.weekdaysRegex       =        weekdaysRegex;
proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

// Hours
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;

function get$1 (format, index, field, setter) {
    var locale = getLocale();
    var utc = createUTC().set(setter, index);
    return locale[field](utc, format);
}

function listMonthsImpl (format, index, field) {
    if (isNumber(format)) {
        index = format;
        format = undefined;
    }

    format = format || '';

    if (index != null) {
        return get$1(format, index, field, 'month');
    }

    var i;
    var out = [];
    for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
    }
    return out;
}

// ()
// (5)
// (fmt, 5)
// (fmt)
// (true)
// (true, 5)
// (true, fmt, 5)
// (true, fmt)
function listWeekdaysImpl (localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    }

    var locale = getLocale(),
        shift = localeSorted ? locale._week.dow : 0;

    if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
    }

    var i;
    var out = [];
    for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
    }
    return out;
}

function listMonths (format, index) {
    return listMonthsImpl(format, index, 'months');
}

function listMonthsShort (format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
}

function listWeekdays (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
}

function listWeekdaysShort (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
}

function listWeekdaysMin (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
}

getSetGlobalLocale('en', {
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (toInt(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    }
});

// Side effect imports
hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

var mathAbs = Math.abs;

function abs () {
    var data           = this._data;

    this._milliseconds = mathAbs(this._milliseconds);
    this._days         = mathAbs(this._days);
    this._months       = mathAbs(this._months);

    data.milliseconds  = mathAbs(data.milliseconds);
    data.seconds       = mathAbs(data.seconds);
    data.minutes       = mathAbs(data.minutes);
    data.hours         = mathAbs(data.hours);
    data.months        = mathAbs(data.months);
    data.years         = mathAbs(data.years);

    return this;
}

function addSubtract$1 (duration, input, value, direction) {
    var other = createDuration(input, value);

    duration._milliseconds += direction * other._milliseconds;
    duration._days         += direction * other._days;
    duration._months       += direction * other._months;

    return duration._bubble();
}

// supports only 2.0-style add(1, 's') or add(duration)
function add$1 (input, value) {
    return addSubtract$1(this, input, value, 1);
}

// supports only 2.0-style subtract(1, 's') or subtract(duration)
function subtract$1 (input, value) {
    return addSubtract$1(this, input, value, -1);
}

function absCeil (number) {
    if (number < 0) {
        return Math.floor(number);
    } else {
        return Math.ceil(number);
    }
}

function bubble () {
    var milliseconds = this._milliseconds;
    var days         = this._days;
    var months       = this._months;
    var data         = this._data;
    var seconds, minutes, hours, years, monthsFromDays;

    // if we have a mix of positive and negative values, bubble down first
    // check: https://github.com/moment/moment/issues/2166
    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
            (milliseconds <= 0 && days <= 0 && months <= 0))) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
    }

    // The following code bubbles up values, see the tests for
    // examples of what that means.
    data.milliseconds = milliseconds % 1000;

    seconds           = absFloor(milliseconds / 1000);
    data.seconds      = seconds % 60;

    minutes           = absFloor(seconds / 60);
    data.minutes      = minutes % 60;

    hours             = absFloor(minutes / 60);
    data.hours        = hours % 24;

    days += absFloor(hours / 24);

    // convert days to months
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));

    // 12 months -> 1 year
    years = absFloor(months / 12);
    months %= 12;

    data.days   = days;
    data.months = months;
    data.years  = years;

    return this;
}

function daysToMonths (days) {
    // 400 years have 146097 days (taking into account leap year rules)
    // 400 years have 12 months === 4800
    return days * 4800 / 146097;
}

function monthsToDays (months) {
    // the reverse of daysToMonths
    return months * 146097 / 4800;
}

function as (units) {
    if (!this.isValid()) {
        return NaN;
    }
    var days;
    var months;
    var milliseconds = this._milliseconds;

    units = normalizeUnits(units);

    if (units === 'month' || units === 'year') {
        days   = this._days   + milliseconds / 864e5;
        months = this._months + daysToMonths(days);
        return units === 'month' ? months : months / 12;
    } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
            case 'week'   : return days / 7     + milliseconds / 6048e5;
            case 'day'    : return days         + milliseconds / 864e5;
            case 'hour'   : return days * 24    + milliseconds / 36e5;
            case 'minute' : return days * 1440  + milliseconds / 6e4;
            case 'second' : return days * 86400 + milliseconds / 1000;
            // Math.floor prevents floating point math errors here
            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
            default: throw new Error('Unknown unit ' + units);
        }
    }
}

// TODO: Use this.as('ms')?
function valueOf$1 () {
    if (!this.isValid()) {
        return NaN;
    }
    return (
        this._milliseconds +
        this._days * 864e5 +
        (this._months % 12) * 2592e6 +
        toInt(this._months / 12) * 31536e6
    );
}

function makeAs (alias) {
    return function () {
        return this.as(alias);
    };
}

var asMilliseconds = makeAs('ms');
var asSeconds      = makeAs('s');
var asMinutes      = makeAs('m');
var asHours        = makeAs('h');
var asDays         = makeAs('d');
var asWeeks        = makeAs('w');
var asMonths       = makeAs('M');
var asYears        = makeAs('y');

function get$2 (units) {
    units = normalizeUnits(units);
    return this.isValid() ? this[units + 's']() : NaN;
}

function makeGetter(name) {
    return function () {
        return this.isValid() ? this._data[name] : NaN;
    };
}

var milliseconds = makeGetter('milliseconds');
var seconds      = makeGetter('seconds');
var minutes      = makeGetter('minutes');
var hours        = makeGetter('hours');
var days         = makeGetter('days');
var months       = makeGetter('months');
var years        = makeGetter('years');

function weeks () {
    return absFloor(this.days() / 7);
}

var round = Math.round;
var thresholds = {
    ss: 44,         // a few seconds to seconds
    s : 45,         // seconds to minute
    m : 45,         // minutes to hour
    h : 22,         // hours to day
    d : 26,         // days to month
    M : 11          // months to year
};

// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}

function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
    var duration = createDuration(posNegDuration).abs();
    var seconds  = round(duration.as('s'));
    var minutes  = round(duration.as('m'));
    var hours    = round(duration.as('h'));
    var days     = round(duration.as('d'));
    var months   = round(duration.as('M'));
    var years    = round(duration.as('y'));

    var a = seconds <= thresholds.ss && ['s', seconds]  ||
            seconds < thresholds.s   && ['ss', seconds] ||
            minutes <= 1             && ['m']           ||
            minutes < thresholds.m   && ['mm', minutes] ||
            hours   <= 1             && ['h']           ||
            hours   < thresholds.h   && ['hh', hours]   ||
            days    <= 1             && ['d']           ||
            days    < thresholds.d   && ['dd', days]    ||
            months  <= 1             && ['M']           ||
            months  < thresholds.M   && ['MM', months]  ||
            years   <= 1             && ['y']           || ['yy', years];

    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
}

// This function allows you to set the rounding function for relative time strings
function getSetRelativeTimeRounding (roundingFunction) {
    if (roundingFunction === undefined) {
        return round;
    }
    if (typeof(roundingFunction) === 'function') {
        round = roundingFunction;
        return true;
    }
    return false;
}

// This function allows you to set a threshold for relative time strings
function getSetRelativeTimeThreshold (threshold, limit) {
    if (thresholds[threshold] === undefined) {
        return false;
    }
    if (limit === undefined) {
        return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    if (threshold === 's') {
        thresholds.ss = limit - 1;
    }
    return true;
}

function humanize (withSuffix) {
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var locale = this.localeData();
    var output = relativeTime$1(this, !withSuffix, locale);

    if (withSuffix) {
        output = locale.pastFuture(+this, output);
    }

    return locale.postformat(output);
}

var abs$1 = Math.abs;

function toISOString$1() {
    // for ISO strings we do not use the normal bubbling rules:
    //  * milliseconds bubble up until they become hours
    //  * days do not bubble at all
    //  * months bubble up until they become years
    // This is because there is no context-free conversion between hours and days
    // (think of clock changes)
    // and also not between days and months (28-31 days per month)
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var seconds = abs$1(this._milliseconds) / 1000;
    var days         = abs$1(this._days);
    var months       = abs$1(this._months);
    var minutes, hours, years;

    // 3600 seconds -> 60 minutes -> 1 hour
    minutes           = absFloor(seconds / 60);
    hours             = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;

    // 12 months -> 1 year
    years  = absFloor(months / 12);
    months %= 12;


    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
    var Y = years;
    var M = months;
    var D = days;
    var h = hours;
    var m = minutes;
    var s = seconds;
    var total = this.asSeconds();

    if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
    }

    return (total < 0 ? '-' : '') +
        'P' +
        (Y ? Y + 'Y' : '') +
        (M ? M + 'M' : '') +
        (D ? D + 'D' : '') +
        ((h || m || s) ? 'T' : '') +
        (h ? h + 'H' : '') +
        (m ? m + 'M' : '') +
        (s ? s + 'S' : '');
}

var proto$2 = Duration.prototype;

proto$2.isValid        = isValid$1;
proto$2.abs            = abs;
proto$2.add            = add$1;
proto$2.subtract       = subtract$1;
proto$2.as             = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds      = asSeconds;
proto$2.asMinutes      = asMinutes;
proto$2.asHours        = asHours;
proto$2.asDays         = asDays;
proto$2.asWeeks        = asWeeks;
proto$2.asMonths       = asMonths;
proto$2.asYears        = asYears;
proto$2.valueOf        = valueOf$1;
proto$2._bubble        = bubble;
proto$2.get            = get$2;
proto$2.milliseconds   = milliseconds;
proto$2.seconds        = seconds;
proto$2.minutes        = minutes;
proto$2.hours          = hours;
proto$2.days           = days;
proto$2.weeks          = weeks;
proto$2.months         = months;
proto$2.years          = years;
proto$2.humanize       = humanize;
proto$2.toISOString    = toISOString$1;
proto$2.toString       = toISOString$1;
proto$2.toJSON         = toISOString$1;
proto$2.locale         = locale;
proto$2.localeData     = localeData;

// Deprecations
proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
proto$2.lang = lang;

// Side effect imports

// FORMATTING

addFormatToken('X', 0, 0, 'unix');
addFormatToken('x', 0, 0, 'valueOf');

// PARSING

addRegexToken('x', matchSigned);
addRegexToken('X', matchTimestamp);
addParseToken('X', function (input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
});
addParseToken('x', function (input, array, config) {
    config._d = new Date(toInt(input));
});

// Side effect imports

//! moment.js
//! version : 2.18.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

hooks.version = '2.18.1';

setHookCallback(createLocal);

hooks.fn                    = proto;
hooks.min                   = min;
hooks.max                   = max;
hooks.now                   = now;
hooks.utc                   = createUTC;
hooks.unix                  = createUnix;
hooks.months                = listMonths;
hooks.isDate                = isDate;
hooks.locale                = getSetGlobalLocale;
hooks.invalid               = createInvalid;
hooks.duration              = createDuration;
hooks.isMoment              = isMoment;
hooks.weekdays              = listWeekdays;
hooks.parseZone             = createInZone;
hooks.localeData            = getLocale;
hooks.isDuration            = isDuration;
hooks.monthsShort           = listMonthsShort;
hooks.weekdaysMin           = listWeekdaysMin;
hooks.defineLocale          = defineLocale;
hooks.updateLocale          = updateLocale;
hooks.locales               = listLocales;
hooks.weekdaysShort         = listWeekdaysShort;
hooks.normalizeUnits        = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat        = getCalendarFormat;
hooks.prototype             = proto;

//! moment.js locale configuration
//! locale : Afrikaans [af]
//! author : Werner Mollentze : https://github.com/wernerm

hooks.defineLocale('af', {
    months : 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
    monthsShort : 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
    weekdays : 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
    weekdaysShort : 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
    weekdaysMin : 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
    meridiemParse: /vm|nm/i,
    isPM : function (input) {
        return /^nm$/i.test(input);
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours < 12) {
            return isLower ? 'vm' : 'VM';
        } else {
            return isLower ? 'nm' : 'NM';
        }
    },
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[Vandag om] LT',
        nextDay : '[Môre om] LT',
        nextWeek : 'dddd [om] LT',
        lastDay : '[Gister om] LT',
        lastWeek : '[Laas] dddd [om] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'oor %s',
        past : '%s gelede',
        s : '\'n paar sekondes',
        m : '\'n minuut',
        mm : '%d minute',
        h : '\'n uur',
        hh : '%d ure',
        d : '\'n dag',
        dd : '%d dae',
        M : '\'n maand',
        MM : '%d maande',
        y : '\'n jaar',
        yy : '%d jaar'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal : function (number) {
        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de'); // Thanks to Joris Röling : https://github.com/jjupiter
    },
    week : {
        dow : 1, // Maandag is die eerste dag van die week.
        doy : 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
    }
});

//! moment.js locale configuration
//! locale : Arabic (Algeria) [ar-dz]
//! author : Noureddine LOUAHEDJ : https://github.com/noureddineme

hooks.defineLocale('ar-dz', {
    months : 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
    monthsShort : 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
    weekdays : 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
    weekdaysShort : 'احد_اثنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
    weekdaysMin : 'أح_إث_ثلا_أر_خم_جم_سب'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[اليوم على الساعة] LT',
        nextDay: '[غدا على الساعة] LT',
        nextWeek: 'dddd [على الساعة] LT',
        lastDay: '[أمس على الساعة] LT',
        lastWeek: 'dddd [على الساعة] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'في %s',
        past : 'منذ %s',
        s : 'ثوان',
        m : 'دقيقة',
        mm : '%d دقائق',
        h : 'ساعة',
        hh : '%d ساعات',
        d : 'يوم',
        dd : '%d أيام',
        M : 'شهر',
        MM : '%d أشهر',
        y : 'سنة',
        yy : '%d سنوات'
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 4  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Arabic (Kuwait) [ar-kw]
//! author : Nusret Parlak: https://github.com/nusretparlak

hooks.defineLocale('ar-kw', {
    months : 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
    monthsShort : 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
    weekdays : 'الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
    weekdaysShort : 'احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
    weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[اليوم على الساعة] LT',
        nextDay: '[غدا على الساعة] LT',
        nextWeek: 'dddd [على الساعة] LT',
        lastDay: '[أمس على الساعة] LT',
        lastWeek: 'dddd [على الساعة] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'في %s',
        past : 'منذ %s',
        s : 'ثوان',
        m : 'دقيقة',
        mm : '%d دقائق',
        h : 'ساعة',
        hh : '%d ساعات',
        d : 'يوم',
        dd : '%d أيام',
        M : 'شهر',
        MM : '%d أشهر',
        y : 'سنة',
        yy : '%d سنوات'
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 12  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Arabic (Lybia) [ar-ly]
//! author : Ali Hmer: https://github.com/kikoanis

var symbolMap = {
    '1': '1',
    '2': '2',
    '3': '3',
    '4': '4',
    '5': '5',
    '6': '6',
    '7': '7',
    '8': '8',
    '9': '9',
    '0': '0'
};
var pluralForm = function (n) {
    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
};
var plurals = {
    s : ['أقل من ثانية', 'ثانية واحدة', ['ثانيتان', 'ثانيتين'], '%d ثوان', '%d ثانية', '%d ثانية'],
    m : ['أقل من دقيقة', 'دقيقة واحدة', ['دقيقتان', 'دقيقتين'], '%d دقائق', '%d دقيقة', '%d دقيقة'],
    h : ['أقل من ساعة', 'ساعة واحدة', ['ساعتان', 'ساعتين'], '%d ساعات', '%d ساعة', '%d ساعة'],
    d : ['أقل من يوم', 'يوم واحد', ['يومان', 'يومين'], '%d أيام', '%d يومًا', '%d يوم'],
    M : ['أقل من شهر', 'شهر واحد', ['شهران', 'شهرين'], '%d أشهر', '%d شهرا', '%d شهر'],
    y : ['أقل من عام', 'عام واحد', ['عامان', 'عامين'], '%d أعوام', '%d عامًا', '%d عام']
};
var pluralize = function (u) {
    return function (number, withoutSuffix, string, isFuture) {
        var f = pluralForm(number),
            str = plurals[u][pluralForm(number)];
        if (f === 2) {
            str = str[withoutSuffix ? 0 : 1];
        }
        return str.replace(/%d/i, number);
    };
};
var months$1 = [
    'يناير',
    'فبراير',
    'مارس',
    'أبريل',
    'مايو',
    'يونيو',
    'يوليو',
    'أغسطس',
    'سبتمبر',
    'أكتوبر',
    'نوفمبر',
    'ديسمبر'
];

hooks.defineLocale('ar-ly', {
    months : months$1,
    monthsShort : months$1,
    weekdays : 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
    weekdaysShort : 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
    weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'D/\u200FM/\u200FYYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /ص|م/,
    isPM : function (input) {
        return 'م' === input;
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return 'ص';
        } else {
            return 'م';
        }
    },
    calendar : {
        sameDay: '[اليوم عند الساعة] LT',
        nextDay: '[غدًا عند الساعة] LT',
        nextWeek: 'dddd [عند الساعة] LT',
        lastDay: '[أمس عند الساعة] LT',
        lastWeek: 'dddd [عند الساعة] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'بعد %s',
        past : 'منذ %s',
        s : pluralize('s'),
        m : pluralize('m'),
        mm : pluralize('m'),
        h : pluralize('h'),
        hh : pluralize('h'),
        d : pluralize('d'),
        dd : pluralize('d'),
        M : pluralize('M'),
        MM : pluralize('M'),
        y : pluralize('y'),
        yy : pluralize('y')
    },
    preparse: function (string) {
        return string.replace(/\u200f/g, '').replace(/،/g, ',');
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap[match];
        }).replace(/,/g, '،');
    },
    week : {
        dow : 6, // Saturday is the first day of the week.
        doy : 12  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Arabic (Morocco) [ar-ma]
//! author : ElFadili Yassine : https://github.com/ElFadiliY
//! author : Abdel Said : https://github.com/abdelsaid

hooks.defineLocale('ar-ma', {
    months : 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
    monthsShort : 'يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر'.split('_'),
    weekdays : 'الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
    weekdaysShort : 'احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت'.split('_'),
    weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[اليوم على الساعة] LT',
        nextDay: '[غدا على الساعة] LT',
        nextWeek: 'dddd [على الساعة] LT',
        lastDay: '[أمس على الساعة] LT',
        lastWeek: 'dddd [على الساعة] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'في %s',
        past : 'منذ %s',
        s : 'ثوان',
        m : 'دقيقة',
        mm : '%d دقائق',
        h : 'ساعة',
        hh : '%d ساعات',
        d : 'يوم',
        dd : '%d أيام',
        M : 'شهر',
        MM : '%d أشهر',
        y : 'سنة',
        yy : '%d سنوات'
    },
    week : {
        dow : 6, // Saturday is the first day of the week.
        doy : 12  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Arabic (Saudi Arabia) [ar-sa]
//! author : Suhail Alkowaileet : https://github.com/xsoh

var symbolMap$1 = {
    '1': '١',
    '2': '٢',
    '3': '٣',
    '4': '٤',
    '5': '٥',
    '6': '٦',
    '7': '٧',
    '8': '٨',
    '9': '٩',
    '0': '٠'
};
var numberMap = {
    '١': '1',
    '٢': '2',
    '٣': '3',
    '٤': '4',
    '٥': '5',
    '٦': '6',
    '٧': '7',
    '٨': '8',
    '٩': '9',
    '٠': '0'
};

hooks.defineLocale('ar-sa', {
    months : 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
    monthsShort : 'يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
    weekdays : 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
    weekdaysShort : 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
    weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /ص|م/,
    isPM : function (input) {
        return 'م' === input;
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return 'ص';
        } else {
            return 'م';
        }
    },
    calendar : {
        sameDay: '[اليوم على الساعة] LT',
        nextDay: '[غدا على الساعة] LT',
        nextWeek: 'dddd [على الساعة] LT',
        lastDay: '[أمس على الساعة] LT',
        lastWeek: 'dddd [على الساعة] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'في %s',
        past : 'منذ %s',
        s : 'ثوان',
        m : 'دقيقة',
        mm : '%d دقائق',
        h : 'ساعة',
        hh : '%d ساعات',
        d : 'يوم',
        dd : '%d أيام',
        M : 'شهر',
        MM : '%d أشهر',
        y : 'سنة',
        yy : '%d سنوات'
    },
    preparse: function (string) {
        return string.replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
            return numberMap[match];
        }).replace(/،/g, ',');
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap$1[match];
        }).replace(/,/g, '،');
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale  :  Arabic (Tunisia) [ar-tn]
//! author : Nader Toukabri : https://github.com/naderio

hooks.defineLocale('ar-tn', {
    months: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
    monthsShort: 'جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر'.split('_'),
    weekdays: 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
    weekdaysShort: 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
    weekdaysMin: 'ح_ن_ث_ر_خ_ج_س'.split('_'),
    weekdaysParseExact : true,
    longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
        sameDay: '[اليوم على الساعة] LT',
        nextDay: '[غدا على الساعة] LT',
        nextWeek: 'dddd [على الساعة] LT',
        lastDay: '[أمس على الساعة] LT',
        lastWeek: 'dddd [على الساعة] LT',
        sameElse: 'L'
    },
    relativeTime: {
        future: 'في %s',
        past: 'منذ %s',
        s: 'ثوان',
        m: 'دقيقة',
        mm: '%d دقائق',
        h: 'ساعة',
        hh: '%d ساعات',
        d: 'يوم',
        dd: '%d أيام',
        M: 'شهر',
        MM: '%d أشهر',
        y: 'سنة',
        yy: '%d سنوات'
    },
    week: {
        dow: 1, // Monday is the first day of the week.
        doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Arabic [ar]
//! author : Abdel Said: https://github.com/abdelsaid
//! author : Ahmed Elkhatib
//! author : forabi https://github.com/forabi

var symbolMap$2 = {
    '1': '١',
    '2': '٢',
    '3': '٣',
    '4': '٤',
    '5': '٥',
    '6': '٦',
    '7': '٧',
    '8': '٨',
    '9': '٩',
    '0': '٠'
};
var numberMap$1 = {
    '١': '1',
    '٢': '2',
    '٣': '3',
    '٤': '4',
    '٥': '5',
    '٦': '6',
    '٧': '7',
    '٨': '8',
    '٩': '9',
    '٠': '0'
};
var pluralForm$1 = function (n) {
    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
};
var plurals$1 = {
    s : ['أقل من ثانية', 'ثانية واحدة', ['ثانيتان', 'ثانيتين'], '%d ثوان', '%d ثانية', '%d ثانية'],
    m : ['أقل من دقيقة', 'دقيقة واحدة', ['دقيقتان', 'دقيقتين'], '%d دقائق', '%d دقيقة', '%d دقيقة'],
    h : ['أقل من ساعة', 'ساعة واحدة', ['ساعتان', 'ساعتين'], '%d ساعات', '%d ساعة', '%d ساعة'],
    d : ['أقل من يوم', 'يوم واحد', ['يومان', 'يومين'], '%d أيام', '%d يومًا', '%d يوم'],
    M : ['أقل من شهر', 'شهر واحد', ['شهران', 'شهرين'], '%d أشهر', '%d شهرا', '%d شهر'],
    y : ['أقل من عام', 'عام واحد', ['عامان', 'عامين'], '%d أعوام', '%d عامًا', '%d عام']
};
var pluralize$1 = function (u) {
    return function (number, withoutSuffix, string, isFuture) {
        var f = pluralForm$1(number),
            str = plurals$1[u][pluralForm$1(number)];
        if (f === 2) {
            str = str[withoutSuffix ? 0 : 1];
        }
        return str.replace(/%d/i, number);
    };
};
var months$2 = [
    'كانون الثاني يناير',
    'شباط فبراير',
    'آذار مارس',
    'نيسان أبريل',
    'أيار مايو',
    'حزيران يونيو',
    'تموز يوليو',
    'آب أغسطس',
    'أيلول سبتمبر',
    'تشرين الأول أكتوبر',
    'تشرين الثاني نوفمبر',
    'كانون الأول ديسمبر'
];

hooks.defineLocale('ar', {
    months : months$2,
    monthsShort : months$2,
    weekdays : 'الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت'.split('_'),
    weekdaysShort : 'أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت'.split('_'),
    weekdaysMin : 'ح_ن_ث_ر_خ_ج_س'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'D/\u200FM/\u200FYYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /ص|م/,
    isPM : function (input) {
        return 'م' === input;
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return 'ص';
        } else {
            return 'م';
        }
    },
    calendar : {
        sameDay: '[اليوم عند الساعة] LT',
        nextDay: '[غدًا عند الساعة] LT',
        nextWeek: 'dddd [عند الساعة] LT',
        lastDay: '[أمس عند الساعة] LT',
        lastWeek: 'dddd [عند الساعة] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'بعد %s',
        past : 'منذ %s',
        s : pluralize$1('s'),
        m : pluralize$1('m'),
        mm : pluralize$1('m'),
        h : pluralize$1('h'),
        hh : pluralize$1('h'),
        d : pluralize$1('d'),
        dd : pluralize$1('d'),
        M : pluralize$1('M'),
        MM : pluralize$1('M'),
        y : pluralize$1('y'),
        yy : pluralize$1('y')
    },
    preparse: function (string) {
        return string.replace(/\u200f/g, '').replace(/[١٢٣٤٥٦٧٨٩٠]/g, function (match) {
            return numberMap$1[match];
        }).replace(/،/g, ',');
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap$2[match];
        }).replace(/,/g, '،');
    },
    week : {
        dow : 6, // Saturday is the first day of the week.
        doy : 12  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Azerbaijani [az]
//! author : topchiyev : https://github.com/topchiyev

var suffixes = {
    1: '-inci',
    5: '-inci',
    8: '-inci',
    70: '-inci',
    80: '-inci',
    2: '-nci',
    7: '-nci',
    20: '-nci',
    50: '-nci',
    3: '-üncü',
    4: '-üncü',
    100: '-üncü',
    6: '-ncı',
    9: '-uncu',
    10: '-uncu',
    30: '-uncu',
    60: '-ıncı',
    90: '-ıncı'
};

hooks.defineLocale('az', {
    months : 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
    monthsShort : 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
    weekdays : 'Bazar_Bazar ertəsi_Çərşənbə axşamı_Çərşənbə_Cümə axşamı_Cümə_Şənbə'.split('_'),
    weekdaysShort : 'Baz_BzE_ÇAx_Çər_CAx_Cüm_Şən'.split('_'),
    weekdaysMin : 'Bz_BE_ÇA_Çə_CA_Cü_Şə'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[bugün saat] LT',
        nextDay : '[sabah saat] LT',
        nextWeek : '[gələn həftə] dddd [saat] LT',
        lastDay : '[dünən] LT',
        lastWeek : '[keçən həftə] dddd [saat] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s sonra',
        past : '%s əvvəl',
        s : 'birneçə saniyyə',
        m : 'bir dəqiqə',
        mm : '%d dəqiqə',
        h : 'bir saat',
        hh : '%d saat',
        d : 'bir gün',
        dd : '%d gün',
        M : 'bir ay',
        MM : '%d ay',
        y : 'bir il',
        yy : '%d il'
    },
    meridiemParse: /gecə|səhər|gündüz|axşam/,
    isPM : function (input) {
        return /^(gündüz|axşam)$/.test(input);
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return 'gecə';
        } else if (hour < 12) {
            return 'səhər';
        } else if (hour < 17) {
            return 'gündüz';
        } else {
            return 'axşam';
        }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(ıncı|inci|nci|üncü|ncı|uncu)/,
    ordinal : function (number) {
        if (number === 0) {  // special case for zero
            return number + '-ıncı';
        }
        var a = number % 10,
            b = number % 100 - a,
            c = number >= 100 ? 100 : null;
        return number + (suffixes[a] || suffixes[b] || suffixes[c]);
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Belarusian [be]
//! author : Dmitry Demidov : https://github.com/demidov91
//! author: Praleska: http://praleska.pro/
//! Author : Menelion Elensúle : https://github.com/Oire

function plural(word, num) {
    var forms = word.split('_');
    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
}
function relativeTimeWithPlural(number, withoutSuffix, key) {
    var format = {
        'mm': withoutSuffix ? 'хвіліна_хвіліны_хвілін' : 'хвіліну_хвіліны_хвілін',
        'hh': withoutSuffix ? 'гадзіна_гадзіны_гадзін' : 'гадзіну_гадзіны_гадзін',
        'dd': 'дзень_дні_дзён',
        'MM': 'месяц_месяцы_месяцаў',
        'yy': 'год_гады_гадоў'
    };
    if (key === 'm') {
        return withoutSuffix ? 'хвіліна' : 'хвіліну';
    }
    else if (key === 'h') {
        return withoutSuffix ? 'гадзіна' : 'гадзіну';
    }
    else {
        return number + ' ' + plural(format[key], +number);
    }
}

hooks.defineLocale('be', {
    months : {
        format: 'студзеня_лютага_сакавіка_красавіка_траўня_чэрвеня_ліпеня_жніўня_верасня_кастрычніка_лістапада_снежня'.split('_'),
        standalone: 'студзень_люты_сакавік_красавік_травень_чэрвень_ліпень_жнівень_верасень_кастрычнік_лістапад_снежань'.split('_')
    },
    monthsShort : 'студ_лют_сак_крас_трав_чэрв_ліп_жнів_вер_каст_ліст_снеж'.split('_'),
    weekdays : {
        format: 'нядзелю_панядзелак_аўторак_сераду_чацвер_пятніцу_суботу'.split('_'),
        standalone: 'нядзеля_панядзелак_аўторак_серада_чацвер_пятніца_субота'.split('_'),
        isFormat: /\[ ?[Вв] ?(?:мінулую|наступную)? ?\] ?dddd/
    },
    weekdaysShort : 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
    weekdaysMin : 'нд_пн_ат_ср_чц_пт_сб'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY г.',
        LLL : 'D MMMM YYYY г., HH:mm',
        LLLL : 'dddd, D MMMM YYYY г., HH:mm'
    },
    calendar : {
        sameDay: '[Сёння ў] LT',
        nextDay: '[Заўтра ў] LT',
        lastDay: '[Учора ў] LT',
        nextWeek: function () {
            return '[У] dddd [ў] LT';
        },
        lastWeek: function () {
            switch (this.day()) {
                case 0:
                case 3:
                case 5:
                case 6:
                    return '[У мінулую] dddd [ў] LT';
                case 1:
                case 2:
                case 4:
                    return '[У мінулы] dddd [ў] LT';
            }
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : 'праз %s',
        past : '%s таму',
        s : 'некалькі секунд',
        m : relativeTimeWithPlural,
        mm : relativeTimeWithPlural,
        h : relativeTimeWithPlural,
        hh : relativeTimeWithPlural,
        d : 'дзень',
        dd : relativeTimeWithPlural,
        M : 'месяц',
        MM : relativeTimeWithPlural,
        y : 'год',
        yy : relativeTimeWithPlural
    },
    meridiemParse: /ночы|раніцы|дня|вечара/,
    isPM : function (input) {
        return /^(дня|вечара)$/.test(input);
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return 'ночы';
        } else if (hour < 12) {
            return 'раніцы';
        } else if (hour < 17) {
            return 'дня';
        } else {
            return 'вечара';
        }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(і|ы|га)/,
    ordinal: function (number, period) {
        switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
            case 'w':
            case 'W':
                return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + '-і' : number + '-ы';
            case 'D':
                return number + '-га';
            default:
                return number;
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Bulgarian [bg]
//! author : Krasen Borisov : https://github.com/kraz

hooks.defineLocale('bg', {
    months : 'януари_февруари_март_април_май_юни_юли_август_септември_октомври_ноември_декември'.split('_'),
    monthsShort : 'янр_фев_мар_апр_май_юни_юли_авг_сеп_окт_ное_дек'.split('_'),
    weekdays : 'неделя_понеделник_вторник_сряда_четвъртък_петък_събота'.split('_'),
    weekdaysShort : 'нед_пон_вто_сря_чет_пет_съб'.split('_'),
    weekdaysMin : 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'D.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY H:mm',
        LLLL : 'dddd, D MMMM YYYY H:mm'
    },
    calendar : {
        sameDay : '[Днес в] LT',
        nextDay : '[Утре в] LT',
        nextWeek : 'dddd [в] LT',
        lastDay : '[Вчера в] LT',
        lastWeek : function () {
            switch (this.day()) {
                case 0:
                case 3:
                case 6:
                    return '[В изминалата] dddd [в] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[В изминалия] dddd [в] LT';
            }
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'след %s',
        past : 'преди %s',
        s : 'няколко секунди',
        m : 'минута',
        mm : '%d минути',
        h : 'час',
        hh : '%d часа',
        d : 'ден',
        dd : '%d дни',
        M : 'месец',
        MM : '%d месеца',
        y : 'година',
        yy : '%d години'
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
    ordinal : function (number) {
        var lastDigit = number % 10,
            last2Digits = number % 100;
        if (number === 0) {
            return number + '-ев';
        } else if (last2Digits === 0) {
            return number + '-ен';
        } else if (last2Digits > 10 && last2Digits < 20) {
            return number + '-ти';
        } else if (lastDigit === 1) {
            return number + '-ви';
        } else if (lastDigit === 2) {
            return number + '-ри';
        } else if (lastDigit === 7 || lastDigit === 8) {
            return number + '-ми';
        } else {
            return number + '-ти';
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Bengali [bn]
//! author : Kaushik Gandhi : https://github.com/kaushikgandhi

var symbolMap$3 = {
    '1': '১',
    '2': '২',
    '3': '৩',
    '4': '৪',
    '5': '৫',
    '6': '৬',
    '7': '৭',
    '8': '৮',
    '9': '৯',
    '0': '০'
};
var numberMap$2 = {
    '১': '1',
    '২': '2',
    '৩': '3',
    '৪': '4',
    '৫': '5',
    '৬': '6',
    '৭': '7',
    '৮': '8',
    '৯': '9',
    '০': '0'
};

hooks.defineLocale('bn', {
    months : 'জানুয়ারী_ফেব্রুয়ারি_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্টেম্বর_অক্টোবর_নভেম্বর_ডিসেম্বর'.split('_'),
    monthsShort : 'জানু_ফেব_মার্চ_এপ্র_মে_জুন_জুল_আগ_সেপ্ট_অক্টো_নভে_ডিসে'.split('_'),
    weekdays : 'রবিবার_সোমবার_মঙ্গলবার_বুধবার_বৃহস্পতিবার_শুক্রবার_শনিবার'.split('_'),
    weekdaysShort : 'রবি_সোম_মঙ্গল_বুধ_বৃহস্পতি_শুক্র_শনি'.split('_'),
    weekdaysMin : 'রবি_সোম_মঙ্গ_বুধ_বৃহঃ_শুক্র_শনি'.split('_'),
    longDateFormat : {
        LT : 'A h:mm সময়',
        LTS : 'A h:mm:ss সময়',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm সময়',
        LLLL : 'dddd, D MMMM YYYY, A h:mm সময়'
    },
    calendar : {
        sameDay : '[আজ] LT',
        nextDay : '[আগামীকাল] LT',
        nextWeek : 'dddd, LT',
        lastDay : '[গতকাল] LT',
        lastWeek : '[গত] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s পরে',
        past : '%s আগে',
        s : 'কয়েক সেকেন্ড',
        m : 'এক মিনিট',
        mm : '%d মিনিট',
        h : 'এক ঘন্টা',
        hh : '%d ঘন্টা',
        d : 'এক দিন',
        dd : '%d দিন',
        M : 'এক মাস',
        MM : '%d মাস',
        y : 'এক বছর',
        yy : '%d বছর'
    },
    preparse: function (string) {
        return string.replace(/[১২৩৪৫৬৭৮৯০]/g, function (match) {
            return numberMap$2[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap$3[match];
        });
    },
    meridiemParse: /রাত|সকাল|দুপুর|বিকাল|রাত/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if ((meridiem === 'রাত' && hour >= 4) ||
                (meridiem === 'দুপুর' && hour < 5) ||
                meridiem === 'বিকাল') {
            return hour + 12;
        } else {
            return hour;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return 'রাত';
        } else if (hour < 10) {
            return 'সকাল';
        } else if (hour < 17) {
            return 'দুপুর';
        } else if (hour < 20) {
            return 'বিকাল';
        } else {
            return 'রাত';
        }
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Tibetan [bo]
//! author : Thupten N. Chakrishar : https://github.com/vajradog

var symbolMap$4 = {
    '1': '༡',
    '2': '༢',
    '3': '༣',
    '4': '༤',
    '5': '༥',
    '6': '༦',
    '7': '༧',
    '8': '༨',
    '9': '༩',
    '0': '༠'
};
var numberMap$3 = {
    '༡': '1',
    '༢': '2',
    '༣': '3',
    '༤': '4',
    '༥': '5',
    '༦': '6',
    '༧': '7',
    '༨': '8',
    '༩': '9',
    '༠': '0'
};

hooks.defineLocale('bo', {
    months : 'ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ'.split('_'),
    monthsShort : 'ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ'.split('_'),
    weekdays : 'གཟའ་ཉི་མ་_གཟའ་ཟླ་བ་_གཟའ་མིག་དམར་_གཟའ་ལྷག་པ་_གཟའ་ཕུར་བུ_གཟའ་པ་སངས་_གཟའ་སྤེན་པ་'.split('_'),
    weekdaysShort : 'ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་'.split('_'),
    weekdaysMin : 'ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་'.split('_'),
    longDateFormat : {
        LT : 'A h:mm',
        LTS : 'A h:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm',
        LLLL : 'dddd, D MMMM YYYY, A h:mm'
    },
    calendar : {
        sameDay : '[དི་རིང] LT',
        nextDay : '[སང་ཉིན] LT',
        nextWeek : '[བདུན་ཕྲག་རྗེས་མ], LT',
        lastDay : '[ཁ་སང] LT',
        lastWeek : '[བདུན་ཕྲག་མཐའ་མ] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ལ་',
        past : '%s སྔན་ལ',
        s : 'ལམ་སང',
        m : 'སྐར་མ་གཅིག',
        mm : '%d སྐར་མ',
        h : 'ཆུ་ཚོད་གཅིག',
        hh : '%d ཆུ་ཚོད',
        d : 'ཉིན་གཅིག',
        dd : '%d ཉིན་',
        M : 'ཟླ་བ་གཅིག',
        MM : '%d ཟླ་བ',
        y : 'ལོ་གཅིག',
        yy : '%d ལོ'
    },
    preparse: function (string) {
        return string.replace(/[༡༢༣༤༥༦༧༨༩༠]/g, function (match) {
            return numberMap$3[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap$4[match];
        });
    },
    meridiemParse: /མཚན་མོ|ཞོགས་ཀས|ཉིན་གུང|དགོང་དག|མཚན་མོ/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if ((meridiem === 'མཚན་མོ' && hour >= 4) ||
                (meridiem === 'ཉིན་གུང' && hour < 5) ||
                meridiem === 'དགོང་དག') {
            return hour + 12;
        } else {
            return hour;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return 'མཚན་མོ';
        } else if (hour < 10) {
            return 'ཞོགས་ཀས';
        } else if (hour < 17) {
            return 'ཉིན་གུང';
        } else if (hour < 20) {
            return 'དགོང་དག';
        } else {
            return 'མཚན་མོ';
        }
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Breton [br]
//! author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou

function relativeTimeWithMutation(number, withoutSuffix, key) {
    var format = {
        'mm': 'munutenn',
        'MM': 'miz',
        'dd': 'devezh'
    };
    return number + ' ' + mutation(format[key], number);
}
function specialMutationForYears(number) {
    switch (lastNumber(number)) {
        case 1:
        case 3:
        case 4:
        case 5:
        case 9:
            return number + ' bloaz';
        default:
            return number + ' vloaz';
    }
}
function lastNumber(number) {
    if (number > 9) {
        return lastNumber(number % 10);
    }
    return number;
}
function mutation(text, number) {
    if (number === 2) {
        return softMutation(text);
    }
    return text;
}
function softMutation(text) {
    var mutationTable = {
        'm': 'v',
        'b': 'v',
        'd': 'z'
    };
    if (mutationTable[text.charAt(0)] === undefined) {
        return text;
    }
    return mutationTable[text.charAt(0)] + text.substring(1);
}

hooks.defineLocale('br', {
    months : 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
    monthsShort : 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
    weekdays : 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
    weekdaysShort : 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
    weekdaysMin : 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'h[e]mm A',
        LTS : 'h[e]mm:ss A',
        L : 'DD/MM/YYYY',
        LL : 'D [a viz] MMMM YYYY',
        LLL : 'D [a viz] MMMM YYYY h[e]mm A',
        LLLL : 'dddd, D [a viz] MMMM YYYY h[e]mm A'
    },
    calendar : {
        sameDay : '[Hiziv da] LT',
        nextDay : '[Warc\'hoazh da] LT',
        nextWeek : 'dddd [da] LT',
        lastDay : '[Dec\'h da] LT',
        lastWeek : 'dddd [paset da] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'a-benn %s',
        past : '%s \'zo',
        s : 'un nebeud segondennoù',
        m : 'ur vunutenn',
        mm : relativeTimeWithMutation,
        h : 'un eur',
        hh : '%d eur',
        d : 'un devezh',
        dd : relativeTimeWithMutation,
        M : 'ur miz',
        MM : relativeTimeWithMutation,
        y : 'ur bloaz',
        yy : specialMutationForYears
    },
    dayOfMonthOrdinalParse: /\d{1,2}(añ|vet)/,
    ordinal : function (number) {
        var output = (number === 1) ? 'añ' : 'vet';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Bosnian [bs]
//! author : Nedim Cholich : https://github.com/frontyard
//! based on (hr) translation by Bojan Marković

function translate(number, withoutSuffix, key) {
    var result = number + ' ';
    switch (key) {
        case 'm':
            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
        case 'mm':
            if (number === 1) {
                result += 'minuta';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'minute';
            } else {
                result += 'minuta';
            }
            return result;
        case 'h':
            return withoutSuffix ? 'jedan sat' : 'jednog sata';
        case 'hh':
            if (number === 1) {
                result += 'sat';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'sata';
            } else {
                result += 'sati';
            }
            return result;
        case 'dd':
            if (number === 1) {
                result += 'dan';
            } else {
                result += 'dana';
            }
            return result;
        case 'MM':
            if (number === 1) {
                result += 'mjesec';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'mjeseca';
            } else {
                result += 'mjeseci';
            }
            return result;
        case 'yy':
            if (number === 1) {
                result += 'godina';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'godine';
            } else {
                result += 'godina';
            }
            return result;
    }
}

hooks.defineLocale('bs', {
    months : 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
    monthsShort : 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
    weekdaysShort : 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
    weekdaysMin : 'ne_po_ut_sr_če_pe_su'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY H:mm',
        LLLL : 'dddd, D. MMMM YYYY H:mm'
    },
    calendar : {
        sameDay  : '[danas u] LT',
        nextDay  : '[sutra u] LT',
        nextWeek : function () {
            switch (this.day()) {
                case 0:
                    return '[u] [nedjelju] [u] LT';
                case 3:
                    return '[u] [srijedu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
            }
        },
        lastDay  : '[jučer u] LT',
        lastWeek : function () {
            switch (this.day()) {
                case 0:
                case 3:
                    return '[prošlu] dddd [u] LT';
                case 6:
                    return '[prošle] [subote] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[prošli] dddd [u] LT';
            }
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'za %s',
        past   : 'prije %s',
        s      : 'par sekundi',
        m      : translate,
        mm     : translate,
        h      : translate,
        hh     : translate,
        d      : 'dan',
        dd     : translate,
        M      : 'mjesec',
        MM     : translate,
        y      : 'godinu',
        yy     : translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Catalan [ca]
//! author : Juan G. Hurtado : https://github.com/juanghurtado

hooks.defineLocale('ca', {
    months : {
        standalone: 'gener_febrer_març_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
        format: 'de gener_de febrer_de març_d\'abril_de maig_de juny_de juliol_d\'agost_de setembre_d\'octubre_de novembre_de desembre'.split('_'),
        isFormat: /D[oD]?(\s)+MMMM/
    },
    monthsShort : 'gen._febr._març_abr._maig_juny_jul._ag._set._oct._nov._des.'.split('_'),
    monthsParseExact : true,
    weekdays : 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
    weekdaysShort : 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
    weekdaysMin : 'Dg_Dl_Dt_Dc_Dj_Dv_Ds'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD/MM/YYYY',
        LL : '[el] D MMMM [de] YYYY',
        ll : 'D MMM YYYY',
        LLL : '[el] D MMMM [de] YYYY [a les] H:mm',
        lll : 'D MMM YYYY, H:mm',
        LLLL : '[el] dddd D MMMM [de] YYYY [a les] H:mm',
        llll : 'ddd D MMM YYYY, H:mm'
    },
    calendar : {
        sameDay : function () {
            return '[avui a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
        },
        nextDay : function () {
            return '[demà a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
        },
        nextWeek : function () {
            return 'dddd [a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
        },
        lastDay : function () {
            return '[ahir a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
        },
        lastWeek : function () {
            return '[el] dddd [passat a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'd\'aquí %s',
        past : 'fa %s',
        s : 'uns segons',
        m : 'un minut',
        mm : '%d minuts',
        h : 'una hora',
        hh : '%d hores',
        d : 'un dia',
        dd : '%d dies',
        M : 'un mes',
        MM : '%d mesos',
        y : 'un any',
        yy : '%d anys'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(r|n|t|è|a)/,
    ordinal : function (number, period) {
        var output = (number === 1) ? 'r' :
            (number === 2) ? 'n' :
            (number === 3) ? 'r' :
            (number === 4) ? 't' : 'è';
        if (period === 'w' || period === 'W') {
            output = 'a';
        }
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Czech [cs]
//! author : petrbela : https://github.com/petrbela

var months$3 = 'leden_únor_březen_duben_květen_červen_červenec_srpen_září_říjen_listopad_prosinec'.split('_');
var monthsShort = 'led_úno_bře_dub_kvě_čvn_čvc_srp_zář_říj_lis_pro'.split('_');
function plural$1(n) {
    return (n > 1) && (n < 5) && (~~(n / 10) !== 1);
}
function translate$1(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';
    switch (key) {
        case 's':  // a few seconds / in a few seconds / a few seconds ago
            return (withoutSuffix || isFuture) ? 'pár sekund' : 'pár sekundami';
        case 'm':  // a minute / in a minute / a minute ago
            return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');
        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
            if (withoutSuffix || isFuture) {
                return result + (plural$1(number) ? 'minuty' : 'minut');
            } else {
                return result + 'minutami';
            }
            break;
        case 'h':  // an hour / in an hour / an hour ago
            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
        case 'hh': // 9 hours / in 9 hours / 9 hours ago
            if (withoutSuffix || isFuture) {
                return result + (plural$1(number) ? 'hodiny' : 'hodin');
            } else {
                return result + 'hodinami';
            }
            break;
        case 'd':  // a day / in a day / a day ago
            return (withoutSuffix || isFuture) ? 'den' : 'dnem';
        case 'dd': // 9 days / in 9 days / 9 days ago
            if (withoutSuffix || isFuture) {
                return result + (plural$1(number) ? 'dny' : 'dní');
            } else {
                return result + 'dny';
            }
            break;
        case 'M':  // a month / in a month / a month ago
            return (withoutSuffix || isFuture) ? 'měsíc' : 'měsícem';
        case 'MM': // 9 months / in 9 months / 9 months ago
            if (withoutSuffix || isFuture) {
                return result + (plural$1(number) ? 'měsíce' : 'měsíců');
            } else {
                return result + 'měsíci';
            }
            break;
        case 'y':  // a year / in a year / a year ago
            return (withoutSuffix || isFuture) ? 'rok' : 'rokem';
        case 'yy': // 9 years / in 9 years / 9 years ago
            if (withoutSuffix || isFuture) {
                return result + (plural$1(number) ? 'roky' : 'let');
            } else {
                return result + 'lety';
            }
            break;
    }
}

hooks.defineLocale('cs', {
    months : months$3,
    monthsShort : monthsShort,
    monthsParse : (function (months, monthsShort) {
        var i, _monthsParse = [];
        for (i = 0; i < 12; i++) {
            // use custom parser to solve problem with July (červenec)
            _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
        }
        return _monthsParse;
    }(months$3, monthsShort)),
    shortMonthsParse : (function (monthsShort) {
        var i, _shortMonthsParse = [];
        for (i = 0; i < 12; i++) {
            _shortMonthsParse[i] = new RegExp('^' + monthsShort[i] + '$', 'i');
        }
        return _shortMonthsParse;
    }(monthsShort)),
    longMonthsParse : (function (months) {
        var i, _longMonthsParse = [];
        for (i = 0; i < 12; i++) {
            _longMonthsParse[i] = new RegExp('^' + months[i] + '$', 'i');
        }
        return _longMonthsParse;
    }(months$3)),
    weekdays : 'neděle_pondělí_úterý_středa_čtvrtek_pátek_sobota'.split('_'),
    weekdaysShort : 'ne_po_út_st_čt_pá_so'.split('_'),
    weekdaysMin : 'ne_po_út_st_čt_pá_so'.split('_'),
    longDateFormat : {
        LT: 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY H:mm',
        LLLL : 'dddd D. MMMM YYYY H:mm',
        l : 'D. M. YYYY'
    },
    calendar : {
        sameDay: '[dnes v] LT',
        nextDay: '[zítra v] LT',
        nextWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[v neděli v] LT';
                case 1:
                case 2:
                    return '[v] dddd [v] LT';
                case 3:
                    return '[ve středu v] LT';
                case 4:
                    return '[ve čtvrtek v] LT';
                case 5:
                    return '[v pátek v] LT';
                case 6:
                    return '[v sobotu v] LT';
            }
        },
        lastDay: '[včera v] LT',
        lastWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[minulou neděli v] LT';
                case 1:
                case 2:
                    return '[minulé] dddd [v] LT';
                case 3:
                    return '[minulou středu v] LT';
                case 4:
                case 5:
                    return '[minulý] dddd [v] LT';
                case 6:
                    return '[minulou sobotu v] LT';
            }
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : 'za %s',
        past : 'před %s',
        s : translate$1,
        m : translate$1,
        mm : translate$1,
        h : translate$1,
        hh : translate$1,
        d : translate$1,
        dd : translate$1,
        M : translate$1,
        MM : translate$1,
        y : translate$1,
        yy : translate$1
    },
    dayOfMonthOrdinalParse : /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Chuvash [cv]
//! author : Anatoly Mironov : https://github.com/mirontoli

hooks.defineLocale('cv', {
    months : 'кӑрлач_нарӑс_пуш_ака_май_ҫӗртме_утӑ_ҫурла_авӑн_юпа_чӳк_раштав'.split('_'),
    monthsShort : 'кӑр_нар_пуш_ака_май_ҫӗр_утӑ_ҫур_авн_юпа_чӳк_раш'.split('_'),
    weekdays : 'вырсарникун_тунтикун_ытларикун_юнкун_кӗҫнерникун_эрнекун_шӑматкун'.split('_'),
    weekdaysShort : 'выр_тун_ытл_юн_кӗҫ_эрн_шӑм'.split('_'),
    weekdaysMin : 'вр_тн_ыт_юн_кҫ_эр_шм'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD-MM-YYYY',
        LL : 'YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ]',
        LLL : 'YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm',
        LLLL : 'dddd, YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm'
    },
    calendar : {
        sameDay: '[Паян] LT [сехетре]',
        nextDay: '[Ыран] LT [сехетре]',
        lastDay: '[Ӗнер] LT [сехетре]',
        nextWeek: '[Ҫитес] dddd LT [сехетре]',
        lastWeek: '[Иртнӗ] dddd LT [сехетре]',
        sameElse: 'L'
    },
    relativeTime : {
        future : function (output) {
            var affix = /сехет$/i.exec(output) ? 'рен' : /ҫул$/i.exec(output) ? 'тан' : 'ран';
            return output + affix;
        },
        past : '%s каялла',
        s : 'пӗр-ик ҫеккунт',
        m : 'пӗр минут',
        mm : '%d минут',
        h : 'пӗр сехет',
        hh : '%d сехет',
        d : 'пӗр кун',
        dd : '%d кун',
        M : 'пӗр уйӑх',
        MM : '%d уйӑх',
        y : 'пӗр ҫул',
        yy : '%d ҫул'
    },
    dayOfMonthOrdinalParse: /\d{1,2}-мӗш/,
    ordinal : '%d-мӗш',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Welsh [cy]
//! author : Robert Allen : https://github.com/robgallen
//! author : https://github.com/ryangreaves

hooks.defineLocale('cy', {
    months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
    monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
    weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
    weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
    weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
    weekdaysParseExact : true,
    // time formats are the same as en-gb
    longDateFormat: {
        LT: 'HH:mm',
        LTS : 'HH:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
        sameDay: '[Heddiw am] LT',
        nextDay: '[Yfory am] LT',
        nextWeek: 'dddd [am] LT',
        lastDay: '[Ddoe am] LT',
        lastWeek: 'dddd [diwethaf am] LT',
        sameElse: 'L'
    },
    relativeTime: {
        future: 'mewn %s',
        past: '%s yn ôl',
        s: 'ychydig eiliadau',
        m: 'munud',
        mm: '%d munud',
        h: 'awr',
        hh: '%d awr',
        d: 'diwrnod',
        dd: '%d diwrnod',
        M: 'mis',
        MM: '%d mis',
        y: 'blwyddyn',
        yy: '%d flynedd'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
    // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
    ordinal: function (number) {
        var b = number,
            output = '',
            lookup = [
                '', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
                'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
            ];
        if (b > 20) {
            if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
                output = 'fed'; // not 30ain, 70ain or 90ain
            } else {
                output = 'ain';
            }
        } else if (b > 0) {
            output = lookup[b];
        }
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Danish [da]
//! author : Ulrik Nielsen : https://github.com/mrbase

hooks.defineLocale('da', {
    months : 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
    monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
    weekdays : 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
    weekdaysShort : 'søn_man_tir_ons_tor_fre_lør'.split('_'),
    weekdaysMin : 'sø_ma_ti_on_to_fr_lø'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY HH:mm',
        LLLL : 'dddd [d.] D. MMMM YYYY [kl.] HH:mm'
    },
    calendar : {
        sameDay : '[i dag kl.] LT',
        nextDay : '[i morgen kl.] LT',
        nextWeek : 'på dddd [kl.] LT',
        lastDay : '[i går kl.] LT',
        lastWeek : '[i] dddd[s kl.] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'om %s',
        past : '%s siden',
        s : 'få sekunder',
        m : 'et minut',
        mm : '%d minutter',
        h : 'en time',
        hh : '%d timer',
        d : 'en dag',
        dd : '%d dage',
        M : 'en måned',
        MM : '%d måneder',
        y : 'et år',
        yy : '%d år'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : German (Austria) [de-at]
//! author : lluchs : https://github.com/lluchs
//! author: Menelion Elensúle: https://github.com/Oire
//! author : Martin Groller : https://github.com/MadMG
//! author : Mikolaj Dadela : https://github.com/mik01aj

function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
        'm': ['eine Minute', 'einer Minute'],
        'h': ['eine Stunde', 'einer Stunde'],
        'd': ['ein Tag', 'einem Tag'],
        'dd': [number + ' Tage', number + ' Tagen'],
        'M': ['ein Monat', 'einem Monat'],
        'MM': [number + ' Monate', number + ' Monaten'],
        'y': ['ein Jahr', 'einem Jahr'],
        'yy': [number + ' Jahre', number + ' Jahren']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
}

hooks.defineLocale('de-at', {
    months : 'Jänner_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort : 'Jän._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
    monthsParseExact : true,
    weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
    weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
    weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY HH:mm',
        LLLL : 'dddd, D. MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[heute um] LT [Uhr]',
        sameElse: 'L',
        nextDay: '[morgen um] LT [Uhr]',
        nextWeek: 'dddd [um] LT [Uhr]',
        lastDay: '[gestern um] LT [Uhr]',
        lastWeek: '[letzten] dddd [um] LT [Uhr]'
    },
    relativeTime : {
        future : 'in %s',
        past : 'vor %s',
        s : 'ein paar Sekunden',
        m : processRelativeTime,
        mm : '%d Minuten',
        h : processRelativeTime,
        hh : '%d Stunden',
        d : processRelativeTime,
        dd : processRelativeTime,
        M : processRelativeTime,
        MM : processRelativeTime,
        y : processRelativeTime,
        yy : processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : German (Switzerland) [de-ch]
//! author : sschueller : https://github.com/sschueller

// based on: https://www.bk.admin.ch/dokumentation/sprachen/04915/05016/index.html?lang=de#

function processRelativeTime$1(number, withoutSuffix, key, isFuture) {
    var format = {
        'm': ['eine Minute', 'einer Minute'],
        'h': ['eine Stunde', 'einer Stunde'],
        'd': ['ein Tag', 'einem Tag'],
        'dd': [number + ' Tage', number + ' Tagen'],
        'M': ['ein Monat', 'einem Monat'],
        'MM': [number + ' Monate', number + ' Monaten'],
        'y': ['ein Jahr', 'einem Jahr'],
        'yy': [number + ' Jahre', number + ' Jahren']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
}

hooks.defineLocale('de-ch', {
    months : 'Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort : 'Jan._Febr._März_April_Mai_Juni_Juli_Aug._Sept._Okt._Nov._Dez.'.split('_'),
    monthsParseExact : true,
    weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
    weekdaysShort : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT: 'HH.mm',
        LTS: 'HH.mm.ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY HH.mm',
        LLLL : 'dddd, D. MMMM YYYY HH.mm'
    },
    calendar : {
        sameDay: '[heute um] LT [Uhr]',
        sameElse: 'L',
        nextDay: '[morgen um] LT [Uhr]',
        nextWeek: 'dddd [um] LT [Uhr]',
        lastDay: '[gestern um] LT [Uhr]',
        lastWeek: '[letzten] dddd [um] LT [Uhr]'
    },
    relativeTime : {
        future : 'in %s',
        past : 'vor %s',
        s : 'ein paar Sekunden',
        m : processRelativeTime$1,
        mm : '%d Minuten',
        h : processRelativeTime$1,
        hh : '%d Stunden',
        d : processRelativeTime$1,
        dd : processRelativeTime$1,
        M : processRelativeTime$1,
        MM : processRelativeTime$1,
        y : processRelativeTime$1,
        yy : processRelativeTime$1
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : German [de]
//! author : lluchs : https://github.com/lluchs
//! author: Menelion Elensúle: https://github.com/Oire
//! author : Mikolaj Dadela : https://github.com/mik01aj

function processRelativeTime$2(number, withoutSuffix, key, isFuture) {
    var format = {
        'm': ['eine Minute', 'einer Minute'],
        'h': ['eine Stunde', 'einer Stunde'],
        'd': ['ein Tag', 'einem Tag'],
        'dd': [number + ' Tage', number + ' Tagen'],
        'M': ['ein Monat', 'einem Monat'],
        'MM': [number + ' Monate', number + ' Monaten'],
        'y': ['ein Jahr', 'einem Jahr'],
        'yy': [number + ' Jahre', number + ' Jahren']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
}

hooks.defineLocale('de', {
    months : 'Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort : 'Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
    monthsParseExact : true,
    weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
    weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
    weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY HH:mm',
        LLLL : 'dddd, D. MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[heute um] LT [Uhr]',
        sameElse: 'L',
        nextDay: '[morgen um] LT [Uhr]',
        nextWeek: 'dddd [um] LT [Uhr]',
        lastDay: '[gestern um] LT [Uhr]',
        lastWeek: '[letzten] dddd [um] LT [Uhr]'
    },
    relativeTime : {
        future : 'in %s',
        past : 'vor %s',
        s : 'ein paar Sekunden',
        m : processRelativeTime$2,
        mm : '%d Minuten',
        h : processRelativeTime$2,
        hh : '%d Stunden',
        d : processRelativeTime$2,
        dd : processRelativeTime$2,
        M : processRelativeTime$2,
        MM : processRelativeTime$2,
        y : processRelativeTime$2,
        yy : processRelativeTime$2
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Maldivian [dv]
//! author : Jawish Hameed : https://github.com/jawish

var months$4 = [
    'ޖެނުއަރީ',
    'ފެބްރުއަރީ',
    'މާރިޗު',
    'އޭޕްރީލު',
    'މޭ',
    'ޖޫން',
    'ޖުލައި',
    'އޯގަސްޓު',
    'ސެޕްޓެމްބަރު',
    'އޮކްޓޯބަރު',
    'ނޮވެމްބަރު',
    'ޑިސެމްބަރު'
];
var weekdays = [
    'އާދިއްތަ',
    'ހޯމަ',
    'އަންގާރަ',
    'ބުދަ',
    'ބުރާސްފަތި',
    'ހުކުރު',
    'ހޮނިހިރު'
];

hooks.defineLocale('dv', {
    months : months$4,
    monthsShort : months$4,
    weekdays : weekdays,
    weekdaysShort : weekdays,
    weekdaysMin : 'އާދި_ހޯމަ_އަން_ބުދަ_ބުރާ_ހުކު_ހޮނި'.split('_'),
    longDateFormat : {

        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'D/M/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /މކ|މފ/,
    isPM : function (input) {
        return 'މފ' === input;
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return 'މކ';
        } else {
            return 'މފ';
        }
    },
    calendar : {
        sameDay : '[މިއަދު] LT',
        nextDay : '[މާދަމާ] LT',
        nextWeek : 'dddd LT',
        lastDay : '[އިއްޔެ] LT',
        lastWeek : '[ފާއިތުވި] dddd LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'ތެރޭގައި %s',
        past : 'ކުރިން %s',
        s : 'ސިކުންތުކޮޅެއް',
        m : 'މިނިޓެއް',
        mm : 'މިނިޓު %d',
        h : 'ގަޑިއިރެއް',
        hh : 'ގަޑިއިރު %d',
        d : 'ދުވަހެއް',
        dd : 'ދުވަސް %d',
        M : 'މަހެއް',
        MM : 'މަސް %d',
        y : 'އަހަރެއް',
        yy : 'އަހަރު %d'
    },
    preparse: function (string) {
        return string.replace(/،/g, ',');
    },
    postformat: function (string) {
        return string.replace(/,/g, '،');
    },
    week : {
        dow : 7,  // Sunday is the first day of the week.
        doy : 12  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Greek [el]
//! author : Aggelos Karalias : https://github.com/mehiel

hooks.defineLocale('el', {
    monthsNominativeEl : 'Ιανουάριος_Φεβρουάριος_Μάρτιος_Απρίλιος_Μάιος_Ιούνιος_Ιούλιος_Αύγουστος_Σεπτέμβριος_Οκτώβριος_Νοέμβριος_Δεκέμβριος'.split('_'),
    monthsGenitiveEl : 'Ιανουαρίου_Φεβρουαρίου_Μαρτίου_Απριλίου_Μαΐου_Ιουνίου_Ιουλίου_Αυγούστου_Σεπτεμβρίου_Οκτωβρίου_Νοεμβρίου_Δεκεμβρίου'.split('_'),
    months : function (momentToFormat, format) {
        if (!momentToFormat) {
            return this._monthsNominativeEl;
        } else if (/D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'
            return this._monthsGenitiveEl[momentToFormat.month()];
        } else {
            return this._monthsNominativeEl[momentToFormat.month()];
        }
    },
    monthsShort : 'Ιαν_Φεβ_Μαρ_Απρ_Μαϊ_Ιουν_Ιουλ_Αυγ_Σεπ_Οκτ_Νοε_Δεκ'.split('_'),
    weekdays : 'Κυριακή_Δευτέρα_Τρίτη_Τετάρτη_Πέμπτη_Παρασκευή_Σάββατο'.split('_'),
    weekdaysShort : 'Κυρ_Δευ_Τρι_Τετ_Πεμ_Παρ_Σαβ'.split('_'),
    weekdaysMin : 'Κυ_Δε_Τρ_Τε_Πε_Πα_Σα'.split('_'),
    meridiem : function (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'μμ' : 'ΜΜ';
        } else {
            return isLower ? 'πμ' : 'ΠΜ';
        }
    },
    isPM : function (input) {
        return ((input + '').toLowerCase()[0] === 'μ');
    },
    meridiemParse : /[ΠΜ]\.?Μ?\.?/i,
    longDateFormat : {
        LT : 'h:mm A',
        LTS : 'h:mm:ss A',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY h:mm A',
        LLLL : 'dddd, D MMMM YYYY h:mm A'
    },
    calendarEl : {
        sameDay : '[Σήμερα {}] LT',
        nextDay : '[Αύριο {}] LT',
        nextWeek : 'dddd [{}] LT',
        lastDay : '[Χθες {}] LT',
        lastWeek : function () {
            switch (this.day()) {
                case 6:
                    return '[το προηγούμενο] dddd [{}] LT';
                default:
                    return '[την προηγούμενη] dddd [{}] LT';
            }
        },
        sameElse : 'L'
    },
    calendar : function (key, mom) {
        var output = this._calendarEl[key],
            hours = mom && mom.hours();
        if (isFunction(output)) {
            output = output.apply(mom);
        }
        return output.replace('{}', (hours % 12 === 1 ? 'στη' : 'στις'));
    },
    relativeTime : {
        future : 'σε %s',
        past : '%s πριν',
        s : 'λίγα δευτερόλεπτα',
        m : 'ένα λεπτό',
        mm : '%d λεπτά',
        h : 'μία ώρα',
        hh : '%d ώρες',
        d : 'μία μέρα',
        dd : '%d μέρες',
        M : 'ένας μήνας',
        MM : '%d μήνες',
        y : 'ένας χρόνος',
        yy : '%d χρόνια'
    },
    dayOfMonthOrdinalParse: /\d{1,2}η/,
    ordinal: '%dη',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : English (Australia) [en-au]
//! author : Jared Morse : https://github.com/jarcoal

hooks.defineLocale('en-au', {
    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat : {
        LT : 'h:mm A',
        LTS : 'h:mm:ss A',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY h:mm A',
        LLLL : 'dddd, D MMMM YYYY h:mm A'
    },
    calendar : {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'in %s',
        past : '%s ago',
        s : 'a few seconds',
        m : 'a minute',
        mm : '%d minutes',
        h : 'an hour',
        hh : '%d hours',
        d : 'a day',
        dd : '%d days',
        M : 'a month',
        MM : '%d months',
        y : 'a year',
        yy : '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (~~(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : English (Canada) [en-ca]
//! author : Jonathan Abourbih : https://github.com/jonbca

hooks.defineLocale('en-ca', {
    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat : {
        LT : 'h:mm A',
        LTS : 'h:mm:ss A',
        L : 'YYYY-MM-DD',
        LL : 'MMMM D, YYYY',
        LLL : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    },
    calendar : {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'in %s',
        past : '%s ago',
        s : 'a few seconds',
        m : 'a minute',
        mm : '%d minutes',
        h : 'an hour',
        hh : '%d hours',
        d : 'a day',
        dd : '%d days',
        M : 'a month',
        MM : '%d months',
        y : 'a year',
        yy : '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (~~(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    }
});

//! moment.js locale configuration
//! locale : English (United Kingdom) [en-gb]
//! author : Chris Gedrim : https://github.com/chrisgedrim

hooks.defineLocale('en-gb', {
    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'in %s',
        past : '%s ago',
        s : 'a few seconds',
        m : 'a minute',
        mm : '%d minutes',
        h : 'an hour',
        hh : '%d hours',
        d : 'a day',
        dd : '%d days',
        M : 'a month',
        MM : '%d months',
        y : 'a year',
        yy : '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (~~(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : English (Ireland) [en-ie]
//! author : Chris Cartlidge : https://github.com/chriscartlidge

hooks.defineLocale('en-ie', {
    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD-MM-YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'in %s',
        past : '%s ago',
        s : 'a few seconds',
        m : 'a minute',
        mm : '%d minutes',
        h : 'an hour',
        hh : '%d hours',
        d : 'a day',
        dd : '%d days',
        M : 'a month',
        MM : '%d months',
        y : 'a year',
        yy : '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (~~(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : English (New Zealand) [en-nz]
//! author : Luke McGregor : https://github.com/lukemcgregor

hooks.defineLocale('en-nz', {
    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat : {
        LT : 'h:mm A',
        LTS : 'h:mm:ss A',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY h:mm A',
        LLLL : 'dddd, D MMMM YYYY h:mm A'
    },
    calendar : {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'in %s',
        past : '%s ago',
        s : 'a few seconds',
        m : 'a minute',
        mm : '%d minutes',
        h : 'an hour',
        hh : '%d hours',
        d : 'a day',
        dd : '%d days',
        M : 'a month',
        MM : '%d months',
        y : 'a year',
        yy : '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (~~(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Esperanto [eo]
//! author : Colin Dean : https://github.com/colindean
//! author : Mia Nordentoft Imperatori : https://github.com/miestasmia
//! comment : miestasmia corrected the translation by colindean

hooks.defineLocale('eo', {
    months : 'januaro_februaro_marto_aprilo_majo_junio_julio_aŭgusto_septembro_oktobro_novembro_decembro'.split('_'),
    monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aŭg_sep_okt_nov_dec'.split('_'),
    weekdays : 'dimanĉo_lundo_mardo_merkredo_ĵaŭdo_vendredo_sabato'.split('_'),
    weekdaysShort : 'dim_lun_mard_merk_ĵaŭ_ven_sab'.split('_'),
    weekdaysMin : 'di_lu_ma_me_ĵa_ve_sa'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYY-MM-DD',
        LL : 'D[-a de] MMMM, YYYY',
        LLL : 'D[-a de] MMMM, YYYY HH:mm',
        LLLL : 'dddd, [la] D[-a de] MMMM, YYYY HH:mm'
    },
    meridiemParse: /[ap]\.t\.m/i,
    isPM: function (input) {
        return input.charAt(0).toLowerCase() === 'p';
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'p.t.m.' : 'P.T.M.';
        } else {
            return isLower ? 'a.t.m.' : 'A.T.M.';
        }
    },
    calendar : {
        sameDay : '[Hodiaŭ je] LT',
        nextDay : '[Morgaŭ je] LT',
        nextWeek : 'dddd [je] LT',
        lastDay : '[Hieraŭ je] LT',
        lastWeek : '[pasinta] dddd [je] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'post %s',
        past : 'antaŭ %s',
        s : 'sekundoj',
        m : 'minuto',
        mm : '%d minutoj',
        h : 'horo',
        hh : '%d horoj',
        d : 'tago',//ne 'diurno', ĉar estas uzita por proksimumo
        dd : '%d tagoj',
        M : 'monato',
        MM : '%d monatoj',
        y : 'jaro',
        yy : '%d jaroj'
    },
    dayOfMonthOrdinalParse: /\d{1,2}a/,
    ordinal : '%da',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Spanish (Dominican Republic) [es-do]

var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_');
var monthsShort$1 = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

hooks.defineLocale('es-do', {
    months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
    monthsShort : function (m, format) {
        if (!m) {
            return monthsShortDot;
        } else if (/-MMM-/.test(format)) {
            return monthsShort$1[m.month()];
        } else {
            return monthsShortDot[m.month()];
        }
    },
    monthsParseExact : true,
    weekdays : 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
    weekdaysShort : 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
    weekdaysMin : 'do_lu_ma_mi_ju_vi_sá'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'h:mm A',
        LTS : 'h:mm:ss A',
        L : 'DD/MM/YYYY',
        LL : 'D [de] MMMM [de] YYYY',
        LLL : 'D [de] MMMM [de] YYYY h:mm A',
        LLLL : 'dddd, D [de] MMMM [de] YYYY h:mm A'
    },
    calendar : {
        sameDay : function () {
            return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        nextDay : function () {
            return '[mañana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        nextWeek : function () {
            return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        lastDay : function () {
            return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        lastWeek : function () {
            return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'en %s',
        past : 'hace %s',
        s : 'unos segundos',
        m : 'un minuto',
        mm : '%d minutos',
        h : 'una hora',
        hh : '%d horas',
        d : 'un día',
        dd : '%d días',
        M : 'un mes',
        MM : '%d meses',
        y : 'un año',
        yy : '%d años'
    },
    dayOfMonthOrdinalParse : /\d{1,2}º/,
    ordinal : '%dº',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Spanish [es]
//! author : Julio Napurí : https://github.com/julionc

var monthsShortDot$1 = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_');
var monthsShort$2 = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');

hooks.defineLocale('es', {
    months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
    monthsShort : function (m, format) {
        if (!m) {
            return monthsShortDot$1;
        } else if (/-MMM-/.test(format)) {
            return monthsShort$2[m.month()];
        } else {
            return monthsShortDot$1[m.month()];
        }
    },
    monthsParseExact : true,
    weekdays : 'domingo_lunes_martes_miércoles_jueves_viernes_sábado'.split('_'),
    weekdaysShort : 'dom._lun._mar._mié._jue._vie._sáb.'.split('_'),
    weekdaysMin : 'do_lu_ma_mi_ju_vi_sá'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D [de] MMMM [de] YYYY',
        LLL : 'D [de] MMMM [de] YYYY H:mm',
        LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
    },
    calendar : {
        sameDay : function () {
            return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        nextDay : function () {
            return '[mañana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        nextWeek : function () {
            return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        lastDay : function () {
            return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        lastWeek : function () {
            return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'en %s',
        past : 'hace %s',
        s : 'unos segundos',
        m : 'un minuto',
        mm : '%d minutos',
        h : 'una hora',
        hh : '%d horas',
        d : 'un día',
        dd : '%d días',
        M : 'un mes',
        MM : '%d meses',
        y : 'un año',
        yy : '%d años'
    },
    dayOfMonthOrdinalParse : /\d{1,2}º/,
    ordinal : '%dº',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Estonian [et]
//! author : Henry Kehlmann : https://github.com/madhenry
//! improvements : Illimar Tambek : https://github.com/ragulka

function processRelativeTime$3(number, withoutSuffix, key, isFuture) {
    var format = {
        's' : ['mõne sekundi', 'mõni sekund', 'paar sekundit'],
        'm' : ['ühe minuti', 'üks minut'],
        'mm': [number + ' minuti', number + ' minutit'],
        'h' : ['ühe tunni', 'tund aega', 'üks tund'],
        'hh': [number + ' tunni', number + ' tundi'],
        'd' : ['ühe päeva', 'üks päev'],
        'M' : ['kuu aja', 'kuu aega', 'üks kuu'],
        'MM': [number + ' kuu', number + ' kuud'],
        'y' : ['ühe aasta', 'aasta', 'üks aasta'],
        'yy': [number + ' aasta', number + ' aastat']
    };
    if (withoutSuffix) {
        return format[key][2] ? format[key][2] : format[key][1];
    }
    return isFuture ? format[key][0] : format[key][1];
}

hooks.defineLocale('et', {
    months        : 'jaanuar_veebruar_märts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
    monthsShort   : 'jaan_veebr_märts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
    weekdays      : 'pühapäev_esmaspäev_teisipäev_kolmapäev_neljapäev_reede_laupäev'.split('_'),
    weekdaysShort : 'P_E_T_K_N_R_L'.split('_'),
    weekdaysMin   : 'P_E_T_K_N_R_L'.split('_'),
    longDateFormat : {
        LT   : 'H:mm',
        LTS : 'H:mm:ss',
        L    : 'DD.MM.YYYY',
        LL   : 'D. MMMM YYYY',
        LLL  : 'D. MMMM YYYY H:mm',
        LLLL : 'dddd, D. MMMM YYYY H:mm'
    },
    calendar : {
        sameDay  : '[Täna,] LT',
        nextDay  : '[Homme,] LT',
        nextWeek : '[Järgmine] dddd LT',
        lastDay  : '[Eile,] LT',
        lastWeek : '[Eelmine] dddd LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s pärast',
        past   : '%s tagasi',
        s      : processRelativeTime$3,
        m      : processRelativeTime$3,
        mm     : processRelativeTime$3,
        h      : processRelativeTime$3,
        hh     : processRelativeTime$3,
        d      : processRelativeTime$3,
        dd     : '%d päeva',
        M      : processRelativeTime$3,
        MM     : processRelativeTime$3,
        y      : processRelativeTime$3,
        yy     : processRelativeTime$3
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Basque [eu]
//! author : Eneko Illarramendi : https://github.com/eillarra

hooks.defineLocale('eu', {
    months : 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
    monthsShort : 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
    monthsParseExact : true,
    weekdays : 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
    weekdaysShort : 'ig._al._ar._az._og._ol._lr.'.split('_'),
    weekdaysMin : 'ig_al_ar_az_og_ol_lr'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYY-MM-DD',
        LL : 'YYYY[ko] MMMM[ren] D[a]',
        LLL : 'YYYY[ko] MMMM[ren] D[a] HH:mm',
        LLLL : 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
        l : 'YYYY-M-D',
        ll : 'YYYY[ko] MMM D[a]',
        lll : 'YYYY[ko] MMM D[a] HH:mm',
        llll : 'ddd, YYYY[ko] MMM D[a] HH:mm'
    },
    calendar : {
        sameDay : '[gaur] LT[etan]',
        nextDay : '[bihar] LT[etan]',
        nextWeek : 'dddd LT[etan]',
        lastDay : '[atzo] LT[etan]',
        lastWeek : '[aurreko] dddd LT[etan]',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s barru',
        past : 'duela %s',
        s : 'segundo batzuk',
        m : 'minutu bat',
        mm : '%d minutu',
        h : 'ordu bat',
        hh : '%d ordu',
        d : 'egun bat',
        dd : '%d egun',
        M : 'hilabete bat',
        MM : '%d hilabete',
        y : 'urte bat',
        yy : '%d urte'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Persian [fa]
//! author : Ebrahim Byagowi : https://github.com/ebraminio

var symbolMap$5 = {
    '1': '۱',
    '2': '۲',
    '3': '۳',
    '4': '۴',
    '5': '۵',
    '6': '۶',
    '7': '۷',
    '8': '۸',
    '9': '۹',
    '0': '۰'
};
var numberMap$4 = {
    '۱': '1',
    '۲': '2',
    '۳': '3',
    '۴': '4',
    '۵': '5',
    '۶': '6',
    '۷': '7',
    '۸': '8',
    '۹': '9',
    '۰': '0'
};

hooks.defineLocale('fa', {
    months : 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split('_'),
    monthsShort : 'ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر'.split('_'),
    weekdays : 'یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه'.split('_'),
    weekdaysShort : 'یک\u200cشنبه_دوشنبه_سه\u200cشنبه_چهارشنبه_پنج\u200cشنبه_جمعه_شنبه'.split('_'),
    weekdaysMin : 'ی_د_س_چ_پ_ج_ش'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    meridiemParse: /قبل از ظهر|بعد از ظهر/,
    isPM: function (input) {
        return /بعد از ظهر/.test(input);
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return 'قبل از ظهر';
        } else {
            return 'بعد از ظهر';
        }
    },
    calendar : {
        sameDay : '[امروز ساعت] LT',
        nextDay : '[فردا ساعت] LT',
        nextWeek : 'dddd [ساعت] LT',
        lastDay : '[دیروز ساعت] LT',
        lastWeek : 'dddd [پیش] [ساعت] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'در %s',
        past : '%s پیش',
        s : 'چند ثانیه',
        m : 'یک دقیقه',
        mm : '%d دقیقه',
        h : 'یک ساعت',
        hh : '%d ساعت',
        d : 'یک روز',
        dd : '%d روز',
        M : 'یک ماه',
        MM : '%d ماه',
        y : 'یک سال',
        yy : '%d سال'
    },
    preparse: function (string) {
        return string.replace(/[۰-۹]/g, function (match) {
            return numberMap$4[match];
        }).replace(/،/g, ',');
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap$5[match];
        }).replace(/,/g, '،');
    },
    dayOfMonthOrdinalParse: /\d{1,2}م/,
    ordinal : '%dم',
    week : {
        dow : 6, // Saturday is the first day of the week.
        doy : 12 // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Finnish [fi]
//! author : Tarmo Aidantausta : https://github.com/bleadof

var numbersPast = 'nolla yksi kaksi kolme neljä viisi kuusi seitsemän kahdeksan yhdeksän'.split(' ');
var numbersFuture = [
        'nolla', 'yhden', 'kahden', 'kolmen', 'neljän', 'viiden', 'kuuden',
        numbersPast[7], numbersPast[8], numbersPast[9]
    ];
function translate$2(number, withoutSuffix, key, isFuture) {
    var result = '';
    switch (key) {
        case 's':
            return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
        case 'm':
            return isFuture ? 'minuutin' : 'minuutti';
        case 'mm':
            result = isFuture ? 'minuutin' : 'minuuttia';
            break;
        case 'h':
            return isFuture ? 'tunnin' : 'tunti';
        case 'hh':
            result = isFuture ? 'tunnin' : 'tuntia';
            break;
        case 'd':
            return isFuture ? 'päivän' : 'päivä';
        case 'dd':
            result = isFuture ? 'päivän' : 'päivää';
            break;
        case 'M':
            return isFuture ? 'kuukauden' : 'kuukausi';
        case 'MM':
            result = isFuture ? 'kuukauden' : 'kuukautta';
            break;
        case 'y':
            return isFuture ? 'vuoden' : 'vuosi';
        case 'yy':
            result = isFuture ? 'vuoden' : 'vuotta';
            break;
    }
    result = verbalNumber(number, isFuture) + ' ' + result;
    return result;
}
function verbalNumber(number, isFuture) {
    return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
}

hooks.defineLocale('fi', {
    months : 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kesäkuu_heinäkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
    monthsShort : 'tammi_helmi_maalis_huhti_touko_kesä_heinä_elo_syys_loka_marras_joulu'.split('_'),
    weekdays : 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
    weekdaysShort : 'su_ma_ti_ke_to_pe_la'.split('_'),
    weekdaysMin : 'su_ma_ti_ke_to_pe_la'.split('_'),
    longDateFormat : {
        LT : 'HH.mm',
        LTS : 'HH.mm.ss',
        L : 'DD.MM.YYYY',
        LL : 'Do MMMM[ta] YYYY',
        LLL : 'Do MMMM[ta] YYYY, [klo] HH.mm',
        LLLL : 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
        l : 'D.M.YYYY',
        ll : 'Do MMM YYYY',
        lll : 'Do MMM YYYY, [klo] HH.mm',
        llll : 'ddd, Do MMM YYYY, [klo] HH.mm'
    },
    calendar : {
        sameDay : '[tänään] [klo] LT',
        nextDay : '[huomenna] [klo] LT',
        nextWeek : 'dddd [klo] LT',
        lastDay : '[eilen] [klo] LT',
        lastWeek : '[viime] dddd[na] [klo] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s päästä',
        past : '%s sitten',
        s : translate$2,
        m : translate$2,
        mm : translate$2,
        h : translate$2,
        hh : translate$2,
        d : translate$2,
        dd : translate$2,
        M : translate$2,
        MM : translate$2,
        y : translate$2,
        yy : translate$2
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Faroese [fo]
//! author : Ragnar Johannesen : https://github.com/ragnar123

hooks.defineLocale('fo', {
    months : 'januar_februar_mars_apríl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
    monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
    weekdays : 'sunnudagur_mánadagur_týsdagur_mikudagur_hósdagur_fríggjadagur_leygardagur'.split('_'),
    weekdaysShort : 'sun_mán_týs_mik_hós_frí_ley'.split('_'),
    weekdaysMin : 'su_má_tý_mi_hó_fr_le'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D. MMMM, YYYY HH:mm'
    },
    calendar : {
        sameDay : '[Í dag kl.] LT',
        nextDay : '[Í morgin kl.] LT',
        nextWeek : 'dddd [kl.] LT',
        lastDay : '[Í gjár kl.] LT',
        lastWeek : '[síðstu] dddd [kl] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'um %s',
        past : '%s síðani',
        s : 'fá sekund',
        m : 'ein minutt',
        mm : '%d minuttir',
        h : 'ein tími',
        hh : '%d tímar',
        d : 'ein dagur',
        dd : '%d dagar',
        M : 'ein mánaði',
        MM : '%d mánaðir',
        y : 'eitt ár',
        yy : '%d ár'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : French (Canada) [fr-ca]
//! author : Jonathan Abourbih : https://github.com/jonbca

hooks.defineLocale('fr-ca', {
    months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
    monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
    monthsParseExact : true,
    weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
    weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
    weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYY-MM-DD',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[Aujourd’hui à] LT',
        nextDay : '[Demain à] LT',
        nextWeek : 'dddd [à] LT',
        lastDay : '[Hier à] LT',
        lastWeek : 'dddd [dernier à] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'dans %s',
        past : 'il y a %s',
        s : 'quelques secondes',
        m : 'une minute',
        mm : '%d minutes',
        h : 'une heure',
        hh : '%d heures',
        d : 'un jour',
        dd : '%d jours',
        M : 'un mois',
        MM : '%d mois',
        y : 'un an',
        yy : '%d ans'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
    ordinal : function (number, period) {
        switch (period) {
            // Words with masculine grammatical gender: mois, trimestre, jour
            default:
            case 'M':
            case 'Q':
            case 'D':
            case 'DDD':
            case 'd':
                return number + (number === 1 ? 'er' : 'e');

            // Words with feminine grammatical gender: semaine
            case 'w':
            case 'W':
                return number + (number === 1 ? 're' : 'e');
        }
    }
});

//! moment.js locale configuration
//! locale : French (Switzerland) [fr-ch]
//! author : Gaspard Bucher : https://github.com/gaspard

hooks.defineLocale('fr-ch', {
    months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
    monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
    monthsParseExact : true,
    weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
    weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
    weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[Aujourd’hui à] LT',
        nextDay : '[Demain à] LT',
        nextWeek : 'dddd [à] LT',
        lastDay : '[Hier à] LT',
        lastWeek : 'dddd [dernier à] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'dans %s',
        past : 'il y a %s',
        s : 'quelques secondes',
        m : 'une minute',
        mm : '%d minutes',
        h : 'une heure',
        hh : '%d heures',
        d : 'un jour',
        dd : '%d jours',
        M : 'un mois',
        MM : '%d mois',
        y : 'un an',
        yy : '%d ans'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
    ordinal : function (number, period) {
        switch (period) {
            // Words with masculine grammatical gender: mois, trimestre, jour
            default:
            case 'M':
            case 'Q':
            case 'D':
            case 'DDD':
            case 'd':
                return number + (number === 1 ? 'er' : 'e');

            // Words with feminine grammatical gender: semaine
            case 'w':
            case 'W':
                return number + (number === 1 ? 're' : 'e');
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : French [fr]
//! author : John Fischer : https://github.com/jfroffice

hooks.defineLocale('fr', {
    months : 'janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre'.split('_'),
    monthsShort : 'janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.'.split('_'),
    monthsParseExact : true,
    weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
    weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
    weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[Aujourd’hui à] LT',
        nextDay : '[Demain à] LT',
        nextWeek : 'dddd [à] LT',
        lastDay : '[Hier à] LT',
        lastWeek : 'dddd [dernier à] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'dans %s',
        past : 'il y a %s',
        s : 'quelques secondes',
        m : 'une minute',
        mm : '%d minutes',
        h : 'une heure',
        hh : '%d heures',
        d : 'un jour',
        dd : '%d jours',
        M : 'un mois',
        MM : '%d mois',
        y : 'un an',
        yy : '%d ans'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
    ordinal : function (number, period) {
        switch (period) {
            // TODO: Return 'e' when day of month > 1. Move this case inside
            // block for masculine words below.
            // See https://github.com/moment/moment/issues/3375
            case 'D':
                return number + (number === 1 ? 'er' : '');

            // Words with masculine grammatical gender: mois, trimestre, jour
            default:
            case 'M':
            case 'Q':
            case 'DDD':
            case 'd':
                return number + (number === 1 ? 'er' : 'e');

            // Words with feminine grammatical gender: semaine
            case 'w':
            case 'W':
                return number + (number === 1 ? 're' : 'e');
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Frisian [fy]
//! author : Robin van der Vliet : https://github.com/robin0van0der0v

var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_');
var monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');

hooks.defineLocale('fy', {
    months : 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
    monthsShort : function (m, format) {
        if (!m) {
            return monthsShortWithDots;
        } else if (/-MMM-/.test(format)) {
            return monthsShortWithoutDots[m.month()];
        } else {
            return monthsShortWithDots[m.month()];
        }
    },
    monthsParseExact : true,
    weekdays : 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
    weekdaysShort : 'si._mo._ti._wo._to._fr._so.'.split('_'),
    weekdaysMin : 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD-MM-YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[hjoed om] LT',
        nextDay: '[moarn om] LT',
        nextWeek: 'dddd [om] LT',
        lastDay: '[juster om] LT',
        lastWeek: '[ôfrûne] dddd [om] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'oer %s',
        past : '%s lyn',
        s : 'in pear sekonden',
        m : 'ien minút',
        mm : '%d minuten',
        h : 'ien oere',
        hh : '%d oeren',
        d : 'ien dei',
        dd : '%d dagen',
        M : 'ien moanne',
        MM : '%d moannen',
        y : 'ien jier',
        yy : '%d jierren'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal : function (number) {
        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Scottish Gaelic [gd]
//! author : Jon Ashdown : https://github.com/jonashdown

var months$5 = [
    'Am Faoilleach', 'An Gearran', 'Am Màrt', 'An Giblean', 'An Cèitean', 'An t-Ògmhios', 'An t-Iuchar', 'An Lùnastal', 'An t-Sultain', 'An Dàmhair', 'An t-Samhain', 'An Dùbhlachd'
];

var monthsShort$3 = ['Faoi', 'Gear', 'Màrt', 'Gibl', 'Cèit', 'Ògmh', 'Iuch', 'Lùn', 'Sult', 'Dàmh', 'Samh', 'Dùbh'];

var weekdays$1 = ['Didòmhnaich', 'Diluain', 'Dimàirt', 'Diciadain', 'Diardaoin', 'Dihaoine', 'Disathairne'];

var weekdaysShort = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'];

var weekdaysMin = ['Dò', 'Lu', 'Mà', 'Ci', 'Ar', 'Ha', 'Sa'];

hooks.defineLocale('gd', {
    months : months$5,
    monthsShort : monthsShort$3,
    monthsParseExact : true,
    weekdays : weekdays$1,
    weekdaysShort : weekdaysShort,
    weekdaysMin : weekdaysMin,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[An-diugh aig] LT',
        nextDay : '[A-màireach aig] LT',
        nextWeek : 'dddd [aig] LT',
        lastDay : '[An-dè aig] LT',
        lastWeek : 'dddd [seo chaidh] [aig] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'ann an %s',
        past : 'bho chionn %s',
        s : 'beagan diogan',
        m : 'mionaid',
        mm : '%d mionaidean',
        h : 'uair',
        hh : '%d uairean',
        d : 'latha',
        dd : '%d latha',
        M : 'mìos',
        MM : '%d mìosan',
        y : 'bliadhna',
        yy : '%d bliadhna'
    },
    dayOfMonthOrdinalParse : /\d{1,2}(d|na|mh)/,
    ordinal : function (number) {
        var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Galician [gl]
//! author : Juan G. Hurtado : https://github.com/juanghurtado

hooks.defineLocale('gl', {
    months : 'xaneiro_febreiro_marzo_abril_maio_xuño_xullo_agosto_setembro_outubro_novembro_decembro'.split('_'),
    monthsShort : 'xan._feb._mar._abr._mai._xuñ._xul._ago._set._out._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays : 'domingo_luns_martes_mércores_xoves_venres_sábado'.split('_'),
    weekdaysShort : 'dom._lun._mar._mér._xov._ven._sáb.'.split('_'),
    weekdaysMin : 'do_lu_ma_mé_xo_ve_sá'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D [de] MMMM [de] YYYY',
        LLL : 'D [de] MMMM [de] YYYY H:mm',
        LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
    },
    calendar : {
        sameDay : function () {
            return '[hoxe ' + ((this.hours() !== 1) ? 'ás' : 'á') + '] LT';
        },
        nextDay : function () {
            return '[mañá ' + ((this.hours() !== 1) ? 'ás' : 'á') + '] LT';
        },
        nextWeek : function () {
            return 'dddd [' + ((this.hours() !== 1) ? 'ás' : 'a') + '] LT';
        },
        lastDay : function () {
            return '[onte ' + ((this.hours() !== 1) ? 'á' : 'a') + '] LT';
        },
        lastWeek : function () {
            return '[o] dddd [pasado ' + ((this.hours() !== 1) ? 'ás' : 'a') + '] LT';
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : function (str) {
            if (str.indexOf('un') === 0) {
                return 'n' + str;
            }
            return 'en ' + str;
        },
        past : 'hai %s',
        s : 'uns segundos',
        m : 'un minuto',
        mm : '%d minutos',
        h : 'unha hora',
        hh : '%d horas',
        d : 'un día',
        dd : '%d días',
        M : 'un mes',
        MM : '%d meses',
        y : 'un ano',
        yy : '%d anos'
    },
    dayOfMonthOrdinalParse : /\d{1,2}º/,
    ordinal : '%dº',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Konkani Latin script [gom-latn]
//! author : The Discoverer : https://github.com/WikiDiscoverer

function processRelativeTime$4(number, withoutSuffix, key, isFuture) {
    var format = {
        's': ['thodde secondanim', 'thodde second'],
        'm': ['eka mintan', 'ek minute'],
        'mm': [number + ' mintanim', number + ' mintam'],
        'h': ['eka horan', 'ek hor'],
        'hh': [number + ' horanim', number + ' hor'],
        'd': ['eka disan', 'ek dis'],
        'dd': [number + ' disanim', number + ' dis'],
        'M': ['eka mhoinean', 'ek mhoino'],
        'MM': [number + ' mhoineanim', number + ' mhoine'],
        'y': ['eka vorsan', 'ek voros'],
        'yy': [number + ' vorsanim', number + ' vorsam']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
}

hooks.defineLocale('gom-latn', {
    months : 'Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr'.split('_'),
    monthsShort : 'Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.'.split('_'),
    monthsParseExact : true,
    weekdays : 'Aitar_Somar_Mongllar_Budvar_Brestar_Sukrar_Son\'var'.split('_'),
    weekdaysShort : 'Ait._Som._Mon._Bud._Bre._Suk._Son.'.split('_'),
    weekdaysMin : 'Ai_Sm_Mo_Bu_Br_Su_Sn'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'A h:mm [vazta]',
        LTS : 'A h:mm:ss [vazta]',
        L : 'DD-MM-YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY A h:mm [vazta]',
        LLLL : 'dddd, MMMM[achea] Do, YYYY, A h:mm [vazta]',
        llll: 'ddd, D MMM YYYY, A h:mm [vazta]'
    },
    calendar : {
        sameDay: '[Aiz] LT',
        nextDay: '[Faleam] LT',
        nextWeek: '[Ieta to] dddd[,] LT',
        lastDay: '[Kal] LT',
        lastWeek: '[Fatlo] dddd[,] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : '%s',
        past : '%s adim',
        s : processRelativeTime$4,
        m : processRelativeTime$4,
        mm : processRelativeTime$4,
        h : processRelativeTime$4,
        hh : processRelativeTime$4,
        d : processRelativeTime$4,
        dd : processRelativeTime$4,
        M : processRelativeTime$4,
        MM : processRelativeTime$4,
        y : processRelativeTime$4,
        yy : processRelativeTime$4
    },
    dayOfMonthOrdinalParse : /\d{1,2}(er)/,
    ordinal : function (number, period) {
        switch (period) {
            // the ordinal 'er' only applies to day of the month
            case 'D':
                return number + 'er';
            default:
            case 'M':
            case 'Q':
            case 'DDD':
            case 'd':
            case 'w':
            case 'W':
                return number;
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    },
    meridiemParse: /rati|sokalli|donparam|sanje/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === 'rati') {
            return hour < 4 ? hour : hour + 12;
        } else if (meridiem === 'sokalli') {
            return hour;
        } else if (meridiem === 'donparam') {
            return hour > 12 ? hour : hour + 12;
        } else if (meridiem === 'sanje') {
            return hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return 'rati';
        } else if (hour < 12) {
            return 'sokalli';
        } else if (hour < 16) {
            return 'donparam';
        } else if (hour < 20) {
            return 'sanje';
        } else {
            return 'rati';
        }
    }
});

//! moment.js locale configuration
//! locale : Hebrew [he]
//! author : Tomer Cohen : https://github.com/tomer
//! author : Moshe Simantov : https://github.com/DevelopmentIL
//! author : Tal Ater : https://github.com/TalAter

hooks.defineLocale('he', {
    months : 'ינואר_פברואר_מרץ_אפריל_מאי_יוני_יולי_אוגוסט_ספטמבר_אוקטובר_נובמבר_דצמבר'.split('_'),
    monthsShort : 'ינו׳_פבר׳_מרץ_אפר׳_מאי_יוני_יולי_אוג׳_ספט׳_אוק׳_נוב׳_דצמ׳'.split('_'),
    weekdays : 'ראשון_שני_שלישי_רביעי_חמישי_שישי_שבת'.split('_'),
    weekdaysShort : 'א׳_ב׳_ג׳_ד׳_ה׳_ו׳_ש׳'.split('_'),
    weekdaysMin : 'א_ב_ג_ד_ה_ו_ש'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D [ב]MMMM YYYY',
        LLL : 'D [ב]MMMM YYYY HH:mm',
        LLLL : 'dddd, D [ב]MMMM YYYY HH:mm',
        l : 'D/M/YYYY',
        ll : 'D MMM YYYY',
        lll : 'D MMM YYYY HH:mm',
        llll : 'ddd, D MMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[היום ב־]LT',
        nextDay : '[מחר ב־]LT',
        nextWeek : 'dddd [בשעה] LT',
        lastDay : '[אתמול ב־]LT',
        lastWeek : '[ביום] dddd [האחרון בשעה] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'בעוד %s',
        past : 'לפני %s',
        s : 'מספר שניות',
        m : 'דקה',
        mm : '%d דקות',
        h : 'שעה',
        hh : function (number) {
            if (number === 2) {
                return 'שעתיים';
            }
            return number + ' שעות';
        },
        d : 'יום',
        dd : function (number) {
            if (number === 2) {
                return 'יומיים';
            }
            return number + ' ימים';
        },
        M : 'חודש',
        MM : function (number) {
            if (number === 2) {
                return 'חודשיים';
            }
            return number + ' חודשים';
        },
        y : 'שנה',
        yy : function (number) {
            if (number === 2) {
                return 'שנתיים';
            } else if (number % 10 === 0 && number !== 10) {
                return number + ' שנה';
            }
            return number + ' שנים';
        }
    },
    meridiemParse: /אחה"צ|לפנה"צ|אחרי הצהריים|לפני הצהריים|לפנות בוקר|בבוקר|בערב/i,
    isPM : function (input) {
        return /^(אחה"צ|אחרי הצהריים|בערב)$/.test(input);
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 5) {
            return 'לפנות בוקר';
        } else if (hour < 10) {
            return 'בבוקר';
        } else if (hour < 12) {
            return isLower ? 'לפנה"צ' : 'לפני הצהריים';
        } else if (hour < 18) {
            return isLower ? 'אחה"צ' : 'אחרי הצהריים';
        } else {
            return 'בערב';
        }
    }
});

//! moment.js locale configuration
//! locale : Hindi [hi]
//! author : Mayank Singhal : https://github.com/mayanksinghal

var symbolMap$6 = {
    '1': '१',
    '2': '२',
    '3': '३',
    '4': '४',
    '5': '५',
    '6': '६',
    '7': '७',
    '8': '८',
    '9': '९',
    '0': '०'
};
var numberMap$5 = {
    '१': '1',
    '२': '2',
    '३': '3',
    '४': '4',
    '५': '5',
    '६': '6',
    '७': '7',
    '८': '8',
    '९': '9',
    '०': '0'
};

hooks.defineLocale('hi', {
    months : 'जनवरी_फ़रवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितम्बर_अक्टूबर_नवम्बर_दिसम्बर'.split('_'),
    monthsShort : 'जन._फ़र._मार्च_अप्रै._मई_जून_जुल._अग._सित._अक्टू._नव._दिस.'.split('_'),
    monthsParseExact: true,
    weekdays : 'रविवार_सोमवार_मंगलवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
    weekdaysShort : 'रवि_सोम_मंगल_बुध_गुरू_शुक्र_शनि'.split('_'),
    weekdaysMin : 'र_सो_मं_बु_गु_शु_श'.split('_'),
    longDateFormat : {
        LT : 'A h:mm बजे',
        LTS : 'A h:mm:ss बजे',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm बजे',
        LLLL : 'dddd, D MMMM YYYY, A h:mm बजे'
    },
    calendar : {
        sameDay : '[आज] LT',
        nextDay : '[कल] LT',
        nextWeek : 'dddd, LT',
        lastDay : '[कल] LT',
        lastWeek : '[पिछले] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s में',
        past : '%s पहले',
        s : 'कुछ ही क्षण',
        m : 'एक मिनट',
        mm : '%d मिनट',
        h : 'एक घंटा',
        hh : '%d घंटे',
        d : 'एक दिन',
        dd : '%d दिन',
        M : 'एक महीने',
        MM : '%d महीने',
        y : 'एक वर्ष',
        yy : '%d वर्ष'
    },
    preparse: function (string) {
        return string.replace(/[१२३४५६७८९०]/g, function (match) {
            return numberMap$5[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap$6[match];
        });
    },
    // Hindi notation for meridiems are quite fuzzy in practice. While there exists
    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
    meridiemParse: /रात|सुबह|दोपहर|शाम/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === 'रात') {
            return hour < 4 ? hour : hour + 12;
        } else if (meridiem === 'सुबह') {
            return hour;
        } else if (meridiem === 'दोपहर') {
            return hour >= 10 ? hour : hour + 12;
        } else if (meridiem === 'शाम') {
            return hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return 'रात';
        } else if (hour < 10) {
            return 'सुबह';
        } else if (hour < 17) {
            return 'दोपहर';
        } else if (hour < 20) {
            return 'शाम';
        } else {
            return 'रात';
        }
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Croatian [hr]
//! author : Bojan Marković : https://github.com/bmarkovic

function translate$3(number, withoutSuffix, key) {
    var result = number + ' ';
    switch (key) {
        case 'm':
            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
        case 'mm':
            if (number === 1) {
                result += 'minuta';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'minute';
            } else {
                result += 'minuta';
            }
            return result;
        case 'h':
            return withoutSuffix ? 'jedan sat' : 'jednog sata';
        case 'hh':
            if (number === 1) {
                result += 'sat';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'sata';
            } else {
                result += 'sati';
            }
            return result;
        case 'dd':
            if (number === 1) {
                result += 'dan';
            } else {
                result += 'dana';
            }
            return result;
        case 'MM':
            if (number === 1) {
                result += 'mjesec';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'mjeseca';
            } else {
                result += 'mjeseci';
            }
            return result;
        case 'yy':
            if (number === 1) {
                result += 'godina';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'godine';
            } else {
                result += 'godina';
            }
            return result;
    }
}

hooks.defineLocale('hr', {
    months : {
        format: 'siječnja_veljače_ožujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split('_'),
        standalone: 'siječanj_veljača_ožujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_')
    },
    monthsShort : 'sij._velj._ožu._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
    monthsParseExact: true,
    weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
    weekdaysShort : 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
    weekdaysMin : 'ne_po_ut_sr_če_pe_su'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY H:mm',
        LLLL : 'dddd, D. MMMM YYYY H:mm'
    },
    calendar : {
        sameDay  : '[danas u] LT',
        nextDay  : '[sutra u] LT',
        nextWeek : function () {
            switch (this.day()) {
                case 0:
                    return '[u] [nedjelju] [u] LT';
                case 3:
                    return '[u] [srijedu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
            }
        },
        lastDay  : '[jučer u] LT',
        lastWeek : function () {
            switch (this.day()) {
                case 0:
                case 3:
                    return '[prošlu] dddd [u] LT';
                case 6:
                    return '[prošle] [subote] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[prošli] dddd [u] LT';
            }
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'za %s',
        past   : 'prije %s',
        s      : 'par sekundi',
        m      : translate$3,
        mm     : translate$3,
        h      : translate$3,
        hh     : translate$3,
        d      : 'dan',
        dd     : translate$3,
        M      : 'mjesec',
        MM     : translate$3,
        y      : 'godinu',
        yy     : translate$3
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Hungarian [hu]
//! author : Adam Brunner : https://github.com/adambrunner

var weekEndings = 'vasárnap hétfőn kedden szerdán csütörtökön pénteken szombaton'.split(' ');
function translate$4(number, withoutSuffix, key, isFuture) {
    var num = number,
        suffix;
    switch (key) {
        case 's':
            return (isFuture || withoutSuffix) ? 'néhány másodperc' : 'néhány másodperce';
        case 'm':
            return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
        case 'mm':
            return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
        case 'h':
            return 'egy' + (isFuture || withoutSuffix ? ' óra' : ' órája');
        case 'hh':
            return num + (isFuture || withoutSuffix ? ' óra' : ' órája');
        case 'd':
            return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
        case 'dd':
            return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
        case 'M':
            return 'egy' + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');
        case 'MM':
            return num + (isFuture || withoutSuffix ? ' hónap' : ' hónapja');
        case 'y':
            return 'egy' + (isFuture || withoutSuffix ? ' év' : ' éve');
        case 'yy':
            return num + (isFuture || withoutSuffix ? ' év' : ' éve');
    }
    return '';
}
function week(isFuture) {
    return (isFuture ? '' : '[múlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
}

hooks.defineLocale('hu', {
    months : 'január_február_március_április_május_június_július_augusztus_szeptember_október_november_december'.split('_'),
    monthsShort : 'jan_feb_márc_ápr_máj_jún_júl_aug_szept_okt_nov_dec'.split('_'),
    weekdays : 'vasárnap_hétfő_kedd_szerda_csütörtök_péntek_szombat'.split('_'),
    weekdaysShort : 'vas_hét_kedd_sze_csüt_pén_szo'.split('_'),
    weekdaysMin : 'v_h_k_sze_cs_p_szo'.split('_'),
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'YYYY.MM.DD.',
        LL : 'YYYY. MMMM D.',
        LLL : 'YYYY. MMMM D. H:mm',
        LLLL : 'YYYY. MMMM D., dddd H:mm'
    },
    meridiemParse: /de|du/i,
    isPM: function (input) {
        return input.charAt(1).toLowerCase() === 'u';
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours < 12) {
            return isLower === true ? 'de' : 'DE';
        } else {
            return isLower === true ? 'du' : 'DU';
        }
    },
    calendar : {
        sameDay : '[ma] LT[-kor]',
        nextDay : '[holnap] LT[-kor]',
        nextWeek : function () {
            return week.call(this, true);
        },
        lastDay : '[tegnap] LT[-kor]',
        lastWeek : function () {
            return week.call(this, false);
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s múlva',
        past : '%s',
        s : translate$4,
        m : translate$4,
        mm : translate$4,
        h : translate$4,
        hh : translate$4,
        d : translate$4,
        dd : translate$4,
        M : translate$4,
        MM : translate$4,
        y : translate$4,
        yy : translate$4
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Armenian [hy-am]
//! author : Armendarabyan : https://github.com/armendarabyan

hooks.defineLocale('hy-am', {
    months : {
        format: 'հունվարի_փետրվարի_մարտի_ապրիլի_մայիսի_հունիսի_հուլիսի_օգոստոսի_սեպտեմբերի_հոկտեմբերի_նոյեմբերի_դեկտեմբերի'.split('_'),
        standalone: 'հունվար_փետրվար_մարտ_ապրիլ_մայիս_հունիս_հուլիս_օգոստոս_սեպտեմբեր_հոկտեմբեր_նոյեմբեր_դեկտեմբեր'.split('_')
    },
    monthsShort : 'հնվ_փտր_մրտ_ապր_մյս_հնս_հլս_օգս_սպտ_հկտ_նմբ_դկտ'.split('_'),
    weekdays : 'կիրակի_երկուշաբթի_երեքշաբթի_չորեքշաբթի_հինգշաբթի_ուրբաթ_շաբաթ'.split('_'),
    weekdaysShort : 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
    weekdaysMin : 'կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY թ.',
        LLL : 'D MMMM YYYY թ., HH:mm',
        LLLL : 'dddd, D MMMM YYYY թ., HH:mm'
    },
    calendar : {
        sameDay: '[այսօր] LT',
        nextDay: '[վաղը] LT',
        lastDay: '[երեկ] LT',
        nextWeek: function () {
            return 'dddd [օրը ժամը] LT';
        },
        lastWeek: function () {
            return '[անցած] dddd [օրը ժամը] LT';
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : '%s հետո',
        past : '%s առաջ',
        s : 'մի քանի վայրկյան',
        m : 'րոպե',
        mm : '%d րոպե',
        h : 'ժամ',
        hh : '%d ժամ',
        d : 'օր',
        dd : '%d օր',
        M : 'ամիս',
        MM : '%d ամիս',
        y : 'տարի',
        yy : '%d տարի'
    },
    meridiemParse: /գիշերվա|առավոտվա|ցերեկվա|երեկոյան/,
    isPM: function (input) {
        return /^(ցերեկվա|երեկոյան)$/.test(input);
    },
    meridiem : function (hour) {
        if (hour < 4) {
            return 'գիշերվա';
        } else if (hour < 12) {
            return 'առավոտվա';
        } else if (hour < 17) {
            return 'ցերեկվա';
        } else {
            return 'երեկոյան';
        }
    },
    dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(ին|րդ)/,
    ordinal: function (number, period) {
        switch (period) {
            case 'DDD':
            case 'w':
            case 'W':
            case 'DDDo':
                if (number === 1) {
                    return number + '-ին';
                }
                return number + '-րդ';
            default:
                return number;
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Indonesian [id]
//! author : Mohammad Satrio Utomo : https://github.com/tyok
//! reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan

hooks.defineLocale('id', {
    months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
    monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des'.split('_'),
    weekdays : 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
    weekdaysShort : 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
    weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
    longDateFormat : {
        LT : 'HH.mm',
        LTS : 'HH.mm.ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY [pukul] HH.mm',
        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /pagi|siang|sore|malam/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === 'pagi') {
            return hour;
        } else if (meridiem === 'siang') {
            return hour >= 11 ? hour : hour + 12;
        } else if (meridiem === 'sore' || meridiem === 'malam') {
            return hour + 12;
        }
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours < 11) {
            return 'pagi';
        } else if (hours < 15) {
            return 'siang';
        } else if (hours < 19) {
            return 'sore';
        } else {
            return 'malam';
        }
    },
    calendar : {
        sameDay : '[Hari ini pukul] LT',
        nextDay : '[Besok pukul] LT',
        nextWeek : 'dddd [pukul] LT',
        lastDay : '[Kemarin pukul] LT',
        lastWeek : 'dddd [lalu pukul] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'dalam %s',
        past : '%s yang lalu',
        s : 'beberapa detik',
        m : 'semenit',
        mm : '%d menit',
        h : 'sejam',
        hh : '%d jam',
        d : 'sehari',
        dd : '%d hari',
        M : 'sebulan',
        MM : '%d bulan',
        y : 'setahun',
        yy : '%d tahun'
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Icelandic [is]
//! author : Hinrik Örn Sigurðsson : https://github.com/hinrik

function plural$2(n) {
    if (n % 100 === 11) {
        return true;
    } else if (n % 10 === 1) {
        return false;
    }
    return true;
}
function translate$5(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';
    switch (key) {
        case 's':
            return withoutSuffix || isFuture ? 'nokkrar sekúndur' : 'nokkrum sekúndum';
        case 'm':
            return withoutSuffix ? 'mínúta' : 'mínútu';
        case 'mm':
            if (plural$2(number)) {
                return result + (withoutSuffix || isFuture ? 'mínútur' : 'mínútum');
            } else if (withoutSuffix) {
                return result + 'mínúta';
            }
            return result + 'mínútu';
        case 'hh':
            if (plural$2(number)) {
                return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
            }
            return result + 'klukkustund';
        case 'd':
            if (withoutSuffix) {
                return 'dagur';
            }
            return isFuture ? 'dag' : 'degi';
        case 'dd':
            if (plural$2(number)) {
                if (withoutSuffix) {
                    return result + 'dagar';
                }
                return result + (isFuture ? 'daga' : 'dögum');
            } else if (withoutSuffix) {
                return result + 'dagur';
            }
            return result + (isFuture ? 'dag' : 'degi');
        case 'M':
            if (withoutSuffix) {
                return 'mánuður';
            }
            return isFuture ? 'mánuð' : 'mánuði';
        case 'MM':
            if (plural$2(number)) {
                if (withoutSuffix) {
                    return result + 'mánuðir';
                }
                return result + (isFuture ? 'mánuði' : 'mánuðum');
            } else if (withoutSuffix) {
                return result + 'mánuður';
            }
            return result + (isFuture ? 'mánuð' : 'mánuði');
        case 'y':
            return withoutSuffix || isFuture ? 'ár' : 'ári';
        case 'yy':
            if (plural$2(number)) {
                return result + (withoutSuffix || isFuture ? 'ár' : 'árum');
            }
            return result + (withoutSuffix || isFuture ? 'ár' : 'ári');
    }
}

hooks.defineLocale('is', {
    months : 'janúar_febrúar_mars_apríl_maí_júní_júlí_ágúst_september_október_nóvember_desember'.split('_'),
    monthsShort : 'jan_feb_mar_apr_maí_jún_júl_ágú_sep_okt_nóv_des'.split('_'),
    weekdays : 'sunnudagur_mánudagur_þriðjudagur_miðvikudagur_fimmtudagur_föstudagur_laugardagur'.split('_'),
    weekdaysShort : 'sun_mán_þri_mið_fim_fös_lau'.split('_'),
    weekdaysMin : 'Su_Má_Þr_Mi_Fi_Fö_La'.split('_'),
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY [kl.] H:mm',
        LLLL : 'dddd, D. MMMM YYYY [kl.] H:mm'
    },
    calendar : {
        sameDay : '[í dag kl.] LT',
        nextDay : '[á morgun kl.] LT',
        nextWeek : 'dddd [kl.] LT',
        lastDay : '[í gær kl.] LT',
        lastWeek : '[síðasta] dddd [kl.] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'eftir %s',
        past : 'fyrir %s síðan',
        s : translate$5,
        m : translate$5,
        mm : translate$5,
        h : 'klukkustund',
        hh : translate$5,
        d : translate$5,
        dd : translate$5,
        M : translate$5,
        MM : translate$5,
        y : translate$5,
        yy : translate$5
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Italian [it]
//! author : Lorenzo : https://github.com/aliem
//! author: Mattia Larentis: https://github.com/nostalgiaz

hooks.defineLocale('it', {
    months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
    monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
    weekdays : 'domenica_lunedì_martedì_mercoledì_giovedì_venerdì_sabato'.split('_'),
    weekdaysShort : 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
    weekdaysMin : 'do_lu_ma_me_gi_ve_sa'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[Oggi alle] LT',
        nextDay: '[Domani alle] LT',
        nextWeek: 'dddd [alle] LT',
        lastDay: '[Ieri alle] LT',
        lastWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[la scorsa] dddd [alle] LT';
                default:
                    return '[lo scorso] dddd [alle] LT';
            }
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : function (s) {
            return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
        },
        past : '%s fa',
        s : 'alcuni secondi',
        m : 'un minuto',
        mm : '%d minuti',
        h : 'un\'ora',
        hh : '%d ore',
        d : 'un giorno',
        dd : '%d giorni',
        M : 'un mese',
        MM : '%d mesi',
        y : 'un anno',
        yy : '%d anni'
    },
    dayOfMonthOrdinalParse : /\d{1,2}º/,
    ordinal: '%dº',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Japanese [ja]
//! author : LI Long : https://github.com/baryon

hooks.defineLocale('ja', {
    months : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
    monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
    weekdays : '日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日'.split('_'),
    weekdaysShort : '日_月_火_水_木_金_土'.split('_'),
    weekdaysMin : '日_月_火_水_木_金_土'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYY/MM/DD',
        LL : 'YYYY年M月D日',
        LLL : 'YYYY年M月D日 HH:mm',
        LLLL : 'YYYY年M月D日 HH:mm dddd',
        l : 'YYYY/MM/DD',
        ll : 'YYYY年M月D日',
        lll : 'YYYY年M月D日 HH:mm',
        llll : 'YYYY年M月D日 HH:mm dddd'
    },
    meridiemParse: /午前|午後/i,
    isPM : function (input) {
        return input === '午後';
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return '午前';
        } else {
            return '午後';
        }
    },
    calendar : {
        sameDay : '[今日] LT',
        nextDay : '[明日] LT',
        nextWeek : '[来週]dddd LT',
        lastDay : '[昨日] LT',
        lastWeek : '[前週]dddd LT',
        sameElse : 'L'
    },
    dayOfMonthOrdinalParse : /\d{1,2}日/,
    ordinal : function (number, period) {
        switch (period) {
            case 'd':
            case 'D':
            case 'DDD':
                return number + '日';
            default:
                return number;
        }
    },
    relativeTime : {
        future : '%s後',
        past : '%s前',
        s : '数秒',
        m : '1分',
        mm : '%d分',
        h : '1時間',
        hh : '%d時間',
        d : '1日',
        dd : '%d日',
        M : '1ヶ月',
        MM : '%dヶ月',
        y : '1年',
        yy : '%d年'
    }
});

//! moment.js locale configuration
//! locale : Javanese [jv]
//! author : Rony Lantip : https://github.com/lantip
//! reference: http://jv.wikipedia.org/wiki/Basa_Jawa

hooks.defineLocale('jv', {
    months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
    monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
    weekdays : 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
    weekdaysShort : 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
    weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
    longDateFormat : {
        LT : 'HH.mm',
        LTS : 'HH.mm.ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY [pukul] HH.mm',
        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /enjing|siyang|sonten|ndalu/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === 'enjing') {
            return hour;
        } else if (meridiem === 'siyang') {
            return hour >= 11 ? hour : hour + 12;
        } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
            return hour + 12;
        }
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours < 11) {
            return 'enjing';
        } else if (hours < 15) {
            return 'siyang';
        } else if (hours < 19) {
            return 'sonten';
        } else {
            return 'ndalu';
        }
    },
    calendar : {
        sameDay : '[Dinten puniko pukul] LT',
        nextDay : '[Mbenjang pukul] LT',
        nextWeek : 'dddd [pukul] LT',
        lastDay : '[Kala wingi pukul] LT',
        lastWeek : 'dddd [kepengker pukul] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'wonten ing %s',
        past : '%s ingkang kepengker',
        s : 'sawetawis detik',
        m : 'setunggal menit',
        mm : '%d menit',
        h : 'setunggal jam',
        hh : '%d jam',
        d : 'sedinten',
        dd : '%d dinten',
        M : 'sewulan',
        MM : '%d wulan',
        y : 'setaun',
        yy : '%d taun'
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Georgian [ka]
//! author : Irakli Janiashvili : https://github.com/irakli-janiashvili

hooks.defineLocale('ka', {
    months : {
        standalone: 'იანვარი_თებერვალი_მარტი_აპრილი_მაისი_ივნისი_ივლისი_აგვისტო_სექტემბერი_ოქტომბერი_ნოემბერი_დეკემბერი'.split('_'),
        format: 'იანვარს_თებერვალს_მარტს_აპრილის_მაისს_ივნისს_ივლისს_აგვისტს_სექტემბერს_ოქტომბერს_ნოემბერს_დეკემბერს'.split('_')
    },
    monthsShort : 'იან_თებ_მარ_აპრ_მაი_ივნ_ივლ_აგვ_სექ_ოქტ_ნოე_დეკ'.split('_'),
    weekdays : {
        standalone: 'კვირა_ორშაბათი_სამშაბათი_ოთხშაბათი_ხუთშაბათი_პარასკევი_შაბათი'.split('_'),
        format: 'კვირას_ორშაბათს_სამშაბათს_ოთხშაბათს_ხუთშაბათს_პარასკევს_შაბათს'.split('_'),
        isFormat: /(წინა|შემდეგ)/
    },
    weekdaysShort : 'კვი_ორშ_სამ_ოთხ_ხუთ_პარ_შაბ'.split('_'),
    weekdaysMin : 'კვ_ორ_სა_ოთ_ხუ_პა_შა'.split('_'),
    longDateFormat : {
        LT : 'h:mm A',
        LTS : 'h:mm:ss A',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY h:mm A',
        LLLL : 'dddd, D MMMM YYYY h:mm A'
    },
    calendar : {
        sameDay : '[დღეს] LT[-ზე]',
        nextDay : '[ხვალ] LT[-ზე]',
        lastDay : '[გუშინ] LT[-ზე]',
        nextWeek : '[შემდეგ] dddd LT[-ზე]',
        lastWeek : '[წინა] dddd LT-ზე',
        sameElse : 'L'
    },
    relativeTime : {
        future : function (s) {
            return (/(წამი|წუთი|საათი|წელი)/).test(s) ?
                s.replace(/ი$/, 'ში') :
                s + 'ში';
        },
        past : function (s) {
            if ((/(წამი|წუთი|საათი|დღე|თვე)/).test(s)) {
                return s.replace(/(ი|ე)$/, 'ის უკან');
            }
            if ((/წელი/).test(s)) {
                return s.replace(/წელი$/, 'წლის უკან');
            }
        },
        s : 'რამდენიმე წამი',
        m : 'წუთი',
        mm : '%d წუთი',
        h : 'საათი',
        hh : '%d საათი',
        d : 'დღე',
        dd : '%d დღე',
        M : 'თვე',
        MM : '%d თვე',
        y : 'წელი',
        yy : '%d წელი'
    },
    dayOfMonthOrdinalParse: /0|1-ლი|მე-\d{1,2}|\d{1,2}-ე/,
    ordinal : function (number) {
        if (number === 0) {
            return number;
        }
        if (number === 1) {
            return number + '-ლი';
        }
        if ((number < 20) || (number <= 100 && (number % 20 === 0)) || (number % 100 === 0)) {
            return 'მე-' + number;
        }
        return number + '-ე';
    },
    week : {
        dow : 1,
        doy : 7
    }
});

//! moment.js locale configuration
//! locale : Kazakh [kk]
//! authors : Nurlan Rakhimzhanov : https://github.com/nurlan

var suffixes$1 = {
    0: '-ші',
    1: '-ші',
    2: '-ші',
    3: '-ші',
    4: '-ші',
    5: '-ші',
    6: '-шы',
    7: '-ші',
    8: '-ші',
    9: '-шы',
    10: '-шы',
    20: '-шы',
    30: '-шы',
    40: '-шы',
    50: '-ші',
    60: '-шы',
    70: '-ші',
    80: '-ші',
    90: '-шы',
    100: '-ші'
};

hooks.defineLocale('kk', {
    months : 'қаңтар_ақпан_наурыз_сәуір_мамыр_маусым_шілде_тамыз_қыркүйек_қазан_қараша_желтоқсан'.split('_'),
    monthsShort : 'қаң_ақп_нау_сәу_мам_мау_шіл_там_қыр_қаз_қар_жел'.split('_'),
    weekdays : 'жексенбі_дүйсенбі_сейсенбі_сәрсенбі_бейсенбі_жұма_сенбі'.split('_'),
    weekdaysShort : 'жек_дүй_сей_сәр_бей_жұм_сен'.split('_'),
    weekdaysMin : 'жк_дй_сй_ср_бй_жм_сн'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[Бүгін сағат] LT',
        nextDay : '[Ертең сағат] LT',
        nextWeek : 'dddd [сағат] LT',
        lastDay : '[Кеше сағат] LT',
        lastWeek : '[Өткен аптаның] dddd [сағат] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ішінде',
        past : '%s бұрын',
        s : 'бірнеше секунд',
        m : 'бір минут',
        mm : '%d минут',
        h : 'бір сағат',
        hh : '%d сағат',
        d : 'бір күн',
        dd : '%d күн',
        M : 'бір ай',
        MM : '%d ай',
        y : 'бір жыл',
        yy : '%d жыл'
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(ші|шы)/,
    ordinal : function (number) {
        var a = number % 10,
            b = number >= 100 ? 100 : null;
        return number + (suffixes$1[number] || suffixes$1[a] || suffixes$1[b]);
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Cambodian [km]
//! author : Kruy Vanna : https://github.com/kruyvanna

hooks.defineLocale('km', {
    months: 'មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split('_'),
    monthsShort: 'មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ'.split('_'),
    weekdays: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
    weekdaysShort: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
    weekdaysMin: 'អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍'.split('_'),
    longDateFormat: {
        LT: 'HH:mm',
        LTS : 'HH:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
        sameDay: '[ថ្ងៃនេះ ម៉ោង] LT',
        nextDay: '[ស្អែក ម៉ោង] LT',
        nextWeek: 'dddd [ម៉ោង] LT',
        lastDay: '[ម្សិលមិញ ម៉ោង] LT',
        lastWeek: 'dddd [សប្តាហ៍មុន] [ម៉ោង] LT',
        sameElse: 'L'
    },
    relativeTime: {
        future: '%sទៀត',
        past: '%sមុន',
        s: 'ប៉ុន្មានវិនាទី',
        m: 'មួយនាទី',
        mm: '%d នាទី',
        h: 'មួយម៉ោង',
        hh: '%d ម៉ោង',
        d: 'មួយថ្ងៃ',
        dd: '%d ថ្ងៃ',
        M: 'មួយខែ',
        MM: '%d ខែ',
        y: 'មួយឆ្នាំ',
        yy: '%d ឆ្នាំ'
    },
    week: {
        dow: 1, // Monday is the first day of the week.
        doy: 4 // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Kannada [kn]
//! author : Rajeev Naik : https://github.com/rajeevnaikte

var symbolMap$7 = {
    '1': '೧',
    '2': '೨',
    '3': '೩',
    '4': '೪',
    '5': '೫',
    '6': '೬',
    '7': '೭',
    '8': '೮',
    '9': '೯',
    '0': '೦'
};
var numberMap$6 = {
    '೧': '1',
    '೨': '2',
    '೩': '3',
    '೪': '4',
    '೫': '5',
    '೬': '6',
    '೭': '7',
    '೮': '8',
    '೯': '9',
    '೦': '0'
};

hooks.defineLocale('kn', {
    months : 'ಜನವರಿ_ಫೆಬ್ರವರಿ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂಬರ್_ಅಕ್ಟೋಬರ್_ನವೆಂಬರ್_ಡಿಸೆಂಬರ್'.split('_'),
    monthsShort : 'ಜನ_ಫೆಬ್ರ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂಬ_ಅಕ್ಟೋಬ_ನವೆಂಬ_ಡಿಸೆಂಬ'.split('_'),
    monthsParseExact: true,
    weekdays : 'ಭಾನುವಾರ_ಸೋಮವಾರ_ಮಂಗಳವಾರ_ಬುಧವಾರ_ಗುರುವಾರ_ಶುಕ್ರವಾರ_ಶನಿವಾರ'.split('_'),
    weekdaysShort : 'ಭಾನು_ಸೋಮ_ಮಂಗಳ_ಬುಧ_ಗುರು_ಶುಕ್ರ_ಶನಿ'.split('_'),
    weekdaysMin : 'ಭಾ_ಸೋ_ಮಂ_ಬು_ಗು_ಶು_ಶ'.split('_'),
    longDateFormat : {
        LT : 'A h:mm',
        LTS : 'A h:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm',
        LLLL : 'dddd, D MMMM YYYY, A h:mm'
    },
    calendar : {
        sameDay : '[ಇಂದು] LT',
        nextDay : '[ನಾಳೆ] LT',
        nextWeek : 'dddd, LT',
        lastDay : '[ನಿನ್ನೆ] LT',
        lastWeek : '[ಕೊನೆಯ] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ನಂತರ',
        past : '%s ಹಿಂದೆ',
        s : 'ಕೆಲವು ಕ್ಷಣಗಳು',
        m : 'ಒಂದು ನಿಮಿಷ',
        mm : '%d ನಿಮಿಷ',
        h : 'ಒಂದು ಗಂಟೆ',
        hh : '%d ಗಂಟೆ',
        d : 'ಒಂದು ದಿನ',
        dd : '%d ದಿನ',
        M : 'ಒಂದು ತಿಂಗಳು',
        MM : '%d ತಿಂಗಳು',
        y : 'ಒಂದು ವರ್ಷ',
        yy : '%d ವರ್ಷ'
    },
    preparse: function (string) {
        return string.replace(/[೧೨೩೪೫೬೭೮೯೦]/g, function (match) {
            return numberMap$6[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap$7[match];
        });
    },
    meridiemParse: /ರಾತ್ರಿ|ಬೆಳಿಗ್ಗೆ|ಮಧ್ಯಾಹ್ನ|ಸಂಜೆ/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === 'ರಾತ್ರಿ') {
            return hour < 4 ? hour : hour + 12;
        } else if (meridiem === 'ಬೆಳಿಗ್ಗೆ') {
            return hour;
        } else if (meridiem === 'ಮಧ್ಯಾಹ್ನ') {
            return hour >= 10 ? hour : hour + 12;
        } else if (meridiem === 'ಸಂಜೆ') {
            return hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return 'ರಾತ್ರಿ';
        } else if (hour < 10) {
            return 'ಬೆಳಿಗ್ಗೆ';
        } else if (hour < 17) {
            return 'ಮಧ್ಯಾಹ್ನ';
        } else if (hour < 20) {
            return 'ಸಂಜೆ';
        } else {
            return 'ರಾತ್ರಿ';
        }
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ನೇ)/,
    ordinal : function (number) {
        return number + 'ನೇ';
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Korean [ko]
//! author : Kyungwook, Park : https://github.com/kyungw00k
//! author : Jeeeyul Lee <jeeeyul@gmail.com>

hooks.defineLocale('ko', {
    months : '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),
    monthsShort : '1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월'.split('_'),
    weekdays : '일요일_월요일_화요일_수요일_목요일_금요일_토요일'.split('_'),
    weekdaysShort : '일_월_화_수_목_금_토'.split('_'),
    weekdaysMin : '일_월_화_수_목_금_토'.split('_'),
    longDateFormat : {
        LT : 'A h:mm',
        LTS : 'A h:mm:ss',
        L : 'YYYY.MM.DD',
        LL : 'YYYY년 MMMM D일',
        LLL : 'YYYY년 MMMM D일 A h:mm',
        LLLL : 'YYYY년 MMMM D일 dddd A h:mm',
        l : 'YYYY.MM.DD',
        ll : 'YYYY년 MMMM D일',
        lll : 'YYYY년 MMMM D일 A h:mm',
        llll : 'YYYY년 MMMM D일 dddd A h:mm'
    },
    calendar : {
        sameDay : '오늘 LT',
        nextDay : '내일 LT',
        nextWeek : 'dddd LT',
        lastDay : '어제 LT',
        lastWeek : '지난주 dddd LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s 후',
        past : '%s 전',
        s : '몇 초',
        ss : '%d초',
        m : '1분',
        mm : '%d분',
        h : '한 시간',
        hh : '%d시간',
        d : '하루',
        dd : '%d일',
        M : '한 달',
        MM : '%d달',
        y : '일 년',
        yy : '%d년'
    },
    dayOfMonthOrdinalParse : /\d{1,2}일/,
    ordinal : '%d일',
    meridiemParse : /오전|오후/,
    isPM : function (token) {
        return token === '오후';
    },
    meridiem : function (hour, minute, isUpper) {
        return hour < 12 ? '오전' : '오후';
    }
});

//! moment.js locale configuration
//! locale : Kyrgyz [ky]
//! author : Chyngyz Arystan uulu : https://github.com/chyngyz


var suffixes$2 = {
    0: '-чү',
    1: '-чи',
    2: '-чи',
    3: '-чү',
    4: '-чү',
    5: '-чи',
    6: '-чы',
    7: '-чи',
    8: '-чи',
    9: '-чу',
    10: '-чу',
    20: '-чы',
    30: '-чу',
    40: '-чы',
    50: '-чү',
    60: '-чы',
    70: '-чи',
    80: '-чи',
    90: '-чу',
    100: '-чү'
};

hooks.defineLocale('ky', {
    months : 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split('_'),
    monthsShort : 'янв_фев_март_апр_май_июнь_июль_авг_сен_окт_ноя_дек'.split('_'),
    weekdays : 'Жекшемби_Дүйшөмбү_Шейшемби_Шаршемби_Бейшемби_Жума_Ишемби'.split('_'),
    weekdaysShort : 'Жек_Дүй_Шей_Шар_Бей_Жум_Ише'.split('_'),
    weekdaysMin : 'Жк_Дй_Шй_Шр_Бй_Жм_Иш'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[Бүгүн саат] LT',
        nextDay : '[Эртең саат] LT',
        nextWeek : 'dddd [саат] LT',
        lastDay : '[Кече саат] LT',
        lastWeek : '[Өткен аптанын] dddd [күнү] [саат] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ичинде',
        past : '%s мурун',
        s : 'бирнече секунд',
        m : 'бир мүнөт',
        mm : '%d мүнөт',
        h : 'бир саат',
        hh : '%d саат',
        d : 'бир күн',
        dd : '%d күн',
        M : 'бир ай',
        MM : '%d ай',
        y : 'бир жыл',
        yy : '%d жыл'
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(чи|чы|чү|чу)/,
    ordinal : function (number) {
        var a = number % 10,
            b = number >= 100 ? 100 : null;
        return number + (suffixes$2[number] || suffixes$2[a] || suffixes$2[b]);
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Luxembourgish [lb]
//! author : mweimerskirch : https://github.com/mweimerskirch
//! author : David Raison : https://github.com/kwisatz

function processRelativeTime$5(number, withoutSuffix, key, isFuture) {
    var format = {
        'm': ['eng Minutt', 'enger Minutt'],
        'h': ['eng Stonn', 'enger Stonn'],
        'd': ['een Dag', 'engem Dag'],
        'M': ['ee Mount', 'engem Mount'],
        'y': ['ee Joer', 'engem Joer']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
}
function processFutureTime(string) {
    var number = string.substr(0, string.indexOf(' '));
    if (eifelerRegelAppliesToNumber(number)) {
        return 'a ' + string;
    }
    return 'an ' + string;
}
function processPastTime(string) {
    var number = string.substr(0, string.indexOf(' '));
    if (eifelerRegelAppliesToNumber(number)) {
        return 'viru ' + string;
    }
    return 'virun ' + string;
}
/**
 * Returns true if the word before the given number loses the '-n' ending.
 * e.g. 'an 10 Deeg' but 'a 5 Deeg'
 *
 * @param number {integer}
 * @returns {boolean}
 */
function eifelerRegelAppliesToNumber(number) {
    number = parseInt(number, 10);
    if (isNaN(number)) {
        return false;
    }
    if (number < 0) {
        // Negative Number --> always true
        return true;
    } else if (number < 10) {
        // Only 1 digit
        if (4 <= number && number <= 7) {
            return true;
        }
        return false;
    } else if (number < 100) {
        // 2 digits
        var lastDigit = number % 10, firstDigit = number / 10;
        if (lastDigit === 0) {
            return eifelerRegelAppliesToNumber(firstDigit);
        }
        return eifelerRegelAppliesToNumber(lastDigit);
    } else if (number < 10000) {
        // 3 or 4 digits --> recursively check first digit
        while (number >= 10) {
            number = number / 10;
        }
        return eifelerRegelAppliesToNumber(number);
    } else {
        // Anything larger than 4 digits: recursively check first n-3 digits
        number = number / 1000;
        return eifelerRegelAppliesToNumber(number);
    }
}

hooks.defineLocale('lb', {
    months: 'Januar_Februar_Mäerz_Abrëll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
    monthsParseExact : true,
    weekdays: 'Sonndeg_Méindeg_Dënschdeg_Mëttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
    weekdaysShort: 'So._Mé._Dë._Më._Do._Fr._Sa.'.split('_'),
    weekdaysMin: 'So_Mé_Dë_Më_Do_Fr_Sa'.split('_'),
    weekdaysParseExact : true,
    longDateFormat: {
        LT: 'H:mm [Auer]',
        LTS: 'H:mm:ss [Auer]',
        L: 'DD.MM.YYYY',
        LL: 'D. MMMM YYYY',
        LLL: 'D. MMMM YYYY H:mm [Auer]',
        LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'
    },
    calendar: {
        sameDay: '[Haut um] LT',
        sameElse: 'L',
        nextDay: '[Muer um] LT',
        nextWeek: 'dddd [um] LT',
        lastDay: '[Gëschter um] LT',
        lastWeek: function () {
            // Different date string for 'Dënschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
            switch (this.day()) {
                case 2:
                case 4:
                    return '[Leschten] dddd [um] LT';
                default:
                    return '[Leschte] dddd [um] LT';
            }
        }
    },
    relativeTime : {
        future : processFutureTime,
        past : processPastTime,
        s : 'e puer Sekonnen',
        m : processRelativeTime$5,
        mm : '%d Minutten',
        h : processRelativeTime$5,
        hh : '%d Stonnen',
        d : processRelativeTime$5,
        dd : '%d Deeg',
        M : processRelativeTime$5,
        MM : '%d Méint',
        y : processRelativeTime$5,
        yy : '%d Joer'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
        dow: 1, // Monday is the first day of the week.
        doy: 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Lao [lo]
//! author : Ryan Hart : https://github.com/ryanhart2

hooks.defineLocale('lo', {
    months : 'ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ'.split('_'),
    monthsShort : 'ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ'.split('_'),
    weekdays : 'ອາທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ'.split('_'),
    weekdaysShort : 'ທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ'.split('_'),
    weekdaysMin : 'ທ_ຈ_ອຄ_ພ_ພຫ_ສກ_ສ'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'ວັນdddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /ຕອນເຊົ້າ|ຕອນແລງ/,
    isPM: function (input) {
        return input === 'ຕອນແລງ';
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return 'ຕອນເຊົ້າ';
        } else {
            return 'ຕອນແລງ';
        }
    },
    calendar : {
        sameDay : '[ມື້ນີ້ເວລາ] LT',
        nextDay : '[ມື້ອື່ນເວລາ] LT',
        nextWeek : '[ວັນ]dddd[ໜ້າເວລາ] LT',
        lastDay : '[ມື້ວານນີ້ເວລາ] LT',
        lastWeek : '[ວັນ]dddd[ແລ້ວນີ້ເວລາ] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'ອີກ %s',
        past : '%sຜ່ານມາ',
        s : 'ບໍ່ເທົ່າໃດວິນາທີ',
        m : '1 ນາທີ',
        mm : '%d ນາທີ',
        h : '1 ຊົ່ວໂມງ',
        hh : '%d ຊົ່ວໂມງ',
        d : '1 ມື້',
        dd : '%d ມື້',
        M : '1 ເດືອນ',
        MM : '%d ເດືອນ',
        y : '1 ປີ',
        yy : '%d ປີ'
    },
    dayOfMonthOrdinalParse: /(ທີ່)\d{1,2}/,
    ordinal : function (number) {
        return 'ທີ່' + number;
    }
});

//! moment.js locale configuration
//! locale : Lithuanian [lt]
//! author : Mindaugas Mozūras : https://github.com/mmozuras

var units = {
    'm' : 'minutė_minutės_minutę',
    'mm': 'minutės_minučių_minutes',
    'h' : 'valanda_valandos_valandą',
    'hh': 'valandos_valandų_valandas',
    'd' : 'diena_dienos_dieną',
    'dd': 'dienos_dienų_dienas',
    'M' : 'mėnuo_mėnesio_mėnesį',
    'MM': 'mėnesiai_mėnesių_mėnesius',
    'y' : 'metai_metų_metus',
    'yy': 'metai_metų_metus'
};
function translateSeconds(number, withoutSuffix, key, isFuture) {
    if (withoutSuffix) {
        return 'kelios sekundės';
    } else {
        return isFuture ? 'kelių sekundžių' : 'kelias sekundes';
    }
}
function translateSingular(number, withoutSuffix, key, isFuture) {
    return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);
}
function special(number) {
    return number % 10 === 0 || (number > 10 && number < 20);
}
function forms(key) {
    return units[key].split('_');
}
function translate$6(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';
    if (number === 1) {
        return result + translateSingular(number, withoutSuffix, key[0], isFuture);
    } else if (withoutSuffix) {
        return result + (special(number) ? forms(key)[1] : forms(key)[0]);
    } else {
        if (isFuture) {
            return result + forms(key)[1];
        } else {
            return result + (special(number) ? forms(key)[1] : forms(key)[2]);
        }
    }
}
hooks.defineLocale('lt', {
    months : {
        format: 'sausio_vasario_kovo_balandžio_gegužės_birželio_liepos_rugpjūčio_rugsėjo_spalio_lapkričio_gruodžio'.split('_'),
        standalone: 'sausis_vasaris_kovas_balandis_gegužė_birželis_liepa_rugpjūtis_rugsėjis_spalis_lapkritis_gruodis'.split('_'),
        isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/
    },
    monthsShort : 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
    weekdays : {
        format: 'sekmadienį_pirmadienį_antradienį_trečiadienį_ketvirtadienį_penktadienį_šeštadienį'.split('_'),
        standalone: 'sekmadienis_pirmadienis_antradienis_trečiadienis_ketvirtadienis_penktadienis_šeštadienis'.split('_'),
        isFormat: /dddd HH:mm/
    },
    weekdaysShort : 'Sek_Pir_Ant_Tre_Ket_Pen_Šeš'.split('_'),
    weekdaysMin : 'S_P_A_T_K_Pn_Š'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYY-MM-DD',
        LL : 'YYYY [m.] MMMM D [d.]',
        LLL : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
        LLLL : 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
        l : 'YYYY-MM-DD',
        ll : 'YYYY [m.] MMMM D [d.]',
        lll : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
        llll : 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
    },
    calendar : {
        sameDay : '[Šiandien] LT',
        nextDay : '[Rytoj] LT',
        nextWeek : 'dddd LT',
        lastDay : '[Vakar] LT',
        lastWeek : '[Praėjusį] dddd LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'po %s',
        past : 'prieš %s',
        s : translateSeconds,
        m : translateSingular,
        mm : translate$6,
        h : translateSingular,
        hh : translate$6,
        d : translateSingular,
        dd : translate$6,
        M : translateSingular,
        MM : translate$6,
        y : translateSingular,
        yy : translate$6
    },
    dayOfMonthOrdinalParse: /\d{1,2}-oji/,
    ordinal : function (number) {
        return number + '-oji';
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Latvian [lv]
//! author : Kristaps Karlsons : https://github.com/skakri
//! author : Jānis Elmeris : https://github.com/JanisE

var units$1 = {
    'm': 'minūtes_minūtēm_minūte_minūtes'.split('_'),
    'mm': 'minūtes_minūtēm_minūte_minūtes'.split('_'),
    'h': 'stundas_stundām_stunda_stundas'.split('_'),
    'hh': 'stundas_stundām_stunda_stundas'.split('_'),
    'd': 'dienas_dienām_diena_dienas'.split('_'),
    'dd': 'dienas_dienām_diena_dienas'.split('_'),
    'M': 'mēneša_mēnešiem_mēnesis_mēneši'.split('_'),
    'MM': 'mēneša_mēnešiem_mēnesis_mēneši'.split('_'),
    'y': 'gada_gadiem_gads_gadi'.split('_'),
    'yy': 'gada_gadiem_gads_gadi'.split('_')
};
/**
 * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
 */
function format$1(forms, number, withoutSuffix) {
    if (withoutSuffix) {
        // E.g. "21 minūte", "3 minūtes".
        return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];
    } else {
        // E.g. "21 minūtes" as in "pēc 21 minūtes".
        // E.g. "3 minūtēm" as in "pēc 3 minūtēm".
        return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
    }
}
function relativeTimeWithPlural$1(number, withoutSuffix, key) {
    return number + ' ' + format$1(units$1[key], number, withoutSuffix);
}
function relativeTimeWithSingular(number, withoutSuffix, key) {
    return format$1(units$1[key], number, withoutSuffix);
}
function relativeSeconds(number, withoutSuffix) {
    return withoutSuffix ? 'dažas sekundes' : 'dažām sekundēm';
}

hooks.defineLocale('lv', {
    months : 'janvāris_februāris_marts_aprīlis_maijs_jūnijs_jūlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
    monthsShort : 'jan_feb_mar_apr_mai_jūn_jūl_aug_sep_okt_nov_dec'.split('_'),
    weekdays : 'svētdiena_pirmdiena_otrdiena_trešdiena_ceturtdiena_piektdiena_sestdiena'.split('_'),
    weekdaysShort : 'Sv_P_O_T_C_Pk_S'.split('_'),
    weekdaysMin : 'Sv_P_O_T_C_Pk_S'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY.',
        LL : 'YYYY. [gada] D. MMMM',
        LLL : 'YYYY. [gada] D. MMMM, HH:mm',
        LLLL : 'YYYY. [gada] D. MMMM, dddd, HH:mm'
    },
    calendar : {
        sameDay : '[Šodien pulksten] LT',
        nextDay : '[Rīt pulksten] LT',
        nextWeek : 'dddd [pulksten] LT',
        lastDay : '[Vakar pulksten] LT',
        lastWeek : '[Pagājušā] dddd [pulksten] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'pēc %s',
        past : 'pirms %s',
        s : relativeSeconds,
        m : relativeTimeWithSingular,
        mm : relativeTimeWithPlural$1,
        h : relativeTimeWithSingular,
        hh : relativeTimeWithPlural$1,
        d : relativeTimeWithSingular,
        dd : relativeTimeWithPlural$1,
        M : relativeTimeWithSingular,
        MM : relativeTimeWithPlural$1,
        y : relativeTimeWithSingular,
        yy : relativeTimeWithPlural$1
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Montenegrin [me]
//! author : Miodrag Nikač <miodrag@restartit.me> : https://github.com/miodragnikac

var translator = {
    words: { //Different grammatical cases
        m: ['jedan minut', 'jednog minuta'],
        mm: ['minut', 'minuta', 'minuta'],
        h: ['jedan sat', 'jednog sata'],
        hh: ['sat', 'sata', 'sati'],
        dd: ['dan', 'dana', 'dana'],
        MM: ['mjesec', 'mjeseca', 'mjeseci'],
        yy: ['godina', 'godine', 'godina']
    },
    correctGrammaticalCase: function (number, wordKey) {
        return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
    },
    translate: function (number, withoutSuffix, key) {
        var wordKey = translator.words[key];
        if (key.length === 1) {
            return withoutSuffix ? wordKey[0] : wordKey[1];
        } else {
            return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
        }
    }
};

hooks.defineLocale('me', {
    months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
    monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
    monthsParseExact : true,
    weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota'.split('_'),
    weekdaysShort: 'ned._pon._uto._sri._čet._pet._sub.'.split('_'),
    weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
    weekdaysParseExact : true,
    longDateFormat: {
        LT: 'H:mm',
        LTS : 'H:mm:ss',
        L: 'DD.MM.YYYY',
        LL: 'D. MMMM YYYY',
        LLL: 'D. MMMM YYYY H:mm',
        LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
        sameDay: '[danas u] LT',
        nextDay: '[sjutra u] LT',

        nextWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[u] [nedjelju] [u] LT';
                case 3:
                    return '[u] [srijedu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
            }
        },
        lastDay  : '[juče u] LT',
        lastWeek : function () {
            var lastWeekDays = [
                '[prošle] [nedjelje] [u] LT',
                '[prošlog] [ponedjeljka] [u] LT',
                '[prošlog] [utorka] [u] LT',
                '[prošle] [srijede] [u] LT',
                '[prošlog] [četvrtka] [u] LT',
                '[prošlog] [petka] [u] LT',
                '[prošle] [subote] [u] LT'
            ];
            return lastWeekDays[this.day()];
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'za %s',
        past   : 'prije %s',
        s      : 'nekoliko sekundi',
        m      : translator.translate,
        mm     : translator.translate,
        h      : translator.translate,
        hh     : translator.translate,
        d      : 'dan',
        dd     : translator.translate,
        M      : 'mjesec',
        MM     : translator.translate,
        y      : 'godinu',
        yy     : translator.translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Maori [mi]
//! author : John Corrigan <robbiecloset@gmail.com> : https://github.com/johnideal

hooks.defineLocale('mi', {
    months: 'Kohi-tāte_Hui-tanguru_Poutū-te-rangi_Paenga-whāwhā_Haratua_Pipiri_Hōngoingoi_Here-turi-kōkā_Mahuru_Whiringa-ā-nuku_Whiringa-ā-rangi_Hakihea'.split('_'),
    monthsShort: 'Kohi_Hui_Pou_Pae_Hara_Pipi_Hōngoi_Here_Mahu_Whi-nu_Whi-ra_Haki'.split('_'),
    monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
    monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
    monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
    monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
    weekdays: 'Rātapu_Mane_Tūrei_Wenerei_Tāite_Paraire_Hātarei'.split('_'),
    weekdaysShort: 'Ta_Ma_Tū_We_Tāi_Pa_Hā'.split('_'),
    weekdaysMin: 'Ta_Ma_Tū_We_Tāi_Pa_Hā'.split('_'),
    longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY [i] HH:mm',
        LLLL: 'dddd, D MMMM YYYY [i] HH:mm'
    },
    calendar: {
        sameDay: '[i teie mahana, i] LT',
        nextDay: '[apopo i] LT',
        nextWeek: 'dddd [i] LT',
        lastDay: '[inanahi i] LT',
        lastWeek: 'dddd [whakamutunga i] LT',
        sameElse: 'L'
    },
    relativeTime: {
        future: 'i roto i %s',
        past: '%s i mua',
        s: 'te hēkona ruarua',
        m: 'he meneti',
        mm: '%d meneti',
        h: 'te haora',
        hh: '%d haora',
        d: 'he ra',
        dd: '%d ra',
        M: 'he marama',
        MM: '%d marama',
        y: 'he tau',
        yy: '%d tau'
    },
    dayOfMonthOrdinalParse: /\d{1,2}º/,
    ordinal: '%dº',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Macedonian [mk]
//! author : Borislav Mickov : https://github.com/B0k0

hooks.defineLocale('mk', {
    months : 'јануари_февруари_март_април_мај_јуни_јули_август_септември_октомври_ноември_декември'.split('_'),
    monthsShort : 'јан_фев_мар_апр_мај_јун_јул_авг_сеп_окт_ное_дек'.split('_'),
    weekdays : 'недела_понеделник_вторник_среда_четврток_петок_сабота'.split('_'),
    weekdaysShort : 'нед_пон_вто_сре_чет_пет_саб'.split('_'),
    weekdaysMin : 'нe_пo_вт_ср_че_пе_сa'.split('_'),
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'D.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY H:mm',
        LLLL : 'dddd, D MMMM YYYY H:mm'
    },
    calendar : {
        sameDay : '[Денес во] LT',
        nextDay : '[Утре во] LT',
        nextWeek : '[Во] dddd [во] LT',
        lastDay : '[Вчера во] LT',
        lastWeek : function () {
            switch (this.day()) {
                case 0:
                case 3:
                case 6:
                    return '[Изминатата] dddd [во] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[Изминатиот] dddd [во] LT';
            }
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'после %s',
        past : 'пред %s',
        s : 'неколку секунди',
        m : 'минута',
        mm : '%d минути',
        h : 'час',
        hh : '%d часа',
        d : 'ден',
        dd : '%d дена',
        M : 'месец',
        MM : '%d месеци',
        y : 'година',
        yy : '%d години'
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
    ordinal : function (number) {
        var lastDigit = number % 10,
            last2Digits = number % 100;
        if (number === 0) {
            return number + '-ев';
        } else if (last2Digits === 0) {
            return number + '-ен';
        } else if (last2Digits > 10 && last2Digits < 20) {
            return number + '-ти';
        } else if (lastDigit === 1) {
            return number + '-ви';
        } else if (lastDigit === 2) {
            return number + '-ри';
        } else if (lastDigit === 7 || lastDigit === 8) {
            return number + '-ми';
        } else {
            return number + '-ти';
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Malayalam [ml]
//! author : Floyd Pink : https://github.com/floydpink

hooks.defineLocale('ml', {
    months : 'ജനുവരി_ഫെബ്രുവരി_മാർച്ച്_ഏപ്രിൽ_മേയ്_ജൂൺ_ജൂലൈ_ഓഗസ്റ്റ്_സെപ്റ്റംബർ_ഒക്ടോബർ_നവംബർ_ഡിസംബർ'.split('_'),
    monthsShort : 'ജനു._ഫെബ്രു._മാർ._ഏപ്രി._മേയ്_ജൂൺ_ജൂലൈ._ഓഗ._സെപ്റ്റ._ഒക്ടോ._നവം._ഡിസം.'.split('_'),
    monthsParseExact : true,
    weekdays : 'ഞായറാഴ്ച_തിങ്കളാഴ്ച_ചൊവ്വാഴ്ച_ബുധനാഴ്ച_വ്യാഴാഴ്ച_വെള്ളിയാഴ്ച_ശനിയാഴ്ച'.split('_'),
    weekdaysShort : 'ഞായർ_തിങ്കൾ_ചൊവ്വ_ബുധൻ_വ്യാഴം_വെള്ളി_ശനി'.split('_'),
    weekdaysMin : 'ഞാ_തി_ചൊ_ബു_വ്യാ_വെ_ശ'.split('_'),
    longDateFormat : {
        LT : 'A h:mm -നു',
        LTS : 'A h:mm:ss -നു',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm -നു',
        LLLL : 'dddd, D MMMM YYYY, A h:mm -നു'
    },
    calendar : {
        sameDay : '[ഇന്ന്] LT',
        nextDay : '[നാളെ] LT',
        nextWeek : 'dddd, LT',
        lastDay : '[ഇന്നലെ] LT',
        lastWeek : '[കഴിഞ്ഞ] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s കഴിഞ്ഞ്',
        past : '%s മുൻപ്',
        s : 'അൽപ നിമിഷങ്ങൾ',
        m : 'ഒരു മിനിറ്റ്',
        mm : '%d മിനിറ്റ്',
        h : 'ഒരു മണിക്കൂർ',
        hh : '%d മണിക്കൂർ',
        d : 'ഒരു ദിവസം',
        dd : '%d ദിവസം',
        M : 'ഒരു മാസം',
        MM : '%d മാസം',
        y : 'ഒരു വർഷം',
        yy : '%d വർഷം'
    },
    meridiemParse: /രാത്രി|രാവിലെ|ഉച്ച കഴിഞ്ഞ്|വൈകുന്നേരം|രാത്രി/i,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if ((meridiem === 'രാത്രി' && hour >= 4) ||
                meridiem === 'ഉച്ച കഴിഞ്ഞ്' ||
                meridiem === 'വൈകുന്നേരം') {
            return hour + 12;
        } else {
            return hour;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return 'രാത്രി';
        } else if (hour < 12) {
            return 'രാവിലെ';
        } else if (hour < 17) {
            return 'ഉച്ച കഴിഞ്ഞ്';
        } else if (hour < 20) {
            return 'വൈകുന്നേരം';
        } else {
            return 'രാത്രി';
        }
    }
});

//! moment.js locale configuration
//! locale : Marathi [mr]
//! author : Harshad Kale : https://github.com/kalehv
//! author : Vivek Athalye : https://github.com/vnathalye

var symbolMap$8 = {
    '1': '१',
    '2': '२',
    '3': '३',
    '4': '४',
    '5': '५',
    '6': '६',
    '7': '७',
    '8': '८',
    '9': '९',
    '0': '०'
};
var numberMap$7 = {
    '१': '1',
    '२': '2',
    '३': '3',
    '४': '4',
    '५': '5',
    '६': '6',
    '७': '7',
    '८': '8',
    '९': '9',
    '०': '0'
};

function relativeTimeMr(number, withoutSuffix, string, isFuture)
{
    var output = '';
    if (withoutSuffix) {
        switch (string) {
            case 's': output = 'काही सेकंद'; break;
            case 'm': output = 'एक मिनिट'; break;
            case 'mm': output = '%d मिनिटे'; break;
            case 'h': output = 'एक तास'; break;
            case 'hh': output = '%d तास'; break;
            case 'd': output = 'एक दिवस'; break;
            case 'dd': output = '%d दिवस'; break;
            case 'M': output = 'एक महिना'; break;
            case 'MM': output = '%d महिने'; break;
            case 'y': output = 'एक वर्ष'; break;
            case 'yy': output = '%d वर्षे'; break;
        }
    }
    else {
        switch (string) {
            case 's': output = 'काही सेकंदां'; break;
            case 'm': output = 'एका मिनिटा'; break;
            case 'mm': output = '%d मिनिटां'; break;
            case 'h': output = 'एका तासा'; break;
            case 'hh': output = '%d तासां'; break;
            case 'd': output = 'एका दिवसा'; break;
            case 'dd': output = '%d दिवसां'; break;
            case 'M': output = 'एका महिन्या'; break;
            case 'MM': output = '%d महिन्यां'; break;
            case 'y': output = 'एका वर्षा'; break;
            case 'yy': output = '%d वर्षां'; break;
        }
    }
    return output.replace(/%d/i, number);
}

hooks.defineLocale('mr', {
    months : 'जानेवारी_फेब्रुवारी_मार्च_एप्रिल_मे_जून_जुलै_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर'.split('_'),
    monthsShort: 'जाने._फेब्रु._मार्च._एप्रि._मे._जून._जुलै._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.'.split('_'),
    monthsParseExact : true,
    weekdays : 'रविवार_सोमवार_मंगळवार_बुधवार_गुरूवार_शुक्रवार_शनिवार'.split('_'),
    weekdaysShort : 'रवि_सोम_मंगळ_बुध_गुरू_शुक्र_शनि'.split('_'),
    weekdaysMin : 'र_सो_मं_बु_गु_शु_श'.split('_'),
    longDateFormat : {
        LT : 'A h:mm वाजता',
        LTS : 'A h:mm:ss वाजता',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm वाजता',
        LLLL : 'dddd, D MMMM YYYY, A h:mm वाजता'
    },
    calendar : {
        sameDay : '[आज] LT',
        nextDay : '[उद्या] LT',
        nextWeek : 'dddd, LT',
        lastDay : '[काल] LT',
        lastWeek: '[मागील] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future: '%sमध्ये',
        past: '%sपूर्वी',
        s: relativeTimeMr,
        m: relativeTimeMr,
        mm: relativeTimeMr,
        h: relativeTimeMr,
        hh: relativeTimeMr,
        d: relativeTimeMr,
        dd: relativeTimeMr,
        M: relativeTimeMr,
        MM: relativeTimeMr,
        y: relativeTimeMr,
        yy: relativeTimeMr
    },
    preparse: function (string) {
        return string.replace(/[१२३४५६७८९०]/g, function (match) {
            return numberMap$7[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap$8[match];
        });
    },
    meridiemParse: /रात्री|सकाळी|दुपारी|सायंकाळी/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === 'रात्री') {
            return hour < 4 ? hour : hour + 12;
        } else if (meridiem === 'सकाळी') {
            return hour;
        } else if (meridiem === 'दुपारी') {
            return hour >= 10 ? hour : hour + 12;
        } else if (meridiem === 'सायंकाळी') {
            return hour + 12;
        }
    },
    meridiem: function (hour, minute, isLower) {
        if (hour < 4) {
            return 'रात्री';
        } else if (hour < 10) {
            return 'सकाळी';
        } else if (hour < 17) {
            return 'दुपारी';
        } else if (hour < 20) {
            return 'सायंकाळी';
        } else {
            return 'रात्री';
        }
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Malay [ms-my]
//! note : DEPRECATED, the correct one is [ms]
//! author : Weldan Jamili : https://github.com/weldan

hooks.defineLocale('ms-my', {
    months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
    monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
    weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
    weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
    weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
    longDateFormat : {
        LT : 'HH.mm',
        LTS : 'HH.mm.ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY [pukul] HH.mm',
        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /pagi|tengahari|petang|malam/,
    meridiemHour: function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === 'pagi') {
            return hour;
        } else if (meridiem === 'tengahari') {
            return hour >= 11 ? hour : hour + 12;
        } else if (meridiem === 'petang' || meridiem === 'malam') {
            return hour + 12;
        }
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours < 11) {
            return 'pagi';
        } else if (hours < 15) {
            return 'tengahari';
        } else if (hours < 19) {
            return 'petang';
        } else {
            return 'malam';
        }
    },
    calendar : {
        sameDay : '[Hari ini pukul] LT',
        nextDay : '[Esok pukul] LT',
        nextWeek : 'dddd [pukul] LT',
        lastDay : '[Kelmarin pukul] LT',
        lastWeek : 'dddd [lepas pukul] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'dalam %s',
        past : '%s yang lepas',
        s : 'beberapa saat',
        m : 'seminit',
        mm : '%d minit',
        h : 'sejam',
        hh : '%d jam',
        d : 'sehari',
        dd : '%d hari',
        M : 'sebulan',
        MM : '%d bulan',
        y : 'setahun',
        yy : '%d tahun'
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Malay [ms]
//! author : Weldan Jamili : https://github.com/weldan

hooks.defineLocale('ms', {
    months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
    monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
    weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
    weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
    weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
    longDateFormat : {
        LT : 'HH.mm',
        LTS : 'HH.mm.ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY [pukul] HH.mm',
        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /pagi|tengahari|petang|malam/,
    meridiemHour: function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === 'pagi') {
            return hour;
        } else if (meridiem === 'tengahari') {
            return hour >= 11 ? hour : hour + 12;
        } else if (meridiem === 'petang' || meridiem === 'malam') {
            return hour + 12;
        }
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours < 11) {
            return 'pagi';
        } else if (hours < 15) {
            return 'tengahari';
        } else if (hours < 19) {
            return 'petang';
        } else {
            return 'malam';
        }
    },
    calendar : {
        sameDay : '[Hari ini pukul] LT',
        nextDay : '[Esok pukul] LT',
        nextWeek : 'dddd [pukul] LT',
        lastDay : '[Kelmarin pukul] LT',
        lastWeek : 'dddd [lepas pukul] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'dalam %s',
        past : '%s yang lepas',
        s : 'beberapa saat',
        m : 'seminit',
        mm : '%d minit',
        h : 'sejam',
        hh : '%d jam',
        d : 'sehari',
        dd : '%d hari',
        M : 'sebulan',
        MM : '%d bulan',
        y : 'setahun',
        yy : '%d tahun'
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Burmese [my]
//! author : Squar team, mysquar.com
//! author : David Rossellat : https://github.com/gholadr
//! author : Tin Aung Lin : https://github.com/thanyawzinmin

var symbolMap$9 = {
    '1': '၁',
    '2': '၂',
    '3': '၃',
    '4': '၄',
    '5': '၅',
    '6': '၆',
    '7': '၇',
    '8': '၈',
    '9': '၉',
    '0': '၀'
};
var numberMap$8 = {
    '၁': '1',
    '၂': '2',
    '၃': '3',
    '၄': '4',
    '၅': '5',
    '၆': '6',
    '၇': '7',
    '၈': '8',
    '၉': '9',
    '၀': '0'
};

hooks.defineLocale('my', {
    months: 'ဇန်နဝါရီ_ဖေဖော်ဝါရီ_မတ်_ဧပြီ_မေ_ဇွန်_ဇူလိုင်_သြဂုတ်_စက်တင်ဘာ_အောက်တိုဘာ_နိုဝင်ဘာ_ဒီဇင်ဘာ'.split('_'),
    monthsShort: 'ဇန်_ဖေ_မတ်_ပြီ_မေ_ဇွန်_လိုင်_သြ_စက်_အောက်_နို_ဒီ'.split('_'),
    weekdays: 'တနင်္ဂနွေ_တနင်္လာ_အင်္ဂါ_ဗုဒ္ဓဟူး_ကြာသပတေး_သောကြာ_စနေ'.split('_'),
    weekdaysShort: 'နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),
    weekdaysMin: 'နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ'.split('_'),

    longDateFormat: {
        LT: 'HH:mm',
        LTS: 'HH:mm:ss',
        L: 'DD/MM/YYYY',
        LL: 'D MMMM YYYY',
        LLL: 'D MMMM YYYY HH:mm',
        LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
        sameDay: '[ယနေ.] LT [မှာ]',
        nextDay: '[မနက်ဖြန်] LT [မှာ]',
        nextWeek: 'dddd LT [မှာ]',
        lastDay: '[မနေ.က] LT [မှာ]',
        lastWeek: '[ပြီးခဲ့သော] dddd LT [မှာ]',
        sameElse: 'L'
    },
    relativeTime: {
        future: 'လာမည့် %s မှာ',
        past: 'လွန်ခဲ့သော %s က',
        s: 'စက္ကန်.အနည်းငယ်',
        m: 'တစ်မိနစ်',
        mm: '%d မိနစ်',
        h: 'တစ်နာရီ',
        hh: '%d နာရီ',
        d: 'တစ်ရက်',
        dd: '%d ရက်',
        M: 'တစ်လ',
        MM: '%d လ',
        y: 'တစ်နှစ်',
        yy: '%d နှစ်'
    },
    preparse: function (string) {
        return string.replace(/[၁၂၃၄၅၆၇၈၉၀]/g, function (match) {
            return numberMap$8[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap$9[match];
        });
    },
    week: {
        dow: 1, // Monday is the first day of the week.
        doy: 4 // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Norwegian Bokmål [nb]
//! authors : Espen Hovlandsdal : https://github.com/rexxars
//!           Sigurd Gartmann : https://github.com/sigurdga

hooks.defineLocale('nb', {
    months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
    monthsShort : 'jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
    monthsParseExact : true,
    weekdays : 'søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag'.split('_'),
    weekdaysShort : 'sø._ma._ti._on._to._fr._lø.'.split('_'),
    weekdaysMin : 'sø_ma_ti_on_to_fr_lø'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY [kl.] HH:mm',
        LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
    },
    calendar : {
        sameDay: '[i dag kl.] LT',
        nextDay: '[i morgen kl.] LT',
        nextWeek: 'dddd [kl.] LT',
        lastDay: '[i går kl.] LT',
        lastWeek: '[forrige] dddd [kl.] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'om %s',
        past : '%s siden',
        s : 'noen sekunder',
        m : 'ett minutt',
        mm : '%d minutter',
        h : 'en time',
        hh : '%d timer',
        d : 'en dag',
        dd : '%d dager',
        M : 'en måned',
        MM : '%d måneder',
        y : 'ett år',
        yy : '%d år'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Nepalese [ne]
//! author : suvash : https://github.com/suvash

var symbolMap$10 = {
    '1': '१',
    '2': '२',
    '3': '३',
    '4': '४',
    '5': '५',
    '6': '६',
    '7': '७',
    '8': '८',
    '9': '९',
    '0': '०'
};
var numberMap$9 = {
    '१': '1',
    '२': '2',
    '३': '3',
    '४': '4',
    '५': '5',
    '६': '6',
    '७': '7',
    '८': '8',
    '९': '9',
    '०': '0'
};

hooks.defineLocale('ne', {
    months : 'जनवरी_फेब्रुवरी_मार्च_अप्रिल_मई_जुन_जुलाई_अगष्ट_सेप्टेम्बर_अक्टोबर_नोभेम्बर_डिसेम्बर'.split('_'),
    monthsShort : 'जन._फेब्रु._मार्च_अप्रि._मई_जुन_जुलाई._अग._सेप्ट._अक्टो._नोभे._डिसे.'.split('_'),
    monthsParseExact : true,
    weekdays : 'आइतबार_सोमबार_मङ्गलबार_बुधबार_बिहिबार_शुक्रबार_शनिबार'.split('_'),
    weekdaysShort : 'आइत._सोम._मङ्गल._बुध._बिहि._शुक्र._शनि.'.split('_'),
    weekdaysMin : 'आ._सो._मं._बु._बि._शु._श.'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'Aको h:mm बजे',
        LTS : 'Aको h:mm:ss बजे',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, Aको h:mm बजे',
        LLLL : 'dddd, D MMMM YYYY, Aको h:mm बजे'
    },
    preparse: function (string) {
        return string.replace(/[१२३४५६७८९०]/g, function (match) {
            return numberMap$9[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap$10[match];
        });
    },
    meridiemParse: /राति|बिहान|दिउँसो|साँझ/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === 'राति') {
            return hour < 4 ? hour : hour + 12;
        } else if (meridiem === 'बिहान') {
            return hour;
        } else if (meridiem === 'दिउँसो') {
            return hour >= 10 ? hour : hour + 12;
        } else if (meridiem === 'साँझ') {
            return hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 3) {
            return 'राति';
        } else if (hour < 12) {
            return 'बिहान';
        } else if (hour < 16) {
            return 'दिउँसो';
        } else if (hour < 20) {
            return 'साँझ';
        } else {
            return 'राति';
        }
    },
    calendar : {
        sameDay : '[आज] LT',
        nextDay : '[भोलि] LT',
        nextWeek : '[आउँदो] dddd[,] LT',
        lastDay : '[हिजो] LT',
        lastWeek : '[गएको] dddd[,] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%sमा',
        past : '%s अगाडि',
        s : 'केही क्षण',
        m : 'एक मिनेट',
        mm : '%d मिनेट',
        h : 'एक घण्टा',
        hh : '%d घण्टा',
        d : 'एक दिन',
        dd : '%d दिन',
        M : 'एक महिना',
        MM : '%d महिना',
        y : 'एक बर्ष',
        yy : '%d बर्ष'
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Dutch (Belgium) [nl-be]
//! author : Joris Röling : https://github.com/jorisroling
//! author : Jacob Middag : https://github.com/middagj

var monthsShortWithDots$1 = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_');
var monthsShortWithoutDots$1 = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
var monthsRegex$1 = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

hooks.defineLocale('nl-be', {
    months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
    monthsShort : function (m, format) {
        if (!m) {
            return monthsShortWithDots$1;
        } else if (/-MMM-/.test(format)) {
            return monthsShortWithoutDots$1[m.month()];
        } else {
            return monthsShortWithDots$1[m.month()];
        }
    },

    monthsRegex: monthsRegex$1,
    monthsShortRegex: monthsRegex$1,
    monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,
    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

    monthsParse : monthsParse,
    longMonthsParse : monthsParse,
    shortMonthsParse : monthsParse,

    weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
    weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
    weekdaysMin : 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[vandaag om] LT',
        nextDay: '[morgen om] LT',
        nextWeek: 'dddd [om] LT',
        lastDay: '[gisteren om] LT',
        lastWeek: '[afgelopen] dddd [om] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'over %s',
        past : '%s geleden',
        s : 'een paar seconden',
        m : 'één minuut',
        mm : '%d minuten',
        h : 'één uur',
        hh : '%d uur',
        d : 'één dag',
        dd : '%d dagen',
        M : 'één maand',
        MM : '%d maanden',
        y : 'één jaar',
        yy : '%d jaar'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal : function (number) {
        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Dutch [nl]
//! author : Joris Röling : https://github.com/jorisroling
//! author : Jacob Middag : https://github.com/middagj

var monthsShortWithDots$2 = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_');
var monthsShortWithoutDots$2 = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

var monthsParse$1 = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
var monthsRegex$2 = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;

hooks.defineLocale('nl', {
    months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
    monthsShort : function (m, format) {
        if (!m) {
            return monthsShortWithDots$2;
        } else if (/-MMM-/.test(format)) {
            return monthsShortWithoutDots$2[m.month()];
        } else {
            return monthsShortWithDots$2[m.month()];
        }
    },

    monthsRegex: monthsRegex$2,
    monthsShortRegex: monthsRegex$2,
    monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,
    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,

    monthsParse : monthsParse$1,
    longMonthsParse : monthsParse$1,
    shortMonthsParse : monthsParse$1,

    weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
    weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
    weekdaysMin : 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD-MM-YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[vandaag om] LT',
        nextDay: '[morgen om] LT',
        nextWeek: 'dddd [om] LT',
        lastDay: '[gisteren om] LT',
        lastWeek: '[afgelopen] dddd [om] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'over %s',
        past : '%s geleden',
        s : 'een paar seconden',
        m : 'één minuut',
        mm : '%d minuten',
        h : 'één uur',
        hh : '%d uur',
        d : 'één dag',
        dd : '%d dagen',
        M : 'één maand',
        MM : '%d maanden',
        y : 'één jaar',
        yy : '%d jaar'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal : function (number) {
        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Nynorsk [nn]
//! author : https://github.com/mechuwind

hooks.defineLocale('nn', {
    months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
    monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
    weekdays : 'sundag_måndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
    weekdaysShort : 'sun_mån_tys_ons_tor_fre_lau'.split('_'),
    weekdaysMin : 'su_må_ty_on_to_fr_lø'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY [kl.] H:mm',
        LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
    },
    calendar : {
        sameDay: '[I dag klokka] LT',
        nextDay: '[I morgon klokka] LT',
        nextWeek: 'dddd [klokka] LT',
        lastDay: '[I går klokka] LT',
        lastWeek: '[Føregåande] dddd [klokka] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'om %s',
        past : '%s sidan',
        s : 'nokre sekund',
        m : 'eit minutt',
        mm : '%d minutt',
        h : 'ein time',
        hh : '%d timar',
        d : 'ein dag',
        dd : '%d dagar',
        M : 'ein månad',
        MM : '%d månader',
        y : 'eit år',
        yy : '%d år'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Punjabi (India) [pa-in]
//! author : Harpreet Singh : https://github.com/harpreetkhalsagtbit

var symbolMap$11 = {
    '1': '੧',
    '2': '੨',
    '3': '੩',
    '4': '੪',
    '5': '੫',
    '6': '੬',
    '7': '੭',
    '8': '੮',
    '9': '੯',
    '0': '੦'
};
var numberMap$10 = {
    '੧': '1',
    '੨': '2',
    '੩': '3',
    '੪': '4',
    '੫': '5',
    '੬': '6',
    '੭': '7',
    '੮': '8',
    '੯': '9',
    '੦': '0'
};

hooks.defineLocale('pa-in', {
    // There are months name as per Nanakshahi Calender but they are not used as rigidly in modern Punjabi.
    months : 'ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ'.split('_'),
    monthsShort : 'ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ'.split('_'),
    weekdays : 'ਐਤਵਾਰ_ਸੋਮਵਾਰ_ਮੰਗਲਵਾਰ_ਬੁਧਵਾਰ_ਵੀਰਵਾਰ_ਸ਼ੁੱਕਰਵਾਰ_ਸ਼ਨੀਚਰਵਾਰ'.split('_'),
    weekdaysShort : 'ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ'.split('_'),
    weekdaysMin : 'ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ'.split('_'),
    longDateFormat : {
        LT : 'A h:mm ਵਜੇ',
        LTS : 'A h:mm:ss ਵਜੇ',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm ਵਜੇ',
        LLLL : 'dddd, D MMMM YYYY, A h:mm ਵਜੇ'
    },
    calendar : {
        sameDay : '[ਅਜ] LT',
        nextDay : '[ਕਲ] LT',
        nextWeek : 'dddd, LT',
        lastDay : '[ਕਲ] LT',
        lastWeek : '[ਪਿਛਲੇ] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s ਵਿੱਚ',
        past : '%s ਪਿਛਲੇ',
        s : 'ਕੁਝ ਸਕਿੰਟ',
        m : 'ਇਕ ਮਿੰਟ',
        mm : '%d ਮਿੰਟ',
        h : 'ਇੱਕ ਘੰਟਾ',
        hh : '%d ਘੰਟੇ',
        d : 'ਇੱਕ ਦਿਨ',
        dd : '%d ਦਿਨ',
        M : 'ਇੱਕ ਮਹੀਨਾ',
        MM : '%d ਮਹੀਨੇ',
        y : 'ਇੱਕ ਸਾਲ',
        yy : '%d ਸਾਲ'
    },
    preparse: function (string) {
        return string.replace(/[੧੨੩੪੫੬੭੮੯੦]/g, function (match) {
            return numberMap$10[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap$11[match];
        });
    },
    // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
    meridiemParse: /ਰਾਤ|ਸਵੇਰ|ਦੁਪਹਿਰ|ਸ਼ਾਮ/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === 'ਰਾਤ') {
            return hour < 4 ? hour : hour + 12;
        } else if (meridiem === 'ਸਵੇਰ') {
            return hour;
        } else if (meridiem === 'ਦੁਪਹਿਰ') {
            return hour >= 10 ? hour : hour + 12;
        } else if (meridiem === 'ਸ਼ਾਮ') {
            return hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return 'ਰਾਤ';
        } else if (hour < 10) {
            return 'ਸਵੇਰ';
        } else if (hour < 17) {
            return 'ਦੁਪਹਿਰ';
        } else if (hour < 20) {
            return 'ਸ਼ਾਮ';
        } else {
            return 'ਰਾਤ';
        }
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Polish [pl]
//! author : Rafal Hirsz : https://github.com/evoL

var monthsNominative = 'styczeń_luty_marzec_kwiecień_maj_czerwiec_lipiec_sierpień_wrzesień_październik_listopad_grudzień'.split('_');
var monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_września_października_listopada_grudnia'.split('_');
function plural$3(n) {
    return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);
}
function translate$7(number, withoutSuffix, key) {
    var result = number + ' ';
    switch (key) {
        case 'm':
            return withoutSuffix ? 'minuta' : 'minutę';
        case 'mm':
            return result + (plural$3(number) ? 'minuty' : 'minut');
        case 'h':
            return withoutSuffix  ? 'godzina'  : 'godzinę';
        case 'hh':
            return result + (plural$3(number) ? 'godziny' : 'godzin');
        case 'MM':
            return result + (plural$3(number) ? 'miesiące' : 'miesięcy');
        case 'yy':
            return result + (plural$3(number) ? 'lata' : 'lat');
    }
}

hooks.defineLocale('pl', {
    months : function (momentToFormat, format) {
        if (!momentToFormat) {
            return monthsNominative;
        } else if (format === '') {
            // Hack: if format empty we know this is used to generate
            // RegExp by moment. Give then back both valid forms of months
            // in RegExp ready format.
            return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';
        } else if (/D MMMM/.test(format)) {
            return monthsSubjective[momentToFormat.month()];
        } else {
            return monthsNominative[momentToFormat.month()];
        }
    },
    monthsShort : 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paź_lis_gru'.split('_'),
    weekdays : 'niedziela_poniedziałek_wtorek_środa_czwartek_piątek_sobota'.split('_'),
    weekdaysShort : 'ndz_pon_wt_śr_czw_pt_sob'.split('_'),
    weekdaysMin : 'Nd_Pn_Wt_Śr_Cz_Pt_So'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[Dziś o] LT',
        nextDay: '[Jutro o] LT',
        nextWeek: '[W] dddd [o] LT',
        lastDay: '[Wczoraj o] LT',
        lastWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[W zeszłą niedzielę o] LT';
                case 3:
                    return '[W zeszłą środę o] LT';
                case 6:
                    return '[W zeszłą sobotę o] LT';
                default:
                    return '[W zeszły] dddd [o] LT';
            }
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : 'za %s',
        past : '%s temu',
        s : 'kilka sekund',
        m : translate$7,
        mm : translate$7,
        h : translate$7,
        hh : translate$7,
        d : '1 dzień',
        dd : '%d dni',
        M : 'miesiąc',
        MM : translate$7,
        y : 'rok',
        yy : translate$7
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Portuguese (Brazil) [pt-br]
//! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira

hooks.defineLocale('pt-br', {
    months : 'Janeiro_Fevereiro_Março_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
    monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
    weekdays : 'Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado'.split('_'),
    weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sáb'.split('_'),
    weekdaysMin : 'Do_2ª_3ª_4ª_5ª_6ª_Sá'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D [de] MMMM [de] YYYY',
        LLL : 'D [de] MMMM [de] YYYY [às] HH:mm',
        LLLL : 'dddd, D [de] MMMM [de] YYYY [às] HH:mm'
    },
    calendar : {
        sameDay: '[Hoje às] LT',
        nextDay: '[Amanhã às] LT',
        nextWeek: 'dddd [às] LT',
        lastDay: '[Ontem às] LT',
        lastWeek: function () {
            return (this.day() === 0 || this.day() === 6) ?
                '[Último] dddd [às] LT' : // Saturday + Sunday
                '[Última] dddd [às] LT'; // Monday - Friday
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : 'em %s',
        past : '%s atrás',
        s : 'poucos segundos',
        m : 'um minuto',
        mm : '%d minutos',
        h : 'uma hora',
        hh : '%d horas',
        d : 'um dia',
        dd : '%d dias',
        M : 'um mês',
        MM : '%d meses',
        y : 'um ano',
        yy : '%d anos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}º/,
    ordinal : '%dº'
});

//! moment.js locale configuration
//! locale : Portuguese [pt]
//! author : Jefferson : https://github.com/jalex79

hooks.defineLocale('pt', {
    months : 'Janeiro_Fevereiro_Março_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
    monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
    weekdays : 'Domingo_Segunda-Feira_Terça-Feira_Quarta-Feira_Quinta-Feira_Sexta-Feira_Sábado'.split('_'),
    weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sáb'.split('_'),
    weekdaysMin : 'Do_2ª_3ª_4ª_5ª_6ª_Sá'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D [de] MMMM [de] YYYY',
        LLL : 'D [de] MMMM [de] YYYY HH:mm',
        LLLL : 'dddd, D [de] MMMM [de] YYYY HH:mm'
    },
    calendar : {
        sameDay: '[Hoje às] LT',
        nextDay: '[Amanhã às] LT',
        nextWeek: 'dddd [às] LT',
        lastDay: '[Ontem às] LT',
        lastWeek: function () {
            return (this.day() === 0 || this.day() === 6) ?
                '[Último] dddd [às] LT' : // Saturday + Sunday
                '[Última] dddd [às] LT'; // Monday - Friday
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : 'em %s',
        past : 'há %s',
        s : 'segundos',
        m : 'um minuto',
        mm : '%d minutos',
        h : 'uma hora',
        hh : '%d horas',
        d : 'um dia',
        dd : '%d dias',
        M : 'um mês',
        MM : '%d meses',
        y : 'um ano',
        yy : '%d anos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}º/,
    ordinal : '%dº',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Romanian [ro]
//! author : Vlad Gurdiga : https://github.com/gurdiga
//! author : Valentin Agachi : https://github.com/avaly

function relativeTimeWithPlural$2(number, withoutSuffix, key) {
    var format = {
            'mm': 'minute',
            'hh': 'ore',
            'dd': 'zile',
            'MM': 'luni',
            'yy': 'ani'
        },
        separator = ' ';
    if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
        separator = ' de ';
    }
    return number + separator + format[key];
}

hooks.defineLocale('ro', {
    months : 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
    monthsShort : 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays : 'duminică_luni_marți_miercuri_joi_vineri_sâmbătă'.split('_'),
    weekdaysShort : 'Dum_Lun_Mar_Mie_Joi_Vin_Sâm'.split('_'),
    weekdaysMin : 'Du_Lu_Ma_Mi_Jo_Vi_Sâ'.split('_'),
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY H:mm',
        LLLL : 'dddd, D MMMM YYYY H:mm'
    },
    calendar : {
        sameDay: '[azi la] LT',
        nextDay: '[mâine la] LT',
        nextWeek: 'dddd [la] LT',
        lastDay: '[ieri la] LT',
        lastWeek: '[fosta] dddd [la] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'peste %s',
        past : '%s în urmă',
        s : 'câteva secunde',
        m : 'un minut',
        mm : relativeTimeWithPlural$2,
        h : 'o oră',
        hh : relativeTimeWithPlural$2,
        d : 'o zi',
        dd : relativeTimeWithPlural$2,
        M : 'o lună',
        MM : relativeTimeWithPlural$2,
        y : 'un an',
        yy : relativeTimeWithPlural$2
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Russian [ru]
//! author : Viktorminator : https://github.com/Viktorminator
//! Author : Menelion Elensúle : https://github.com/Oire
//! author : Коренберг Марк : https://github.com/socketpair

function plural$4(word, num) {
    var forms = word.split('_');
    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
}
function relativeTimeWithPlural$3(number, withoutSuffix, key) {
    var format = {
        'mm': withoutSuffix ? 'минута_минуты_минут' : 'минуту_минуты_минут',
        'hh': 'час_часа_часов',
        'dd': 'день_дня_дней',
        'MM': 'месяц_месяца_месяцев',
        'yy': 'год_года_лет'
    };
    if (key === 'm') {
        return withoutSuffix ? 'минута' : 'минуту';
    }
    else {
        return number + ' ' + plural$4(format[key], +number);
    }
}
var monthsParse$2 = [/^янв/i, /^фев/i, /^мар/i, /^апр/i, /^ма[йя]/i, /^июн/i, /^июл/i, /^авг/i, /^сен/i, /^окт/i, /^ноя/i, /^дек/i];

// http://new.gramota.ru/spravka/rules/139-prop : § 103
// Сокращения месяцев: http://new.gramota.ru/spravka/buro/search-answer?s=242637
// CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753
hooks.defineLocale('ru', {
    months : {
        format: 'января_февраля_марта_апреля_мая_июня_июля_августа_сентября_октября_ноября_декабря'.split('_'),
        standalone: 'январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь'.split('_')
    },
    monthsShort : {
        // по CLDR именно "июл." и "июн.", но какой смысл менять букву на точку ?
        format: 'янв._февр._мар._апр._мая_июня_июля_авг._сент._окт._нояб._дек.'.split('_'),
        standalone: 'янв._февр._март_апр._май_июнь_июль_авг._сент._окт._нояб._дек.'.split('_')
    },
    weekdays : {
        standalone: 'воскресенье_понедельник_вторник_среда_четверг_пятница_суббота'.split('_'),
        format: 'воскресенье_понедельник_вторник_среду_четверг_пятницу_субботу'.split('_'),
        isFormat: /\[ ?[Вв] ?(?:прошлую|следующую|эту)? ?\] ?dddd/
    },
    weekdaysShort : 'вс_пн_вт_ср_чт_пт_сб'.split('_'),
    weekdaysMin : 'вс_пн_вт_ср_чт_пт_сб'.split('_'),
    monthsParse : monthsParse$2,
    longMonthsParse : monthsParse$2,
    shortMonthsParse : monthsParse$2,

    // полные названия с падежами, по три буквы, для некоторых, по 4 буквы, сокращения с точкой и без точки
    monthsRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,

    // копия предыдущего
    monthsShortRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,

    // полные названия с падежами
    monthsStrictRegex: /^(январ[яь]|феврал[яь]|марта?|апрел[яь]|ма[яй]|июн[яь]|июл[яь]|августа?|сентябр[яь]|октябр[яь]|ноябр[яь]|декабр[яь])/i,

    // Выражение, которое соотвествует только сокращённым формам
    monthsShortStrictRegex: /^(янв\.|февр?\.|мар[т.]|апр\.|ма[яй]|июн[ья.]|июл[ья.]|авг\.|сент?\.|окт\.|нояб?\.|дек\.)/i,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY г.',
        LLL : 'D MMMM YYYY г., HH:mm',
        LLLL : 'dddd, D MMMM YYYY г., HH:mm'
    },
    calendar : {
        sameDay: '[Сегодня в] LT',
        nextDay: '[Завтра в] LT',
        lastDay: '[Вчера в] LT',
        nextWeek: function (now) {
            if (now.week() !== this.week()) {
                switch (this.day()) {
                    case 0:
                        return '[В следующее] dddd [в] LT';
                    case 1:
                    case 2:
                    case 4:
                        return '[В следующий] dddd [в] LT';
                    case 3:
                    case 5:
                    case 6:
                        return '[В следующую] dddd [в] LT';
                }
            } else {
                if (this.day() === 2) {
                    return '[Во] dddd [в] LT';
                } else {
                    return '[В] dddd [в] LT';
                }
            }
        },
        lastWeek: function (now) {
            if (now.week() !== this.week()) {
                switch (this.day()) {
                    case 0:
                        return '[В прошлое] dddd [в] LT';
                    case 1:
                    case 2:
                    case 4:
                        return '[В прошлый] dddd [в] LT';
                    case 3:
                    case 5:
                    case 6:
                        return '[В прошлую] dddd [в] LT';
                }
            } else {
                if (this.day() === 2) {
                    return '[Во] dddd [в] LT';
                } else {
                    return '[В] dddd [в] LT';
                }
            }
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : 'через %s',
        past : '%s назад',
        s : 'несколько секунд',
        m : relativeTimeWithPlural$3,
        mm : relativeTimeWithPlural$3,
        h : 'час',
        hh : relativeTimeWithPlural$3,
        d : 'день',
        dd : relativeTimeWithPlural$3,
        M : 'месяц',
        MM : relativeTimeWithPlural$3,
        y : 'год',
        yy : relativeTimeWithPlural$3
    },
    meridiemParse: /ночи|утра|дня|вечера/i,
    isPM : function (input) {
        return /^(дня|вечера)$/.test(input);
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return 'ночи';
        } else if (hour < 12) {
            return 'утра';
        } else if (hour < 17) {
            return 'дня';
        } else {
            return 'вечера';
        }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(й|го|я)/,
    ordinal: function (number, period) {
        switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
                return number + '-й';
            case 'D':
                return number + '-го';
            case 'w':
            case 'W':
                return number + '-я';
            default:
                return number;
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Sindhi [sd]
//! author : Narain Sagar : https://github.com/narainsagar

var months$6 = [
    'جنوري',
    'فيبروري',
    'مارچ',
    'اپريل',
    'مئي',
    'جون',
    'جولاءِ',
    'آگسٽ',
    'سيپٽمبر',
    'آڪٽوبر',
    'نومبر',
    'ڊسمبر'
];
var days$1 = [
    'آچر',
    'سومر',
    'اڱارو',
    'اربع',
    'خميس',
    'جمع',
    'ڇنڇر'
];

hooks.defineLocale('sd', {
    months : months$6,
    monthsShort : months$6,
    weekdays : days$1,
    weekdaysShort : days$1,
    weekdaysMin : days$1,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd، D MMMM YYYY HH:mm'
    },
    meridiemParse: /صبح|شام/,
    isPM : function (input) {
        return 'شام' === input;
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return 'صبح';
        }
        return 'شام';
    },
    calendar : {
        sameDay : '[اڄ] LT',
        nextDay : '[سڀاڻي] LT',
        nextWeek : 'dddd [اڳين هفتي تي] LT',
        lastDay : '[ڪالهه] LT',
        lastWeek : '[گزريل هفتي] dddd [تي] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s پوء',
        past : '%s اڳ',
        s : 'چند سيڪنڊ',
        m : 'هڪ منٽ',
        mm : '%d منٽ',
        h : 'هڪ ڪلاڪ',
        hh : '%d ڪلاڪ',
        d : 'هڪ ڏينهن',
        dd : '%d ڏينهن',
        M : 'هڪ مهينو',
        MM : '%d مهينا',
        y : 'هڪ سال',
        yy : '%d سال'
    },
    preparse: function (string) {
        return string.replace(/،/g, ',');
    },
    postformat: function (string) {
        return string.replace(/,/g, '،');
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Northern Sami [se]
//! authors : Bård Rolstad Henriksen : https://github.com/karamell


hooks.defineLocale('se', {
    months : 'ođđajagemánnu_guovvamánnu_njukčamánnu_cuoŋománnu_miessemánnu_geassemánnu_suoidnemánnu_borgemánnu_čakčamánnu_golggotmánnu_skábmamánnu_juovlamánnu'.split('_'),
    monthsShort : 'ođđj_guov_njuk_cuo_mies_geas_suoi_borg_čakč_golg_skáb_juov'.split('_'),
    weekdays : 'sotnabeaivi_vuossárga_maŋŋebárga_gaskavahkku_duorastat_bearjadat_lávvardat'.split('_'),
    weekdaysShort : 'sotn_vuos_maŋ_gask_duor_bear_láv'.split('_'),
    weekdaysMin : 's_v_m_g_d_b_L'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'MMMM D. [b.] YYYY',
        LLL : 'MMMM D. [b.] YYYY [ti.] HH:mm',
        LLLL : 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm'
    },
    calendar : {
        sameDay: '[otne ti] LT',
        nextDay: '[ihttin ti] LT',
        nextWeek: 'dddd [ti] LT',
        lastDay: '[ikte ti] LT',
        lastWeek: '[ovddit] dddd [ti] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : '%s geažes',
        past : 'maŋit %s',
        s : 'moadde sekunddat',
        m : 'okta minuhta',
        mm : '%d minuhtat',
        h : 'okta diimmu',
        hh : '%d diimmut',
        d : 'okta beaivi',
        dd : '%d beaivvit',
        M : 'okta mánnu',
        MM : '%d mánut',
        y : 'okta jahki',
        yy : '%d jagit'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Sinhalese [si]
//! author : Sampath Sitinamaluwa : https://github.com/sampathsris

/*jshint -W100*/
hooks.defineLocale('si', {
    months : 'ජනවාරි_පෙබරවාරි_මාර්තු_අප්‍රේල්_මැයි_ජූනි_ජූලි_අගෝස්තු_සැප්තැම්බර්_ඔක්තෝබර්_නොවැම්බර්_දෙසැම්බර්'.split('_'),
    monthsShort : 'ජන_පෙබ_මාර්_අප්_මැයි_ජූනි_ජූලි_අගෝ_සැප්_ඔක්_නොවැ_දෙසැ'.split('_'),
    weekdays : 'ඉරිදා_සඳුදා_අඟහරුවාදා_බදාදා_බ්‍රහස්පතින්දා_සිකුරාදා_සෙනසුරාදා'.split('_'),
    weekdaysShort : 'ඉරි_සඳු_අඟ_බදා_බ්‍රහ_සිකු_සෙන'.split('_'),
    weekdaysMin : 'ඉ_ස_අ_බ_බ්‍ර_සි_සෙ'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'a h:mm',
        LTS : 'a h:mm:ss',
        L : 'YYYY/MM/DD',
        LL : 'YYYY MMMM D',
        LLL : 'YYYY MMMM D, a h:mm',
        LLLL : 'YYYY MMMM D [වැනි] dddd, a h:mm:ss'
    },
    calendar : {
        sameDay : '[අද] LT[ට]',
        nextDay : '[හෙට] LT[ට]',
        nextWeek : 'dddd LT[ට]',
        lastDay : '[ඊයේ] LT[ට]',
        lastWeek : '[පසුගිය] dddd LT[ට]',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%sකින්',
        past : '%sකට පෙර',
        s : 'තත්පර කිහිපය',
        m : 'මිනිත්තුව',
        mm : 'මිනිත්තු %d',
        h : 'පැය',
        hh : 'පැය %d',
        d : 'දිනය',
        dd : 'දින %d',
        M : 'මාසය',
        MM : 'මාස %d',
        y : 'වසර',
        yy : 'වසර %d'
    },
    dayOfMonthOrdinalParse: /\d{1,2} වැනි/,
    ordinal : function (number) {
        return number + ' වැනි';
    },
    meridiemParse : /පෙර වරු|පස් වරු|පෙ.ව|ප.ව./,
    isPM : function (input) {
        return input === 'ප.ව.' || input === 'පස් වරු';
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'ප.ව.' : 'පස් වරු';
        } else {
            return isLower ? 'පෙ.ව.' : 'පෙර වරු';
        }
    }
});

//! moment.js locale configuration
//! locale : Slovak [sk]
//! author : Martin Minka : https://github.com/k2s
//! based on work of petrbela : https://github.com/petrbela

var months$7 = 'január_február_marec_apríl_máj_jún_júl_august_september_október_november_december'.split('_');
var monthsShort$4 = 'jan_feb_mar_apr_máj_jún_júl_aug_sep_okt_nov_dec'.split('_');
function plural$5(n) {
    return (n > 1) && (n < 5);
}
function translate$8(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';
    switch (key) {
        case 's':  // a few seconds / in a few seconds / a few seconds ago
            return (withoutSuffix || isFuture) ? 'pár sekúnd' : 'pár sekundami';
        case 'm':  // a minute / in a minute / a minute ago
            return withoutSuffix ? 'minúta' : (isFuture ? 'minútu' : 'minútou');
        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
            if (withoutSuffix || isFuture) {
                return result + (plural$5(number) ? 'minúty' : 'minút');
            } else {
                return result + 'minútami';
            }
            break;
        case 'h':  // an hour / in an hour / an hour ago
            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
        case 'hh': // 9 hours / in 9 hours / 9 hours ago
            if (withoutSuffix || isFuture) {
                return result + (plural$5(number) ? 'hodiny' : 'hodín');
            } else {
                return result + 'hodinami';
            }
            break;
        case 'd':  // a day / in a day / a day ago
            return (withoutSuffix || isFuture) ? 'deň' : 'dňom';
        case 'dd': // 9 days / in 9 days / 9 days ago
            if (withoutSuffix || isFuture) {
                return result + (plural$5(number) ? 'dni' : 'dní');
            } else {
                return result + 'dňami';
            }
            break;
        case 'M':  // a month / in a month / a month ago
            return (withoutSuffix || isFuture) ? 'mesiac' : 'mesiacom';
        case 'MM': // 9 months / in 9 months / 9 months ago
            if (withoutSuffix || isFuture) {
                return result + (plural$5(number) ? 'mesiace' : 'mesiacov');
            } else {
                return result + 'mesiacmi';
            }
            break;
        case 'y':  // a year / in a year / a year ago
            return (withoutSuffix || isFuture) ? 'rok' : 'rokom';
        case 'yy': // 9 years / in 9 years / 9 years ago
            if (withoutSuffix || isFuture) {
                return result + (plural$5(number) ? 'roky' : 'rokov');
            } else {
                return result + 'rokmi';
            }
            break;
    }
}

hooks.defineLocale('sk', {
    months : months$7,
    monthsShort : monthsShort$4,
    weekdays : 'nedeľa_pondelok_utorok_streda_štvrtok_piatok_sobota'.split('_'),
    weekdaysShort : 'ne_po_ut_st_št_pi_so'.split('_'),
    weekdaysMin : 'ne_po_ut_st_št_pi_so'.split('_'),
    longDateFormat : {
        LT: 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY H:mm',
        LLLL : 'dddd D. MMMM YYYY H:mm'
    },
    calendar : {
        sameDay: '[dnes o] LT',
        nextDay: '[zajtra o] LT',
        nextWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[v nedeľu o] LT';
                case 1:
                case 2:
                    return '[v] dddd [o] LT';
                case 3:
                    return '[v stredu o] LT';
                case 4:
                    return '[vo štvrtok o] LT';
                case 5:
                    return '[v piatok o] LT';
                case 6:
                    return '[v sobotu o] LT';
            }
        },
        lastDay: '[včera o] LT',
        lastWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[minulú nedeľu o] LT';
                case 1:
                case 2:
                    return '[minulý] dddd [o] LT';
                case 3:
                    return '[minulú stredu o] LT';
                case 4:
                case 5:
                    return '[minulý] dddd [o] LT';
                case 6:
                    return '[minulú sobotu o] LT';
            }
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : 'za %s',
        past : 'pred %s',
        s : translate$8,
        m : translate$8,
        mm : translate$8,
        h : translate$8,
        hh : translate$8,
        d : translate$8,
        dd : translate$8,
        M : translate$8,
        MM : translate$8,
        y : translate$8,
        yy : translate$8
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Slovenian [sl]
//! author : Robert Sedovšek : https://github.com/sedovsek

function processRelativeTime$6(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';
    switch (key) {
        case 's':
            return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';
        case 'm':
            return withoutSuffix ? 'ena minuta' : 'eno minuto';
        case 'mm':
            if (number === 1) {
                result += withoutSuffix ? 'minuta' : 'minuto';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? 'minute' : 'minutami';
            } else {
                result += withoutSuffix || isFuture ? 'minut' : 'minutami';
            }
            return result;
        case 'h':
            return withoutSuffix ? 'ena ura' : 'eno uro';
        case 'hh':
            if (number === 1) {
                result += withoutSuffix ? 'ura' : 'uro';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'uri' : 'urama';
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? 'ure' : 'urami';
            } else {
                result += withoutSuffix || isFuture ? 'ur' : 'urami';
            }
            return result;
        case 'd':
            return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
        case 'dd':
            if (number === 1) {
                result += withoutSuffix || isFuture ? 'dan' : 'dnem';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
            } else {
                result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
            }
            return result;
        case 'M':
            return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
        case 'MM':
            if (number === 1) {
                result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
            } else {
                result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
            }
            return result;
        case 'y':
            return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
        case 'yy':
            if (number === 1) {
                result += withoutSuffix || isFuture ? 'leto' : 'letom';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'leti' : 'letoma';
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? 'leta' : 'leti';
            } else {
                result += withoutSuffix || isFuture ? 'let' : 'leti';
            }
            return result;
    }
}

hooks.defineLocale('sl', {
    months : 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
    monthsShort : 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays : 'nedelja_ponedeljek_torek_sreda_četrtek_petek_sobota'.split('_'),
    weekdaysShort : 'ned._pon._tor._sre._čet._pet._sob.'.split('_'),
    weekdaysMin : 'ne_po_to_sr_če_pe_so'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM YYYY',
        LLL : 'D. MMMM YYYY H:mm',
        LLLL : 'dddd, D. MMMM YYYY H:mm'
    },
    calendar : {
        sameDay  : '[danes ob] LT',
        nextDay  : '[jutri ob] LT',

        nextWeek : function () {
            switch (this.day()) {
                case 0:
                    return '[v] [nedeljo] [ob] LT';
                case 3:
                    return '[v] [sredo] [ob] LT';
                case 6:
                    return '[v] [soboto] [ob] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[v] dddd [ob] LT';
            }
        },
        lastDay  : '[včeraj ob] LT',
        lastWeek : function () {
            switch (this.day()) {
                case 0:
                    return '[prejšnjo] [nedeljo] [ob] LT';
                case 3:
                    return '[prejšnjo] [sredo] [ob] LT';
                case 6:
                    return '[prejšnjo] [soboto] [ob] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[prejšnji] dddd [ob] LT';
            }
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'čez %s',
        past   : 'pred %s',
        s      : processRelativeTime$6,
        m      : processRelativeTime$6,
        mm     : processRelativeTime$6,
        h      : processRelativeTime$6,
        hh     : processRelativeTime$6,
        d      : processRelativeTime$6,
        dd     : processRelativeTime$6,
        M      : processRelativeTime$6,
        MM     : processRelativeTime$6,
        y      : processRelativeTime$6,
        yy     : processRelativeTime$6
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Albanian [sq]
//! author : Flakërim Ismani : https://github.com/flakerimi
//! author : Menelion Elensúle : https://github.com/Oire
//! author : Oerd Cukalla : https://github.com/oerd

hooks.defineLocale('sq', {
    months : 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nëntor_Dhjetor'.split('_'),
    monthsShort : 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nën_Dhj'.split('_'),
    weekdays : 'E Diel_E Hënë_E Martë_E Mërkurë_E Enjte_E Premte_E Shtunë'.split('_'),
    weekdaysShort : 'Die_Hën_Mar_Mër_Enj_Pre_Sht'.split('_'),
    weekdaysMin : 'D_H_Ma_Më_E_P_Sh'.split('_'),
    weekdaysParseExact : true,
    meridiemParse: /PD|MD/,
    isPM: function (input) {
        return input.charAt(0) === 'M';
    },
    meridiem : function (hours, minutes, isLower) {
        return hours < 12 ? 'PD' : 'MD';
    },
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[Sot në] LT',
        nextDay : '[Nesër në] LT',
        nextWeek : 'dddd [në] LT',
        lastDay : '[Dje në] LT',
        lastWeek : 'dddd [e kaluar në] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'në %s',
        past : '%s më parë',
        s : 'disa sekonda',
        m : 'një minutë',
        mm : '%d minuta',
        h : 'një orë',
        hh : '%d orë',
        d : 'një ditë',
        dd : '%d ditë',
        M : 'një muaj',
        MM : '%d muaj',
        y : 'një vit',
        yy : '%d vite'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Serbian Cyrillic [sr-cyrl]
//! author : Milan Janačković<milanjanackovic@gmail.com> : https://github.com/milan-j

var translator$1 = {
    words: { //Different grammatical cases
        m: ['један минут', 'једне минуте'],
        mm: ['минут', 'минуте', 'минута'],
        h: ['један сат', 'једног сата'],
        hh: ['сат', 'сата', 'сати'],
        dd: ['дан', 'дана', 'дана'],
        MM: ['месец', 'месеца', 'месеци'],
        yy: ['година', 'године', 'година']
    },
    correctGrammaticalCase: function (number, wordKey) {
        return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
    },
    translate: function (number, withoutSuffix, key) {
        var wordKey = translator$1.words[key];
        if (key.length === 1) {
            return withoutSuffix ? wordKey[0] : wordKey[1];
        } else {
            return number + ' ' + translator$1.correctGrammaticalCase(number, wordKey);
        }
    }
};

hooks.defineLocale('sr-cyrl', {
    months: 'јануар_фебруар_март_април_мај_јун_јул_август_септембар_октобар_новембар_децембар'.split('_'),
    monthsShort: 'јан._феб._мар._апр._мај_јун_јул_авг._сеп._окт._нов._дец.'.split('_'),
    monthsParseExact: true,
    weekdays: 'недеља_понедељак_уторак_среда_четвртак_петак_субота'.split('_'),
    weekdaysShort: 'нед._пон._уто._сре._чет._пет._суб.'.split('_'),
    weekdaysMin: 'не_по_ут_ср_че_пе_су'.split('_'),
    weekdaysParseExact : true,
    longDateFormat: {
        LT: 'H:mm',
        LTS : 'H:mm:ss',
        L: 'DD.MM.YYYY',
        LL: 'D. MMMM YYYY',
        LLL: 'D. MMMM YYYY H:mm',
        LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
        sameDay: '[данас у] LT',
        nextDay: '[сутра у] LT',
        nextWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[у] [недељу] [у] LT';
                case 3:
                    return '[у] [среду] [у] LT';
                case 6:
                    return '[у] [суботу] [у] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[у] dddd [у] LT';
            }
        },
        lastDay  : '[јуче у] LT',
        lastWeek : function () {
            var lastWeekDays = [
                '[прошле] [недеље] [у] LT',
                '[прошлог] [понедељка] [у] LT',
                '[прошлог] [уторка] [у] LT',
                '[прошле] [среде] [у] LT',
                '[прошлог] [четвртка] [у] LT',
                '[прошлог] [петка] [у] LT',
                '[прошле] [суботе] [у] LT'
            ];
            return lastWeekDays[this.day()];
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'за %s',
        past   : 'пре %s',
        s      : 'неколико секунди',
        m      : translator$1.translate,
        mm     : translator$1.translate,
        h      : translator$1.translate,
        hh     : translator$1.translate,
        d      : 'дан',
        dd     : translator$1.translate,
        M      : 'месец',
        MM     : translator$1.translate,
        y      : 'годину',
        yy     : translator$1.translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Serbian [sr]
//! author : Milan Janačković<milanjanackovic@gmail.com> : https://github.com/milan-j

var translator$2 = {
    words: { //Different grammatical cases
        m: ['jedan minut', 'jedne minute'],
        mm: ['minut', 'minute', 'minuta'],
        h: ['jedan sat', 'jednog sata'],
        hh: ['sat', 'sata', 'sati'],
        dd: ['dan', 'dana', 'dana'],
        MM: ['mesec', 'meseca', 'meseci'],
        yy: ['godina', 'godine', 'godina']
    },
    correctGrammaticalCase: function (number, wordKey) {
        return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
    },
    translate: function (number, withoutSuffix, key) {
        var wordKey = translator$2.words[key];
        if (key.length === 1) {
            return withoutSuffix ? wordKey[0] : wordKey[1];
        } else {
            return number + ' ' + translator$2.correctGrammaticalCase(number, wordKey);
        }
    }
};

hooks.defineLocale('sr', {
    months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
    monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'nedelja_ponedeljak_utorak_sreda_četvrtak_petak_subota'.split('_'),
    weekdaysShort: 'ned._pon._uto._sre._čet._pet._sub.'.split('_'),
    weekdaysMin: 'ne_po_ut_sr_če_pe_su'.split('_'),
    weekdaysParseExact : true,
    longDateFormat: {
        LT: 'H:mm',
        LTS : 'H:mm:ss',
        L: 'DD.MM.YYYY',
        LL: 'D. MMMM YYYY',
        LLL: 'D. MMMM YYYY H:mm',
        LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
        sameDay: '[danas u] LT',
        nextDay: '[sutra u] LT',
        nextWeek: function () {
            switch (this.day()) {
                case 0:
                    return '[u] [nedelju] [u] LT';
                case 3:
                    return '[u] [sredu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
            }
        },
        lastDay  : '[juče u] LT',
        lastWeek : function () {
            var lastWeekDays = [
                '[prošle] [nedelje] [u] LT',
                '[prošlog] [ponedeljka] [u] LT',
                '[prošlog] [utorka] [u] LT',
                '[prošle] [srede] [u] LT',
                '[prošlog] [četvrtka] [u] LT',
                '[prošlog] [petka] [u] LT',
                '[prošle] [subote] [u] LT'
            ];
            return lastWeekDays[this.day()];
        },
        sameElse : 'L'
    },
    relativeTime : {
        future : 'za %s',
        past   : 'pre %s',
        s      : 'nekoliko sekundi',
        m      : translator$2.translate,
        mm     : translator$2.translate,
        h      : translator$2.translate,
        hh     : translator$2.translate,
        d      : 'dan',
        dd     : translator$2.translate,
        M      : 'mesec',
        MM     : translator$2.translate,
        y      : 'godinu',
        yy     : translator$2.translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : siSwati [ss]
//! author : Nicolai Davies<mail@nicolai.io> : https://github.com/nicolaidavies


hooks.defineLocale('ss', {
    months : "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split('_'),
    monthsShort : 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
    weekdays : 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split('_'),
    weekdaysShort : 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
    weekdaysMin : 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'h:mm A',
        LTS : 'h:mm:ss A',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY h:mm A',
        LLLL : 'dddd, D MMMM YYYY h:mm A'
    },
    calendar : {
        sameDay : '[Namuhla nga] LT',
        nextDay : '[Kusasa nga] LT',
        nextWeek : 'dddd [nga] LT',
        lastDay : '[Itolo nga] LT',
        lastWeek : 'dddd [leliphelile] [nga] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'nga %s',
        past : 'wenteka nga %s',
        s : 'emizuzwana lomcane',
        m : 'umzuzu',
        mm : '%d emizuzu',
        h : 'lihora',
        hh : '%d emahora',
        d : 'lilanga',
        dd : '%d emalanga',
        M : 'inyanga',
        MM : '%d tinyanga',
        y : 'umnyaka',
        yy : '%d iminyaka'
    },
    meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
    meridiem : function (hours, minutes, isLower) {
        if (hours < 11) {
            return 'ekuseni';
        } else if (hours < 15) {
            return 'emini';
        } else if (hours < 19) {
            return 'entsambama';
        } else {
            return 'ebusuku';
        }
    },
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === 'ekuseni') {
            return hour;
        } else if (meridiem === 'emini') {
            return hour >= 11 ? hour : hour + 12;
        } else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {
            if (hour === 0) {
                return 0;
            }
            return hour + 12;
        }
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal : '%d',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Swedish [sv]
//! author : Jens Alm : https://github.com/ulmus

hooks.defineLocale('sv', {
    months : 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
    monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
    weekdays : 'söndag_måndag_tisdag_onsdag_torsdag_fredag_lördag'.split('_'),
    weekdaysShort : 'sön_mån_tis_ons_tor_fre_lör'.split('_'),
    weekdaysMin : 'sö_må_ti_on_to_fr_lö'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYY-MM-DD',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY [kl.] HH:mm',
        LLLL : 'dddd D MMMM YYYY [kl.] HH:mm',
        lll : 'D MMM YYYY HH:mm',
        llll : 'ddd D MMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[Idag] LT',
        nextDay: '[Imorgon] LT',
        lastDay: '[Igår] LT',
        nextWeek: '[På] dddd LT',
        lastWeek: '[I] dddd[s] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'om %s',
        past : 'för %s sedan',
        s : 'några sekunder',
        m : 'en minut',
        mm : '%d minuter',
        h : 'en timme',
        hh : '%d timmar',
        d : 'en dag',
        dd : '%d dagar',
        M : 'en månad',
        MM : '%d månader',
        y : 'ett år',
        yy : '%d år'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(e|a)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (~~(number % 100 / 10) === 1) ? 'e' :
            (b === 1) ? 'a' :
            (b === 2) ? 'a' :
            (b === 3) ? 'e' : 'e';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Swahili [sw]
//! author : Fahad Kassim : https://github.com/fadsel

hooks.defineLocale('sw', {
    months : 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split('_'),
    monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
    weekdays : 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split('_'),
    weekdaysShort : 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
    weekdaysMin : 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[leo saa] LT',
        nextDay : '[kesho saa] LT',
        nextWeek : '[wiki ijayo] dddd [saat] LT',
        lastDay : '[jana] LT',
        lastWeek : '[wiki iliyopita] dddd [saat] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s baadaye',
        past : 'tokea %s',
        s : 'hivi punde',
        m : 'dakika moja',
        mm : 'dakika %d',
        h : 'saa limoja',
        hh : 'masaa %d',
        d : 'siku moja',
        dd : 'masiku %d',
        M : 'mwezi mmoja',
        MM : 'miezi %d',
        y : 'mwaka mmoja',
        yy : 'miaka %d'
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Tamil [ta]
//! author : Arjunkumar Krishnamoorthy : https://github.com/tk120404

var symbolMap$12 = {
    '1': '௧',
    '2': '௨',
    '3': '௩',
    '4': '௪',
    '5': '௫',
    '6': '௬',
    '7': '௭',
    '8': '௮',
    '9': '௯',
    '0': '௦'
};
var numberMap$11 = {
    '௧': '1',
    '௨': '2',
    '௩': '3',
    '௪': '4',
    '௫': '5',
    '௬': '6',
    '௭': '7',
    '௮': '8',
    '௯': '9',
    '௦': '0'
};

hooks.defineLocale('ta', {
    months : 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split('_'),
    monthsShort : 'ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்'.split('_'),
    weekdays : 'ஞாயிற்றுக்கிழமை_திங்கட்கிழமை_செவ்வாய்கிழமை_புதன்கிழமை_வியாழக்கிழமை_வெள்ளிக்கிழமை_சனிக்கிழமை'.split('_'),
    weekdaysShort : 'ஞாயிறு_திங்கள்_செவ்வாய்_புதன்_வியாழன்_வெள்ளி_சனி'.split('_'),
    weekdaysMin : 'ஞா_தி_செ_பு_வி_வெ_ச'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, HH:mm',
        LLLL : 'dddd, D MMMM YYYY, HH:mm'
    },
    calendar : {
        sameDay : '[இன்று] LT',
        nextDay : '[நாளை] LT',
        nextWeek : 'dddd, LT',
        lastDay : '[நேற்று] LT',
        lastWeek : '[கடந்த வாரம்] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s இல்',
        past : '%s முன்',
        s : 'ஒரு சில விநாடிகள்',
        m : 'ஒரு நிமிடம்',
        mm : '%d நிமிடங்கள்',
        h : 'ஒரு மணி நேரம்',
        hh : '%d மணி நேரம்',
        d : 'ஒரு நாள்',
        dd : '%d நாட்கள்',
        M : 'ஒரு மாதம்',
        MM : '%d மாதங்கள்',
        y : 'ஒரு வருடம்',
        yy : '%d ஆண்டுகள்'
    },
    dayOfMonthOrdinalParse: /\d{1,2}வது/,
    ordinal : function (number) {
        return number + 'வது';
    },
    preparse: function (string) {
        return string.replace(/[௧௨௩௪௫௬௭௮௯௦]/g, function (match) {
            return numberMap$11[match];
        });
    },
    postformat: function (string) {
        return string.replace(/\d/g, function (match) {
            return symbolMap$12[match];
        });
    },
    // refer http://ta.wikipedia.org/s/1er1
    meridiemParse: /யாமம்|வைகறை|காலை|நண்பகல்|எற்பாடு|மாலை/,
    meridiem : function (hour, minute, isLower) {
        if (hour < 2) {
            return ' யாமம்';
        } else if (hour < 6) {
            return ' வைகறை';  // வைகறை
        } else if (hour < 10) {
            return ' காலை'; // காலை
        } else if (hour < 14) {
            return ' நண்பகல்'; // நண்பகல்
        } else if (hour < 18) {
            return ' எற்பாடு'; // எற்பாடு
        } else if (hour < 22) {
            return ' மாலை'; // மாலை
        } else {
            return ' யாமம்';
        }
    },
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === 'யாமம்') {
            return hour < 2 ? hour : hour + 12;
        } else if (meridiem === 'வைகறை' || meridiem === 'காலை') {
            return hour;
        } else if (meridiem === 'நண்பகல்') {
            return hour >= 10 ? hour : hour + 12;
        } else {
            return hour + 12;
        }
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Telugu [te]
//! author : Krishna Chaitanya Thota : https://github.com/kcthota

hooks.defineLocale('te', {
    months : 'జనవరి_ఫిబ్రవరి_మార్చి_ఏప్రిల్_మే_జూన్_జూలై_ఆగస్టు_సెప్టెంబర్_అక్టోబర్_నవంబర్_డిసెంబర్'.split('_'),
    monthsShort : 'జన._ఫిబ్ర._మార్చి_ఏప్రి._మే_జూన్_జూలై_ఆగ._సెప్._అక్టో._నవ._డిసె.'.split('_'),
    monthsParseExact : true,
    weekdays : 'ఆదివారం_సోమవారం_మంగళవారం_బుధవారం_గురువారం_శుక్రవారం_శనివారం'.split('_'),
    weekdaysShort : 'ఆది_సోమ_మంగళ_బుధ_గురు_శుక్ర_శని'.split('_'),
    weekdaysMin : 'ఆ_సో_మం_బు_గు_శు_శ'.split('_'),
    longDateFormat : {
        LT : 'A h:mm',
        LTS : 'A h:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY, A h:mm',
        LLLL : 'dddd, D MMMM YYYY, A h:mm'
    },
    calendar : {
        sameDay : '[నేడు] LT',
        nextDay : '[రేపు] LT',
        nextWeek : 'dddd, LT',
        lastDay : '[నిన్న] LT',
        lastWeek : '[గత] dddd, LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s లో',
        past : '%s క్రితం',
        s : 'కొన్ని క్షణాలు',
        m : 'ఒక నిమిషం',
        mm : '%d నిమిషాలు',
        h : 'ఒక గంట',
        hh : '%d గంటలు',
        d : 'ఒక రోజు',
        dd : '%d రోజులు',
        M : 'ఒక నెల',
        MM : '%d నెలలు',
        y : 'ఒక సంవత్సరం',
        yy : '%d సంవత్సరాలు'
    },
    dayOfMonthOrdinalParse : /\d{1,2}వ/,
    ordinal : '%dవ',
    meridiemParse: /రాత్రి|ఉదయం|మధ్యాహ్నం|సాయంత్రం/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === 'రాత్రి') {
            return hour < 4 ? hour : hour + 12;
        } else if (meridiem === 'ఉదయం') {
            return hour;
        } else if (meridiem === 'మధ్యాహ్నం') {
            return hour >= 10 ? hour : hour + 12;
        } else if (meridiem === 'సాయంత్రం') {
            return hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return 'రాత్రి';
        } else if (hour < 10) {
            return 'ఉదయం';
        } else if (hour < 17) {
            return 'మధ్యాహ్నం';
        } else if (hour < 20) {
            return 'సాయంత్రం';
        } else {
            return 'రాత్రి';
        }
    },
    week : {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Tetun Dili (East Timor) [tet]
//! author : Joshua Brooks : https://github.com/joshbrooks
//! author : Onorio De J. Afonso : https://github.com/marobo

hooks.defineLocale('tet', {
    months : 'Janeiru_Fevereiru_Marsu_Abril_Maiu_Juniu_Juliu_Augustu_Setembru_Outubru_Novembru_Dezembru'.split('_'),
    monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Aug_Set_Out_Nov_Dez'.split('_'),
    weekdays : 'Domingu_Segunda_Tersa_Kuarta_Kinta_Sexta_Sabadu'.split('_'),
    weekdaysShort : 'Dom_Seg_Ters_Kua_Kint_Sext_Sab'.split('_'),
    weekdaysMin : 'Do_Seg_Te_Ku_Ki_Sex_Sa'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[Ohin iha] LT',
        nextDay: '[Aban iha] LT',
        nextWeek: 'dddd [iha] LT',
        lastDay: '[Horiseik iha] LT',
        lastWeek: 'dddd [semana kotuk] [iha] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'iha %s',
        past : '%s liuba',
        s : 'minutu balun',
        m : 'minutu ida',
        mm : 'minutus %d',
        h : 'horas ida',
        hh : 'horas %d',
        d : 'loron ida',
        dd : 'loron %d',
        M : 'fulan ida',
        MM : 'fulan %d',
        y : 'tinan ida',
        yy : 'tinan %d'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (~~(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Thai [th]
//! author : Kridsada Thanabulpong : https://github.com/sirn

hooks.defineLocale('th', {
    months : 'มกราคม_กุมภาพันธ์_มีนาคม_เมษายน_พฤษภาคม_มิถุนายน_กรกฎาคม_สิงหาคม_กันยายน_ตุลาคม_พฤศจิกายน_ธันวาคม'.split('_'),
    monthsShort : 'ม.ค._ก.พ._มี.ค._เม.ย._พ.ค._มิ.ย._ก.ค._ส.ค._ก.ย._ต.ค._พ.ย._ธ.ค.'.split('_'),
    monthsParseExact: true,
    weekdays : 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัสบดี_ศุกร์_เสาร์'.split('_'),
    weekdaysShort : 'อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัส_ศุกร์_เสาร์'.split('_'), // yes, three characters difference
    weekdaysMin : 'อา._จ._อ._พ._พฤ._ศ._ส.'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'H:mm',
        LTS : 'H:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY เวลา H:mm',
        LLLL : 'วันddddที่ D MMMM YYYY เวลา H:mm'
    },
    meridiemParse: /ก่อนเที่ยง|หลังเที่ยง/,
    isPM: function (input) {
        return input === 'หลังเที่ยง';
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return 'ก่อนเที่ยง';
        } else {
            return 'หลังเที่ยง';
        }
    },
    calendar : {
        sameDay : '[วันนี้ เวลา] LT',
        nextDay : '[พรุ่งนี้ เวลา] LT',
        nextWeek : 'dddd[หน้า เวลา] LT',
        lastDay : '[เมื่อวานนี้ เวลา] LT',
        lastWeek : '[วัน]dddd[ที่แล้ว เวลา] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'อีก %s',
        past : '%sที่แล้ว',
        s : 'ไม่กี่วินาที',
        m : '1 นาที',
        mm : '%d นาที',
        h : '1 ชั่วโมง',
        hh : '%d ชั่วโมง',
        d : '1 วัน',
        dd : '%d วัน',
        M : '1 เดือน',
        MM : '%d เดือน',
        y : '1 ปี',
        yy : '%d ปี'
    }
});

//! moment.js locale configuration
//! locale : Tagalog (Philippines) [tl-ph]
//! author : Dan Hagman : https://github.com/hagmandan

hooks.defineLocale('tl-ph', {
    months : 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
    monthsShort : 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
    weekdays : 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
    weekdaysShort : 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
    weekdaysMin : 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'MM/D/YYYY',
        LL : 'MMMM D, YYYY',
        LLL : 'MMMM D, YYYY HH:mm',
        LLLL : 'dddd, MMMM DD, YYYY HH:mm'
    },
    calendar : {
        sameDay: 'LT [ngayong araw]',
        nextDay: '[Bukas ng] LT',
        nextWeek: 'LT [sa susunod na] dddd',
        lastDay: 'LT [kahapon]',
        lastWeek: 'LT [noong nakaraang] dddd',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'sa loob ng %s',
        past : '%s ang nakalipas',
        s : 'ilang segundo',
        m : 'isang minuto',
        mm : '%d minuto',
        h : 'isang oras',
        hh : '%d oras',
        d : 'isang araw',
        dd : '%d araw',
        M : 'isang buwan',
        MM : '%d buwan',
        y : 'isang taon',
        yy : '%d taon'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal : function (number) {
        return number;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Klingon [tlh]
//! author : Dominika Kruk : https://github.com/amaranthrose

var numbersNouns = 'pagh_wa’_cha’_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');

function translateFuture(output) {
    var time = output;
    time = (output.indexOf('jaj') !== -1) ?
    time.slice(0, -3) + 'leS' :
    (output.indexOf('jar') !== -1) ?
    time.slice(0, -3) + 'waQ' :
    (output.indexOf('DIS') !== -1) ?
    time.slice(0, -3) + 'nem' :
    time + ' pIq';
    return time;
}

function translatePast(output) {
    var time = output;
    time = (output.indexOf('jaj') !== -1) ?
    time.slice(0, -3) + 'Hu’' :
    (output.indexOf('jar') !== -1) ?
    time.slice(0, -3) + 'wen' :
    (output.indexOf('DIS') !== -1) ?
    time.slice(0, -3) + 'ben' :
    time + ' ret';
    return time;
}

function translate$9(number, withoutSuffix, string, isFuture) {
    var numberNoun = numberAsNoun(number);
    switch (string) {
        case 'mm':
            return numberNoun + ' tup';
        case 'hh':
            return numberNoun + ' rep';
        case 'dd':
            return numberNoun + ' jaj';
        case 'MM':
            return numberNoun + ' jar';
        case 'yy':
            return numberNoun + ' DIS';
    }
}

function numberAsNoun(number) {
    var hundred = Math.floor((number % 1000) / 100),
    ten = Math.floor((number % 100) / 10),
    one = number % 10,
    word = '';
    if (hundred > 0) {
        word += numbersNouns[hundred] + 'vatlh';
    }
    if (ten > 0) {
        word += ((word !== '') ? ' ' : '') + numbersNouns[ten] + 'maH';
    }
    if (one > 0) {
        word += ((word !== '') ? ' ' : '') + numbersNouns[one];
    }
    return (word === '') ? 'pagh' : word;
}

hooks.defineLocale('tlh', {
    months : 'tera’ jar wa’_tera’ jar cha’_tera’ jar wej_tera’ jar loS_tera’ jar vagh_tera’ jar jav_tera’ jar Soch_tera’ jar chorgh_tera’ jar Hut_tera’ jar wa’maH_tera’ jar wa’maH wa’_tera’ jar wa’maH cha’'.split('_'),
    monthsShort : 'jar wa’_jar cha’_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wa’maH_jar wa’maH wa’_jar wa’maH cha’'.split('_'),
    monthsParseExact : true,
    weekdays : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
    weekdaysShort : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
    weekdaysMin : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[DaHjaj] LT',
        nextDay: '[wa’leS] LT',
        nextWeek: 'LLL',
        lastDay: '[wa’Hu’] LT',
        lastWeek: 'LLL',
        sameElse: 'L'
    },
    relativeTime : {
        future : translateFuture,
        past : translatePast,
        s : 'puS lup',
        m : 'wa’ tup',
        mm : translate$9,
        h : 'wa’ rep',
        hh : translate$9,
        d : 'wa’ jaj',
        dd : translate$9,
        M : 'wa’ jar',
        MM : translate$9,
        y : 'wa’ DIS',
        yy : translate$9
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Turkish [tr]
//! authors : Erhan Gundogan : https://github.com/erhangundogan,
//!           Burak Yiğit Kaya: https://github.com/BYK

var suffixes$3 = {
    1: '\'inci',
    5: '\'inci',
    8: '\'inci',
    70: '\'inci',
    80: '\'inci',
    2: '\'nci',
    7: '\'nci',
    20: '\'nci',
    50: '\'nci',
    3: '\'üncü',
    4: '\'üncü',
    100: '\'üncü',
    6: '\'ncı',
    9: '\'uncu',
    10: '\'uncu',
    30: '\'uncu',
    60: '\'ıncı',
    90: '\'ıncı'
};

hooks.defineLocale('tr', {
    months : 'Ocak_Şubat_Mart_Nisan_Mayıs_Haziran_Temmuz_Ağustos_Eylül_Ekim_Kasım_Aralık'.split('_'),
    monthsShort : 'Oca_Şub_Mar_Nis_May_Haz_Tem_Ağu_Eyl_Eki_Kas_Ara'.split('_'),
    weekdays : 'Pazar_Pazartesi_Salı_Çarşamba_Perşembe_Cuma_Cumartesi'.split('_'),
    weekdaysShort : 'Paz_Pts_Sal_Çar_Per_Cum_Cts'.split('_'),
    weekdaysMin : 'Pz_Pt_Sa_Ça_Pe_Cu_Ct'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[bugün saat] LT',
        nextDay : '[yarın saat] LT',
        nextWeek : '[haftaya] dddd [saat] LT',
        lastDay : '[dün] LT',
        lastWeek : '[geçen hafta] dddd [saat] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s sonra',
        past : '%s önce',
        s : 'birkaç saniye',
        m : 'bir dakika',
        mm : '%d dakika',
        h : 'bir saat',
        hh : '%d saat',
        d : 'bir gün',
        dd : '%d gün',
        M : 'bir ay',
        MM : '%d ay',
        y : 'bir yıl',
        yy : '%d yıl'
    },
    dayOfMonthOrdinalParse: /\d{1,2}'(inci|nci|üncü|ncı|uncu|ıncı)/,
    ordinal : function (number) {
        if (number === 0) {  // special case for zero
            return number + '\'ıncı';
        }
        var a = number % 10,
            b = number % 100 - a,
            c = number >= 100 ? 100 : null;
        return number + (suffixes$3[a] || suffixes$3[b] || suffixes$3[c]);
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Talossan [tzl]
//! author : Robin van der Vliet : https://github.com/robin0van0der0v
//! author : Iustì Canun

// After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
// This is currently too difficult (maybe even impossible) to add.
hooks.defineLocale('tzl', {
    months : 'Januar_Fevraglh_Març_Avrïu_Mai_Gün_Julia_Guscht_Setemvar_Listopäts_Noemvar_Zecemvar'.split('_'),
    monthsShort : 'Jan_Fev_Mar_Avr_Mai_Gün_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
    weekdays : 'Súladi_Lúneçi_Maitzi_Márcuri_Xhúadi_Viénerçi_Sáturi'.split('_'),
    weekdaysShort : 'Súl_Lún_Mai_Már_Xhú_Vié_Sát'.split('_'),
    weekdaysMin : 'Sú_Lú_Ma_Má_Xh_Vi_Sá'.split('_'),
    longDateFormat : {
        LT : 'HH.mm',
        LTS : 'HH.mm.ss',
        L : 'DD.MM.YYYY',
        LL : 'D. MMMM [dallas] YYYY',
        LLL : 'D. MMMM [dallas] YYYY HH.mm',
        LLLL : 'dddd, [li] D. MMMM [dallas] YYYY HH.mm'
    },
    meridiemParse: /d\'o|d\'a/i,
    isPM : function (input) {
        return 'd\'o' === input.toLowerCase();
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'd\'o' : 'D\'O';
        } else {
            return isLower ? 'd\'a' : 'D\'A';
        }
    },
    calendar : {
        sameDay : '[oxhi à] LT',
        nextDay : '[demà à] LT',
        nextWeek : 'dddd [à] LT',
        lastDay : '[ieiri à] LT',
        lastWeek : '[sür el] dddd [lasteu à] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'osprei %s',
        past : 'ja%s',
        s : processRelativeTime$7,
        m : processRelativeTime$7,
        mm : processRelativeTime$7,
        h : processRelativeTime$7,
        hh : processRelativeTime$7,
        d : processRelativeTime$7,
        dd : processRelativeTime$7,
        M : processRelativeTime$7,
        MM : processRelativeTime$7,
        y : processRelativeTime$7,
        yy : processRelativeTime$7
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal : '%d.',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

function processRelativeTime$7(number, withoutSuffix, key, isFuture) {
    var format = {
        's': ['viensas secunds', '\'iensas secunds'],
        'm': ['\'n míut', '\'iens míut'],
        'mm': [number + ' míuts', '' + number + ' míuts'],
        'h': ['\'n þora', '\'iensa þora'],
        'hh': [number + ' þoras', '' + number + ' þoras'],
        'd': ['\'n ziua', '\'iensa ziua'],
        'dd': [number + ' ziuas', '' + number + ' ziuas'],
        'M': ['\'n mes', '\'iens mes'],
        'MM': [number + ' mesen', '' + number + ' mesen'],
        'y': ['\'n ar', '\'iens ar'],
        'yy': [number + ' ars', '' + number + ' ars']
    };
    return isFuture ? format[key][0] : (withoutSuffix ? format[key][0] : format[key][1]);
}

//! moment.js locale configuration
//! locale : Central Atlas Tamazight Latin [tzm-latn]
//! author : Abdel Said : https://github.com/abdelsaid

hooks.defineLocale('tzm-latn', {
    months : 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split('_'),
    monthsShort : 'innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir'.split('_'),
    weekdays : 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
    weekdaysShort : 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
    weekdaysMin : 'asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[asdkh g] LT',
        nextDay: '[aska g] LT',
        nextWeek: 'dddd [g] LT',
        lastDay: '[assant g] LT',
        lastWeek: 'dddd [g] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'dadkh s yan %s',
        past : 'yan %s',
        s : 'imik',
        m : 'minuḍ',
        mm : '%d minuḍ',
        h : 'saɛa',
        hh : '%d tassaɛin',
        d : 'ass',
        dd : '%d ossan',
        M : 'ayowr',
        MM : '%d iyyirn',
        y : 'asgas',
        yy : '%d isgasn'
    },
    week : {
        dow : 6, // Saturday is the first day of the week.
        doy : 12  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Central Atlas Tamazight [tzm]
//! author : Abdel Said : https://github.com/abdelsaid

hooks.defineLocale('tzm', {
    months : 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split('_'),
    monthsShort : 'ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ'.split('_'),
    weekdays : 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
    weekdaysShort : 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
    weekdaysMin : 'ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS: 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[ⴰⵙⴷⵅ ⴴ] LT',
        nextDay: '[ⴰⵙⴽⴰ ⴴ] LT',
        nextWeek: 'dddd [ⴴ] LT',
        lastDay: '[ⴰⵚⴰⵏⵜ ⴴ] LT',
        lastWeek: 'dddd [ⴴ] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : 'ⴷⴰⴷⵅ ⵙ ⵢⴰⵏ %s',
        past : 'ⵢⴰⵏ %s',
        s : 'ⵉⵎⵉⴽ',
        m : 'ⵎⵉⵏⵓⴺ',
        mm : '%d ⵎⵉⵏⵓⴺ',
        h : 'ⵙⴰⵄⴰ',
        hh : '%d ⵜⴰⵙⵙⴰⵄⵉⵏ',
        d : 'ⴰⵙⵙ',
        dd : '%d oⵙⵙⴰⵏ',
        M : 'ⴰⵢoⵓⵔ',
        MM : '%d ⵉⵢⵢⵉⵔⵏ',
        y : 'ⴰⵙⴳⴰⵙ',
        yy : '%d ⵉⵙⴳⴰⵙⵏ'
    },
    week : {
        dow : 6, // Saturday is the first day of the week.
        doy : 12  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Ukrainian [uk]
//! author : zemlanin : https://github.com/zemlanin
//! Author : Menelion Elensúle : https://github.com/Oire

function plural$6(word, num) {
    var forms = word.split('_');
    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
}
function relativeTimeWithPlural$4(number, withoutSuffix, key) {
    var format = {
        'mm': withoutSuffix ? 'хвилина_хвилини_хвилин' : 'хвилину_хвилини_хвилин',
        'hh': withoutSuffix ? 'година_години_годин' : 'годину_години_годин',
        'dd': 'день_дні_днів',
        'MM': 'місяць_місяці_місяців',
        'yy': 'рік_роки_років'
    };
    if (key === 'm') {
        return withoutSuffix ? 'хвилина' : 'хвилину';
    }
    else if (key === 'h') {
        return withoutSuffix ? 'година' : 'годину';
    }
    else {
        return number + ' ' + plural$6(format[key], +number);
    }
}
function weekdaysCaseReplace(m, format) {
    var weekdays = {
        'nominative': 'неділя_понеділок_вівторок_середа_четвер_п’ятниця_субота'.split('_'),
        'accusative': 'неділю_понеділок_вівторок_середу_четвер_п’ятницю_суботу'.split('_'),
        'genitive': 'неділі_понеділка_вівторка_середи_четверга_п’ятниці_суботи'.split('_')
    };

    if (!m) {
        return weekdays['nominative'];
    }

    var nounCase = (/(\[[ВвУу]\]) ?dddd/).test(format) ?
        'accusative' :
        ((/\[?(?:минулої|наступної)? ?\] ?dddd/).test(format) ?
            'genitive' :
            'nominative');
    return weekdays[nounCase][m.day()];
}
function processHoursFunction(str) {
    return function () {
        return str + 'о' + (this.hours() === 11 ? 'б' : '') + '] LT';
    };
}

hooks.defineLocale('uk', {
    months : {
        'format': 'січня_лютого_березня_квітня_травня_червня_липня_серпня_вересня_жовтня_листопада_грудня'.split('_'),
        'standalone': 'січень_лютий_березень_квітень_травень_червень_липень_серпень_вересень_жовтень_листопад_грудень'.split('_')
    },
    monthsShort : 'січ_лют_бер_квіт_трав_черв_лип_серп_вер_жовт_лист_груд'.split('_'),
    weekdays : weekdaysCaseReplace,
    weekdaysShort : 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
    weekdaysMin : 'нд_пн_вт_ср_чт_пт_сб'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD.MM.YYYY',
        LL : 'D MMMM YYYY р.',
        LLL : 'D MMMM YYYY р., HH:mm',
        LLLL : 'dddd, D MMMM YYYY р., HH:mm'
    },
    calendar : {
        sameDay: processHoursFunction('[Сьогодні '),
        nextDay: processHoursFunction('[Завтра '),
        lastDay: processHoursFunction('[Вчора '),
        nextWeek: processHoursFunction('[У] dddd ['),
        lastWeek: function () {
            switch (this.day()) {
                case 0:
                case 3:
                case 5:
                case 6:
                    return processHoursFunction('[Минулої] dddd [').call(this);
                case 1:
                case 2:
                case 4:
                    return processHoursFunction('[Минулого] dddd [').call(this);
            }
        },
        sameElse: 'L'
    },
    relativeTime : {
        future : 'за %s',
        past : '%s тому',
        s : 'декілька секунд',
        m : relativeTimeWithPlural$4,
        mm : relativeTimeWithPlural$4,
        h : 'годину',
        hh : relativeTimeWithPlural$4,
        d : 'день',
        dd : relativeTimeWithPlural$4,
        M : 'місяць',
        MM : relativeTimeWithPlural$4,
        y : 'рік',
        yy : relativeTimeWithPlural$4
    },
    // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
    meridiemParse: /ночі|ранку|дня|вечора/,
    isPM: function (input) {
        return /^(дня|вечора)$/.test(input);
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 4) {
            return 'ночі';
        } else if (hour < 12) {
            return 'ранку';
        } else if (hour < 17) {
            return 'дня';
        } else {
            return 'вечора';
        }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(й|го)/,
    ordinal: function (number, period) {
        switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
            case 'w':
            case 'W':
                return number + '-й';
            case 'D':
                return number + '-го';
            default:
                return number;
        }
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Urdu [ur]
//! author : Sawood Alam : https://github.com/ibnesayeed
//! author : Zack : https://github.com/ZackVision

var months$8 = [
    'جنوری',
    'فروری',
    'مارچ',
    'اپریل',
    'مئی',
    'جون',
    'جولائی',
    'اگست',
    'ستمبر',
    'اکتوبر',
    'نومبر',
    'دسمبر'
];
var days$2 = [
    'اتوار',
    'پیر',
    'منگل',
    'بدھ',
    'جمعرات',
    'جمعہ',
    'ہفتہ'
];

hooks.defineLocale('ur', {
    months : months$8,
    monthsShort : months$8,
    weekdays : days$2,
    weekdaysShort : days$2,
    weekdaysMin : days$2,
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd، D MMMM YYYY HH:mm'
    },
    meridiemParse: /صبح|شام/,
    isPM : function (input) {
        return 'شام' === input;
    },
    meridiem : function (hour, minute, isLower) {
        if (hour < 12) {
            return 'صبح';
        }
        return 'شام';
    },
    calendar : {
        sameDay : '[آج بوقت] LT',
        nextDay : '[کل بوقت] LT',
        nextWeek : 'dddd [بوقت] LT',
        lastDay : '[گذشتہ روز بوقت] LT',
        lastWeek : '[گذشتہ] dddd [بوقت] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : '%s بعد',
        past : '%s قبل',
        s : 'چند سیکنڈ',
        m : 'ایک منٹ',
        mm : '%d منٹ',
        h : 'ایک گھنٹہ',
        hh : '%d گھنٹے',
        d : 'ایک دن',
        dd : '%d دن',
        M : 'ایک ماہ',
        MM : '%d ماہ',
        y : 'ایک سال',
        yy : '%d سال'
    },
    preparse: function (string) {
        return string.replace(/،/g, ',');
    },
    postformat: function (string) {
        return string.replace(/,/g, '،');
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Uzbek Latin [uz-latn]
//! author : Rasulbek Mirzayev : github.com/Rasulbeeek

hooks.defineLocale('uz-latn', {
    months : 'Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr'.split('_'),
    monthsShort : 'Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek'.split('_'),
    weekdays : 'Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba'.split('_'),
    weekdaysShort : 'Yak_Dush_Sesh_Chor_Pay_Jum_Shan'.split('_'),
    weekdaysMin : 'Ya_Du_Se_Cho_Pa_Ju_Sha'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'D MMMM YYYY, dddd HH:mm'
    },
    calendar : {
        sameDay : '[Bugun soat] LT [da]',
        nextDay : '[Ertaga] LT [da]',
        nextWeek : 'dddd [kuni soat] LT [da]',
        lastDay : '[Kecha soat] LT [da]',
        lastWeek : '[O\'tgan] dddd [kuni soat] LT [da]',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'Yaqin %s ichida',
        past : 'Bir necha %s oldin',
        s : 'soniya',
        m : 'bir daqiqa',
        mm : '%d daqiqa',
        h : 'bir soat',
        hh : '%d soat',
        d : 'bir kun',
        dd : '%d kun',
        M : 'bir oy',
        MM : '%d oy',
        y : 'bir yil',
        yy : '%d yil'
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 1st is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Uzbek [uz]
//! author : Sardor Muminov : https://github.com/muminoff

hooks.defineLocale('uz', {
    months : 'январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр'.split('_'),
    monthsShort : 'янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек'.split('_'),
    weekdays : 'Якшанба_Душанба_Сешанба_Чоршанба_Пайшанба_Жума_Шанба'.split('_'),
    weekdaysShort : 'Якш_Душ_Сеш_Чор_Пай_Жум_Шан'.split('_'),
    weekdaysMin : 'Як_Ду_Се_Чо_Па_Жу_Ша'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'D MMMM YYYY, dddd HH:mm'
    },
    calendar : {
        sameDay : '[Бугун соат] LT [да]',
        nextDay : '[Эртага] LT [да]',
        nextWeek : 'dddd [куни соат] LT [да]',
        lastDay : '[Кеча соат] LT [да]',
        lastWeek : '[Утган] dddd [куни соат] LT [да]',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'Якин %s ичида',
        past : 'Бир неча %s олдин',
        s : 'фурсат',
        m : 'бир дакика',
        mm : '%d дакика',
        h : 'бир соат',
        hh : '%d соат',
        d : 'бир кун',
        dd : '%d кун',
        M : 'бир ой',
        MM : '%d ой',
        y : 'бир йил',
        yy : '%d йил'
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 7  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Vietnamese [vi]
//! author : Bang Nguyen : https://github.com/bangnk

hooks.defineLocale('vi', {
    months : 'tháng 1_tháng 2_tháng 3_tháng 4_tháng 5_tháng 6_tháng 7_tháng 8_tháng 9_tháng 10_tháng 11_tháng 12'.split('_'),
    monthsShort : 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
    monthsParseExact : true,
    weekdays : 'chủ nhật_thứ hai_thứ ba_thứ tư_thứ năm_thứ sáu_thứ bảy'.split('_'),
    weekdaysShort : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
    weekdaysMin : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
    weekdaysParseExact : true,
    meridiemParse: /sa|ch/i,
    isPM : function (input) {
        return /^ch$/i.test(input);
    },
    meridiem : function (hours, minutes, isLower) {
        if (hours < 12) {
            return isLower ? 'sa' : 'SA';
        } else {
            return isLower ? 'ch' : 'CH';
        }
    },
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM [năm] YYYY',
        LLL : 'D MMMM [năm] YYYY HH:mm',
        LLLL : 'dddd, D MMMM [năm] YYYY HH:mm',
        l : 'DD/M/YYYY',
        ll : 'D MMM YYYY',
        lll : 'D MMM YYYY HH:mm',
        llll : 'ddd, D MMM YYYY HH:mm'
    },
    calendar : {
        sameDay: '[Hôm nay lúc] LT',
        nextDay: '[Ngày mai lúc] LT',
        nextWeek: 'dddd [tuần tới lúc] LT',
        lastDay: '[Hôm qua lúc] LT',
        lastWeek: 'dddd [tuần rồi lúc] LT',
        sameElse: 'L'
    },
    relativeTime : {
        future : '%s tới',
        past : '%s trước',
        s : 'vài giây',
        m : 'một phút',
        mm : '%d phút',
        h : 'một giờ',
        hh : '%d giờ',
        d : 'một ngày',
        dd : '%d ngày',
        M : 'một tháng',
        MM : '%d tháng',
        y : 'một năm',
        yy : '%d năm'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal : function (number) {
        return number;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Pseudo [x-pseudo]
//! author : Andrew Hood : https://github.com/andrewhood125

hooks.defineLocale('x-pseudo', {
    months : 'J~áñúá~rý_F~ébrú~árý_~Márc~h_Áp~ríl_~Máý_~Júñé~_Júl~ý_Áú~gúst~_Sép~témb~ér_Ó~ctób~ér_Ñ~óvém~bér_~Décé~mbér'.split('_'),
    monthsShort : 'J~áñ_~Féb_~Már_~Ápr_~Máý_~Júñ_~Júl_~Áúg_~Sép_~Óct_~Ñóv_~Déc'.split('_'),
    monthsParseExact : true,
    weekdays : 'S~úñdá~ý_Mó~ñdáý~_Túé~sdáý~_Wéd~ñésd~áý_T~húrs~dáý_~Fríd~áý_S~átúr~dáý'.split('_'),
    weekdaysShort : 'S~úñ_~Móñ_~Túé_~Wéd_~Thú_~Frí_~Sát'.split('_'),
    weekdaysMin : 'S~ú_Mó~_Tú_~Wé_T~h_Fr~_Sá'.split('_'),
    weekdaysParseExact : true,
    longDateFormat : {
        LT : 'HH:mm',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY HH:mm',
        LLLL : 'dddd, D MMMM YYYY HH:mm'
    },
    calendar : {
        sameDay : '[T~ódá~ý át] LT',
        nextDay : '[T~ómó~rró~w át] LT',
        nextWeek : 'dddd [át] LT',
        lastDay : '[Ý~ést~érdá~ý át] LT',
        lastWeek : '[L~ást] dddd [át] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'í~ñ %s',
        past : '%s á~gó',
        s : 'á ~féw ~sécó~ñds',
        m : 'á ~míñ~úté',
        mm : '%d m~íñú~tés',
        h : 'á~ñ hó~úr',
        hh : '%d h~óúrs',
        d : 'á ~dáý',
        dd : '%d d~áýs',
        M : 'á ~móñ~th',
        MM : '%d m~óñt~hs',
        y : 'á ~ýéár',
        yy : '%d ý~éárs'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (~~(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    },
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Yoruba Nigeria [yo]
//! author : Atolagbe Abisoye : https://github.com/andela-batolagbe

hooks.defineLocale('yo', {
    months : 'Sẹ́rẹ́_Èrèlè_Ẹrẹ̀nà_Ìgbé_Èbibi_Òkùdu_Agẹmo_Ògún_Owewe_Ọ̀wàrà_Bélú_Ọ̀pẹ̀̀'.split('_'),
    monthsShort : 'Sẹ́r_Èrl_Ẹrn_Ìgb_Èbi_Òkù_Agẹ_Ògú_Owe_Ọ̀wà_Bél_Ọ̀pẹ̀̀'.split('_'),
    weekdays : 'Àìkú_Ajé_Ìsẹ́gun_Ọjọ́rú_Ọjọ́bọ_Ẹtì_Àbámẹ́ta'.split('_'),
    weekdaysShort : 'Àìk_Ajé_Ìsẹ́_Ọjr_Ọjb_Ẹtì_Àbá'.split('_'),
    weekdaysMin : 'Àì_Aj_Ìs_Ọr_Ọb_Ẹt_Àb'.split('_'),
    longDateFormat : {
        LT : 'h:mm A',
        LTS : 'h:mm:ss A',
        L : 'DD/MM/YYYY',
        LL : 'D MMMM YYYY',
        LLL : 'D MMMM YYYY h:mm A',
        LLLL : 'dddd, D MMMM YYYY h:mm A'
    },
    calendar : {
        sameDay : '[Ònì ni] LT',
        nextDay : '[Ọ̀la ni] LT',
        nextWeek : 'dddd [Ọsẹ̀ tón\'bọ] [ni] LT',
        lastDay : '[Àna ni] LT',
        lastWeek : 'dddd [Ọsẹ̀ tólọ́] [ni] LT',
        sameElse : 'L'
    },
    relativeTime : {
        future : 'ní %s',
        past : '%s kọjá',
        s : 'ìsẹjú aayá die',
        m : 'ìsẹjú kan',
        mm : 'ìsẹjú %d',
        h : 'wákati kan',
        hh : 'wákati %d',
        d : 'ọjọ́ kan',
        dd : 'ọjọ́ %d',
        M : 'osù kan',
        MM : 'osù %d',
        y : 'ọdún kan',
        yy : 'ọdún %d'
    },
    dayOfMonthOrdinalParse : /ọjọ́\s\d{1,2}/,
    ordinal : 'ọjọ́ %d',
    week : {
        dow : 1, // Monday is the first day of the week.
        doy : 4 // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Chinese (China) [zh-cn]
//! author : suupic : https://github.com/suupic
//! author : Zeno Zeng : https://github.com/zenozeng

hooks.defineLocale('zh-cn', {
    months : '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
    monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
    weekdays : '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
    weekdaysShort : '周日_周一_周二_周三_周四_周五_周六'.split('_'),
    weekdaysMin : '日_一_二_三_四_五_六'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYY年MMMD日',
        LL : 'YYYY年MMMD日',
        LLL : 'YYYY年MMMD日Ah点mm分',
        LLLL : 'YYYY年MMMD日ddddAh点mm分',
        l : 'YYYY年MMMD日',
        ll : 'YYYY年MMMD日',
        lll : 'YYYY年MMMD日 HH:mm',
        llll : 'YYYY年MMMD日dddd HH:mm'
    },
    meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
    meridiemHour: function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '凌晨' || meridiem === '早上' ||
                meridiem === '上午') {
            return hour;
        } else if (meridiem === '下午' || meridiem === '晚上') {
            return hour + 12;
        } else {
            // '中午'
            return hour >= 11 ? hour : hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        var hm = hour * 100 + minute;
        if (hm < 600) {
            return '凌晨';
        } else if (hm < 900) {
            return '早上';
        } else if (hm < 1130) {
            return '上午';
        } else if (hm < 1230) {
            return '中午';
        } else if (hm < 1800) {
            return '下午';
        } else {
            return '晚上';
        }
    },
    calendar : {
        sameDay : '[今天]LT',
        nextDay : '[明天]LT',
        nextWeek : '[下]ddddLT',
        lastDay : '[昨天]LT',
        lastWeek : '[上]ddddLT',
        sameElse : 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(日|月|周)/,
    ordinal : function (number, period) {
        switch (period) {
            case 'd':
            case 'D':
            case 'DDD':
                return number + '日';
            case 'M':
                return number + '月';
            case 'w':
            case 'W':
                return number + '周';
            default:
                return number;
        }
    },
    relativeTime : {
        future : '%s内',
        past : '%s前',
        s : '几秒',
        m : '1 分钟',
        mm : '%d 分钟',
        h : '1 小时',
        hh : '%d 小时',
        d : '1 天',
        dd : '%d 天',
        M : '1 个月',
        MM : '%d 个月',
        y : '1 年',
        yy : '%d 年'
    },
    week : {
        // GB/T 7408-1994《数据元和交换格式·信息交换·日期和时间表示法》与ISO 8601:1988等效
        dow : 1, // Monday is the first day of the week.
        doy : 4  // The week that contains Jan 4th is the first week of the year.
    }
});

//! moment.js locale configuration
//! locale : Chinese (Hong Kong) [zh-hk]
//! author : Ben : https://github.com/ben-lin
//! author : Chris Lam : https://github.com/hehachris
//! author : Konstantin : https://github.com/skfd

hooks.defineLocale('zh-hk', {
    months : '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
    monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
    weekdays : '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
    weekdaysShort : '週日_週一_週二_週三_週四_週五_週六'.split('_'),
    weekdaysMin : '日_一_二_三_四_五_六'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYY年MMMD日',
        LL : 'YYYY年MMMD日',
        LLL : 'YYYY年MMMD日 HH:mm',
        LLLL : 'YYYY年MMMD日dddd HH:mm',
        l : 'YYYY年MMMD日',
        ll : 'YYYY年MMMD日',
        lll : 'YYYY年MMMD日 HH:mm',
        llll : 'YYYY年MMMD日dddd HH:mm'
    },
    meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '凌晨' || meridiem === '早上' || meridiem === '上午') {
            return hour;
        } else if (meridiem === '中午') {
            return hour >= 11 ? hour : hour + 12;
        } else if (meridiem === '下午' || meridiem === '晚上') {
            return hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        var hm = hour * 100 + minute;
        if (hm < 600) {
            return '凌晨';
        } else if (hm < 900) {
            return '早上';
        } else if (hm < 1130) {
            return '上午';
        } else if (hm < 1230) {
            return '中午';
        } else if (hm < 1800) {
            return '下午';
        } else {
            return '晚上';
        }
    },
    calendar : {
        sameDay : '[今天]LT',
        nextDay : '[明天]LT',
        nextWeek : '[下]ddddLT',
        lastDay : '[昨天]LT',
        lastWeek : '[上]ddddLT',
        sameElse : 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
    ordinal : function (number, period) {
        switch (period) {
            case 'd' :
            case 'D' :
            case 'DDD' :
                return number + '日';
            case 'M' :
                return number + '月';
            case 'w' :
            case 'W' :
                return number + '週';
            default :
                return number;
        }
    },
    relativeTime : {
        future : '%s內',
        past : '%s前',
        s : '幾秒',
        m : '1 分鐘',
        mm : '%d 分鐘',
        h : '1 小時',
        hh : '%d 小時',
        d : '1 天',
        dd : '%d 天',
        M : '1 個月',
        MM : '%d 個月',
        y : '1 年',
        yy : '%d 年'
    }
});

//! moment.js locale configuration
//! locale : Chinese (Taiwan) [zh-tw]
//! author : Ben : https://github.com/ben-lin
//! author : Chris Lam : https://github.com/hehachris

hooks.defineLocale('zh-tw', {
    months : '一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月'.split('_'),
    monthsShort : '1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月'.split('_'),
    weekdays : '星期日_星期一_星期二_星期三_星期四_星期五_星期六'.split('_'),
    weekdaysShort : '週日_週一_週二_週三_週四_週五_週六'.split('_'),
    weekdaysMin : '日_一_二_三_四_五_六'.split('_'),
    longDateFormat : {
        LT : 'HH:mm',
        LTS : 'HH:mm:ss',
        L : 'YYYY年MMMD日',
        LL : 'YYYY年MMMD日',
        LLL : 'YYYY年MMMD日 HH:mm',
        LLLL : 'YYYY年MMMD日dddd HH:mm',
        l : 'YYYY年MMMD日',
        ll : 'YYYY年MMMD日',
        lll : 'YYYY年MMMD日 HH:mm',
        llll : 'YYYY年MMMD日dddd HH:mm'
    },
    meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
    meridiemHour : function (hour, meridiem) {
        if (hour === 12) {
            hour = 0;
        }
        if (meridiem === '凌晨' || meridiem === '早上' || meridiem === '上午') {
            return hour;
        } else if (meridiem === '中午') {
            return hour >= 11 ? hour : hour + 12;
        } else if (meridiem === '下午' || meridiem === '晚上') {
            return hour + 12;
        }
    },
    meridiem : function (hour, minute, isLower) {
        var hm = hour * 100 + minute;
        if (hm < 600) {
            return '凌晨';
        } else if (hm < 900) {
            return '早上';
        } else if (hm < 1130) {
            return '上午';
        } else if (hm < 1230) {
            return '中午';
        } else if (hm < 1800) {
            return '下午';
        } else {
            return '晚上';
        }
    },
    calendar : {
        sameDay : '[今天]LT',
        nextDay : '[明天]LT',
        nextWeek : '[下]ddddLT',
        lastDay : '[昨天]LT',
        lastWeek : '[上]ddddLT',
        sameElse : 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
    ordinal : function (number, period) {
        switch (period) {
            case 'd' :
            case 'D' :
            case 'DDD' :
                return number + '日';
            case 'M' :
                return number + '月';
            case 'w' :
            case 'W' :
                return number + '週';
            default :
                return number;
        }
    },
    relativeTime : {
        future : '%s內',
        past : '%s前',
        s : '幾秒',
        m : '1 分鐘',
        mm : '%d 分鐘',
        h : '1 小時',
        hh : '%d 小時',
        d : '1 天',
        dd : '%d 天',
        M : '1 個月',
        MM : '%d 個月',
        y : '1 年',
        yy : '%d 年'
    }
});

hooks.locale('en');

return hooks;

})));

}.call(window));

/***/ }),

/***/ 2983:
/***/ (function(module, exports) {

/*** IMPORTS FROM imports-loader ***/
var define = undefined;
var require = undefined;
var module = undefined;
var exports = undefined;
(function() {

/*
 * CAUTION: This file (and everything in this directory) is marked as noParse
 * in our Webpack configuration. This means it cannot import modules, and that
 * it will not be transpiled to ES5. Do *NOT* use any ES6 features that our
 * supported browsers don't support natively (i.e., IE11 does not support arrow
 * functions).
 */

//! moment-timezone.js
//! version : 0.5.13
//! Copyright (c) JS Foundation and other contributors
//! license : MIT
//! github.com/moment/moment-timezone

(function (root, factory) {
	"use strict";

	/*global define*/
	if (typeof define === 'function' && define.amd) {
		define(['moment'], factory);                 // AMD
	} else if (typeof module === 'object' && module.exports) {
		module.exports = factory(require('moment')); // Node
	} else {
		factory(root.moment);                        // Browser
	}
}(this, function (moment) {
	"use strict";

	// Do not load moment-timezone a second time.
	// if (moment.tz !== undefined) {
	// 	logError('Moment Timezone ' + moment.tz.version + ' was already loaded ' + (moment.tz.dataVersion ? 'with data from ' : 'without any data') + moment.tz.dataVersion);
	// 	return moment;
	// }

	var VERSION = "0.5.13",
		zones = {},
		links = {},
		names = {},
		guesses = {},
		cachedGuess,

		momentVersion = moment.version.split('.'),
		major = +momentVersion[0],
		minor = +momentVersion[1];

	// Moment.js version check
	if (major < 2 || (major === 2 && minor < 6)) {
		logError('Moment Timezone requires Moment.js >= 2.6.0. You are using Moment.js ' + moment.version + '. See momentjs.com');
	}

	/************************************
		Unpacking
	************************************/

	function charCodeToInt(charCode) {
		if (charCode > 96) {
			return charCode - 87;
		} else if (charCode > 64) {
			return charCode - 29;
		}
		return charCode - 48;
	}

	function unpackBase60(string) {
		var i = 0,
			parts = string.split('.'),
			whole = parts[0],
			fractional = parts[1] || '',
			multiplier = 1,
			num,
			out = 0,
			sign = 1;

		// handle negative numbers
		if (string.charCodeAt(0) === 45) {
			i = 1;
			sign = -1;
		}

		// handle digits before the decimal
		for (i; i < whole.length; i++) {
			num = charCodeToInt(whole.charCodeAt(i));
			out = 60 * out + num;
		}

		// handle digits after the decimal
		for (i = 0; i < fractional.length; i++) {
			multiplier = multiplier / 60;
			num = charCodeToInt(fractional.charCodeAt(i));
			out += num * multiplier;
		}

		return out * sign;
	}

	function arrayToInt (array) {
		for (var i = 0; i < array.length; i++) {
			array[i] = unpackBase60(array[i]);
		}
	}

	function intToUntil (array, length) {
		for (var i = 0; i < length; i++) {
			array[i] = Math.round((array[i - 1] || 0) + (array[i] * 60000)); // minutes to milliseconds
		}

		array[length - 1] = Infinity;
	}

	function mapIndices (source, indices) {
		var out = [], i;

		for (i = 0; i < indices.length; i++) {
			out[i] = source[indices[i]];
		}

		return out;
	}

	function unpack (string) {
		var data = string.split('|'),
			offsets = data[2].split(' '),
			indices = data[3].split(''),
			untils  = data[4].split(' ');

		arrayToInt(offsets);
		arrayToInt(indices);
		arrayToInt(untils);

		intToUntil(untils, indices.length);

		return {
			name       : data[0],
			abbrs      : mapIndices(data[1].split(' '), indices),
			offsets    : mapIndices(offsets, indices),
			untils     : untils,
			population : data[5] | 0
		};
	}

	/************************************
		Zone object
	************************************/

	function Zone (packedString) {
		if (packedString) {
			this._set(unpack(packedString));
		}
	}

	Zone.prototype = {
		_set : function (unpacked) {
			this.name       = unpacked.name;
			this.abbrs      = unpacked.abbrs;
			this.untils     = unpacked.untils;
			this.offsets    = unpacked.offsets;
			this.population = unpacked.population;
		},

		_index : function (timestamp) {
			var target = +timestamp,
				untils = this.untils,
				i;

			for (i = 0; i < untils.length; i++) {
				if (target < untils[i]) {
					return i;
				}
			}
		},

		parse : function (timestamp) {
			var target  = +timestamp,
				offsets = this.offsets,
				untils  = this.untils,
				max     = untils.length - 1,
				offset, offsetNext, offsetPrev, i;

			for (i = 0; i < max; i++) {
				offset     = offsets[i];
				offsetNext = offsets[i + 1];
				offsetPrev = offsets[i ? i - 1 : i];

				if (offset < offsetNext && tz.moveAmbiguousForward) {
					offset = offsetNext;
				} else if (offset > offsetPrev && tz.moveInvalidForward) {
					offset = offsetPrev;
				}

				if (target < untils[i] - (offset * 60000)) {
					return offsets[i];
				}
			}

			return offsets[max];
		},

		abbr : function (mom) {
			return this.abbrs[this._index(mom)];
		},

		offset : function (mom) {
			return this.offsets[this._index(mom)];
		}
	};

	/************************************
		Current Timezone
	************************************/

	function OffsetAt(at) {
		var timeString = at.toTimeString();
		var abbr = timeString.match(/\([a-z ]+\)/i);
		if (abbr && abbr[0]) {
			// 17:56:31 GMT-0600 (CST)
			// 17:56:31 GMT-0600 (Central Standard Time)
			abbr = abbr[0].match(/[A-Z]/g);
			abbr = abbr ? abbr.join('') : undefined;
		} else {
			// 17:56:31 CST
			// 17:56:31 GMT+0800 (台北標準時間)
			abbr = timeString.match(/[A-Z]{3,5}/g);
			abbr = abbr ? abbr[0] : undefined;
		}

		if (abbr === 'GMT') {
			abbr = undefined;
		}

		this.at = +at;
		this.abbr = abbr;
		this.offset = at.getTimezoneOffset();
	}

	function ZoneScore(zone) {
		this.zone = zone;
		this.offsetScore = 0;
		this.abbrScore = 0;
	}

	ZoneScore.prototype.scoreOffsetAt = function (offsetAt) {
		this.offsetScore += Math.abs(this.zone.offset(offsetAt.at) - offsetAt.offset);
		if (this.zone.abbr(offsetAt.at).replace(/[^A-Z]/g, '') !== offsetAt.abbr) {
			this.abbrScore++;
		}
	};

	function findChange(low, high) {
		var mid, diff;

		while ((diff = ((high.at - low.at) / 12e4 | 0) * 6e4)) {
			mid = new OffsetAt(new Date(low.at + diff));
			if (mid.offset === low.offset) {
				low = mid;
			} else {
				high = mid;
			}
		}

		return low;
	}

	function userOffsets() {
		var startYear = new Date().getFullYear() - 2,
			last = new OffsetAt(new Date(startYear, 0, 1)),
			offsets = [last],
			change, next, i;

		for (i = 1; i < 48; i++) {
			next = new OffsetAt(new Date(startYear, i, 1));
			if (next.offset !== last.offset) {
				change = findChange(last, next);
				offsets.push(change);
				offsets.push(new OffsetAt(new Date(change.at + 6e4)));
			}
			last = next;
		}

		for (i = 0; i < 4; i++) {
			offsets.push(new OffsetAt(new Date(startYear + i, 0, 1)));
			offsets.push(new OffsetAt(new Date(startYear + i, 6, 1)));
		}

		return offsets;
	}

	function sortZoneScores (a, b) {
		if (a.offsetScore !== b.offsetScore) {
			return a.offsetScore - b.offsetScore;
		}
		if (a.abbrScore !== b.abbrScore) {
			return a.abbrScore - b.abbrScore;
		}
		return b.zone.population - a.zone.population;
	}

	function addToGuesses (name, offsets) {
		var i, offset;
		arrayToInt(offsets);
		for (i = 0; i < offsets.length; i++) {
			offset = offsets[i];
			guesses[offset] = guesses[offset] || {};
			guesses[offset][name] = true;
		}
	}

	function guessesForUserOffsets (offsets) {
		var offsetsLength = offsets.length,
			filteredGuesses = {},
			out = [],
			i, j, guessesOffset;

		for (i = 0; i < offsetsLength; i++) {
			guessesOffset = guesses[offsets[i].offset] || {};
			for (j in guessesOffset) {
				if (guessesOffset.hasOwnProperty(j)) {
					filteredGuesses[j] = true;
				}
			}
		}

		for (i in filteredGuesses) {
			if (filteredGuesses.hasOwnProperty(i)) {
				out.push(names[i]);
			}
		}

		return out;
	}

	function rebuildGuess () {

		// use Intl API when available and returning valid time zone
		try {
			var intlName = Intl.DateTimeFormat().resolvedOptions().timeZone;
			if (intlName){
				var name = names[normalizeName(intlName)];
				if (name) {
					return name;
				}
				logError("Moment Timezone found " + intlName + " from the Intl api, but did not have that data loaded.");
			}
		} catch (e) {
			// Intl unavailable, fall back to manual guessing.
		}

		var offsets = userOffsets(),
			offsetsLength = offsets.length,
			guesses = guessesForUserOffsets(offsets),
			zoneScores = [],
			zoneScore, i, j;

		for (i = 0; i < guesses.length; i++) {
			zoneScore = new ZoneScore(getZone(guesses[i]), offsetsLength);
			for (j = 0; j < offsetsLength; j++) {
				zoneScore.scoreOffsetAt(offsets[j]);
			}
			zoneScores.push(zoneScore);
		}

		zoneScores.sort(sortZoneScores);

		return zoneScores.length > 0 ? zoneScores[0].zone.name : undefined;
	}

	function guess (ignoreCache) {
		if (!cachedGuess || ignoreCache) {
			cachedGuess = rebuildGuess();
		}
		return cachedGuess;
	}

	/************************************
		Global Methods
	************************************/

	function normalizeName (name) {
		return (name || '').toLowerCase().replace(/\//g, '_');
	}

	function addZone (packed) {
		var i, name, split, normalized;

		if (typeof packed === "string") {
			packed = [packed];
		}

		for (i = 0; i < packed.length; i++) {
			split = packed[i].split('|');
			name = split[0];
			normalized = normalizeName(name);
			zones[normalized] = packed[i];
			names[normalized] = name;
			if (split[5]) {
				addToGuesses(normalized, split[2].split(' '));
			}
		}
	}

	function getZone (name, caller) {
		name = normalizeName(name);

		var zone = zones[name];
		var link;

		if (zone instanceof Zone) {
			return zone;
		}

		if (typeof zone === 'string') {
			zone = new Zone(zone);
			zones[name] = zone;
			return zone;
		}

		// Pass getZone to prevent recursion more than 1 level deep
		if (links[name] && caller !== getZone && (link = getZone(links[name], getZone))) {
			zone = zones[name] = new Zone();
			zone._set(link);
			zone.name = names[name];
			return zone;
		}

		return null;
	}

	function getNames () {
		var i, out = [];

		for (i in names) {
			if (names.hasOwnProperty(i) && (zones[i] || zones[links[i]]) && names[i]) {
				out.push(names[i]);
			}
		}

		return out.sort();
	}

	function addLink (aliases) {
		var i, alias, normal0, normal1;

		if (typeof aliases === "string") {
			aliases = [aliases];
		}

		for (i = 0; i < aliases.length; i++) {
			alias = aliases[i].split('|');

			normal0 = normalizeName(alias[0]);
			normal1 = normalizeName(alias[1]);

			links[normal0] = normal1;
			names[normal0] = alias[0];

			links[normal1] = normal0;
			names[normal1] = alias[1];
		}
	}

	function loadData (data) {
		addZone(data.zones);
		addLink(data.links);
		tz.dataVersion = data.version;
	}

	function zoneExists (name) {
		if (!zoneExists.didShowError) {
			zoneExists.didShowError = true;
				logError("moment.tz.zoneExists('" + name + "') has been deprecated in favor of !moment.tz.zone('" + name + "')");
		}
		return !!getZone(name);
	}

	function needsOffset (m) {
		return !!(m._a && (m._tzm === undefined));
	}

	function logError (message) {
		if (typeof console !== 'undefined' && typeof console.error === 'function') {
			console.error(message);
		}
	}

	/************************************
		moment.tz namespace
	************************************/

	function tz (input) {
		var args = Array.prototype.slice.call(arguments, 0, -1),
			name = arguments[arguments.length - 1],
			zone = getZone(name),
			out  = moment.utc.apply(null, args);

		if (zone && !moment.isMoment(input) && needsOffset(out)) {
			out.add(zone.parse(out), 'minutes');
		}

		out.tz(name);

		return out;
	}

	tz.version      = VERSION;
	tz.dataVersion  = '';
	tz._zones       = zones;
	tz._links       = links;
	tz._names       = names;
	tz.add          = addZone;
	tz.link         = addLink;
	tz.load         = loadData;
	tz.zone         = getZone;
	tz.zoneExists   = zoneExists; // deprecated in 0.1.0
	tz.guess        = guess;
	tz.names        = getNames;
	tz.Zone         = Zone;
	tz.unpack       = unpack;
	tz.unpackBase60 = unpackBase60;
	tz.needsOffset  = needsOffset;
	tz.moveInvalidForward   = true;
	tz.moveAmbiguousForward = false;

	/************************************
		Interface with Moment.js
	************************************/

	var fn = moment.fn;

	moment.tz = tz;

	moment.defaultZone = null;

	moment.updateOffset = function (mom, keepTime) {
		var zone = moment.defaultZone,
			offset;

		if (mom._z === undefined) {
			if (zone && needsOffset(mom) && !mom._isUTC) {
				mom._d = moment.utc(mom._a)._d;
				mom.utc().add(zone.parse(mom), 'minutes');
			}
			mom._z = zone;
		}
		if (mom._z) {
			offset = mom._z.offset(mom);
			if (Math.abs(offset) < 16) {
				offset = offset / 60;
			}
			if (mom.utcOffset !== undefined) {
				mom.utcOffset(-offset, keepTime);
			} else {
				mom.zone(offset, keepTime);
			}
		}
	};

	fn.tz = function (name) {
		if (name) {
			this._z = getZone(name);
			if (this._z) {
				moment.updateOffset(this);
			} else {
				logError("Moment Timezone has no data for " + name + ". See http://momentjs.com/timezone/docs/#/data-loading/.");
			}
			return this;
		}
		if (this._z) { return this._z.name; }
	};

	function abbrWrap (old) {
		return function () {
			if (this._z) { return this._z.abbr(this); }
			return old.call(this);
		};
	}

	function resetZoneWrap (old) {
		return function () {
			this._z = null;
			return old.apply(this, arguments);
		};
	}

	fn.zoneName = abbrWrap(fn.zoneName);
	fn.zoneAbbr = abbrWrap(fn.zoneAbbr);
	fn.utc      = resetZoneWrap(fn.utc);

	moment.tz.setDefault = function(name) {
		if (major < 2 || (major === 2 && minor < 9)) {
			logError('Moment Timezone setDefault() requires Moment.js >= 2.9.0. You are using Moment.js ' + moment.version + '.');
		}
		moment.defaultZone = name ? getZone(name) : null;
		return moment;
	};

	// Cloning a moment should include the _z property.
	var momentProperties = moment.momentProperties;
	if (Object.prototype.toString.call(momentProperties) === '[object Array]') {
		// moment 2.8.1+
		momentProperties.push('_z');
		momentProperties.push('_a');
	} else if (momentProperties) {
		// moment 2.7.0
		momentProperties._z = null;
	}

	loadData({
		"version": "2017b",
		"zones": [
			"Africa/Abidjan|GMT|0|0||48e5",
			"Africa/Khartoum|EAT|-30|0||51e5",
			"Africa/Algiers|CET|-10|0||26e5",
			"Africa/Lagos|WAT|-10|0||17e6",
			"Africa/Maputo|CAT|-20|0||26e5",
			"Africa/Cairo|EET EEST|-20 -30|01010|1M2m0 gL0 e10 mn0|15e6",
			"Africa/Casablanca|WET WEST|0 -10|0101010101010101010101010101010101010101010|1H3C0 wM0 co0 go0 1o00 s00 dA0 vc0 11A0 A00 e00 y00 11A0 uM0 e00 Dc0 11A0 s00 e00 IM0 WM0 mo0 gM0 LA0 WM0 jA0 e00 Rc0 11A0 e00 e00 U00 11A0 8o0 e00 11A0 11A0 5A0 e00 17c0 1fA0 1a00|32e5",
			"Europe/Paris|CET CEST|-10 -20|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|11e6",
			"Africa/Johannesburg|SAST|-20|0||84e5",
			"Africa/Tripoli|EET CET CEST|-20 -10 -20|0120|1IlA0 TA0 1o00|11e5",
			"Africa/Windhoek|WAST WAT|-20 -10|01010101010101010101010|1GQo0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0|32e4",
			"America/Adak|HST HDT|a0 90|01010101010101010101010|1GIc0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|326",
			"America/Anchorage|AKST AKDT|90 80|01010101010101010101010|1GIb0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|30e4",
			"America/Santo_Domingo|AST|40|0||29e5",
			"America/Araguaina|-03 -02|30 20|010|1IdD0 Lz0|14e4",
			"America/Fortaleza|-03|30|0||34e5",
			"America/Asuncion|-03 -04|30 40|01010101010101010101010|1GTf0 1cN0 17b0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0|28e5",
			"America/Panama|EST|50|0||15e5",
			"America/Bahia|-02 -03|20 30|01|1GCq0|27e5",
			"America/Mexico_City|CST CDT|60 50|01010101010101010101010|1GQw0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0|20e6",
			"America/Managua|CST|60|0||22e5",
			"America/La_Paz|-04|40|0||19e5",
			"America/Lima|-05|50|0||11e6",
			"America/Denver|MST MDT|70 60|01010101010101010101010|1GI90 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|26e5",
			"America/Campo_Grande|-03 -04|30 40|01010101010101010101010|1GCr0 1zd0 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 On0 1zd0 On0 1C10 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0|77e4",
			"America/Cancun|CST CDT EST|60 50 50|01010102|1GQw0 1nX0 14p0 1lb0 14p0 1lb0 Dd0|63e4",
			"America/Caracas|-0430 -04|4u 40|01|1QMT0|29e5",
			"America/Chicago|CST CDT|60 50|01010101010101010101010|1GI80 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|92e5",
			"America/Chihuahua|MST MDT|70 60|01010101010101010101010|1GQx0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0|81e4",
			"America/Phoenix|MST|70|0||42e5",
			"America/Los_Angeles|PST PDT|80 70|01010101010101010101010|1GIa0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|15e6",
			"America/New_York|EST EDT|50 40|01010101010101010101010|1GI70 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|21e6",
			"America/Rio_Branco|-04 -05|40 50|01|1KLE0|31e4",
			"America/Fort_Nelson|PST PDT MST|80 70 70|01010102|1GIa0 1zb0 Op0 1zb0 Op0 1zb0 Op0|39e2",
			"America/Halifax|AST ADT|40 30|01010101010101010101010|1GI60 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|39e4",
			"America/Godthab|-03 -02|30 20|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|17e3",
			"America/Grand_Turk|EST EDT AST|50 40 40|010101012|1GI70 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|37e2",
			"America/Havana|CST CDT|50 40|01010101010101010101010|1GQt0 1qM0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0|21e5",
			"America/Metlakatla|PST AKST AKDT|80 90 80|0121212121212121|1PAa0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|14e2",
			"America/Miquelon|-03 -02|30 20|01010101010101010101010|1GI50 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|61e2",
			"America/Montevideo|-02 -03|20 30|01010101|1GI40 1o10 11z0 1o10 11z0 1o10 11z0|17e5",
			"America/Noronha|-02|20|0||30e2",
			"America/Port-au-Prince|EST EDT|50 40|010101010101010101010|1GI70 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 3iN0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|23e5",
			"Antarctica/Palmer|-03 -04|30 40|010101010|1H3D0 Op0 1zb0 Rd0 1wn0 Rd0 46n0 Ap0|40",
			"America/Santiago|-03 -04|30 40|010101010101010101010|1H3D0 Op0 1zb0 Rd0 1wn0 Rd0 46n0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Dd0 1Nb0 Ap0|62e5",
			"America/Sao_Paulo|-02 -03|20 30|01010101010101010101010|1GCq0 1zd0 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0 On0 1zd0 On0 1C10 Lz0 1C10 Lz0 1C10 On0 1zd0 On0 1zd0|20e6",
			"Atlantic/Azores|-01 +00|10 0|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|25e4",
			"America/St_Johns|NST NDT|3u 2u|01010101010101010101010|1GI5u 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0|11e4",
			"Antarctica/Casey|+11 +08|-b0 -80|010|1GAF0 blz0|10",
			"Antarctica/Davis|+05 +07|-50 -70|01|1GAI0|70",
			"Pacific/Port_Moresby|+10|-a0|0||25e4",
			"Pacific/Guadalcanal|+11|-b0|0||11e4",
			"Asia/Tashkent|+05|-50|0||23e5",
			"Pacific/Auckland|NZDT NZST|-d0 -c0|01010101010101010101010|1GQe0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00|14e5",
			"Asia/Baghdad|+03|-30|0||66e5",
			"Antarctica/Troll|+00 +02|0 -20|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|40",
			"Asia/Dhaka|+06|-60|0||16e6",
			"Asia/Amman|EET EEST|-20 -30|010101010101010101010|1GPy0 4bX0 Dd0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00|25e5",
			"Asia/Kamchatka|+12|-c0|0||18e4",
			"Asia/Baku|+04 +05|-40 -50|010101010|1GNA0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00|27e5",
			"Asia/Bangkok|+07|-70|0||15e6",
			"Asia/Barnaul|+07 +06|-70 -60|010|1N7v0 3rd0",
			"Asia/Beirut|EET EEST|-20 -30|01010101010101010101010|1GNy0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0|22e5",
			"Asia/Manila|+08|-80|0||24e6",
			"Asia/Kolkata|IST|-5u|0||15e6",
			"Asia/Chita|+10 +08 +09|-a0 -80 -90|012|1N7s0 3re0|33e4",
			"Asia/Ulaanbaatar|+08 +09|-80 -90|01010|1O8G0 1cJ0 1cP0 1cJ0|12e5",
			"Asia/Shanghai|CST|-80|0||23e6",
			"Asia/Colombo|+0530|-5u|0||22e5",
			"Asia/Damascus|EET EEST|-20 -30|01010101010101010101010|1GPy0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0|26e5",
			"Asia/Dili|+09|-90|0||19e4",
			"Asia/Dubai|+04|-40|0||39e5",
			"Asia/Famagusta|EET EEST +03|-20 -30 -30|01010101012|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 15U0",
			"Asia/Gaza|EET EEST|-20 -30|01010101010101010101010|1GPy0 1a00 1fA0 1cL0 1cN0 1nX0 1210 1nz0 1220 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0|18e5",
			"Asia/Hong_Kong|HKT|-80|0||73e5",
			"Asia/Hovd|+07 +08|-70 -80|01010|1O8H0 1cJ0 1cP0 1cJ0|81e3",
			"Asia/Irkutsk|+09 +08|-90 -80|01|1N7t0|60e4",
			"Europe/Istanbul|EET EEST +03|-20 -30 -30|01010101012|1GNB0 1qM0 11A0 1o00 1200 1nA0 11A0 1tA0 U00 15w0|13e6",
			"Asia/Jakarta|WIB|-70|0||31e6",
			"Asia/Jayapura|WIT|-90|0||26e4",
			"Asia/Jerusalem|IST IDT|-20 -30|01010101010101010101010|1GPA0 1aL0 1eN0 1oL0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0|81e4",
			"Asia/Kabul|+0430|-4u|0||46e5",
			"Asia/Karachi|PKT|-50|0||24e6",
			"Asia/Kathmandu|+0545|-5J|0||12e5",
			"Asia/Yakutsk|+10 +09|-a0 -90|01|1N7s0|28e4",
			"Asia/Krasnoyarsk|+08 +07|-80 -70|01|1N7u0|10e5",
			"Asia/Magadan|+12 +10 +11|-c0 -a0 -b0|012|1N7q0 3Cq0|95e3",
			"Asia/Makassar|WITA|-80|0||15e5",
			"Europe/Athens|EET EEST|-20 -30|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|35e5",
			"Asia/Novosibirsk|+07 +06|-70 -60|010|1N7v0 4eN0|15e5",
			"Asia/Omsk|+07 +06|-70 -60|01|1N7v0|12e5",
			"Asia/Pyongyang|KST KST|-90 -8u|01|1P4D0|29e5",
			"Asia/Rangoon|+0630|-6u|0||48e5",
			"Asia/Sakhalin|+11 +10|-b0 -a0|010|1N7r0 3rd0|58e4",
			"Asia/Seoul|KST|-90|0||23e6",
			"Asia/Srednekolymsk|+12 +11|-c0 -b0|01|1N7q0|35e2",
			"Asia/Tehran|+0330 +0430|-3u -4u|01010101010101010101010|1GLUu 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0|14e6",
			"Asia/Tokyo|JST|-90|0||38e6",
			"Asia/Tomsk|+07 +06|-70 -60|010|1N7v0 3Qp0|10e5",
			"Asia/Vladivostok|+11 +10|-b0 -a0|01|1N7r0|60e4",
			"Asia/Yekaterinburg|+06 +05|-60 -50|01|1N7w0|14e5",
			"Europe/Lisbon|WET WEST|0 -10|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|27e5",
			"Atlantic/Cape_Verde|-01|10|0||50e4",
			"Australia/Sydney|AEDT AEST|-b0 -a0|01010101010101010101010|1GQg0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0|40e5",
			"Australia/Adelaide|ACDT ACST|-au -9u|01010101010101010101010|1GQgu 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0|11e5",
			"Australia/Brisbane|AEST|-a0|0||20e5",
			"Australia/Darwin|ACST|-9u|0||12e4",
			"Australia/Eucla|+0845|-8J|0||368",
			"Australia/Lord_Howe|+11 +1030|-b0 -au|01010101010101010101010|1GQf0 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu|347",
			"Australia/Perth|AWST|-80|0||18e5",
			"Pacific/Easter|-05 -06|50 60|010101010101010101010|1H3D0 Op0 1zb0 Rd0 1wn0 Rd0 46n0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1Nb0 Dd0 1Nb0 Ap0|30e2",
			"Europe/Dublin|GMT IST|0 -10|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|12e5",
			"Pacific/Tahiti|-10|a0|0||18e4",
			"Pacific/Niue|-11|b0|0||12e2",
			"Etc/GMT+12|-12|c0|0|",
			"Pacific/Galapagos|-06|60|0||25e3",
			"Etc/GMT+7|-07|70|0|",
			"Pacific/Pitcairn|-08|80|0||56",
			"Pacific/Gambier|-09|90|0||125",
			"Etc/GMT-1|+01|-10|0|",
			"Pacific/Fakaofo|+13|-d0|0||483",
			"Pacific/Kiritimati|+14|-e0|0||51e2",
			"Etc/GMT-2|+02|-20|0|",
			"Etc/UCT|UCT|0|0|",
			"Etc/UTC|UTC|0|0|",
			"Europe/Astrakhan|+04 +03|-40 -30|010|1N7y0 3rd0",
			"Europe/London|GMT BST|0 -10|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|10e6",
			"Europe/Chisinau|EET EEST|-20 -30|01010101010101010101010|1GNA0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0|67e4",
			"Europe/Kaliningrad|+03 EET|-30 -20|01|1N7z0|44e4",
			"Europe/Volgograd|+04 +03|-40 -30|01|1N7y0|10e5",
			"Europe/Moscow|MSK MSK|-40 -30|01|1N7y0|16e6",
			"Europe/Saratov|+04 +03|-40 -30|010|1N7y0 5810",
			"Europe/Simferopol|EET EEST MSK MSK|-20 -30 -40 -30|0101023|1GNB0 1qM0 11A0 1o00 11z0 1nW0|33e4",
			"Pacific/Honolulu|HST|a0|0||37e4",
			"MET|MET MEST|-10 -20|01010101010101010101010|1GNB0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0",
			"Pacific/Chatham|+1345 +1245|-dJ -cJ|01010101010101010101010|1GQe0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00|600",
			"Pacific/Apia|+14 +13|-e0 -d0|01010101010101010101010|1GQe0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00|37e3",
			"Pacific/Bougainville|+10 +11|-a0 -b0|01|1NwE0|18e4",
			"Pacific/Fiji|+13 +12|-d0 -c0|01010101010101010101010|1Goe0 1Nc0 Ao0 1Q00 xz0 1SN0 uM0 1SM0 uM0 1VA0 s00 1VA0 uM0 1SM0 uM0 1SM0 uM0 1SM0 uM0 1VA0 s00 1VA0|88e4",
			"Pacific/Guam|ChST|-a0|0||17e4",
			"Pacific/Marquesas|-0930|9u|0||86e2",
			"Pacific/Pago_Pago|SST|b0|0||37e2",
			"Pacific/Norfolk|+1130 +11|-bu -b0|01|1PoCu|25e4",
			"Pacific/Tongatapu|+13 +14|-d0 -e0|01010101010101|1S4d0 s00 1VA0 uM0 1SM0 uM0 1SM0 uM0 1SM0 uM0 1VA0 s00 1VA0|75e3"
		],
		"links": [
			"Africa/Abidjan|Africa/Accra",
			"Africa/Abidjan|Africa/Bamako",
			"Africa/Abidjan|Africa/Banjul",
			"Africa/Abidjan|Africa/Bissau",
			"Africa/Abidjan|Africa/Conakry",
			"Africa/Abidjan|Africa/Dakar",
			"Africa/Abidjan|Africa/Freetown",
			"Africa/Abidjan|Africa/Lome",
			"Africa/Abidjan|Africa/Monrovia",
			"Africa/Abidjan|Africa/Nouakchott",
			"Africa/Abidjan|Africa/Ouagadougou",
			"Africa/Abidjan|Africa/Sao_Tome",
			"Africa/Abidjan|Africa/Timbuktu",
			"Africa/Abidjan|America/Danmarkshavn",
			"Africa/Abidjan|Atlantic/Reykjavik",
			"Africa/Abidjan|Atlantic/St_Helena",
			"Africa/Abidjan|Etc/GMT",
			"Africa/Abidjan|Etc/GMT+0",
			"Africa/Abidjan|Etc/GMT-0",
			"Africa/Abidjan|Etc/GMT0",
			"Africa/Abidjan|Etc/Greenwich",
			"Africa/Abidjan|GMT",
			"Africa/Abidjan|GMT+0",
			"Africa/Abidjan|GMT-0",
			"Africa/Abidjan|GMT0",
			"Africa/Abidjan|Greenwich",
			"Africa/Abidjan|Iceland",
			"Africa/Algiers|Africa/Tunis",
			"Africa/Cairo|Egypt",
			"Africa/Casablanca|Africa/El_Aaiun",
			"Africa/Johannesburg|Africa/Maseru",
			"Africa/Johannesburg|Africa/Mbabane",
			"Africa/Khartoum|Africa/Addis_Ababa",
			"Africa/Khartoum|Africa/Asmara",
			"Africa/Khartoum|Africa/Asmera",
			"Africa/Khartoum|Africa/Dar_es_Salaam",
			"Africa/Khartoum|Africa/Djibouti",
			"Africa/Khartoum|Africa/Juba",
			"Africa/Khartoum|Africa/Kampala",
			"Africa/Khartoum|Africa/Mogadishu",
			"Africa/Khartoum|Africa/Nairobi",
			"Africa/Khartoum|Indian/Antananarivo",
			"Africa/Khartoum|Indian/Comoro",
			"Africa/Khartoum|Indian/Mayotte",
			"Africa/Lagos|Africa/Bangui",
			"Africa/Lagos|Africa/Brazzaville",
			"Africa/Lagos|Africa/Douala",
			"Africa/Lagos|Africa/Kinshasa",
			"Africa/Lagos|Africa/Libreville",
			"Africa/Lagos|Africa/Luanda",
			"Africa/Lagos|Africa/Malabo",
			"Africa/Lagos|Africa/Ndjamena",
			"Africa/Lagos|Africa/Niamey",
			"Africa/Lagos|Africa/Porto-Novo",
			"Africa/Maputo|Africa/Blantyre",
			"Africa/Maputo|Africa/Bujumbura",
			"Africa/Maputo|Africa/Gaborone",
			"Africa/Maputo|Africa/Harare",
			"Africa/Maputo|Africa/Kigali",
			"Africa/Maputo|Africa/Lubumbashi",
			"Africa/Maputo|Africa/Lusaka",
			"Africa/Tripoli|Libya",
			"America/Adak|America/Atka",
			"America/Adak|US/Aleutian",
			"America/Anchorage|America/Juneau",
			"America/Anchorage|America/Nome",
			"America/Anchorage|America/Sitka",
			"America/Anchorage|America/Yakutat",
			"America/Anchorage|US/Alaska",
			"America/Campo_Grande|America/Cuiaba",
			"America/Chicago|America/Indiana/Knox",
			"America/Chicago|America/Indiana/Tell_City",
			"America/Chicago|America/Knox_IN",
			"America/Chicago|America/Matamoros",
			"America/Chicago|America/Menominee",
			"America/Chicago|America/North_Dakota/Beulah",
			"America/Chicago|America/North_Dakota/Center",
			"America/Chicago|America/North_Dakota/New_Salem",
			"America/Chicago|America/Rainy_River",
			"America/Chicago|America/Rankin_Inlet",
			"America/Chicago|America/Resolute",
			"America/Chicago|America/Winnipeg",
			"America/Chicago|CST6CDT",
			"America/Chicago|Canada/Central",
			"America/Chicago|US/Central",
			"America/Chicago|US/Indiana-Starke",
			"America/Chihuahua|America/Mazatlan",
			"America/Chihuahua|Mexico/BajaSur",
			"America/Denver|America/Boise",
			"America/Denver|America/Cambridge_Bay",
			"America/Denver|America/Edmonton",
			"America/Denver|America/Inuvik",
			"America/Denver|America/Ojinaga",
			"America/Denver|America/Shiprock",
			"America/Denver|America/Yellowknife",
			"America/Denver|Canada/Mountain",
			"America/Denver|MST7MDT",
			"America/Denver|Navajo",
			"America/Denver|US/Mountain",
			"America/Fortaleza|America/Argentina/Buenos_Aires",
			"America/Fortaleza|America/Argentina/Catamarca",
			"America/Fortaleza|America/Argentina/ComodRivadavia",
			"America/Fortaleza|America/Argentina/Cordoba",
			"America/Fortaleza|America/Argentina/Jujuy",
			"America/Fortaleza|America/Argentina/La_Rioja",
			"America/Fortaleza|America/Argentina/Mendoza",
			"America/Fortaleza|America/Argentina/Rio_Gallegos",
			"America/Fortaleza|America/Argentina/Salta",
			"America/Fortaleza|America/Argentina/San_Juan",
			"America/Fortaleza|America/Argentina/San_Luis",
			"America/Fortaleza|America/Argentina/Tucuman",
			"America/Fortaleza|America/Argentina/Ushuaia",
			"America/Fortaleza|America/Belem",
			"America/Fortaleza|America/Buenos_Aires",
			"America/Fortaleza|America/Catamarca",
			"America/Fortaleza|America/Cayenne",
			"America/Fortaleza|America/Cordoba",
			"America/Fortaleza|America/Jujuy",
			"America/Fortaleza|America/Maceio",
			"America/Fortaleza|America/Mendoza",
			"America/Fortaleza|America/Paramaribo",
			"America/Fortaleza|America/Recife",
			"America/Fortaleza|America/Rosario",
			"America/Fortaleza|America/Santarem",
			"America/Fortaleza|Antarctica/Rothera",
			"America/Fortaleza|Atlantic/Stanley",
			"America/Fortaleza|Etc/GMT+3",
			"America/Halifax|America/Glace_Bay",
			"America/Halifax|America/Goose_Bay",
			"America/Halifax|America/Moncton",
			"America/Halifax|America/Thule",
			"America/Halifax|Atlantic/Bermuda",
			"America/Halifax|Canada/Atlantic",
			"America/Havana|Cuba",
			"America/La_Paz|America/Boa_Vista",
			"America/La_Paz|America/Guyana",
			"America/La_Paz|America/Manaus",
			"America/La_Paz|America/Porto_Velho",
			"America/La_Paz|Brazil/West",
			"America/La_Paz|Etc/GMT+4",
			"America/Lima|America/Bogota",
			"America/Lima|America/Guayaquil",
			"America/Lima|Etc/GMT+5",
			"America/Los_Angeles|America/Dawson",
			"America/Los_Angeles|America/Ensenada",
			"America/Los_Angeles|America/Santa_Isabel",
			"America/Los_Angeles|America/Tijuana",
			"America/Los_Angeles|America/Vancouver",
			"America/Los_Angeles|America/Whitehorse",
			"America/Los_Angeles|Canada/Pacific",
			"America/Los_Angeles|Canada/Yukon",
			"America/Los_Angeles|Mexico/BajaNorte",
			"America/Los_Angeles|PST8PDT",
			"America/Los_Angeles|US/Pacific",
			"America/Los_Angeles|US/Pacific-New",
			"America/Managua|America/Belize",
			"America/Managua|America/Costa_Rica",
			"America/Managua|America/El_Salvador",
			"America/Managua|America/Guatemala",
			"America/Managua|America/Regina",
			"America/Managua|America/Swift_Current",
			"America/Managua|America/Tegucigalpa",
			"America/Managua|Canada/East-Saskatchewan",
			"America/Managua|Canada/Saskatchewan",
			"America/Mexico_City|America/Bahia_Banderas",
			"America/Mexico_City|America/Merida",
			"America/Mexico_City|America/Monterrey",
			"America/Mexico_City|Mexico/General",
			"America/New_York|America/Detroit",
			"America/New_York|America/Fort_Wayne",
			"America/New_York|America/Indiana/Indianapolis",
			"America/New_York|America/Indiana/Marengo",
			"America/New_York|America/Indiana/Petersburg",
			"America/New_York|America/Indiana/Vevay",
			"America/New_York|America/Indiana/Vincennes",
			"America/New_York|America/Indiana/Winamac",
			"America/New_York|America/Indianapolis",
			"America/New_York|America/Iqaluit",
			"America/New_York|America/Kentucky/Louisville",
			"America/New_York|America/Kentucky/Monticello",
			"America/New_York|America/Louisville",
			"America/New_York|America/Montreal",
			"America/New_York|America/Nassau",
			"America/New_York|America/Nipigon",
			"America/New_York|America/Pangnirtung",
			"America/New_York|America/Thunder_Bay",
			"America/New_York|America/Toronto",
			"America/New_York|Canada/Eastern",
			"America/New_York|EST5EDT",
			"America/New_York|US/East-Indiana",
			"America/New_York|US/Eastern",
			"America/New_York|US/Michigan",
			"America/Noronha|Atlantic/South_Georgia",
			"America/Noronha|Brazil/DeNoronha",
			"America/Noronha|Etc/GMT+2",
			"America/Panama|America/Atikokan",
			"America/Panama|America/Cayman",
			"America/Panama|America/Coral_Harbour",
			"America/Panama|America/Jamaica",
			"America/Panama|EST",
			"America/Panama|Jamaica",
			"America/Phoenix|America/Creston",
			"America/Phoenix|America/Dawson_Creek",
			"America/Phoenix|America/Hermosillo",
			"America/Phoenix|MST",
			"America/Phoenix|US/Arizona",
			"America/Rio_Branco|America/Eirunepe",
			"America/Rio_Branco|America/Porto_Acre",
			"America/Rio_Branco|Brazil/Acre",
			"America/Santiago|Chile/Continental",
			"America/Santo_Domingo|America/Anguilla",
			"America/Santo_Domingo|America/Antigua",
			"America/Santo_Domingo|America/Aruba",
			"America/Santo_Domingo|America/Barbados",
			"America/Santo_Domingo|America/Blanc-Sablon",
			"America/Santo_Domingo|America/Curacao",
			"America/Santo_Domingo|America/Dominica",
			"America/Santo_Domingo|America/Grenada",
			"America/Santo_Domingo|America/Guadeloupe",
			"America/Santo_Domingo|America/Kralendijk",
			"America/Santo_Domingo|America/Lower_Princes",
			"America/Santo_Domingo|America/Marigot",
			"America/Santo_Domingo|America/Martinique",
			"America/Santo_Domingo|America/Montserrat",
			"America/Santo_Domingo|America/Port_of_Spain",
			"America/Santo_Domingo|America/Puerto_Rico",
			"America/Santo_Domingo|America/St_Barthelemy",
			"America/Santo_Domingo|America/St_Kitts",
			"America/Santo_Domingo|America/St_Lucia",
			"America/Santo_Domingo|America/St_Thomas",
			"America/Santo_Domingo|America/St_Vincent",
			"America/Santo_Domingo|America/Tortola",
			"America/Santo_Domingo|America/Virgin",
			"America/Sao_Paulo|Brazil/East",
			"America/St_Johns|Canada/Newfoundland",
			"Antarctica/Palmer|America/Punta_Arenas",
			"Asia/Baghdad|Antarctica/Syowa",
			"Asia/Baghdad|Asia/Aden",
			"Asia/Baghdad|Asia/Bahrain",
			"Asia/Baghdad|Asia/Kuwait",
			"Asia/Baghdad|Asia/Qatar",
			"Asia/Baghdad|Asia/Riyadh",
			"Asia/Baghdad|Etc/GMT-3",
			"Asia/Baghdad|Europe/Minsk",
			"Asia/Bangkok|Asia/Ho_Chi_Minh",
			"Asia/Bangkok|Asia/Novokuznetsk",
			"Asia/Bangkok|Asia/Phnom_Penh",
			"Asia/Bangkok|Asia/Saigon",
			"Asia/Bangkok|Asia/Vientiane",
			"Asia/Bangkok|Etc/GMT-7",
			"Asia/Bangkok|Indian/Christmas",
			"Asia/Dhaka|Antarctica/Vostok",
			"Asia/Dhaka|Asia/Almaty",
			"Asia/Dhaka|Asia/Bishkek",
			"Asia/Dhaka|Asia/Dacca",
			"Asia/Dhaka|Asia/Kashgar",
			"Asia/Dhaka|Asia/Qyzylorda",
			"Asia/Dhaka|Asia/Thimbu",
			"Asia/Dhaka|Asia/Thimphu",
			"Asia/Dhaka|Asia/Urumqi",
			"Asia/Dhaka|Etc/GMT-6",
			"Asia/Dhaka|Indian/Chagos",
			"Asia/Dili|Etc/GMT-9",
			"Asia/Dili|Pacific/Palau",
			"Asia/Dubai|Asia/Muscat",
			"Asia/Dubai|Asia/Tbilisi",
			"Asia/Dubai|Asia/Yerevan",
			"Asia/Dubai|Etc/GMT-4",
			"Asia/Dubai|Europe/Samara",
			"Asia/Dubai|Indian/Mahe",
			"Asia/Dubai|Indian/Mauritius",
			"Asia/Dubai|Indian/Reunion",
			"Asia/Gaza|Asia/Hebron",
			"Asia/Hong_Kong|Hongkong",
			"Asia/Jakarta|Asia/Pontianak",
			"Asia/Jerusalem|Asia/Tel_Aviv",
			"Asia/Jerusalem|Israel",
			"Asia/Kamchatka|Asia/Anadyr",
			"Asia/Kamchatka|Etc/GMT-12",
			"Asia/Kamchatka|Kwajalein",
			"Asia/Kamchatka|Pacific/Funafuti",
			"Asia/Kamchatka|Pacific/Kwajalein",
			"Asia/Kamchatka|Pacific/Majuro",
			"Asia/Kamchatka|Pacific/Nauru",
			"Asia/Kamchatka|Pacific/Tarawa",
			"Asia/Kamchatka|Pacific/Wake",
			"Asia/Kamchatka|Pacific/Wallis",
			"Asia/Kathmandu|Asia/Katmandu",
			"Asia/Kolkata|Asia/Calcutta",
			"Asia/Makassar|Asia/Ujung_Pandang",
			"Asia/Manila|Asia/Brunei",
			"Asia/Manila|Asia/Kuala_Lumpur",
			"Asia/Manila|Asia/Kuching",
			"Asia/Manila|Asia/Singapore",
			"Asia/Manila|Etc/GMT-8",
			"Asia/Manila|Singapore",
			"Asia/Rangoon|Asia/Yangon",
			"Asia/Rangoon|Indian/Cocos",
			"Asia/Seoul|ROK",
			"Asia/Shanghai|Asia/Chongqing",
			"Asia/Shanghai|Asia/Chungking",
			"Asia/Shanghai|Asia/Harbin",
			"Asia/Shanghai|Asia/Macao",
			"Asia/Shanghai|Asia/Macau",
			"Asia/Shanghai|Asia/Taipei",
			"Asia/Shanghai|PRC",
			"Asia/Shanghai|ROC",
			"Asia/Tashkent|Antarctica/Mawson",
			"Asia/Tashkent|Asia/Aqtau",
			"Asia/Tashkent|Asia/Aqtobe",
			"Asia/Tashkent|Asia/Ashgabat",
			"Asia/Tashkent|Asia/Ashkhabad",
			"Asia/Tashkent|Asia/Atyrau",
			"Asia/Tashkent|Asia/Dushanbe",
			"Asia/Tashkent|Asia/Oral",
			"Asia/Tashkent|Asia/Samarkand",
			"Asia/Tashkent|Etc/GMT-5",
			"Asia/Tashkent|Indian/Kerguelen",
			"Asia/Tashkent|Indian/Maldives",
			"Asia/Tehran|Iran",
			"Asia/Tokyo|Japan",
			"Asia/Ulaanbaatar|Asia/Choibalsan",
			"Asia/Ulaanbaatar|Asia/Ulan_Bator",
			"Asia/Vladivostok|Asia/Ust-Nera",
			"Asia/Yakutsk|Asia/Khandyga",
			"Atlantic/Azores|America/Scoresbysund",
			"Atlantic/Cape_Verde|Etc/GMT+1",
			"Australia/Adelaide|Australia/Broken_Hill",
			"Australia/Adelaide|Australia/South",
			"Australia/Adelaide|Australia/Yancowinna",
			"Australia/Brisbane|Australia/Lindeman",
			"Australia/Brisbane|Australia/Queensland",
			"Australia/Darwin|Australia/North",
			"Australia/Lord_Howe|Australia/LHI",
			"Australia/Perth|Australia/West",
			"Australia/Sydney|Australia/ACT",
			"Australia/Sydney|Australia/Canberra",
			"Australia/Sydney|Australia/Currie",
			"Australia/Sydney|Australia/Hobart",
			"Australia/Sydney|Australia/Melbourne",
			"Australia/Sydney|Australia/NSW",
			"Australia/Sydney|Australia/Tasmania",
			"Australia/Sydney|Australia/Victoria",
			"Etc/UCT|UCT",
			"Etc/UTC|Etc/Universal",
			"Etc/UTC|Etc/Zulu",
			"Etc/UTC|UTC",
			"Etc/UTC|Universal",
			"Etc/UTC|Zulu",
			"Europe/Astrakhan|Europe/Ulyanovsk",
			"Europe/Athens|Asia/Nicosia",
			"Europe/Athens|EET",
			"Europe/Athens|Europe/Bucharest",
			"Europe/Athens|Europe/Helsinki",
			"Europe/Athens|Europe/Kiev",
			"Europe/Athens|Europe/Mariehamn",
			"Europe/Athens|Europe/Nicosia",
			"Europe/Athens|Europe/Riga",
			"Europe/Athens|Europe/Sofia",
			"Europe/Athens|Europe/Tallinn",
			"Europe/Athens|Europe/Uzhgorod",
			"Europe/Athens|Europe/Vilnius",
			"Europe/Athens|Europe/Zaporozhye",
			"Europe/Chisinau|Europe/Tiraspol",
			"Europe/Dublin|Eire",
			"Europe/Istanbul|Asia/Istanbul",
			"Europe/Istanbul|Turkey",
			"Europe/Lisbon|Atlantic/Canary",
			"Europe/Lisbon|Atlantic/Faeroe",
			"Europe/Lisbon|Atlantic/Faroe",
			"Europe/Lisbon|Atlantic/Madeira",
			"Europe/Lisbon|Portugal",
			"Europe/Lisbon|WET",
			"Europe/London|Europe/Belfast",
			"Europe/London|Europe/Guernsey",
			"Europe/London|Europe/Isle_of_Man",
			"Europe/London|Europe/Jersey",
			"Europe/London|GB",
			"Europe/London|GB-Eire",
			"Europe/Moscow|W-SU",
			"Europe/Paris|Africa/Ceuta",
			"Europe/Paris|Arctic/Longyearbyen",
			"Europe/Paris|Atlantic/Jan_Mayen",
			"Europe/Paris|CET",
			"Europe/Paris|Europe/Amsterdam",
			"Europe/Paris|Europe/Andorra",
			"Europe/Paris|Europe/Belgrade",
			"Europe/Paris|Europe/Berlin",
			"Europe/Paris|Europe/Bratislava",
			"Europe/Paris|Europe/Brussels",
			"Europe/Paris|Europe/Budapest",
			"Europe/Paris|Europe/Busingen",
			"Europe/Paris|Europe/Copenhagen",
			"Europe/Paris|Europe/Gibraltar",
			"Europe/Paris|Europe/Ljubljana",
			"Europe/Paris|Europe/Luxembourg",
			"Europe/Paris|Europe/Madrid",
			"Europe/Paris|Europe/Malta",
			"Europe/Paris|Europe/Monaco",
			"Europe/Paris|Europe/Oslo",
			"Europe/Paris|Europe/Podgorica",
			"Europe/Paris|Europe/Prague",
			"Europe/Paris|Europe/Rome",
			"Europe/Paris|Europe/San_Marino",
			"Europe/Paris|Europe/Sarajevo",
			"Europe/Paris|Europe/Skopje",
			"Europe/Paris|Europe/Stockholm",
			"Europe/Paris|Europe/Tirane",
			"Europe/Paris|Europe/Vaduz",
			"Europe/Paris|Europe/Vatican",
			"Europe/Paris|Europe/Vienna",
			"Europe/Paris|Europe/Warsaw",
			"Europe/Paris|Europe/Zagreb",
			"Europe/Paris|Europe/Zurich",
			"Europe/Paris|Poland",
			"Europe/Volgograd|Europe/Kirov",
			"Pacific/Auckland|Antarctica/McMurdo",
			"Pacific/Auckland|Antarctica/South_Pole",
			"Pacific/Auckland|NZ",
			"Pacific/Chatham|NZ-CHAT",
			"Pacific/Easter|Chile/EasterIsland",
			"Pacific/Fakaofo|Etc/GMT-13",
			"Pacific/Fakaofo|Pacific/Enderbury",
			"Pacific/Galapagos|Etc/GMT+6",
			"Pacific/Gambier|Etc/GMT+9",
			"Pacific/Guadalcanal|Antarctica/Macquarie",
			"Pacific/Guadalcanal|Etc/GMT-11",
			"Pacific/Guadalcanal|Pacific/Efate",
			"Pacific/Guadalcanal|Pacific/Kosrae",
			"Pacific/Guadalcanal|Pacific/Noumea",
			"Pacific/Guadalcanal|Pacific/Pohnpei",
			"Pacific/Guadalcanal|Pacific/Ponape",
			"Pacific/Guam|Pacific/Saipan",
			"Pacific/Honolulu|HST",
			"Pacific/Honolulu|Pacific/Johnston",
			"Pacific/Honolulu|US/Hawaii",
			"Pacific/Kiritimati|Etc/GMT-14",
			"Pacific/Niue|Etc/GMT+11",
			"Pacific/Pago_Pago|Pacific/Midway",
			"Pacific/Pago_Pago|Pacific/Samoa",
			"Pacific/Pago_Pago|US/Samoa",
			"Pacific/Pitcairn|Etc/GMT+8",
			"Pacific/Port_Moresby|Antarctica/DumontDUrville",
			"Pacific/Port_Moresby|Etc/GMT-10",
			"Pacific/Port_Moresby|Pacific/Chuuk",
			"Pacific/Port_Moresby|Pacific/Truk",
			"Pacific/Port_Moresby|Pacific/Yap",
			"Pacific/Tahiti|Etc/GMT+10",
			"Pacific/Tahiti|Pacific/Rarotonga"
		]
	});


	return moment;
}));

}.call(window));

/***/ }),

/***/ 2984:
/***/ (function(module, exports) {

/*** IMPORTS FROM imports-loader ***/
var define = undefined;
var require = undefined;
var module = undefined;
var exports = undefined;
(function() {

/*
 * CAUTION: This file (and everything in this directory) is marked as noParse
 * in our Webpack configuration. This means it cannot import modules, and that
 * it will not be transpiled to ES5. Do *NOT* use any ES6 features that our
 * supported browsers don't support natively (i.e., IE11 does not support arrow
 * functions).
 */

(function (root) {/*global exports, Intl*/
/**
 * This script gives you the zone info key representing your device's time zone setting.
 *
 * @name jsTimezoneDetect
 * @version 1.0.6
 * @author Jon Nylander
 * @license MIT License - https://bitbucket.org/pellepim/jstimezonedetect/src/default/LICENCE.txt
 *
 * For usage and examples, visit:
 * http://pellepim.bitbucket.org/jstz/
 *
 * Copyright (c) Jon Nylander
 */


/**
 * Namespace to hold all the code for timezone detection.
 */
var jstz = (function () {
    'use strict';
    var HEMISPHERE_SOUTH = 's',

        consts = {
            DAY: 86400000,
            HOUR: 3600000,
            MINUTE: 60000,
            SECOND: 1000,
            BASELINE_YEAR: 2014,
            MAX_SCORE: 864000000, // 10 days
            AMBIGUITIES: {
                'America/Denver':       ['America/Mazatlan'],
                'Europe/London':        ['Africa/Casablanca'],
                'America/Chicago':      ['America/Mexico_City'],
                'America/Asuncion':     ['America/Campo_Grande', 'America/Santiago'],
                'America/Montevideo':   ['America/Sao_Paulo', 'America/Santiago'],
                // Europe/Minsk should not be in this list... but Windows.
                'Asia/Beirut':          ['Asia/Amman', 'Asia/Jerusalem', 'Europe/Helsinki', 'Asia/Damascus', 'Africa/Cairo', 'Asia/Gaza', 'Europe/Minsk'],
                'Pacific/Auckland':     ['Pacific/Fiji'],
                'America/Los_Angeles':  ['America/Santa_Isabel'],
                'America/New_York':     ['America/Havana'],
                'America/Halifax':      ['America/Goose_Bay'],
                'America/Godthab':      ['America/Miquelon'],
                'Asia/Dubai':           ['Asia/Yerevan'],
                'Asia/Jakarta':         ['Asia/Krasnoyarsk'],
                'Asia/Shanghai':        ['Asia/Irkutsk', 'Australia/Perth'],
                'Australia/Sydney':     ['Australia/Lord_Howe'],
                'Asia/Tokyo':           ['Asia/Yakutsk'],
                'Asia/Dhaka':           ['Asia/Omsk'],
                // In the real world Yerevan is not ambigous for Baku... but Windows.
                'Asia/Baku':            ['Asia/Yerevan'],
                'Australia/Brisbane':   ['Asia/Vladivostok'],
                'Pacific/Noumea':       ['Asia/Vladivostok'],
                'Pacific/Majuro':       ['Asia/Kamchatka', 'Pacific/Fiji'],
                'Pacific/Tongatapu':    ['Pacific/Apia'],
                'Asia/Baghdad':         ['Europe/Minsk', 'Europe/Moscow'],
                'Asia/Karachi':         ['Asia/Yekaterinburg'],
                'Africa/Johannesburg':  ['Asia/Gaza', 'Africa/Cairo']
            }
        },

        /**
         * Gets the offset in minutes from UTC for a certain date.
         * @param {Date} date
         * @returns {Number}
         */
        get_date_offset = function get_date_offset(date) {
            var offset = -date.getTimezoneOffset();
            return (offset !== null ? offset : 0);
        },

        /**
         * This function does some basic calculations to create information about
         * the user's timezone. It uses REFERENCE_YEAR as a solid year for which
         * the script has been tested rather than depend on the year set by the
         * client device.
         *
         * Returns a key that can be used to do lookups in jstz.olson.timezones.
         * eg: "720,1,2".
         *
         * @returns {String}
         */
        lookup_key = function lookup_key() {
            var january_offset = get_date_offset(new Date(consts.BASELINE_YEAR, 0, 2)),
                june_offset = get_date_offset(new Date(consts.BASELINE_YEAR, 5, 2)),
                diff = january_offset - june_offset;

            if (diff < 0) {
                return january_offset + ",1";
            } else if (diff > 0) {
                return june_offset + ",1," + HEMISPHERE_SOUTH;
            }

            return january_offset + ",0";
        },


        /**
         * Tries to get the time zone key directly from the operating system for those
         * environments that support the ECMAScript Internationalization API.
         */
        get_from_internationalization_api = function get_from_internationalization_api() {
            var format, timezone;
            if (typeof Intl === "undefined" || typeof Intl.DateTimeFormat === "undefined") {
                return;
            }

            format = Intl.DateTimeFormat();

            if (typeof format === "undefined" || typeof format.resolvedOptions === "undefined") {
                return;
            }

            timezone = format.resolvedOptions().timeZone;

            if (timezone && (timezone.indexOf("/") > -1 || timezone === 'UTC')) {
                return timezone;
            }

        },

        /**
         * Starting point for getting all the DST rules for a specific year
         * for the current timezone (as described by the client system).
         *
         * Returns an object with start and end attributes, or false if no
         * DST rules were found for the year.
         *
         * @param year
         * @returns {Object} || {Boolean}
         */
        dst_dates = function dst_dates(year) {
            var yearstart = new Date(year, 0, 1, 0, 0, 1, 0).getTime();
            var yearend = new Date(year, 12, 31, 23, 59, 59).getTime();
            var current = yearstart;
            var offset = (new Date(current)).getTimezoneOffset();
            var dst_start = null;
            var dst_end = null;

            while (current < yearend - 86400000) {
                var dateToCheck = new Date(current);
                var dateToCheckOffset = dateToCheck.getTimezoneOffset();

                if (dateToCheckOffset !== offset) {
                    if (dateToCheckOffset < offset) {
                        dst_start = dateToCheck;
                    }
                    if (dateToCheckOffset > offset) {
                        dst_end = dateToCheck;
                    }
                    offset = dateToCheckOffset;
                }

                current += 86400000;
            }

            if (dst_start && dst_end) {
                return {
                    s: find_dst_fold(dst_start).getTime(),
                    e: find_dst_fold(dst_end).getTime()
                };
            }

            return false;
        },

        /**
         * Probably completely unnecessary function that recursively finds the
         * exact (to the second) time when a DST rule was changed.
         *
         * @param a_date - The candidate Date.
         * @param padding - integer specifying the padding to allow around the candidate
         *                  date for finding the fold.
         * @param iterator - integer specifying how many milliseconds to iterate while
         *                   searching for the fold.
         *
         * @returns {Date}
         */
        find_dst_fold = function find_dst_fold(a_date, padding, iterator) {
            if (typeof padding === 'undefined') {
                padding = consts.DAY;
                iterator = consts.HOUR;
            }

            var date_start = new Date(a_date.getTime() - padding).getTime();
            var date_end = a_date.getTime() + padding;
            var offset = new Date(date_start).getTimezoneOffset();

            var current = date_start;

            var dst_change = null;
            while (current < date_end - iterator) {
                var dateToCheck = new Date(current);
                var dateToCheckOffset = dateToCheck.getTimezoneOffset();

                if (dateToCheckOffset !== offset) {
                    dst_change = dateToCheck;
                    break;
                }
                current += iterator;
            }

            if (padding === consts.DAY) {
                return find_dst_fold(dst_change, consts.HOUR, consts.MINUTE);
            }

            if (padding === consts.HOUR) {
                return find_dst_fold(dst_change, consts.MINUTE, consts.SECOND);
            }

            return dst_change;
        },

        windows7_adaptations = function windows7_adaptions(rule_list, preliminary_timezone, score, sample) {
            if (score !== 'N/A') {
                return score;
            }
            if (preliminary_timezone === 'Asia/Beirut') {
                if (sample.name === 'Africa/Cairo') {
                    if (rule_list[6].s === 1398376800000 && rule_list[6].e === 1411678800000) {
                        return 0;
                    }
                }
                if (sample.name === 'Asia/Jerusalem') {
                    if (rule_list[6].s === 1395964800000 && rule_list[6].e === 1411858800000) {
                        return 0;
                }
            }
            } else if (preliminary_timezone === 'America/Santiago') {
                if (sample.name === 'America/Asuncion') {
                    if (rule_list[6].s === 1412481600000 && rule_list[6].e === 1397358000000) {
                        return 0;
                    }
                }
                if (sample.name === 'America/Campo_Grande') {
                    if (rule_list[6].s === 1413691200000 && rule_list[6].e === 1392519600000) {
                        return 0;
                    }
                }
            } else if (preliminary_timezone === 'America/Montevideo') {
                if (sample.name === 'America/Sao_Paulo') {
                    if (rule_list[6].s === 1413687600000 && rule_list[6].e === 1392516000000) {
                        return 0;
                    }
                }
            } else if (preliminary_timezone === 'Pacific/Auckland') {
                if (sample.name === 'Pacific/Fiji') {
                    if (rule_list[6].s === 1414245600000 && rule_list[6].e === 1396101600000) {
                        return 0;
                    }
                }
            }

            return score;
        },

        /**
         * Takes the DST rules for the current timezone, and proceeds to find matches
         * in the jstz.olson.dst_rules.zones array.
         *
         * Compares samples to the current timezone on a scoring basis.
         *
         * Candidates are ruled immediately if either the candidate or the current zone
         * has a DST rule where the other does not.
         *
         * Candidates are ruled out immediately if the current zone has a rule that is
         * outside the DST scope of the candidate.
         *
         * Candidates are included for scoring if the current zones rules fall within the
         * span of the samples rules.
         *
         * Low score is best, the score is calculated by summing up the differences in DST
         * rules and if the consts.MAX_SCORE is overreached the candidate is ruled out.
         *
         * Yah follow? :)
         *
         * @param rule_list
         * @param preliminary_timezone
         * @returns {*}
         */
        best_dst_match = function best_dst_match(rule_list, preliminary_timezone) {
            var score_sample = function score_sample(sample) {
                var score = 0;

                for (var j = 0; j < rule_list.length; j++) {

                    // Both sample and current time zone report DST during the year.
                    if (!!sample.rules[j] && !!rule_list[j]) {

                        // The current time zone's DST rules are inside the sample's. Include.
                        if (rule_list[j].s >= sample.rules[j].s && rule_list[j].e <= sample.rules[j].e) {
                            score = 0;
                            score += Math.abs(rule_list[j].s - sample.rules[j].s);
                            score += Math.abs(sample.rules[j].e - rule_list[j].e);

                        // The current time zone's DST rules are outside the sample's. Discard.
                        } else {
                            score = 'N/A';
                            break;
                        }

                        // The max score has been reached. Discard.
                        if (score > consts.MAX_SCORE) {
                            score = 'N/A';
                            break;
                        }
                    }
                }

                score = windows7_adaptations(rule_list, preliminary_timezone, score, sample);

                return score;
            };
            var scoreboard = {};
            var dst_zones = jstz.olson.dst_rules.zones;
            var dst_zones_length = dst_zones.length;
            var ambiguities = consts.AMBIGUITIES[preliminary_timezone];

            for (var i = 0; i < dst_zones_length; i++) {
                var sample = dst_zones[i];
                var score = score_sample(dst_zones[i]);

                if (score !== 'N/A') {
                    scoreboard[sample.name] = score;
                }
            }

            for (var tz in scoreboard) {
                if (scoreboard.hasOwnProperty(tz)) {
                    for (var j = 0; j < ambiguities.length; j++) {
                        if (ambiguities[j] === tz) {
                            return tz;
                        }
                    }
                }
            }

            return preliminary_timezone;
        },

        /**
         * Takes the preliminary_timezone as detected by lookup_key().
         *
         * Builds up the current timezones DST rules for the years defined
         * in the jstz.olson.dst_rules.years array.
         *
         * If there are no DST occurences for those years, immediately returns
         * the preliminary timezone. Otherwise proceeds and tries to solve
         * ambiguities.
         *
         * @param preliminary_timezone
         * @returns {String} timezone_name
         */
        get_by_dst = function get_by_dst(preliminary_timezone) {
            var get_rules = function get_rules() {
                var rule_list = [];
                for (var i = 0; i < jstz.olson.dst_rules.years.length; i++) {
                    var year_rules = dst_dates(jstz.olson.dst_rules.years[i]);
                    rule_list.push(year_rules);
                }
                return rule_list;
            };
            var check_has_dst = function check_has_dst(rules) {
                for (var i = 0; i < rules.length; i++) {
                    if (rules[i] !== false) {
                        return true;
                    }
                }
                return false;
            };
            var rules = get_rules();
            var has_dst = check_has_dst(rules);

            if (has_dst) {
                return best_dst_match(rules, preliminary_timezone);
            }

            return preliminary_timezone;
        },

        /**
         * Uses get_timezone_info() to formulate a key to use in the olson.timezones dictionary.
         *
         * Returns an object with one function ".name()"
         *
         * @returns Object
         */
        determine = function determine() {
            var preliminary_tz = get_from_internationalization_api();

            if (!preliminary_tz) {
                preliminary_tz = jstz.olson.timezones[lookup_key()];

                if (typeof consts.AMBIGUITIES[preliminary_tz] !== 'undefined') {
                    preliminary_tz = get_by_dst(preliminary_tz);
                }
            }

            return {
                name: function () {
                    return preliminary_tz;
                }
            };
        };

    return {
        determine: determine
    };
}());


jstz.olson = jstz.olson || {};

/**
 * The keys in this dictionary are comma separated as such:
 *
 * First the offset compared to UTC time in minutes.
 *
 * Then a flag which is 0 if the timezone does not take daylight savings into account and 1 if it
 * does.
 *
 * Thirdly an optional 's' signifies that the timezone is in the southern hemisphere,
 * only interesting for timezones with DST.
 *
 * The mapped arrays is used for constructing the jstz.TimeZone object from within
 * jstz.determine();
 */
jstz.olson.timezones = {
    '-720,0': 'Etc/GMT+12',
    '-660,0': 'Pacific/Pago_Pago',
    '-660,1,s': 'Pacific/Apia', // Why? Because windows... cry!
    '-600,1': 'America/Adak',
    '-600,0': 'Pacific/Honolulu',
    '-570,0': 'Pacific/Marquesas',
    '-540,0': 'Pacific/Gambier',
    '-540,1': 'America/Anchorage',
    '-480,1': 'America/Los_Angeles',
    '-480,0': 'Pacific/Pitcairn',
    '-420,0': 'America/Phoenix',
    '-420,1': 'America/Denver',
    '-360,0': 'America/Guatemala',
    '-360,1': 'America/Chicago',
    '-360,1,s': 'Pacific/Easter',
    '-300,0': 'America/Bogota',
    '-300,1': 'America/New_York',
    '-270,0': 'America/Caracas',
    '-240,1': 'America/Halifax',
    '-240,0': 'America/Santo_Domingo',
    '-240,1,s': 'America/Asuncion',
    '-210,1': 'America/St_Johns',
    '-180,1': 'America/Godthab',
    '-180,0': 'America/Argentina/Buenos_Aires',
    '-180,1,s': 'America/Montevideo',
    '-120,0': 'America/Noronha',
    '-120,1': 'America/Noronha',
    '-60,1': 'Atlantic/Azores',
    '-60,0': 'Atlantic/Cape_Verde',
    '0,0': 'UTC',
    '0,1': 'Europe/London',
    '60,1': 'Europe/Berlin',
    '60,0': 'Africa/Lagos',
    '60,1,s': 'Africa/Windhoek',
    '120,1': 'Asia/Beirut',
    '120,0': 'Africa/Johannesburg',
    '180,0': 'Asia/Baghdad',
    '180,1': 'Europe/Moscow',
    '210,1': 'Asia/Tehran',
    '240,0': 'Asia/Dubai',
    '240,1': 'Asia/Baku',
    '270,0': 'Asia/Kabul',
    '300,1': 'Asia/Yekaterinburg',
    '300,0': 'Asia/Karachi',
    '330,0': 'Asia/Kolkata',
    '345,0': 'Asia/Kathmandu',
    '360,0': 'Asia/Dhaka',
    '360,1': 'Asia/Omsk',
    '390,0': 'Asia/Rangoon',
    '420,1': 'Asia/Krasnoyarsk',
    '420,0': 'Asia/Jakarta',
    '480,0': 'Asia/Shanghai',
    '480,1': 'Asia/Irkutsk',
    '525,0': 'Australia/Eucla',
    '525,1,s': 'Australia/Eucla',
    '540,1': 'Asia/Yakutsk',
    '540,0': 'Asia/Tokyo',
    '570,0': 'Australia/Darwin',
    '570,1,s': 'Australia/Adelaide',
    '600,0': 'Australia/Brisbane',
    '600,1': 'Asia/Vladivostok',
    '600,1,s': 'Australia/Sydney',
    '630,1,s': 'Australia/Lord_Howe',
    '660,1': 'Asia/Kamchatka',
    '660,0': 'Pacific/Noumea',
    '690,0': 'Pacific/Norfolk',
    '720,1,s': 'Pacific/Auckland',
    '720,0': 'Pacific/Majuro',
    '765,1,s': 'Pacific/Chatham',
    '780,0': 'Pacific/Tongatapu',
    '780,1,s': 'Pacific/Apia',
    '840,0': 'Pacific/Kiritimati'
};

/* Build time: 2015-11-02 13:01:00Z Build by invoking python utilities/dst.py generate */
jstz.olson.dst_rules = {
    "years": [
        2008,
        2009,
        2010,
        2011,
        2012,
        2013,
        2014
    ],
    "zones": [
        {
            "name": "Africa/Cairo",
            "rules": [
                {
                    "e": 1219957200000,
                    "s": 1209074400000
                },
                {
                    "e": 1250802000000,
                    "s": 1240524000000
                },
                {
                    "e": 1285880400000,
                    "s": 1284069600000
                },
                false,
                false,
                false,
                {
                    "e": 1411678800000,
                    "s": 1406844000000
                }
            ]
        },
        {
            "name": "Africa/Casablanca",
            "rules": [
                {
                    "e": 1220223600000,
                    "s": 1212278400000
                },
                {
                    "e": 1250809200000,
                    "s": 1243814400000
                },
                {
                    "e": 1281222000000,
                    "s": 1272758400000
                },
                {
                    "e": 1312066800000,
                    "s": 1301788800000
                },
                {
                    "e": 1348970400000,
                    "s": 1345428000000
                },
                {
                    "e": 1382839200000,
                    "s": 1376100000000
                },
                {
                    "e": 1414288800000,
                    "s": 1406944800000
                }
            ]
        },
        {
            "name": "America/Asuncion",
            "rules": [
                {
                    "e": 1205031600000,
                    "s": 1224388800000
                },
                {
                    "e": 1236481200000,
                    "s": 1255838400000
                },
                {
                    "e": 1270954800000,
                    "s": 1286078400000
                },
                {
                    "e": 1302404400000,
                    "s": 1317528000000
                },
                {
                    "e": 1333854000000,
                    "s": 1349582400000
                },
                {
                    "e": 1364094000000,
                    "s": 1381032000000
                },
                {
                    "e": 1395543600000,
                    "s": 1412481600000
                }
            ]
        },
        {
            "name": "America/Campo_Grande",
            "rules": [
                {
                    "e": 1203217200000,
                    "s": 1224388800000
                },
                {
                    "e": 1234666800000,
                    "s": 1255838400000
                },
                {
                    "e": 1266721200000,
                    "s": 1287288000000
                },
                {
                    "e": 1298170800000,
                    "s": 1318737600000
                },
                {
                    "e": 1330225200000,
                    "s": 1350792000000
                },
                {
                    "e": 1361070000000,
                    "s": 1382241600000
                },
                {
                    "e": 1392519600000,
                    "s": 1413691200000
                }
            ]
        },
        {
            "name": "America/Goose_Bay",
            "rules": [
                {
                    "e": 1225594860000,
                    "s": 1205035260000
                },
                {
                    "e": 1257044460000,
                    "s": 1236484860000
                },
                {
                    "e": 1289098860000,
                    "s": 1268539260000
                },
                {
                    "e": 1320555600000,
                    "s": 1299988860000
                },
                {
                    "e": 1352005200000,
                    "s": 1331445600000
                },
                {
                    "e": 1383454800000,
                    "s": 1362895200000
                },
                {
                    "e": 1414904400000,
                    "s": 1394344800000
                }
            ]
        },
        {
            "name": "America/Havana",
            "rules": [
                {
                    "e": 1224997200000,
                    "s": 1205643600000
                },
                {
                    "e": 1256446800000,
                    "s": 1236488400000
                },
                {
                    "e": 1288501200000,
                    "s": 1268542800000
                },
                {
                    "e": 1321160400000,
                    "s": 1300597200000
                },
                {
                    "e": 1352005200000,
                    "s": 1333256400000
                },
                {
                    "e": 1383454800000,
                    "s": 1362891600000
                },
                {
                    "e": 1414904400000,
                    "s": 1394341200000
                }
            ]
        },
        {
            "name": "America/Mazatlan",
            "rules": [
                {
                    "e": 1225008000000,
                    "s": 1207472400000
                },
                {
                    "e": 1256457600000,
                    "s": 1238922000000
                },
                {
                    "e": 1288512000000,
                    "s": 1270371600000
                },
                {
                    "e": 1319961600000,
                    "s": 1301821200000
                },
                {
                    "e": 1351411200000,
                    "s": 1333270800000
                },
                {
                    "e": 1382860800000,
                    "s": 1365325200000
                },
                {
                    "e": 1414310400000,
                    "s": 1396774800000
                }
            ]
        },
        {
            "name": "America/Mexico_City",
            "rules": [
                {
                    "e": 1225004400000,
                    "s": 1207468800000
                },
                {
                    "e": 1256454000000,
                    "s": 1238918400000
                },
                {
                    "e": 1288508400000,
                    "s": 1270368000000
                },
                {
                    "e": 1319958000000,
                    "s": 1301817600000
                },
                {
                    "e": 1351407600000,
                    "s": 1333267200000
                },
                {
                    "e": 1382857200000,
                    "s": 1365321600000
                },
                {
                    "e": 1414306800000,
                    "s": 1396771200000
                }
            ]
        },
        {
            "name": "America/Miquelon",
            "rules": [
                {
                    "e": 1225598400000,
                    "s": 1205038800000
                },
                {
                    "e": 1257048000000,
                    "s": 1236488400000
                },
                {
                    "e": 1289102400000,
                    "s": 1268542800000
                },
                {
                    "e": 1320552000000,
                    "s": 1299992400000
                },
                {
                    "e": 1352001600000,
                    "s": 1331442000000
                },
                {
                    "e": 1383451200000,
                    "s": 1362891600000
                },
                {
                    "e": 1414900800000,
                    "s": 1394341200000
                }
            ]
        },
        {
            "name": "America/Santa_Isabel",
            "rules": [
                {
                    "e": 1225011600000,
                    "s": 1207476000000
                },
                {
                    "e": 1256461200000,
                    "s": 1238925600000
                },
                {
                    "e": 1288515600000,
                    "s": 1270375200000
                },
                {
                    "e": 1319965200000,
                    "s": 1301824800000
                },
                {
                    "e": 1351414800000,
                    "s": 1333274400000
                },
                {
                    "e": 1382864400000,
                    "s": 1365328800000
                },
                {
                    "e": 1414314000000,
                    "s": 1396778400000
                }
            ]
        },
        {
            "name": "America/Santiago",
            "rules": [
                {
                    "e": 1206846000000,
                    "s": 1223784000000
                },
                {
                    "e": 1237086000000,
                    "s": 1255233600000
                },
                {
                    "e": 1270350000000,
                    "s": 1286683200000
                },
                {
                    "e": 1304823600000,
                    "s": 1313899200000
                },
                {
                    "e": 1335668400000,
                    "s": 1346558400000
                },
                {
                    "e": 1367118000000,
                    "s": 1378612800000
                },
                {
                    "e": 1398567600000,
                    "s": 1410062400000
                }
            ]
        },
        {
            "name": "America/Sao_Paulo",
            "rules": [
                {
                    "e": 1203213600000,
                    "s": 1224385200000
                },
                {
                    "e": 1234663200000,
                    "s": 1255834800000
                },
                {
                    "e": 1266717600000,
                    "s": 1287284400000
                },
                {
                    "e": 1298167200000,
                    "s": 1318734000000
                },
                {
                    "e": 1330221600000,
                    "s": 1350788400000
                },
                {
                    "e": 1361066400000,
                    "s": 1382238000000
                },
                {
                    "e": 1392516000000,
                    "s": 1413687600000
                }
            ]
        },
        {
            "name": "Asia/Amman",
            "rules": [
                {
                    "e": 1225404000000,
                    "s": 1206655200000
                },
                {
                    "e": 1256853600000,
                    "s": 1238104800000
                },
                {
                    "e": 1288303200000,
                    "s": 1269554400000
                },
                {
                    "e": 1319752800000,
                    "s": 1301608800000
                },
                false,
                false,
                {
                    "e": 1414706400000,
                    "s": 1395957600000
                }
            ]
        },
        {
            "name": "Asia/Damascus",
            "rules": [
                {
                    "e": 1225486800000,
                    "s": 1207260000000
                },
                {
                    "e": 1256850000000,
                    "s": 1238104800000
                },
                {
                    "e": 1288299600000,
                    "s": 1270159200000
                },
                {
                    "e": 1319749200000,
                    "s": 1301608800000
                },
                {
                    "e": 1351198800000,
                    "s": 1333058400000
                },
                {
                    "e": 1382648400000,
                    "s": 1364508000000
                },
                {
                    "e": 1414702800000,
                    "s": 1395957600000
                }
            ]
        },
        {
            "name": "Asia/Dubai",
            "rules": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
            ]
        },
        {
            "name": "Asia/Gaza",
            "rules": [
                {
                    "e": 1219957200000,
                    "s": 1206655200000
                },
                {
                    "e": 1252015200000,
                    "s": 1238104800000
                },
                {
                    "e": 1281474000000,
                    "s": 1269640860000
                },
                {
                    "e": 1312146000000,
                    "s": 1301608860000
                },
                {
                    "e": 1348178400000,
                    "s": 1333058400000
                },
                {
                    "e": 1380229200000,
                    "s": 1364508000000
                },
                {
                    "e": 1414098000000,
                    "s": 1395957600000
                }
            ]
        },
        {
            "name": "Asia/Irkutsk",
            "rules": [
                {
                    "e": 1224957600000,
                    "s": 1206813600000
                },
                {
                    "e": 1256407200000,
                    "s": 1238263200000
                },
                {
                    "e": 1288461600000,
                    "s": 1269712800000
                },
                false,
                false,
                false,
                false
            ]
        },
        {
            "name": "Asia/Jerusalem",
            "rules": [
                {
                    "e": 1223161200000,
                    "s": 1206662400000
                },
                {
                    "e": 1254006000000,
                    "s": 1238112000000
                },
                {
                    "e": 1284246000000,
                    "s": 1269561600000
                },
                {
                    "e": 1317510000000,
                    "s": 1301616000000
                },
                {
                    "e": 1348354800000,
                    "s": 1333065600000
                },
                {
                    "e": 1382828400000,
                    "s": 1364515200000
                },
                {
                    "e": 1414278000000,
                    "s": 1395964800000
                }
            ]
        },
        {
            "name": "Asia/Kamchatka",
            "rules": [
                {
                    "e": 1224943200000,
                    "s": 1206799200000
                },
                {
                    "e": 1256392800000,
                    "s": 1238248800000
                },
                {
                    "e": 1288450800000,
                    "s": 1269698400000
                },
                false,
                false,
                false,
                false
            ]
        },
        {
            "name": "Asia/Krasnoyarsk",
            "rules": [
                {
                    "e": 1224961200000,
                    "s": 1206817200000
                },
                {
                    "e": 1256410800000,
                    "s": 1238266800000
                },
                {
                    "e": 1288465200000,
                    "s": 1269716400000
                },
                false,
                false,
                false,
                false
            ]
        },
        {
            "name": "Asia/Omsk",
            "rules": [
                {
                    "e": 1224964800000,
                    "s": 1206820800000
                },
                {
                    "e": 1256414400000,
                    "s": 1238270400000
                },
                {
                    "e": 1288468800000,
                    "s": 1269720000000
                },
                false,
                false,
                false,
                false
            ]
        },
        {
            "name": "Asia/Vladivostok",
            "rules": [
                {
                    "e": 1224950400000,
                    "s": 1206806400000
                },
                {
                    "e": 1256400000000,
                    "s": 1238256000000
                },
                {
                    "e": 1288454400000,
                    "s": 1269705600000
                },
                false,
                false,
                false,
                false
            ]
        },
        {
            "name": "Asia/Yakutsk",
            "rules": [
                {
                    "e": 1224954000000,
                    "s": 1206810000000
                },
                {
                    "e": 1256403600000,
                    "s": 1238259600000
                },
                {
                    "e": 1288458000000,
                    "s": 1269709200000
                },
                false,
                false,
                false,
                false
            ]
        },
        {
            "name": "Asia/Yekaterinburg",
            "rules": [
                {
                    "e": 1224968400000,
                    "s": 1206824400000
                },
                {
                    "e": 1256418000000,
                    "s": 1238274000000
                },
                {
                    "e": 1288472400000,
                    "s": 1269723600000
                },
                false,
                false,
                false,
                false
            ]
        },
        {
            "name": "Asia/Yerevan",
            "rules": [
                {
                    "e": 1224972000000,
                    "s": 1206828000000
                },
                {
                    "e": 1256421600000,
                    "s": 1238277600000
                },
                {
                    "e": 1288476000000,
                    "s": 1269727200000
                },
                {
                    "e": 1319925600000,
                    "s": 1301176800000
                },
                false,
                false,
                false
            ]
        },
        {
            "name": "Australia/Lord_Howe",
            "rules": [
                {
                    "e": 1207407600000,
                    "s": 1223134200000
                },
                {
                    "e": 1238857200000,
                    "s": 1254583800000
                },
                {
                    "e": 1270306800000,
                    "s": 1286033400000
                },
                {
                    "e": 1301756400000,
                    "s": 1317483000000
                },
                {
                    "e": 1333206000000,
                    "s": 1349537400000
                },
                {
                    "e": 1365260400000,
                    "s": 1380987000000
                },
                {
                    "e": 1396710000000,
                    "s": 1412436600000
                }
            ]
        },
        {
            "name": "Australia/Perth",
            "rules": [
                {
                    "e": 1206813600000,
                    "s": 1224957600000
                },
                false,
                false,
                false,
                false,
                false,
                false
            ]
        },
        {
            "name": "Europe/Helsinki",
            "rules": [
                {
                    "e": 1224982800000,
                    "s": 1206838800000
                },
                {
                    "e": 1256432400000,
                    "s": 1238288400000
                },
                {
                    "e": 1288486800000,
                    "s": 1269738000000
                },
                {
                    "e": 1319936400000,
                    "s": 1301187600000
                },
                {
                    "e": 1351386000000,
                    "s": 1332637200000
                },
                {
                    "e": 1382835600000,
                    "s": 1364691600000
                },
                {
                    "e": 1414285200000,
                    "s": 1396141200000
                }
            ]
        },
        {
            "name": "Europe/Minsk",
            "rules": [
                {
                    "e": 1224979200000,
                    "s": 1206835200000
                },
                {
                    "e": 1256428800000,
                    "s": 1238284800000
                },
                {
                    "e": 1288483200000,
                    "s": 1269734400000
                },
                false,
                false,
                false,
                false
            ]
        },
        {
            "name": "Europe/Moscow",
            "rules": [
                {
                    "e": 1224975600000,
                    "s": 1206831600000
                },
                {
                    "e": 1256425200000,
                    "s": 1238281200000
                },
                {
                    "e": 1288479600000,
                    "s": 1269730800000
                },
                false,
                false,
                false,
                false
            ]
        },
        {
            "name": "Pacific/Apia",
            "rules": [
                false,
                false,
                false,
                {
                    "e": 1301752800000,
                    "s": 1316872800000
                },
                {
                    "e": 1333202400000,
                    "s": 1348927200000
                },
                {
                    "e": 1365256800000,
                    "s": 1380376800000
                },
                {
                    "e": 1396706400000,
                    "s": 1411826400000
                }
            ]
        },
        {
            "name": "Pacific/Fiji",
            "rules": [
                false,
                false,
                {
                    "e": 1269698400000,
                    "s": 1287842400000
                },
                {
                    "e": 1327154400000,
                    "s": 1319292000000
                },
                {
                    "e": 1358604000000,
                    "s": 1350741600000
                },
                {
                    "e": 1390050000000,
                    "s": 1382796000000
                },
                {
                    "e": 1421503200000,
                    "s": 1414850400000
                }
            ]
        },
        {
            "name": "Europe/London",
            "rules": [
                {
                    "e": 1224982800000,
                    "s": 1206838800000
                },
                {
                    "e": 1256432400000,
                    "s": 1238288400000
                },
                {
                    "e": 1288486800000,
                    "s": 1269738000000
                },
                {
                    "e": 1319936400000,
                    "s": 1301187600000
                },
                {
                    "e": 1351386000000,
                    "s": 1332637200000
                },
                {
                    "e": 1382835600000,
                    "s": 1364691600000
                },
                {
                    "e": 1414285200000,
                    "s": 1396141200000
                }
            ]
        }
    ]
};
if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
    module.exports = jstz;
} else if ((typeof define !== 'undefined' && define !== null) && (define.amd != null)) {
    define([], function() {
        return jstz;
    });
} else {
    if (typeof root === 'undefined') {
        window.jstz = jstz;
    } else {
        root.jstz = jstz;
    }
}
}());

}.call(window));

/***/ }),

/***/ 2985:
/***/ (function(module, exports) {

// Create blist namespace if DNE

/*global blist: true */
if (!window.blist) {
  window.blist = {};
} // Create file namespace if DNE


if (!blist.namespace) {
  blist.namespace = {};
}

blist.namespace.fetch = function (nsString) {
  var nsArray = nsString.split('.');
  var curNS = window;

  for (var i = 0; i < nsArray.length; i++) {
    var n = nsArray[i];

    if (!curNS[n]) {
      curNS[n] = {};
    }

    curNS = curNS[n];
  }

  return curNS;
}; // Let scripts know that we're in-browser


blist.inBrowser = true;

/***/ }),

/***/ 2986:
/***/ (function(module, exports) {

/*** IMPORTS FROM imports-loader ***/
var define = undefined;
var require = undefined;
var module = undefined;
var exports = undefined;
(function() {

/*
 * CAUTION: This file (and everything in this directory) is marked as noParse
 * in our Webpack configuration. This means it cannot import modules, and that
 * it will not be transpiled to ES5. Do *NOT* use any ES6 features that our
 * supported browsers don't support natively (i.e., IE11 does not support arrow
 * functions).
 */

/* Simple JavaScript Inheritance
 * By John Resig http://ejohn.org/
 * http://ejohn.org/blog/simple-javascript-inheritance/
 * MIT Licensed.
 */
// Inspired by base2 and Prototype
(function(){
  var initializing = false, fnTest = /xyz/.test(function(){xyz;}) ? /\b_super\b/ : /.*/;

  // The base Class implementation (does nothing)
  var Class = function(){};

  // Create a new Class that inherits from this class
  Class.extend = function(prop) {
    var _super = this.prototype;

    // Instantiate a base class (but only create the instance,
    // don't run the init constructor)
    initializing = true;
    var prototype = new this();
    initializing = false;

    var addProperties = function(obj, newProps, _s) {
      // Copy the properties over onto the new object
      for (var name in newProps) {
        // Check if we're overwriting an existing function
        obj[name] = typeof newProps[name] == "function" &&
          typeof _s[name] == "function" && fnTest.test(newProps[name]) ?
          (function(name, fn){
            return function() {
              var tmp = this._super;

              // Add a new ._super() method that is the same method
              // but on the super-class. If we have hit a pure virtual,
              // super is undefined.
              var _newSuper = _s[name];
              this._super = (_newSuper == pureVirtual)? undefined : _newSuper;

              // The method only need to be bound temporarily, so we
              // remove it when we're done executing
              var ret = fn.apply(this, arguments);
              this._super = tmp;

              return ret;
            };
          })(name, newProps[name]) :
          newProps[name];
      }
    };

    // Placeholder for a pure-virtual interface entry.
    var pureVirtual = function()
    {
      console.error('Pure virtual call');
      throw new Error('Pure virtual call');
    };

    // Copy the properties over onto the new prototype
    addProperties(prototype, prop, _super);

    // The dummy class constructor
    function Class() {
        this.Class = Class;
      // All construction is actually done in the init method
      if ( !initializing && this._init )
        this._init.apply(this, arguments);
    }

    // Populate our constructed prototype object
    Class.prototype = prototype;

    // Enforce the constructor to be what we expect
    Class.constructor = Class;

    // And make this class extendable
    Class.extend = arguments.callee;

    Class.addProperties = addProperties;

    Class.pureVirtual = pureVirtual;

    return Class;
  };

  if (typeof blist !== 'undefined')
  { this.Class = Class; }
  else
  { module.exports = Class; }

})();


}.call(window));

/***/ }),

/***/ 2987:
/***/ (function(module, exports) {

(function ($) {
  var controlRegistry = {};

  $.fn.isControlClass = function (name) {
    return !!($(this[0]).data('controlClass') || {})[name];
  };

  $.Control = {
    extend: function extend(name, childModel, defaults, parentName, virtual) {
      if ($.isBlank(parentName)) {
        parentName = 'Control';
      }

      var parentModel = controlRegistry[parentName];

      if ($.isBlank(parentModel)) {
        throw 'Unrecognized parent ' + parentName + ' for ' + name;
      }

      var NewModel = parentModel.model.extend(childModel);
      var df = $.extend(true, {}, parentModel.defaults, defaults);
      controlRegistry[name] = {
        defaults: df,
        model: NewModel,
        name: parentModel.name + '.' + name
      };

      if (!virtual) {
        $.fn[name] = function (options) {
          // Check if object was already created
          var $t = $(this[0]);
          var obj = $t.data(name);

          if ($.isBlank(obj)) {
            obj = new NewModel(options, this[0], controlRegistry[name]);
            $t.data(name, obj);
            var cc = $t.data('controlClass') || {};

            _.each(controlRegistry[name].name.split('.'), function (n) {
              cc[n] = true;
            });

            $t.data('controlClass', cc);
          }

          return obj;
        };
      }

      return NewModel;
    },
    registerMixin: function registerMixin(name, model, defaults, parentName, dependsOn) {
      if ($.isBlank(parentName)) {
        parentName = 'Control';
      }

      var parentModel = controlRegistry[parentName];

      if ($.isBlank(parentModel)) {
        throw 'Unrecognized parent ' + parentName + ' for mixin ' + name;
      }

      parentModel.mixins = parentModel.mixins || {};
      parentModel.mixins[name] = {
        model: model,
        defaults: defaults,
        dependsOn: dependsOn
      };
    }
  };
  controlRegistry.Control = {
    defaults: {},
    model: Class.extend({
      _init: function _init(options, dom, modelHash) {
        var df = $.extend(true, {}, modelHash.defaults);
        var obj = this;
        var addedMixins = {};

        var addMixin = function addMixin(mn) {
          if (!addedMixins[mn] && $.subKeyDefined(modelHash.mixins, mn)) {
            var mix = modelHash.mixins[mn];

            _.each($.makeArray(mix.dependsOn), addMixin); // We want to layer all the mixins so they chain together via _super.
            // We can't just inherit from any prototype object, because that doesn't
            // change with each mixin added. Instead, we make a copy of this object
            // as it exists right now, and mixin the model on top of that. This
            // correctly adds just the new methods from mix.model, referencing the
            // previous version of the current object.


            modelHash.model.addProperties(obj, mix.model, $.extend({}, obj));
            addedMixins[mn] = true;
            $.extend(true, df, mix.defaults);
          }
        };

        _.each(obj._getMixins(options) || [], addMixin);

        obj.settings = $.extend(df, options);
        obj.currentDom = dom;

        obj._initMixins();
      },
      // Returns a list of names that should be applied to this instance
      _getMixins: function _getMixins() {
        return [];
      },
      // This is used since mixins aren't added until during _init, so overriding _init will do nothing
      _initMixins: function _initMixins() {},
      $dom: function $dom() {
        if (!this._$dom) {
          this._$dom = $(this.currentDom);
        }

        return this._$dom;
      }
    }),
    name: 'Control'
  };
})(jQuery);

/***/ }),

/***/ 2988:
/***/ (function(module, exports) {

(function ($) {
  $.fn.loadingSpinner = function (options) {
    // Check if object was already created
    var loadingSpinner = $(this[0]).data('loadingSpinner');

    if (!loadingSpinner) {
      loadingSpinner = new LoadingSpinnerObj(options, this[0]);
    }

    return loadingSpinner;
  };

  var LoadingSpinnerObj = function LoadingSpinnerObj(options, dom) {
    this.settings = $.extend({}, LoadingSpinnerObj.defaults, options);
    this.currentDom = dom;
    this.init();
  };

  $.extend(LoadingSpinnerObj, {
    defaults: {
      minimal: false,
      model: null,
      metric: null,
      overlay: false,
      showInitially: false
    },
    prototype: {
      init: function init() {
        var spObj = this;
        spObj.$dom().data('loadingSpinner', spObj);
        spObj.setMetric(spObj.settings.metric);
        spObj.showHide(spObj.settings.showInitially);
        spObj.setModel(spObj.settings.model);
      },
      setModel: function setModel(newModel) {
        var spObj = this;

        if (!$.isBlank(spObj._model)) {
          spObj._model.unbind(null, null, spObj);
        }

        if (!$.isBlank(newModel)) {
          newModel.bind('request_start', function () {
            spObj.showHide(true);
          }, spObj);
          newModel.bind('request_status', function () {
            spObj.setMessage.apply(spObj, arguments);
          }, spObj);
          newModel.bind('request_finish', function () {
            spObj.showHide(false);
          }, spObj);
          spObj._model = newModel;
        }
      },
      $dom: function $dom() {
        if (!this._$dom) {
          this._$dom = $(this.currentDom);
        }

        return this._$dom;
      },
      $content: function $content() {
        if ($.isBlank(this._$content)) {
          this._$content = $.tag({
            tagName: 'div',
            'class': 'loadingSpinnerContainer'
          });

          this._$content.append($.tag({
            tagName: 'div',
            'class': ['loadingSpinner', {
              value: 'minimal',
              onlyIf: this.settings.minimal
            }]
          }));

          this._$content.append($.tag({
            tagName: 'div',
            'class': 'loadingMessage'
          }));

          this._$content.append($.tag({
            tagName: 'div',
            'class': ['loadingCountdown', 'hide'],
            contents: ['Checking', {
              tagName: 'span',
              'class': 'secondsSection',
              contents: [' in ', {
                tagName: 'span',
                'class': 'seconds'
              }, ' seconds']
            }, '...']
          }));

          this.$dom().append(this._$content);

          if (this.settings.overlay) {
            var $o = $.tag({
              tagName: 'div',
              'class': 'loadingOverlay'
            });
            this.$dom().append($o);
            this._$content = this._$content.add($o);
          }
        }

        return this._$content;
      },
      setMetric: function setMetric(metric) {
        if (this.metric && !metric) {
          $.metrics.stopwatch('domain-intern', 'js-spinner-' + this.metric + '-time', 'clear');
        }

        this.metric = metric;
      },
      showHide: function showHide(doShow) {
        this.$content().toggleClass('hide', !doShow);

        if (!doShow) {
          this.$content().find('.loadingMessage, .loadingCountdown').addClass('hide');
          clearCountdown(this);
        }

        if (!$.isBlank(this.metric)) {
          var fullMetric = 'js-spinner-' + this.metric + '-time';
          var stopwatch = $.metrics.stopwatches['domain-intern/' + fullMetric];

          if (doShow) {
            $.metrics.stopwatch('domain-intern', fullMetric, 'start');
          } else if (stopwatch && stopwatch.started) {
            $.metrics.stopwatch('domain-intern', fullMetric, 'end');
          }
        }
      },
      setMessage: function setMessage(message, countdown) {
        var spObj = this;

        if (!$.isBlank(message)) {
          spObj.$content().find('.loadingMessage').removeClass('hide').html(message.plainTextToHtml());
        }

        if (!$.isBlank(countdown)) {
          var $sec = spObj.$content().find('.loadingCountdown').removeClass('hide').find('.secondsSection').removeClass('hide').find('.seconds').text(countdown);
          clearCountdown(spObj);
          spObj._countdownTimer = setInterval(function () {
            countdown--;
            $sec.text(countdown);

            if (countdown < 1) {
              clearCountdown(spObj);
              spObj.$content().find('.secondsSection').addClass('hide');
            }
          }, 1000);
        }
      }
    }
  });

  var clearCountdown = function clearCountdown(spObj) {
    if (!$.isBlank(spObj._countdownTimer)) {
      clearInterval(spObj._countdownTimer);
      delete spObj._countdownTimer;
    }
  };
})(jQuery);

/***/ }),

/***/ 2989:
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

blist.namespace.fetch('blist.util');
blist.namespace.fetch('blist.util.patterns'); // expose Sizzle globally

window.Sizzle = jQuery.find; // Prototype defs

String.prototype.startsWith = function (str) {
  //eslint-disable-line no-extend-native
  return this.indexOf(str) == 0;
};

String.prototype.endsWith = function (str) {
  //eslint-disable-line no-extend-native
  return this.length >= str.length && this.lastIndexOf(str) == this.length - str.length;
}; // Caution: common/js_utils/index.js also overrides String.prototype.format
// In pages where both the files are included, based on the order of loading
// <string>.format calls this one or the other one


String.prototype.format = function () {
  //eslint-disable-line no-extend-native
  var txt = this,
      i = arguments.length;

  while (i--) {
    txt = txt.replace(new RegExp('\\{' + i + '\\}', 'gm'), arguments[i]);
  }

  return txt;
};
/* Adapted from http://blog.mastykarz.nl/measuring-the-length-of-a-string-in-pixels-using-javascript/ */


String.prototype.visualSize = function (fontSize) {
  //eslint-disable-line no-extend-native
  var $ruler = $('#ruler');

  if ($ruler.length < 1) {
    $('body').append('<span class="ruler" id="ruler"></span>');
    $ruler = $('#ruler');
  }

  if (!fontSize) {
    fontSize = '';
  }

  $ruler.css('font-size', fontSize);
  $ruler.text(this + '');
  return {
    width: $ruler.width(),
    height: $ruler.height()
  };
};

String.prototype.visualHeight = function (fontSize) {
  //eslint-disable-line no-extend-native
  return this.visualSize(fontSize).height;
};

String.prototype.visualLength = function (fontSize) {
  //eslint-disable-line no-extend-native
  return this.visualSize(fontSize).width;
};

String.prototype.capitalize = function () {
  //eslint-disable-line no-extend-native
  return this.charAt(0).toUpperCase() + this.substring(1);
};

String.prototype.displayable = function () {
  //eslint-disable-line no-extend-native
  return $.map(this.replace(/(\S)([A-Z])/g, '$1 $2').replace(/_/g, ' ').split(' '), $.capitalize).join(' ');
};

String.prototype.trim = function () {
  //eslint-disable-line no-extend-native
  return this.replace(/^\s+/, '').replace(/\s+$/, '');
};

String.prototype.clean = function () {
  //eslint-disable-line no-extend-native
  // Sometimes strings have &nbsp;, so replace them all with normal spaces
  return this.replace(/\xa0/g, ' ');
};

String.prototype.camelize = function () {
  //eslint-disable-line no-extend-native
  return _.map(this.split(/[\W_]/), function (item) {
    return item.substring(0, 1).toUpperCase() + item.substring(1);
  }).join('');
};

String.prototype.plainTextToHtml = function () {
  //eslint-disable-line no-extend-native
  return ('<p>' + this.replace(/\n/g, '</p><p>') + '</p>').replace(/<p><\/p>/g, '<p>&nbsp;</p>');
};
/* from wikibooks: http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#JavaScript */


String.prototype.levenshtein = function (other) {
  //eslint-disable-line no-extend-native
  var l1 = this.length,
      l2 = other.length;

  if (Math.min(l1, l2) === 0) {
    return Math.max(l1, l2);
  }

  var i = 0,
      j = 0,
      d = [];

  for (i = 0; i <= l1; i++) {
    d[i] = [];
    d[i][0] = i;
  }

  for (j = 0; j <= l2; j++) {
    d[0][j] = j;
  }

  for (i = 1; i <= l1; i++) {
    for (j = 1; j <= l2; j++) {
      d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + (this.charAt(i - 1) === other.charAt(j - 1) ? 0 : 1));
    }
  }

  return d[l1][l2];
};

String.prototype.heuristicDistance = function (other) {
  //eslint-disable-line no-extend-native
  if ($.isBlank(other)) {
    return NaN;
  }

  return this.replace(/^[a-z0-9]/ig, '').toLowerCase().levenshtein(other.replace(/^[a-z0-9]/ig, '').toLowerCase());
};

Function.prototype.curry = function () {
  //eslint-disable-line no-extend-native
  var f = this;
  var appliedArgs = Array.prototype.slice.call(arguments);
  return function () {
    return f.apply(this, appliedArgs.concat(Array.prototype.slice.call(arguments)));
  };
};

String.prototype.linkify = function (extra) {
  //eslint-disable-line no-extend-native
  if ($.isBlank(this)) {
    return '';
  }

  if ($.isBlank(extra)) {
    extra = '';
  }

  var replacedText, replacePattern1, replacePattern2, replacePattern3; //URLs starting with http://, https://, or ftp://

  replacePattern1 = /(\b(https?|ftp):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/gim;
  replacedText = this.replace(replacePattern1, '<a href="$1" ' + extra + '>$1</a>'); //URLs starting with "www." (without // before it, or it'd re-link the ones done above).

  replacePattern2 = /(^|[^\/])(www\.[\S]+(\b|$))/gim;
  replacedText = replacedText.replace(replacePattern2, '$1<a href="http://$2" ' + extra + '>$2</a>'); //Change email addresses to mailto:: links.

  replacePattern3 = /(\w+@[a-zA-Z_]+?\.[a-zA-Z]{2,6})/gim;
  replacedText = replacedText.replace(replacePattern3, '<a href="mailto:$1">$1</a>');
  return replacedText;
}; // jQuery defs


(function ($) {
  $.hashHref = function (href) {
    // IE sticks the entire page URL on, so we can't just strip off the hash;
    // instead we need to index into it and take everything after
    return href.slice(href.indexOf('#') + 1);
  };

  $.urlParam = function (url, name, value) {
    var regex = new RegExp('([\\?#&]' + name + '=)([^&#]*)');

    if (value !== undefined && value !== null) {
      return url.replace(regex, '$1' + value);
    }

    var results = regex.exec(url);

    if (results) {
      return results[2] || 0;
    } else {
      return 0;
    }
  };

  $.hasParam = $.urlParam.curry(window.location.href);

  $.toParam = function (hash) {
    return _.map(hash, function (v, k) {
      return escape(k) + '=' + escape(v);
    }).join('&');
  };

  $.escapeQuotes = function (text) {
    if (typeof text !== 'string') {
      return text;
    }

    return $.htmlEscape(text).replace(/'/, '&apos;');
  };

  $.unescapeQuotes = function (text) {
    if (typeof text !== 'string') {
      return text;
    }

    return $.htmlUnescape(text).replace(/&apos;/g, "'").replace(/&#39;/g, "'").replace(/&#x27;/g, "'");
  };

  $.htmlEscape = function (text) {
    if (typeof text !== 'string') {
      return text;
    }

    return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
  };

  $.htmlUnescape = function (text) {
    if (typeof text !== 'string') {
      return text;
    }

    return text.replace(/&quot;/g, '"').replace(/&gt;/g, '>').replace(/&lt;/g, '<').replace(/&amp;/g, '&');
  };

  $.unescapeObject = function (obj) {
    if (obj === null || obj === undefined) {
      return obj;
    } else if (typeof obj == 'string') {
      return $.htmlUnescape(obj);
    } else if (_typeof(obj) == 'object') {
      var newObj = obj instanceof Array ? [] : {};
      $.each(obj, function (k, v) {
        newObj[k] = $.unescapeObject(v);
      });
      return newObj;
    } else {
      return obj;
    }
  };

  $.htmlStrip = function (text) {
    // NOTE: This regex is an imperfect filter:
    //
    //  <img src="foo" alt="2 > 1">
    //
    // I would like to replace this with DOMPurify, but its sanitize method will also
    // perform HTML escaping, which is not part of the current contract for this method.
    try {
      return text.replace(/<[^>]*>/g, '');
    } catch (ex) {
      return '';
    }
  };

  $.urlSafe = function (text) {
    var output = text.replace(/\s+/g, '-').replace(/[^a-zA-Z0-9_\-]/g, '-').replace(/\-+/g, '-');

    if (output.length < 1) {
      output = '-';
    }

    return output.slice(0, 50);
  };

  $.capitalize = function (text) {
    text += '';
    return text.charAt(0).toUpperCase() + text.substring(1);
  };

  $.live = function (selector, type, fn) {
    var $obj = $('body');
    $obj.context = document;
    $obj.on(type, selector, fn);
    return $obj;
  }; // TODO: not integrated with component locale stuffing


  $.t = function (key, data) {
    return $.tNull(key, data) || '(no translation available) - [key: ' + key + ']';
  };

  $.tNull = function (key, data) {
    if (blist.locale == 'nyan') {
      return 'nyan';
    }

    if (!$.subKeyDefined(blist.translations, key)) {
      return null;
    }

    var result = $.deepGetStringField(blist.translations, key);

    if ($.isPlainObject(result) && _.has(data, 'count')) {
      // Someday, we will have real pluralization rules.
      // Our Rails instance doesn't have these yet, though.
      if (data.count == 1) {
        result = result.one;
      } else {
        result = result.other;
      }

      if (!result) {
        return null;
      }
    }

    result = result.replace(/%{[^}]+}/g, function (dataKey) {
      return (data || {})[dataKey.slice(2, -1)] || '';
    });
    return key.endsWith('_html') ? result : $.htmlStrip(result);
  };

  $.rootPath = function () {
    return blist.locale == blist.defaultLocale ? '' : '/' + blist.locale;
  };

  $.path = function (path) {
    return $.rootPath() + (path || '');
  };

  $.localize = function (obj) {
    if (!$.isPlainObject(obj)) {
      return obj;
    }

    return $.subKeyDefined(obj, blist.locale) ? obj[blist.locale] : '';
  };
  /* Do a deep compact on any object.  For any array, run a normal compact on
   * the array; then deep compact all sub-values.  For an object, leave out blank
   * values; and deep compact all the non-blank ones */


  $.deepCompact = function (obj) {
    if (_.isArray(obj)) {
      return _.chain(obj).map(function (o) {
        return $.deepCompact(o);
      }).reject(function (o) {
        return $.isBlank(o);
      }).value();
    }

    if (!$.isPlainObject(obj)) {
      return obj;
    }

    var newObj = {};

    _.each(obj, function (v, k) {
      if (!$.isBlank(v)) {
        newObj[k] = $.deepCompact(v);
      }
    });

    return newObj;
  };
  /* Do a deep compare on two objects (if they are objects), or just compare
     directly if they are normal values.  For this case, null == undefined, but
     not 0, empty string or false.  Also, when comparing objects, both objects
     must have all the same keys, even if they are null.  If one object has a key
     with a null value and the other does not have the key, the objects are not
     equal. */


  $.compareValues = function (obj1, obj2) {
    // If directly equal, great
    if (obj1 === obj2) {
      return true;
    } // If obj1 is null/undef, then a quick check determines obj2


    if (obj1 === null || obj1 === undefined) {
      if (obj2 === null || obj2 === undefined) {
        return true;
      }

      return false;
    } // If obj1 exists, but obj2 doesn't, not equals


    if (obj2 === null || obj2 === undefined) {
      return false;
    } // If either is not an object, they aren't equal


    if (!(obj1 instanceof Object) || !(obj2 instanceof Object)) {
      return false;
    } // Now we have two real objects to check


    var compareKey = function compareKey(o1, o2, k) {
      if (!o1.hasOwnProperty(k) || !o2.hasOwnProperty(k)) {
        return false;
      }

      return $.compareValues(o1[k], o2[k]);
    };

    for (var v1 in obj1) {
      if (!compareKey(obj1, obj2, v1)) {
        return false;
      }
    }

    for (var v2 in obj2) {
      if (!compareKey(obj2, obj1, v2)) {
        return false;
      }
    }

    return true;
  };

  $.syncObjects = function (dest, src) {
    $.extend(dest, src);

    _.each(dest, function (v, k) {
      if (_.isUndefined(src[k])) {
        delete dest[k];
      }
    });
  };

  $.flattenChildren = function (array, key) {
    key = key || 'children';

    var recurse = function recurse(arrayInner) {
      return _.map(arrayInner, function (elem) {
        if (_.isUndefined(elem[key])) return elem;else return [elem, recurse(elem[key])];
      });
    };

    return _.flatten(recurse(array));
  };

  $.unwrapHtml = function (html) {
    return html.replace(/^\s*<[^<>]+>/i, '').replace(/<\/[^<>]+>\s*$/i, '');
  }; // Get a template DOM fragment, checking first in the JS appended templates,
  // then in the page-injected templates


  $.getTemplate = function (template) {
    var templateSelector = '.' + template;
    var $jsAppendedTemplates = $('#js-appended-templates').children();

    if ($jsAppendedTemplates.is(templateSelector)) {
      return $jsAppendedTemplates.filter(templateSelector);
    }

    return $($('#templates').html()).filter(templateSelector);
  };

  $.renderTemplate = function (template, data, directive, keepText) {
    var $template = $.getTemplate(template);

    if ($template.length < 1) {
      throw 'No template found: ' + template;
    }

    if (_.isUndefined(data)) {
      return keepText ? $template.html() : $template.clone().children();
    } else {
      // IE10 doesn't properly copy the checked state on radio buttons with jQuery clone
      // cloneNode handles it correctly, though
      var $templateCopy = $($template[0].cloneNode(true)); // pure needs a wrapping element

      $templateCopy.appendTo($('<div/>')); // I think this is the cause of the 'ep is null' error in pure; but can't
      // figure out why it would happen...

      if ($.isBlank($templateCopy[0].parentNode)) {
        throw 'templateCopy has no parent!';
      }

      var rendered = $templateCopy.render(data, directive);
      return keepText ? rendered.innerHTML : $(rendered).children();
    }
  };

  $.compileTemplate = function (template, directive) {
    var $templateCopy = $.getTemplate(template).clone();

    if ($templateCopy.length < 1) {
      throw 'No template found: ' + template;
    } // pure needs a wrapping element


    $templateCopy.appendTo($('<div/>'));
    var compiledDirective = $templateCopy.compile(directive);
    return function (data) {
      // strip off opening and closing tags of toplevel element
      // to match behavior of $.renderTemplate
      return $.unwrapHtml(compiledDirective(data));
    };
  };

  $.isBlank = function (obj) {
    return _.isUndefined(obj) || _.isNull(obj) || obj === '';
  };

  $.isPresent = function (obj) {
    return !$.isBlank(obj);
  };

  $.arrayify = function (obj) {
    return !_.isArray(obj) ? [obj] : obj;
  };

  $.objectify = function (obj, key) {
    if (!$.isPlainObject(obj)) {
      var newObj = {};
      newObj[key] = obj;
      return newObj;
    }

    return obj;
  };

  $.numericalSanitize = function (str) {
    return (str || '').replace(/[^0-9\.\+\-]/, '');
  };

  $.arrayToObjKeys = function (arr, v) {
    var obj = {};

    _.each($.makeArray(arr), function (k) {
      obj[k] = v;
    });

    return obj;
  }; // Used to insert items into an object that is acting like a sparse array


  $.addItemsToObject = function (obj, values, index) {
    values = $.makeArray(values);
    var numInserts = values.length; // Use a temporary object to hold new indices, so we don't overwrite old
    // as we iterate

    var tmp = {}; // Move each index up one

    _.each(obj, function (r, i) {
      i = parseInt(i);

      if (i >= index) {
        if (!$.isBlank(r.index)) {
          r.index = i + numInserts;
        }

        tmp[i + numInserts] = r;
        delete obj[i];
      }
    }); // Merge moved values into original


    $.extend(obj, tmp); // Add all the new values

    _.each(values, function (v, i) {
      i = parseInt(i);

      if (!$.isBlank(v.index)) {
        v.index = index + i;
      }

      obj[index + i] = v;
    });
  }; // Used to remove items from an object that is acting like a sparse array


  $.removeItemsFromObject = function (obj, index, numItems) {
    // Remove specified number of items
    for (var j = 0; j < numItems; j++) {
      delete obj[index + j];
    } // Use a temporary object to hold new indices, so we don't overwrite old
    // as we iterate


    var tmp = {}; // Move each item down one

    _.each(obj, function (r, i) {
      i = parseInt(i);

      if (i > index) {
        if (!$.isBlank(r.index)) {
          r.index = i - numItems;
        }

        tmp[i - numItems] = r;
        delete obj[i];
      }
    }); // Merge moved values into original


    $.extend(obj, tmp);
  };

  $.keyValueToObject = function (key, value) {
    var temp = {};
    temp[key] = value;
    return temp;
  }; // goes to a deep location in an object. pass in true
  // as the first arg to force creation of undefined
  // objects on the way to your destination.
  // From https://github.com/clint-tseng/kor.events/blob/master/kor.events.js#L217


  $.deepGet = function ()
  /* [create], obj, keys* */
  {
    var idx = 0;
    var create = false;

    if (arguments[0] === true) {
      idx++;
      create = true;
    }

    var obj = arguments[idx++];

    for (; idx < arguments.length; idx++) {
      var key = arguments[idx];

      if (_.isArray(obj)) {
        var m = key.match(/^\[(\w*)=?(\w*)\]$/);

        if (!$.isBlank(m)) {
          var arrayKey = m[1];
          var arrayVal = m[2];
          var checkVals = !$.isBlank(arrayKey) && !$.isBlank(arrayVal);
          var result;
          var remArgs = $.makeArray(arguments).slice(idx + 1);

          for (var i = 0; i < obj.length; i++) {
            var arrayItem = obj[i];

            if (checkVals && arrayItem[arrayKey] != arrayVal) {
              continue;
            }

            result = $.deepGet.apply($, _.compact([create ? true : null, arrayItem]).concat(remArgs));

            if (!create && !$.isBlank(result)) {
              break;
            }
          }

          return result;
        }
      }

      if (_.isString(obj)) {
        try {
          obj = JSON.parse(obj);
        } catch (e) {
          /* noop */
        }
      }

      if (obj[key] == null) // null or undefined
        if (!create) return undefined;else obj[key] = {};

      if (_.isFunction(obj[key])) {
        obj = obj[key].apply(obj);
      } else {
        obj = obj[key];
      }
    }

    return obj;
  };

  $.deepSet = function ()
  /* obj, value, keys* */
  {
    var obj = arguments[0];
    var value = arguments[1];

    for (var i = 2; i < arguments.length - 1; i++) {
      var key = arguments[i];
      if (_.isUndefined(obj[key])) obj[key] = {};
      obj = obj[key];
    }

    obj[_.last(arguments)] = value;
  };

  $.deepGetStringField = function (obj, field) {
    return $.deepGet.apply($, [obj].concat(field.split('.')));
  };

  $.deepPluck = function (obj, field) {
    return _.map(obj, function (x) {
      return $.deepGetStringField(x, field);
    });
  };

  $.subKeyDefined = function (obj, keystring) {
    if ($.isBlank(obj) || !_.isString(keystring)) {
      return false;
    }

    var objIter = obj;
    var keys = keystring.split('.');

    while (keys.length > 0) {
      objIter = objIter[keys[0]];

      if ($.isBlank(objIter)) {
        return false;
      }

      keys.shift();
    }

    return true;
  };

  $.isSubKeyEqual = function (obj1, obj2, keystring) {
    if ($.isBlank(obj1) || $.isBlank(obj2) || !_.isString(keystring)) {
      return _.isEqual(obj1, obj2);
    }

    var objIter1 = obj1,
        objIter2 = obj2;
    var keys = keystring.split('.');

    while (keys.length > 0) {
      objIter1 = objIter1[keys[0]];
      objIter2 = objIter2[keys[0]];

      if ($.isBlank(objIter1) || $.isBlank(objIter2)) {
        return _.isEqual(objIter1, objIter2);
      }

      keys.shift();
    }

    return _.isEqual(objIter1, objIter2);
  };

  $.safeId = function (id) {
    return id.replace(/(\.|\:)/g, '\\$1');
  };

  $.arrayToSentence = function (arr, joinWord, separator, alwaysUseSep) {
    return arr.length < 3 ? arr.join((alwaysUseSep ? separator : '') + ' ' + joinWord + ' ') : arr.slice(0, -1).join(separator + ' ') + separator + ' ' + joinWord + ' ' + arr[arr.length - 1];
  };

  $.wordify = function (num) {
    var t = function t(str) {
      return $.t('core.numbers.' + str);
    };

    var numWords = {
      '0': t('num_zero'),
      '1': t('num_one'),
      '2': t('num_two'),
      '3': t('three'),
      '4': t('four'),
      '5': t('five'),
      '6': t('six'),
      '7': t('seven'),
      '8': t('eight'),
      '9': t('nine')
    };
    return numWords[num.toString()] || num;
  };

  $.commaify = function (value) {
    value = value + '';
    var pos = value.indexOf('.');

    if (pos == -1) {
      pos = value.length;
    }

    pos -= 3;

    while (pos > 0 && value.charAt(pos - 1) >= '0' && value.charAt(pos - 1) <= '9') {
      value = value.substring(0, pos) + ',' + value.substring(pos);
      pos -= 3;
    }

    return value;
  };

  $.humanify = function (humaneDecimals, fixedDecimals, value) {
    var abs = Math.abs(value);
    return abs >= 1000 ? blist.util.toHumaneNumber(value, humaneDecimals) : abs - Math.floor(abs) > 0 ? value.toFixed(fixedDecimals) : value;
  }; // it's kind of dumb. if you need anything it doesn't do, just explicitly tell it.


  $.pluralize = function (number, word, pluralized) {
    if (_.isUndefined(pluralized)) {
      if (word.match(/[oiu]$/i)) pluralized = word + 'es';else if (word.match(/y$/i)) pluralized = word.substring(0, word.length - 1) + 'ies';else pluralized = word + 's';
    }

    return number + ' ' + (number === 1 ? word : pluralized);
  };

  $.addAppToken = function (url) {
    return url + (url.indexOf('?') == -1 ? '?' : '&') + 'app_token=' + blist.configuration.appToken;
  }; // force an integer to appear as a double through the json transport


  $.jsonIntToFloat = function (integer) {
    if (integer.toString().indexOf('.') < 0) {
      return parseFloat(integer.toString() + '.000001');
    }

    return integer;
  };

  $.clamp = function (number, bounds) {
    // use ternary for perf
    return number < bounds[0] ? bounds[0] : number > bounds[1] ? bounds[1] : number;
  }; // Underscore's _.union uses _.uniq, which uses === rather than _.isEqual.


  $.union = function () {
    return _.reduce(_.flatten(arguments), function (memo, item) {
      if (_.every(memo, function (val) {
        return !_.isEqual(item, val);
      })) {
        memo.push(item);
      }

      return memo;
    }, []);
  };

  $.fn.tagName = function () {
    return this.get(0).tagName.toLowerCase();
  }; // fast checker for input type


  $.fn.isInputType = function (inputType) {
    return this.tagName() == 'input' && this.attr('type') == inputType;
  }; // Calculate widths/heights without scrollbars to give actual renderable area
  // clientWidth to account for scrollbar, minus padding


  $.fn.renderWidth = function () {
    return this[0].clientWidth - (this.innerWidth() - this.width());
  };

  $.fn.renderHeight = function () {
    return this[0].clientHeight - (this.innerHeight() - this.height());
  };

  $.fn.lockScroll = function (lock) {
    if (lock === true) {
      this.on('mousewheel.lockScroll DOMMouseScroll.lockScroll', function (event) {
        var scrollTo = null;

        if (event.type == 'mousewheel') {
          scrollTo = event.originalEvent.wheelDelta * -0.5;
        } else if (event.type == 'DOMMouseScroll') {
          scrollTo = 20 * event.originalEvent.detail;
        }

        if (scrollTo) {
          $(this).scrollTop(scrollTo + $(this).scrollTop());
          event.preventDefault();
        }
      });
    } else {
      this.off('mousewheel.lockScroll DOMMouseScroll.lockScroll');
    }
  }; // hooray, fake green-threading!


  $.batchProcess = function (array, batchSize, eachItem, eachBatch, onComplete) {
    if (!_.isArray(array)) return;
    array = _.clone(array);
    var thisBatch = array.splice(0, batchSize);

    var batchResult = _.map(thisBatch, eachItem);

    if (_.isFunction(eachBatch)) eachBatch(batchResult);

    if (array.length === 0) {
      if (_.isFunction(onComplete)) onComplete();
    } else {
      // 10 ms is long enough a break so that the browser doesn't think we're hung
      setTimeout(function () {
        $.batchProcess(array, batchSize, eachItem, eachBatch, onComplete);
      }, 10);
    }
  };

  $.extract = function (obj, prop) {
    var result = {};

    _.each(obj, function (value, key) {
      result[key] = value[prop];
    });

    return result;
  };

  $.assertThrowOnFail = true;

  $.assert = function (condition, message) {
    if (!condition) {
      console.error('Assertion failed: ' + message);

      if ($.assertThrowOnFail) {
        throw message;
      }
    }
  };

  $.parseParams = function (query) {
    var re = /([^&=]+)=?([^&]*)/g;

    var decode = function decode(str) {
      return decodeURIComponent(str.replace(/\+/g, ' '));
    };

    var params = {},
        e;

    if (!query) {
      query = window.location.search;
    }

    if (query.substr(0, 1) == '?') {
      query = query.substr(1);
    }

    while (e = re.exec(query)) {
      //eslint-disable-line no-cond-assign
      var k = decode(e[1]);
      var v = decode(e[2]);

      if (params[k] !== undefined) {
        if (!$.isArray(params[k])) {
          params[k] = [params[k]];
        }

        params[k].push(v);
      } else {
        params[k] = v;
      }
    }

    return params;
  }; // gives you a faster jquery this on each iter


  jQuery.fn.quickEach = function () {
    var jq = jQuery([1]);
    return function (c) {
      var i = -1,
          el,
          len = this.length;

      try {
        while (++i < len && (el = jq[0] = this[i]) && c.call(jq, i, el) !== false) {
          ;
        }
      } catch (e) {
        delete jq[0];
        throw e;
      }

      delete jq[0];
      return this;
    };
  }();

  $.fn.hasChildren = function () {
    var elem = this.get(0);
    return elem != null && elem.firstChild != null;
  };

  $.fn.exists = function () {
    return this.length !== 0;
  }; // TODO Used only in d3.impl.pie.js - replace with _.constant()


  $.thunk = function (val) {
    return function () {
      return val;
    };
  };
  /**
   * Like jQuery.when, but will never exit early. Instead, failed promises will have the value null.
   *
   * @param {...Promise} - the promises to wait on. Once resolved, the parent promise will resolve.
   * @return {Promise} that resolves when all the given
   */


  $.whenever = function () {
    var args = Array.prototype.slice.call(arguments);
    args = _.map(args, function (promise) {
      var deferred = $.Deferred(); //eslint-disable-line new-cap

      promise.done(function () {
        deferred.resolveWith(null, arguments);
      }).fail(function () {
        deferred.resolve(null);
      });
      return deferred.promise();
    });
    return $.when.apply($, args);
  }; // @param ary - takes an array of functions.
  // Each function must return a promise.
  //
  // Each function will be executed sequentially, waiting for the
  // previous promise to resolve before firing.
  //


  $.serialPromiser = function (ary) {
    var result = $.Deferred(),
        //eslint-disable-line new-cap
    promises = _.filter($.makeArray(ary), _.isFunction);

    var promiseIterator = function promiseIterator(promiseFactory, args) {
      promiseFactory.apply(null, args).then(function () {
        if (promises.length > 0) {
          promiseIterator(promises.shift(), arguments);
        } else {
          result.resolveWith(null, arguments);
        }
      }).fail(function () {
        result.reject();
      });
    };

    promiseIterator(promises.shift());
    return result.promise();
  }; // Wrapper around inlineLogin.verifyUser; simply does nothing
  // if auth fails


  blist.util.doAuthedAction = function (actionText, callback) {
    if (!blist.currentUserId) {
      window.location = $.path('/login');
    } else {
      callback();
    }
  };

  blist.util.railsFlash = function (text, level) {
    var existingFlash = $.cookies.get('js_flash');
    var flashObj = existingFlash ? JSON.parse(existingFlash) : {};
    flashObj[level || 'notice'] = text;
    $.cookies.set('js_flash', JSON.stringify(flashObj));
  };

  blist.util.patterns.UID = /^\w{4}-\w{4}$/;
  blist.util.patterns.mobileBrowser = /iPhone|iPod|Android/i;
  blist.util.patterns.customUrl = /^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i;
  blist.util.patterns.customHttpMaybeSUrl = /^https?:\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i;
  blist.util.patterns.core = {
    emailValidator: /^[A-Z0-9._%+-]+@(?:[A-Z0-9-]+\.)+[A-Z]{2,4}$/i,
    urlValidator: /^(mailto\:|(news|(ht|f)tp(s?))\:\/\/)?[a-zA-Z0-9\-\.]+\.([a-zA-Z]{2,}|[0-9]+)(\:\d+)?(\/?\S*)?$/i
  };

  blist.util.isMobile = function () {
    return blist.util.patterns.mobileBrowser.test(navigator.userAgent);
  };

  blist.isMobile = blist.util.isMobile();

  blist.util.loadCaptcha = function (id) {
    window.onRecaptchaLoaded = function () {
      window.grecaptcha.render(id, {
        sitekey: blist.configuration.RECAPTCHA_2_SITE_KEY
      });
    };

    if ($('#' + id).hasClass('placeholder')) {
      blist.util.assetLoading.loadAssets({
        javascripts: ['https://www.google.com/recaptcha/api.js?onload=onRecaptchaLoaded&render=explicit']
      });
    }
  };
  /**
   * @function recursivePluck
   * @description
   * A recursive version of _.pluck.
   *
   * For example:
   * blist.util.recursivePluck({hello: 'world', key: {hello: 'world'}}, 'hello')
   * => ['world', 'world']
   *
   * IMPORTANT: This is not a function for dot-delimited string searches.
   *
   * @param {Array|Object} pluckee - The object to pull searchKey from.
   * @param {Number|String} searchKey - The key within pluckee to pull out.
   * @returns {Array} - All pluckable searchKeys from the pluckee.
   */


  blist.util.recursivePluck = function (pluckee, searchKey) {
    var pluckedArray = [];

    for (var key in pluckee) {
      if (_.isPlainObject(pluckee[key]) || _.isArray(pluckee[key])) {
        var plucked = blist.util.recursivePluck(pluckee[key], searchKey);

        if (_.isArray(plucked)) {
          pluckedArray = pluckedArray.concat(plucked);
        } else {
          pluckedArray.push(plucked);
        }
      }
    }

    if (!_.isUndefined(pluckee[searchKey])) {
      pluckedArray.push(pluckee[searchKey]);
    }

    return pluckedArray;
  }; // Because NYS dynamically inserts Underscore 1.6.0 into our page, it is capable
  // of overwriting an existing Lodash instance if it has already been loaded.
  // This function checks to see whether or not this occurred and forces it back to
  // using lodash.


  blist.util.enforceLodashFunctions = function () {
    if (window._ !== window.socrataLodash) {
      if (window.console && typeof window.console.info === 'function') {
        console.info("Lodash collision detected. Expected version: ".concat(window.socrataLodash.VERSION, ". Actual version: ").concat(window._.VERSION, "."));
      }

      window.collidedWithLodash = _.noConflict();
      window._ = window.socrataLodash; // We are not currently aware of any breakages that
      // this would fix. This is a safety measure in case
      // forcing us back to lodash causes problems for NYS'
      // code.
      //
      // Known NYS cnames:
      // 'health.data.ny.gov',
      // 'nys-staging.demo.socrata.com',
      // 'data.ny.gov',
      // 'nysdoh-staging.demo.socrata.com'

      if (/nys(doh)?-staging|data.ny.gov/.test(window.location.hostname)) {
        var functionsUsedByNYS = ['template', 'first', 'keys', 'each', 'extend', 'debounce', 'pluck', 'reject', 'findWhere'];
        functionsUsedByNYS.forEach(function (func) {
          window._[func] = window.collidedWithLodash[func];
        });
      }
    }
  };
})(jQuery);

/***/ }),

/***/ 2990:
/***/ (function(module, exports) {

(function () {
  blist.translations = {};

  if (!_.isUndefined(window.blistTranslations)) {
    _.each(window.blistTranslations, function (translation) {
      $.extend(true, blist.translations, translation());
    });
  }

  blist.locale = $('body').data('locale');
  blist.defaultLocale = $('body').data('defaultlocale');
})();

/***/ }),

/***/ 2991:
/***/ (function(module, exports) {

var blistUtilNS = blist.namespace.fetch('blist.util');

blistUtilNS.toHumaneNumber = function (val, precision) {
  var symbol = ['K', 'M', 'B', 'T'];
  var step = 1000;
  var divider = Math.pow(step, symbol.length);
  var absVal = Math.abs(val);
  var result;
  val = parseFloat(val);

  for (var i = symbol.length - 1; i >= 0; i--) {
    if (absVal >= divider) {
      result = (absVal / divider).toFixed(precision);

      if (val < 0) {
        result = -result;
      }

      return result + symbol[i];
    }

    divider = divider / step;
  }

  return val.toFixed(precision);
};

blistUtilNS.parseHumaneNumber = function (val) {
  var symbol = ['K', 'M', 'B', 'T'];
  var step = 1000;
  var adjVal;
  var i;

  if ($.isBlank(val)) {
    return val;
  }

  var lastChar = val.charAt(val.length - 1);
  lastChar = lastChar.valueOf().toUpperCase();

  for (i = symbol.length - 1; i >= 0; i--) {
    if (lastChar === symbol[i]) {
      adjVal = val.slice(0, val.length - 1);
      return parseFloat(adjVal) ? adjVal * Math.pow(step, i + 1) : val;
    }
  }

  return val;
};

/***/ }),

/***/ 2992:
/***/ (function(module, exports, __webpack_require__) {

/*
 * Javascript Humane Dates
 * Copyright (c) 2008 Dean Landolt (deanlandolt.com
 *
 *
 * Adopted from the John Resig's pretty.js
 * at http://ejohn.org/blog/javascript-pretty-date
 * and henrah's proposed modification
 * at http://ejohn.org/blog/javascript-pretty-date/#comment-297458
 *
 * Licensed under the MIT license.
 */
// Takes an ISO time and returns a string representing how
// long ago the date represents.

/*
 * (jeff.scherpelz@blist.com):
 *          * Moved into project namespace & reformatted code to match style
 *          * Separate calls for ISO date and Date object
 */
var moment = __webpack_require__(11);

moment.locale(blist.locale);
var humaneUtilNS = blist.namespace.fetch('blist.util.humaneDate');

_.each(['minute', 'hour', 'day', 'week', 'month', 'year'], function (duration) {
  blist.util.humaneDate[duration.toUpperCase()] = {
    duration: moment.duration(1, duration).as('milliseconds'),
    translation_key: 'current_' + duration + '_future'
  };
});

blist.util.humaneDate.getFromDate = function (dateObj, granularity) {
  var date = moment(dateObj);

  if (!date.isValid()) {
    return $.t('core.forms.none');
  } // Yes, I'm cheating.


  if (_.isUndefined(granularity)) {
    return date.fromNow();
  }

  var now = moment();
  var absDiff = Math.abs(date.diff(now));

  if (granularity.duration >= absDiff) {
    return $.t('core.date_time.' + granularity.translation_key);
  } else {
    return date.fromNow();
  }
};

blist.util.humaneDate.getFromISO = function (dateStr) {
  var time = ('' + dateStr).replace(/-/g, '/').replace(/[TZ]/g, ' ');
  return humaneUtilNS.getFromDate(new Date(time));
}; // If jQuery is included in the page, adds a jQuery plugin to handle it as well


if (typeof jQuery != 'undefined') {
  jQuery.fn.humane_dates = function () {
    return this.each(function () {
      var date = moment(this.title);

      if (date.isValid()) {
        jQuery(this).text(date.fromNow());
      }
    });
  };
}

/***/ }),

/***/ 2993:
/***/ (function(module, exports) {

(function ($) {
  blist.defaultColors = ['#003366', '#D95F02', '#1B9E77', '#e6ab02', '#7570b3']; // There are enough places in the legacy UI that have been subject to XSS
  // vulnerabilities that we need a helper method. Whitelisting on the backend
  // would be preferable but is unfortunately not yet a priority.
  // @param maybeHex string value that should be a hex color
  // @return a hex color string, or undefined

  $.sanitizeColor = function (maybeHex) {
    // This function is sometimes invoked in contexts where a color value is not
    // guaranteed to exist, so we return early.
    if (maybeHex === null || maybeHex === undefined) {
      return undefined;
    }

    if (typeof maybeHex !== 'string') {
      console.warn('Attempted to call sanitizeColor with non-string input');
      return undefined;
    }

    return (maybeHex.match(/(#[0-9a-f]{6})/i) || [])[1];
  }; // Colors and imagebuilder


  $.colorToObj = function (rgb) {
    if (rgb.startsWith('#') || rgb.match(/^[a-fA-F0-9]{3,6}$/)) {
      return $.hexToRgb(rgb);
    }

    var m = rgb.match(/rgb\((\d+),\s*(\d+),\s*(\d+)(,\s*\d+\.?\d+)?\)/);
    return {
      r: parseInt(m[1]),
      g: parseInt(m[2]),
      b: parseInt(m[3])
    };
  };

  $.hexToRgb = function (hex) {
    hex = hex.replace('#', '');

    if (hex.length < 6) {
      hex = hex.replace(/([0-9abcdef])/gi, '$1$1');
    }

    hex = parseInt(hex, 16);
    return {
      r: hex >> 16,
      g: (hex & 0x00FF00) >> 8,
      b: hex & 0x0000FF
    };
  };

  $.rgbToHex = function (rgb) {
    var hex = [rgb.r.toString(16), rgb.g.toString(16), rgb.b.toString(16)];
    $.each(hex, function (i) {
      if (hex[i].length == 1) {
        hex[i] = '0' + hex[i];
      }
    });
    return hex.join('');
  }; // Adapted from http://svn.dojotoolkit.org/src/dojox/trunk/color/_base.js


  $.hsvToRgb = function (hsv) {
    //  hue from 0-359 (degrees), saturation and value 0-100.
    var hue = hsv.h,
        saturation = hsv.s,
        value = hsv.v;

    if (hue == 360) {
      hue = 0;
    }

    saturation /= 100;
    value /= 100;
    var r, g, b;

    if (saturation == 0) {
      r = value, b = value, g = value;
    } else {
      var hTemp = hue / 60,
          i = Math.floor(hTemp),
          f = hTemp - i;
      var p = value * (1 - saturation);
      var q = value * (1 - saturation * f);
      var t = value * (1 - saturation * (1 - f));

      switch (i) {
        case 0:
          {
            r = value, g = t, b = p;
            break;
          }

        case 1:
          {
            r = q, g = value, b = p;
            break;
          }

        case 2:
          {
            r = p, g = value, b = t;
            break;
          }

        case 3:
          {
            r = p, g = q, b = value;
            break;
          }

        case 4:
          {
            r = t, g = p, b = value;
            break;
          }

        case 5:
          {
            r = value, g = p, b = q;
            break;
          }
      }
    }

    return {
      r: Math.round(r * 255),
      g: Math.round(g * 255),
      b: Math.round(b * 255)
    };
  }; // Adapted from http://svn.dojotoolkit.org/src/dojox/trunk/color/_base.js


  $.rgbToHsv = function (rgb) {
    var r = rgb.r / 255,
        g = rgb.g / 255,
        b = rgb.b / 255;
    var min = Math.min(r, b, g),
        max = Math.max(r, g, b);
    var delta = max - min;
    var h = null,
        s = max == 0 ? 0 : delta / max;

    if (s == 0) {
      h = 0;
    } else {
      if (r == max) {
        h = 60 * (g - b) / delta;
      } else if (g == max) {
        h = 120 + 60 * (b - r) / delta;
      } else {
        h = 240 + 60 * (r - g) / delta;
      }

      if (h < 0) {
        h += 360;
      }
    }

    return {
      h: h,
      s: Math.round(s * 100),
      v: Math.round(max * 100)
    };
  }; // Adapted from http://svn.dojotoolkit.org/src/dojox/trunk/color/_base.js


  $.hslToRgb = function (hsl) {
    var hue = hsl.h,
        saturation = hsl.s,
        luminosity = hsl.l;
    saturation /= 100;
    luminosity /= 100;

    while (hue < 0) {
      hue += 360;
    }

    while (hue >= 360) {
      hue -= 360;
    }

    var r, g, b;

    if (hue < 120) {
      r = (120 - hue) / 60, g = hue / 60, b = 0;
    } else if (hue < 240) {
      r = 0, g = (240 - hue) / 60, b = (hue - 120) / 60;
    } else {
      r = (hue - 240) / 60, g = 0, b = (360 - hue) / 60;
    }

    r = 2 * saturation * Math.min(r, 1) + (1 - saturation);
    g = 2 * saturation * Math.min(g, 1) + (1 - saturation);
    b = 2 * saturation * Math.min(b, 1) + (1 - saturation);

    if (luminosity < 0.5) {
      r *= luminosity, g *= luminosity, b *= luminosity;
    } else {
      r = (1 - luminosity) * r + 2 * luminosity - 1;
      g = (1 - luminosity) * g + 2 * luminosity - 1;
      b = (1 - luminosity) * b + 2 * luminosity - 1;
    }

    return {
      r: Math.round(r * 255),
      g: Math.round(g * 255),
      b: Math.round(b * 255)
    };
  }; // Adapted from http://svn.dojotoolkit.org/src/dojox/trunk/color/_base.js


  $.rgbToHsl = function (rgb) {
    var r = rgb.r / 255,
        g = rgb.g / 255,
        b = rgb.b / 255;
    var min = Math.min(r, b, g),
        max = Math.max(r, g, b);
    var delta = max - min;
    var h = 0,
        s = 0,
        l = (min + max) / 2;

    if (l > 0 && l < 1) {
      s = delta / (l < 0.5 ? 2 * l : 2 - 2 * l);
    }

    if (delta > 0) {
      if (max == r && max != g) {
        h += (g - b) / delta;
      }

      if (max == g && max != b) {
        h += 2 + (b - r) / delta;
      }

      if (max == b && max != r) {
        h += 4 + (r - g) / delta;
      }

      h *= 60;
    }

    return {
      h: h,
      s: Math.round(s * 100),
      l: Math.round(l * 100)
    }; //  Object
  };

  $.rgbTosRGB = function (rgb) {
    _.each(['r', 'g', 'b'], function (comp) {
      rgb[comp] = rgb[comp] <= 0.03928 ? rgb[comp] / 12.92 : Math.pow((rgb[comp] + 0.055) / 1.055, 2.4);
    });

    return rgb;
  };

  $.rotateHue = function (hsv, degrees) {
    var h = hsv.h + degrees;
    h += Math.ceil(-h / 360) * 360;
    hsv.h = h % 360;
    return hsv;
  };

  $.rotateRgb = function (rgb, degrees) {
    return $.hsvToRgb($.rotateHue($.rgbToHsv(rgb), degrees));
  };

  $.rotateHex = function (hex, degrees) {
    return '#' + $.rgbToHex($.rotateRgb($.hexToRgb(hex), degrees));
  }; // As defined in WCAG 2.0, §1.4.3, 1.4.6.
  // Level AA >= 4.5; Level AAA >= 7.


  $.colorContrast = function () {
    var colorsAsSRGB = _.map(_.map(arguments, $.hexToRgb), $.rgbTosRGB); // Relative luminscence: http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef


    var L = _.map(colorsAsSRGB, function (sRGB) {
      return 0.2126 * sRGB.r + 0.7152 * sRGB.g + 0.0722 * sRGB.b;
    });

    return Math.round((Math.max.apply(null, L) + 0.05) / (Math.min.apply(null, L) + 0.05) * 10) / 10;
  };

  $.addColors = function (a, b) {
    var rgbA = $.hexToRgb(a);
    var rgbB = $.hexToRgb(b);

    var addComponent = function addComponent(x, y) {
      return Math.min(x + y, 255);
    };

    return $.rgbToHex({
      r: addComponent(rgbA.r, rgbB.r),
      g: addComponent(rgbA.g, rgbB.g),
      b: addComponent(rgbA.b, rgbB.b)
    });
  };

  $.subtractColors = function (a, b) {
    var rgbA = $.hexToRgb(a);
    var rgbB = $.hexToRgb(b);

    var subtractComponent = function subtractComponent(x, y) {
      return Math.max(x - y, 0);
    };

    return $.rgbToHex({
      r: subtractComponent(rgbA.r, rgbB.r),
      g: subtractComponent(rgbA.g, rgbB.g),
      b: subtractComponent(rgbA.b, rgbB.b)
    });
  };

  $.gradientString = function (stops) {
    var results = [];

    for (var i = 0; i < stops.length; i++) {
      if (stops[i] instanceof Array) {
        stops[i][0] = stops[i][0].replace(/#/, '');
        results.push(stops[i].join(':'));
      } else {
        stops[i] = stops[i].replace(/#/, '');
        results.push(stops[i]);
      }
    }

    return results.join(',');
  };

  $.urlToImageBuilder = function (options, format, css) {
    var result = '/ui/box.' + (format === undefined ? 'png' : format) + '?';
    var properties = [];

    for (var property in options) {
      properties.push(property + '=' + options[property]);
    }

    result += properties.join('&');
    return css === true ? 'url(' + result + ')' : result;
  };

  $.gradient = function (stops, colors, options) {
    options = options || {
      maxValue: 100
    };

    if (!_.isArray(colors)) {
      colors = [colors];
    }

    colors = _.map(colors, function (color) {
      if (!color.r) {
        color = $.hexToRgb(color);
      }

      return $.rgbToHsv(color);
    });
    var toColor = colors[0]; // Anchor on black if it's a high value color
    // Anchor on white if it's a high saturation color

    var lowColor = colors.length > 1 ? colors[1] : {
      h: toColor.h,
      s: toColor.s > 50 ? 0 : 100,
      v: toColor.v > 50 ? 0 : options.maxValue
    };
    var colorStep = {
      h: (toColor.h - lowColor.h) / (stops - 1),
      s: (toColor.s - lowColor.s) / (stops - 1),
      v: (toColor.v - lowColor.v) / (stops - 1)
    };
    var colorList = [];

    for (var i = 0; i < stops; i++) {
      colorList[i] = $.hsvToRgb({
        h: toColor.h - i * colorStep.h,
        s: toColor.s - i * colorStep.s,
        v: toColor.v - i * colorStep.v
      });
    }

    return colorList.reverse();
  };

  $.complementaryGradient = function (stops, color) {
    var hsv = $.rgbToHsv($.hexToRgb(color));
    var complementHue = hsv.h * 2 + 137;
    complementHue = complementHue < 360 ? complementHue : Math.floor(hsv.h / 2) - 137;
    var lowStops = stops % 2 == 0 ? stops / 2 + 1 : Math.ceil(stops / 2);
    var highStops = stops - lowStops + 1;
    var gradient = $.gradient(lowStops, $.hsvToRgb($.extend({}, hsv, {
      h: complementHue
    }))).reverse();
    gradient.pop();
    return gradient.concat($.gradient(highStops, color));
  }; // FIXME: 'brighten' is so utterly wrong...
  // This is a replacement for Highcharts' brighten function.
  // amount is defined as steps along a 100 point scale.


  $.brighten = function (color, amount) {
    if (!amount) {
      amount = 10;
    }

    if (!color.r) {
      color = $.hexToRgb(color);
    }

    color = $.rgbToHsv(color);
    color.v += amount;

    if (color.v > 100) {
      color.v = 100;
    }

    return $.hsvToRgb(color);
  };
})(jQuery);

/***/ }),

/***/ 2994:
/***/ (function(module, exports) {

blist.namespace.fetch('blist.events');
blist.events.MODAL_SHOWN = 'modalshown';
blist.events.MODAL_HIDDEN = 'modalhidden';
blist.events.DISPLAY_ROW = 'displayrow';

/***/ }),

/***/ 2995:
/***/ (function(module, exports) {

(function () {
  window.Page = ServerModel.extend({
    _init: function _init(v) {
      this._super();

      $.extend(this, v);
    },
    update: function update(newItems) {
      if ($.subKeyDefined(newItems, 'path') && newItems.path != this.path) {
        this._pathDirty = true;
        this._oldPath = this.path;
      }

      $.extend(this, newItems);
    },
    save: function save(successCallback, errorCallback) {
      var page = this;
      var type = 'PUT';

      var finalSuccess = function finalSuccess(resp) {
        var flags = {};

        if (page._pathDirty) {
          flags.oldPath = page._oldPath;
        }

        page.update(resp);
        page._pathDirty = false;
        delete page._oldPath;

        if (_.isFunction(successCallback)) {
          successCallback(page, flags);
        }
      };

      var realSave = function realSave() {
        page.makeRequest({
          type: type,
          success: function success(resp) {
            finalSuccess(resp);
          },
          error: errorCallback
        });
      };

      if (page._pathDirty) {
        // Check if overwrite
        Page.checkUnique(page.path, realSave, function () {
          if (_.isFunction(errorCallback)) {
            errorCallback({
              duplicatePath: true
            });
          }
        });
      } else {
        realSave();
      }
    },
    saveCopy: function saveCopy(newProps, successCallback, errorCallback) {
      var newPage = $.extend(this.cleanCopy(), newProps);

      _.each(['uid', 'version', 'createdAt', 'updatedAt'], function (p) {
        delete newPage[p];
      });

      this.makeRequest({
        type: 'POST',
        data: JSON.stringify(newPage),
        success: function success(resp) {
          if (_.isFunction(successCallback)) {
            successCallback(new Page(resp));
          }
        },
        error: errorCallback
      });
    },
    makeRequest: function makeRequest(req) {
      if ($.isBlank(req.url)) {
        if (req.type == 'POST') {
          req.url = '/api/pages.json';
        } else if (req.type == 'PUT') {
          req.url = '/api/pages/' + this.uid + '.json';
        }

        req.data = req.data || JSON.stringify(this.cleanCopy());
      }

      this._super(req);
    },
    _validKeys: {
      uid: true,
      path: true,
      name: true,
      format: true,
      privateData: true,
      status: true,
      category: true,
      grouping: true,
      version: true,
      permission: true,
      content: true,
      data: true,
      metadata: true,
      cacheInfo: true
    }
  });

  Page.createFromId = function (newId, successCallback, errorCallback) {
    $.Tache.Get({
      //eslint-disable-line new-cap
      url: '/api/pages/' + newId + '.json',
      success: function success(page) {
        if (_.isArray(page)) {
          page = _.first(page);
        }

        if (_.isFunction(successCallback)) {
          successCallback(new Page(page));
        }
      },
      error: errorCallback
    });
  };

  Page.deleteById = function (newId, successCallback, errorCallback) {
    if (!$.isBlank(newId)) {
      $.socrataServer.makeRequest({
        type: 'DELETE',
        url: '/api/pages/' + newId + '.json',
        error: errorCallback,
        success: successCallback
      });
    } else {
      successCallback();
    }
  };

  Page.checkUnique = function (path, successCallback, errorCallback) {
    $.socrataServer.makeRequest({
      type: 'GET',
      cache: false,
      url: '/api/pages.json?method=isPathAvailable',
      params: {
        path: path
      },
      success: function success(resp) {
        if (resp) {
          successCallback();
        } else {
          errorCallback();
        }
      }
    });
  };

  Page.uniquePath = function (title, prefix, successCallback) {
    if ($.isBlank(title)) {
      title = 'unnamed';
    }

    if ($.isBlank(prefix)) {
      prefix = '/';
    }

    if (!prefix.startsWith('/')) {
      prefix = '/' + prefix;
    }

    var p = prefix + $.urlSafe(title);
    var check = p;
    var i = 1;

    var doCheck = function doCheck() {
      Page.checkUnique(check, function () {
        successCallback(check);
      }, function () {
        check = p + '-' + i;
        i++;
        doCheck();
      });
    };

    doCheck();
  };
})();

/***/ }),

/***/ 2996:
/***/ (function(module, exports) {

// Set caret position easily in jQuery
// Written by and Copyright of Luke Morton, 2011
// Licensed under MIT
(function ($) {
  // Behind the scenes method deals with browser
  // idiosyncrasies and such
  $.caretTo = function (el, index) {
    if (el.createTextRange) {
      var range = el.createTextRange();
      range.move('character', index);
      range.select();
    } else if (el.selectionStart != null) {
      el.focus();
      el.setSelectionRange(index, index);
    }
  }; // The following methods are queued under fx for more
  // flexibility when combining with $.fn.delay() and
  // jQuery effects.
  // Set caret to a particular index


  $.fn.caretTo = function (index, offset) {
    return this.queue(function (next) {
      if (isNaN(index)) {
        var i = $(this).val().indexOf(index);

        if (offset === true) {
          i += index.length;
        } else if (offset) {
          i += offset;
        }

        $.caretTo(this, i);
      } else {
        $.caretTo(this, index);
      }

      next();
    });
  }; // Set caret to beginning of an element


  $.fn.caretToStart = function () {
    return this.caretTo(0);
  }; // Set caret to the end of an element


  $.fn.caretToEnd = function () {
    return this.queue(function (next) {
      $.caretTo(this, $(this).val().length);
      next();
    });
  };
})(jQuery);

/***/ }),

/***/ 2997:
/***/ (function(module, exports) {

(function ($) {
  /* Call this to generate an html tag.
     Takes a second optional argument; set it to true to get
     a string response rather than a jQuery obj.
      Special keys are:
       tagName: name of the tag
       style: takes a key/value hash
       contents: specified, textual, or html content of the tag
      Examples:
       $.tag({ tagName: 'div',
               class: [ 'item',
                        { value: 'selected', onlyIf: $this.isSelected() } ],
               id: 'item' + _.getUid(),
               contents: [
                   { tagName: 'span',
                     contents: 'Hello there, ' },
                   person.getFirstName()
               ]
       });
        $.tag({ tagName: 'input',
               type: 'text',
               class: 'required',
               disabled: form.isDisabled(),
               value: { value: 'Hello there', onlyIf: someCondition() },
               style: { border: '1px solid red',
                        display: { value: 'none', onlyIf: form.hasClass('something') } }
       });
  */
  $.tag = function (attrs, keepAsString) {
    // First check for any blanks/failed conditionals
    attrs = tagParseConditionalElement(attrs);

    if (attrs === false) {
      return null;
    } // deal with toplevel array case


    if (_.isArray(attrs)) {
      var markup = _.map(attrs, function (tag) {
        return $.tag(tag, true);
      }).join('');

      return keepAsString === true ? markup : $(markup);
    } // deal with toplevel string case


    if (_.isString(attrs)) {
      return attrs;
    } // normal case


    var result = '<' + attrs.tagName.toLowerCase();

    _.each(attrs, function (value, key) {
      // _.include is more concise but slower
      var k = key.toLowerCase();
      var newValue;

      if (key == 'tagName' || key == 'contents') {
        return;
      } else if (value === true && (k == 'checked' || k == 'selected' || k == 'disabled' || k == 'readonly' || k == 'multiple' || k == 'ismap' || k == 'defer' || k == 'declare' || k == 'noresize' || k == 'nowrap' || k == 'noshade' || k == 'compact')) {
        result += tagAppend(key, key);
      } else if (value === false) {
        return;
      } else if (key == 'style') {
        newValue = [];

        _.each(value, function (v, valueKey) {
          var parsed = tagParseConditionalElement(v);

          if (parsed !== false) {
            newValue.push(valueKey + ':' + parsed);
          }
        });

        result += tagAppend(key, newValue.join(';'));
      } else if (key == 'data') {
        _.each(value, function (v, valueKey) {
          result += tagAppend('data-' + valueKey, v);
        });
      } else if (_.isArray(value)) {
        newValue = [];

        _.each(value, function (elem) {
          var parsed = tagParseConditionalElement(elem);

          if (parsed !== false) {
            newValue.push(parsed);
          }
        });

        result += tagAppend(key, newValue.join(' '));
      } else {
        if (_.isString(value)) {
          result += tagAppend(key, value);
        } else {
          var parsedElem = tagParseConditionalElement(value);

          if (parsedElem !== false) {
            result += tagAppend(key, parsedElem);
          }
        }
      }
    });

    if (attrs.tagName == 'input' || attrs.tagName == 'img' || attrs.tagName == 'link' || attrs.tagName == 'meta') {
      result += '/>';
    } else if (!$.isBlank(attrs.contents)) {
      result += '>';
      result += tagRenderChildren(attrs.contents);
      result += '</' + attrs.tagName + '>';
    } else {
      result += '></' + attrs.tagName + '>';
    }

    if (keepAsString === true) {
      return result;
    } else {
      return $(result);
    }
  };

  var tagAppend = function tagAppend(key, value) {
    return ' ' + key + '="' + value + '"';
  };

  var tagParseConditionalElement = function tagParseConditionalElement(elem) {
    if ($.isBlank(elem)) {
      return false;
    } else if ($.isBlank(elem.tagName) && (!_.isUndefined(elem.value) || !$.isBlank(elem.onlyIf))) {
      if (elem.onlyIf === true) {
        return elem.value;
      } else {
        return false;
      }
    } else {
      return elem;
    }
  };

  var tagRenderChildren = function tagRenderChildren(children) {
    children = $.makeArray(children); // for each child, $.tag recurse if necessary, then "compact"
    // and join the resultant array. Don't use _.compact since that
    // strips 0.

    return _.reject(_.map(children, function (child) {
      if ($.isPlainObject(child)) {
        child = $.tag(child, true);
      }

      if (_.isArray(child)) {
        child = tagRenderChildren(child);
      }

      return child;
    }), function (child) {
      return $.isBlank(child);
    }). // Don't join with a space, because FF will add extra
    // un-controllable padding
    join('');
  };

  $.button = function (opts, keepAsText) {
    if (_.isString(opts)) {
      opts = {
        text: opts,
        href: '#' + $.urlSafe(opts)
      };
    }

    return $.tag($.extend(opts.customAttrs, {
      tagName: 'a',
      href: opts.href || '#',
      'class': _.flatten(['button', opts.className, opts.iconClass]),
      contents: [{
        value: {
          tagName: 'span',
          'class': 'icon'
        },
        onlyIf: !$.isBlank(opts.iconClass)
      }, opts.text]
    }), keepAsText);
  };
})(jQuery);

/***/ }),

/***/ 2998:
/***/ (function(module, exports) {

$(function () {
  var getModal = function getModal(selector) {
    var $modal = $('#modals ' + selector);

    if ($modal.length === 0) {
      // didn't find a modal; grab it out of templates and initialize it.
      $modal = $($('#templates').contents().text()).filter(selector);
      $modal.appendTo('#modals');
      $modal.jqm({
        trigger: false
      });
    }

    return $modal;
  };

  window.alert = function (msg) {
    getModal('#jqmAlert').jqmShow().find('.alertMessage').text(msg);
  };

  window.prettyConfirm = function (msg, yes, no) {
    getModal('#jqmConfirm').jqmShow().find('.confirmMessage').text(msg).end().find('.button.yes').click(yes).end().find('.button.no').click(no).end();
  };
});

/***/ }),

/***/ 2999:
/***/ (function(module, exports) {

jQuery.analytics = {
  trackEvent: function trackEvent(category, action, label, value) {
    // validate params
    if (category === undefined || action === undefined) return false; // bail if we didn't load GA

    if (window._gaq === undefined) return false;

    window._gaq.push(['_trackEvent', category, action, label, value]);
  }
};

/***/ }),

/***/ 3000:
/***/ (function(module, exports) {

(function () {
  window.User = ServerModel.extend({
    _init: function _init(v) {
      this._super();

      $.extend(this, v);
    },
    isCurrentUser: function isCurrentUser() {
      return this.id == blist.currentUserId;
    },
    isMember: function isMember() {
      var superAdmin = _.includes(this.flags, 'admin');

      var roledUser = 'roleName' in this;
      return superAdmin || roledUser;
    },
    nameAndOrEmail: function nameAndOrEmail() {
      var base = '';

      if (this.displayName) {
        base = this.displayName;
      }

      if (this.email) {
        if (base == '') {
          base = this.email;
        } else {
          base += ' (' + this.email + ')';
        }
      }

      return base;
    },
    hasRight: function hasRight(right) {
      return _.includes(this.rights, right);
    },
    getDatasets: function getDatasets(callback) {
      var user = this;

      if ($.isBlank(user._datasets)) {
        user.makeRequest({
          url: '/users/' + user.id + '/views.json',
          type: 'GET',
          cache: false,
          pageCache: true,
          success: function success(dss) {
            user._datasets = _.map(dss, function (d) {
              return createDatasetFromView(d);
            });
            callback(user._datasets);
          }
        });
      } else {
        callback(user._datasets);
      }
    },
    addEmailInterest: function addEmailInterest(tag, info, callback) {
      var user = this;
      user.makeRequest({
        url: '/users/' + user.id + '/email_interests.json',
        data: JSON.stringify({
          eventTag: tag.toUpperCase(),
          extraInfo: info
        }),
        type: 'POST',
        success: callback
      });
    },
    getEmailInterest: function getEmailInterest(tag, info, callback) {
      var user = this;
      user.makeRequest({
        url: '/users/' + user.id + '/email_interests/' + tag.toUpperCase(),
        params: {
          extraInfo: info
        },
        type: 'GET',
        cache: false,
        pageCache: true,
        complete: callback // api does not return a valid json string
        // which results in a parsing error not allowing
        // the function to finish successfully.
        // complete will succeed on failures.

      });
    },
    removeEmailInterest: function removeEmailInterest(tag, info, callback) {
      var user = this;
      user.makeRequest({
        url: '/users/' + user.id + '/email_interests/' + tag.toUpperCase(),
        params: {
          extraInfo: info
        },
        type: 'DELETE',
        pageCache: false,
        success: callback
      });
    },
    getProfileImageUrl: function getProfileImageUrl(size) {
      var user = this;
      size = size.toLowerCase();
      return user['profileImageUrl' + size.capitalize()] || '/images/' + size + '-profile.png';
    },
    getProfileUrl: function getProfileUrl() {
      var user = this;
      return $.path('/profile/' + $.urlSafe(user.displayName || '-') + '/' + user.id);
    }
  });

  User.createFromUserId = function (id, successCallback, errorCallback) {
    $.Tache.Get({
      //eslint-disable-line new-cap
      url: '/api/users/' + id + '.json',
      success: function success(user) {
        if (_.isFunction(successCallback)) {
          successCallback(new User(user));
        }
      },
      error: errorCallback
    });
  };
})();

/***/ }),

/***/ 3001:
/***/ (function(module, exports) {

(function () {
  var Configuration = ServerModel.extend({
    _init: function _init(c) {
      this._super();

      $.extend(this, c);

      this._translateProperties();
    },
    _translateProperties: function _translateProperties() {
      var conf = this;

      if ($.isBlank(conf.rawProperties) && !$.isBlank(conf.properties)) {
        conf.rawProperties = conf.properties;
        conf.properties = {};

        _.each(conf.rawProperties, function (prop) {
          $.deepSet.apply($, [conf.properties, prop.value].concat(prop.name.split('.')));
        });
      }
    },
    // TODO: make updating work by translating rawProperties back to properties
    _validKeys: {
      'default': true,
      domainCName: true,
      id: true,
      name: true,
      properties: true,
      type: true
    }
  });

  Configuration.findByType = function (type, options, successCallback, errorCallback) {
    var params = $.extend({
      merge: true
    }, options, {
      type: type
    });
    $.socrataServer.makeRequest({
      pageCache: true,
      url: '/admin/configuration.json',
      params: params,
      success: function success(result) {
        if (_.isFunction(successCallback)) {
          successCallback(new Configuration(result));
        }
      },
      error: errorCallback
    });
  };

  if (blist.inBrowser) {
    window.Configuration = Configuration;
  } else {
    module.exports = Configuration;
  }
})();

/***/ }),

/***/ 3002:
/***/ (function(module, exports, __webpack_require__) {

var _require = __webpack_require__(21),
    FeatureFlags = _require.FeatureFlags;

(function () {
  var ColumnContainer = function ColumnContainer(colName, selfUrl, urlBase) {
    var _columnIDLookup = {};
    var _columnTCIDLookup = {};
    var _columnFieldNameLookup = {};
    var _metaColumnLookup = {};
    var capName = colName.capitalize();
    var colSet = colName + 's';
    var capSet = colSet.capitalize();
    var oldCapSet = 'old' + capSet; // Convenience methods

    var forID = function forID(item, id) {
      return item[colName + 'ForID'](id);
    };

    var forTCID = function forTCID(item, id) {
      return item[colName + 'ForTCID'](id);
    };

    var forField = function forField(item, id) {
      return item[colName + 'ForFieldName'](id);
    };

    var forIdentifier = function forIdentifier(item, id) {
      return item[colName + 'ForIdentifier'](id);
    };

    var update = function update(item, nc, ff, uo) {
      return item['update' + capSet](nc, ff, uo);
    };

    var realSet = function realSet(item) {
      return item['real' + capSet];
    };

    var visibleSet = function visibleSet(item) {
      return item['visible' + capSet];
    };

    var findOldColumnFromSet = function findOldColumnFromSet(columnSet, newColumn) {
      var oldColumn; // Hack to guess at the matching column
      // If the fieldName doesn't match, we have no way of reliably determining the
      // analogous OBE column. We use `name` and `description` as fingers-crossed
      // guesstimations that rely on the user neglecting to change them when changing
      // the fieldName.
      //
      // Another proposed solution has been to compare row-sets as signatures, but
      // this would require at least two trips to the server and is also not guaranteed
      // to be 100% certain.

      _.some(['fieldName', 'name', 'description'], function (propertyTesting) {
        oldColumn = _.find(columnSet, function (oc) {
          return oc[propertyTesting] === newColumn[propertyTesting];
        });
        return !!oldColumn; // Break if we've found something.
      });

      return oldColumn;
    };

    var props = {}; // defines: columnForID, childColumnForID

    props[colName + 'ForID'] = function (id) {
      return _columnIDLookup[parseInt(id) || id];
    }; // defines: columnForTCID, childColumnForTCID


    props[colName + 'ForTCID'] = function (tcId) {
      return _columnTCIDLookup[parseInt(tcId)];
    }; // defines: columnForFieldName, childColumnForFieldName


    props[colName + 'ForFieldName'] = function (fName) {
      return _columnFieldNameLookup[fName.toString()];
    }; // defines: columnForIdentifier, childColumnForIdentifier


    props[colName + 'ForIdentifier'] = function (ident) {
      if ($.isBlank(ident)) {
        return null;
      }

      return _.isNumber(ident) || (ident || '').match(/^\d+$/) ? forID(this, ident) || forTCID(this, ident) : forField(this, ident) || forID(this, ident);
    }; // defines: metaColumnForName, metaChildColumnForName


    props['meta' + capName + 'ForName'] = function (name) {
      return _metaColumnLookup[name.toString()];
    }; // defines: clearColumn, clearChildColumn
    // Removes a column from the model without doing anything on the server;
    // use removeColumns or Column.remove for that


    props['clear' + capName] = function (col) {
      if (!$.isBlank(this._super)) {
        this._super(col);
      }

      this[colSet] = _.without(this[colSet], col);
      delete _columnIDLookup[col.id];
      delete _columnIDLookup[col.lookup];
      delete _columnTCIDLookup[col.tableColumnId];
      delete _columnFieldNameLookup[col.fieldName];

      if (FeatureFlags.value('prohibit_use_of_row_set')) {// noop
      } else {
        if (this.newBackend) {
          // Look through each row and delete the column data.
          _.each(this.loadedRows(), function (row) {
            delete row.data[col.lookup];
          });
        }
      }

      if (col.isMeta) {
        delete _metaColumnLookup[col.name];
      }

      update(this);
    }; // defines: columnsForType, childColumnsForType


    props[colSet + 'ForType'] = function (type, includeHidden) {
      var cols = includeHidden ? realSet(this) : visibleSet(this);

      if (!$.isBlank(type)) {
        cols = _.filter(cols, function (c) {
          return _.includes($.makeArray(type), c.renderTypeName);
        });
      }

      return cols;
    }; // defines: addColumn, addChildColumn


    props['add' + capName] = function (column, successCallback, errorCallback, customParams) {
      if (!$.isBlank(this._super) && this._super(arguments)) {
        return true;
      } // true means abort


      var cont = this;

      var columnAdded = function columnAdded(newCol) {
        cont[colSet].push(newCol);
        update(cont);
        cont.trigger('columns_changed', ['added']);

        if (_.isFunction(successCallback)) {
          successCallback(forID(cont, newCol.id));
        }
      };

      var req = {
        url: urlBase + '.json',
        type: 'POST',
        success: columnAdded,
        error: errorCallback
      };

      if (!$.isBlank(column)) {
        var cleanColumn = new Column(column, cont).cleanCopy(); // EN-14748 - Update Grid View to Allow Geocoding NBE Point Columns
        //
        // Of course, <Column>.cleanCopy() has no notion of computation
        // strategies and rather than trying to teach it about them for this one
        // specific case it is probably easier just to modify the clean copy
        // if we know that we should (e.g. when it is a new point column on a
        // NBE dataset and there was a computationStrategy on the original
        // column metadata passed to this method).

        if (Column.isNbePointColumn(blist.dataset, column) && _.has(column, 'computationStrategy')) {
          cleanColumn.computationStrategy = column.computationStrategy;
        }

        req.data = JSON.stringify(cleanColumn);
      }

      if (!$.isBlank(customParams)) {
        req.params = customParams;
      }

      this.makeRequest(req);
    }; // defines: removeColumns, removeChildColumns


    props['remove' + capSet] = function (columnIds, successCallback, errorCallback) {
      var cont = this;

      _.each($.makeArray(columnIds), function (cId) {
        var c = forID(cont, cId);
        c.remove(null, errorCallback, true);
      });

      var columnsRemoved = function columnsRemoved() {
        update(cont);

        if (_.isFunction(successCallback)) {
          successCallback();
        }
      };

      ServerModel.sendBatch(columnsRemoved);
    }; // defines: setVisibleColumns, setVisibleChildColumns


    props['setVisible' + capSet] = function (visColIds, callback, skipRequest) {
      var cont = this;

      if (_.isEqual(visColIds, _.map(visibleSet(cont), 'id'))) {
        if (_.isFunction(callback)) {
          callback();
        }

        return;
      } // If we need a validation/pre-processing on the columns, do it here


      if (!$.isBlank(cont['_adjustVisible' + capSet])) {
        visColIds = cont['_adjustVisible' + capSet](visColIds);
      } // First figure out if we need to update positions.  If the newly-visible
      // columns are in the same order as their existing position says, then
      // we just need to hide/show each column


      var prevPos = -1;

      var needsReorder = _.some(visColIds, function (colId) {
        var col = forID(cont, colId);

        if (col.position <= prevPos) {
          return true;
        }

        prevPos = col.position;
        return false;
      });

      var didHideShow = false;
      var vizCols = [];

      _.each(visColIds, function (colId, i) {
        var col = forID(cont, colId);

        if (!$.isBlank(col)) {
          didHideShow = col.show(null, null, true) || didHideShow;

          if (needsReorder) {
            col.update({
              position: i + 1
            });
          }

          var cc = col.cleanCopy();

          if (!$.isBlank(cc.childColumns)) {
            cc.childColumns = _.reject(cc.childColumns, function (ccc) {
              return _.includes(ccc.flags || [], 'hidden');
            });
          }

          vizCols.push(cc);
        }
      });

      _.each(realSet(cont), function (c) {
        if ($.isBlank(_.find(vizCols, function (vc) {
          return vc.id == c.id;
        }))) {
          didHideShow = c.hide(null, null, true) || didHideShow;
        }
      });

      update(cont, vizCols, false, needsReorder);

      var columnsChanged = function columnsChanged() {
        if (!needsReorder && didHideShow) {
          _.defer(function () {
            (cont.view || cont).trigger('columns_changed', ['visibility']);
          });
        }
      };

      if ((cont.view || cont).canUpdate() && !skipRequest) {
        if (needsReorder) {
          var item = {};
          item[colSet] = vizCols;
          this.makeRequest({
            url: selfUrl,
            type: 'PUT',
            data: JSON.stringify(item),
            batch: true
          });
        }

        ServerModel.sendBatch(function () {
          if (_.isFunction(callback)) {
            callback();
          }

          columnsChanged();
        });
      } else {
        (cont.view || cont)._markTemporary((cont.view || cont).isUnpublished() || (cont.view || cont).newBackend);

        if (_.isFunction(callback)) {
          callback();
        }

        columnsChanged();
      }
    };

    props.cleanCopy = function (allowedKeys) {
      var item = this._super(allowedKeys);

      if (!_.isUndefined(item[colSet])) {
        item[colSet] = _.chain(item[colSet]).reject(function (c) {
          return c.id == -1;
        }).sortBy(function (c) {
          return c.position;
        }).value();
      }

      return item;
    };

    props.clone = function () {
      this._cloneExclude['real' + capSet] = true;
      this._cloneExclude['visible' + capSet] = true;
      return this._super.apply(this, arguments);
    };

    props.setAccessType = function (accessType) {
      this._super(accessType);

      _.each(this[colSet] || [], function (c) {
        c.setAccessType(accessType);
      });
    }; // defines: updateColumns, updateChildColumns


    props['update' + capSet] = function (newCols, forceFull, updateOrder, masterUpdate) {
      if ($.isBlank(this[colSet]) && $.isBlank(newCols)) {
        return;
      }

      var cont = this;
      var changeType;

      if (!$.isBlank(newCols)) {
        // if we have no columns to begin with just set them
        if ($.isBlank(cont[colSet])) {
          cont[colSet] = newCols;
          changeType = 'fullSet';
        } else {
          var colById = {};

          _.each(newCols, function (nc, i) {
            // Columns may or may not be in the list already; they may
            // also be at the wrong spot.  So find the column and index
            // if it already exists
            var c = nc.dataTypeName != 'meta_data' ? forIdentifier(cont, nc.fieldName || nc.id) : _.find(cont[colSet], function (mc) {
              return mc.dataTypeName == 'meta_data' && mc.name == nc.name;
            });

            var ci = _.indexOf(cont[colSet], c); // If it is new, just splice it in


            if ($.isBlank(c)) {
              // Setting the ID to -1 so that this column that is added to the client
              // is dropped when cleanCopy() is called. This is useful for query based
              // views that may be adding/removing columns that don't have an immediate
              // lens_column ID associated with a column until after save occurs. Otherwise
              // columns with no ID, or incorrect IDs get included in the PUT to api/views
              // which will result in a 400. Simply not including the column in the View object
              // avoids this.
              nc.id = -1;

              if (updateOrder) {
                cont[colSet].splice(i, 0, nc);
              } else {
                cont[colSet].push(nc);
              }

              changeType = 'added';
            } else {
              // If the column existed but not at this index, remove
              // it from the old spot and put it in the new one
              if (updateOrder && ci != i) {
                cont[colSet].splice(ci, 1);
                cont[colSet].splice(i, 0, c);
                changeType = 'moved';
              } // Update the column object in-place


              c.update(nc, forceFull, updateOrder);
            }

            colById[nc.id] = true;
          }); // If master update, remove any cols not in set


          if (masterUpdate) {
            cont[colSet] = _.reject(cont[colSet], function (c) {
              if (!colById[c.id]) {
                cont['clear' + capName](c);
                return true;
              }

              return false;
            });
          }
        }
      }

      _columnIDLookup = {};
      _columnTCIDLookup = {};
      _columnFieldNameLookup = {};
      _metaColumnLookup = {};
      this[colSet] = _.map(this[colSet], function (c) {
        if (!(c instanceof Column)) {
          c = new Column(c, cont);
        } else if ($.isBlank(c.view)) {
          c.setParent(cont);
        }

        _columnIDLookup[c.id] = c;

        if (c.lookup != c.id) {
          _columnIDLookup[c.lookup] = c;
        }

        _columnTCIDLookup[c.tableColumnId] = c;
        _columnFieldNameLookup[c.fieldName] = c;

        if (cont[oldCapSet]) {
          var oldC = findOldColumnFromSet(cont[oldCapSet], c);

          if (oldC) {
            _columnIDLookup[oldC.id] = c;

            if (oldC.lookup != c.id) {
              _columnIDLookup[oldC.lookup] = c;
            }

            _columnTCIDLookup[oldC.tableColumnId] = c;
            _columnFieldNameLookup[oldC.fieldName] = c;
          }
        }

        if (c.isMeta) {
          _metaColumnLookup[c.name] = c;
        }

        if (!$.isBlank(cont.accessType)) {
          c.setAccessType(cont.accessType);
        }

        return c;
      });
      this['real' + capSet] = _.reject(this[colSet], function (c) {
        return c.isMeta;
      });
      this['visible' + capSet] = _.chain(realSet(this)).reject(function (c) {
        return c.hidden;
      }).sortBy(function (c) {
        return c.position;
      }).value();

      if (_.some(this[colSet], function (c) {
        return c.renderType.soda1Only;
      })) {
        (cont.view || cont)._useSODA2 = false;
      }

      if (!$.isBlank(changeType)) {
        _.defer(function () {
          (cont.view || cont).trigger('columns_changed', [changeType]);
        });
      }
    };

    return props;
  };

  if (blist && blist.inBrowser) {
    window.ColumnContainer = ColumnContainer;
  } else {
    module.exports = ColumnContainer;
  }
})();

/***/ }),

/***/ 3003:
/***/ (function(module, exports, __webpack_require__) {

var _require = __webpack_require__(21),
    FeatureFlags = _require.FeatureFlags;

(function () {
  var Column = ServerModel.extend({
    _init: function _init(c, parent) {
      this._super();

      $.extend(this, c); // Calls _setUpColumn & updateChildColumns

      this.setParent(parent);
      this.aggregates = this.aggregates || {};
      $.extend(this._cloneExclude, {
        _ntInit: true
      });
    },
    baseUrl: function baseUrl() {
      if (this.renderTypeName == 'geospatial') {
        return '/api/views/' + this.view.id + '/geometry/';
      } else {
        return '/views/' + this.view.id + '/files/';
      }
    },
    getSummary: function getSummary(successCallback, limit) {
      var col = this;

      var canCallback = _.isFunction(successCallback);

      limit = limit || 100;

      var colSumLoaded = function colSumLoaded(resp) {
        col._summary = {};
        col._summaryLimit = limit;

        _.each(resp.columnSummaries || [], function (s) {
          if ((s.topFrequencies || []).length > 0) {
            col._summary[s.subColumnType] = s;
          }
        });

        if (canCallback) {
          successCallback(col._summary);
        }
      };

      var colSumLoadedSODA2 = function colSumLoadedSODA2(resp) {
        col._summary = {};
        col._summaryLimit = limit; // Yeah, we're just making this all up.
        // It normally comes back from getSummary for us.

        col._summary[col.renderTypeName] = {
          subColumnType: col.renderTypeName,
          topFrequencies: _.map(resp, function (item) {
            return {
              count: parseInt(item[aggregateAlias], 10),
              value: item[col.fieldName]
            };
          })
        };

        if (canCallback) {
          successCallback(col._summary);
        }
      };

      if ($.isBlank(col._summary) || limit > col._summaryLimit) {
        if (col.view._useSODA2) {
          var aggregateAlias = "count_".concat(col.fieldName);
          var soql = {
            '$select': [col.fieldName, "count(".concat(col.fieldName, ") as ").concat(aggregateAlias)].join(','),
            '$group': col.fieldName,
            '$order': "".concat(aggregateAlias, " desc"),
            '$limit': limit
          };
          col.view.makeRequest({
            url: "/resource/".concat(col.view.id, ".json"),
            params: soql,
            isSODA: true,
            success: colSumLoadedSODA2
          });
        } else {
          col.view.makeRequest({
            inline: true,
            params: {
              method: 'getSummary',
              columnId: col.id,
              limit: limit
            },
            success: colSumLoaded
          });
        }
      } else {
        if (canCallback) {
          successCallback(col._summary);
        }
      }
    },
    invalidateData: function invalidateData() {
      delete this._summary;
      delete this._summaryLimit;
    },
    canUpdate: function canUpdate() {
      return !this.view.isSnapshot() && this.view.hasRight(blist.rights.view.UPDATE_COLUMN);
    },
    save: function save(successCallback, errorCallback) {
      var col = this;

      var colSaved = function colSaved(newCol) {
        col.update(newCol, true);

        if (!$.isBlank(col.parentColumn)) {
          col.parentColumn.updateChildColumns();
        } else {
          col.view.updateColumns();
        }

        if (_.isFunction(successCallback)) {
          successCallback(col);
        }
      };

      if (col.canUpdate()) {
        this.makeRequest({
          url: '/views/' + this.view.id + '/columns/' + this.id + '.json',
          type: 'PUT',
          data: JSON.stringify(this.cleanCopy()),
          success: colSaved,
          error: errorCallback
        });
        return true;
      } else {
        if (!$.isBlank(col.parentColumn)) {
          col.parentColumn.updateChildColumns();
        } else {
          col.view.updateColumns();
        }

        col.view._markTemporary();

        return false;
      }
    },
    show: function show(successCallback, errorCallback, isBatch) {
      return this.setVisible(true, successCallback, errorCallback, isBatch);
    },
    hide: function hide(successCallback, errorCallback, isBatch, skipReq) {
      return this.setVisible(false, successCallback, errorCallback, isBatch, skipReq);
    },
    setVisible: function setVisible(isVisible, successCallback, errorCallback, isBatch, skipReq) {
      var col = this;

      if (col.hidden !== isVisible) {
        return false;
      }

      col.hidden = !isVisible;

      if (isVisible) {
        col.flags = _.without(col.flags || [], 'hidden');
      } else {
        col.flags = col.flags || [];
        col.flags.push('hidden');
      }

      if (!isBatch) {
        if (!$.isBlank(col.parentColumn)) {
          col.parentColumn.updateChildColumns();
        } else {
          col.view.updateColumns();
        }
      }

      if (col.canUpdate() && !skipReq) {
        this.makeRequest({
          url: '/views/' + this.view.id + '/columns/' + this.id + '.json',
          type: 'PUT',
          data: JSON.stringify({
            hidden: !isVisible
          }),
          batch: isBatch,
          success: successCallback,
          error: errorCallback
        });
      } else {
        col.view._markTemporary();
      }

      return true;
    },
    update: function update(newCol, forceFull, updateColOrder) {
      var col = this;
      newCol.id = col.id;
      var oldWidth = col.width;
      var oldAgg = col.format.aggregate;

      if (forceFull) {
        // If we are updating the entire column, then clean out all the
        // valid keys; then the next lines will copy all the new ones over
        _.each(col._validKeys, function (v, k) {
          if (k != 'childColumns') {
            delete col[k];
          }
        });
      }

      _.each(newCol, function (v, k) {
        if (k != 'childColumns' && col._validKeys[k]) {
          col[k] = v;
        }
      }); // renderTypeName is not a valid key to post back, but we want to copy
      // it over if present


      if (!$.isBlank(newCol.renderTypeName)) {
        col.renderTypeName = newCol.renderTypeName;
      } // Same for subColumnTypes


      if (!$.isBlank(newCol.subColumnTypes)) {
        col.subColumnTypes = newCol.subColumnTypes;
      }

      this.updateChildColumns(newCol.childColumns, forceFull, updateColOrder); // dropDown is special, because it only comes from the server; it isn't
      // posted back, so it isn't considered valid

      if (!$.isBlank(newCol.dropDown)) {
        col.dropDown = newCol.dropDown;
      }

      this._setUpColumn();

      if (oldWidth !== col.width) {
        col.view.trigger('column_resized', [col]);
      }

      if (FeatureFlags.value('prohibit_use_of_row_set')) {// noop
      } else {
        if ($.subKeyDefined(newCol, 'updatedAggregate.value')) {
          col.aggregates[newCol.updatedAggregate.name] = parseFloat(newCol.updatedAggregate.value);
          col.view.aggregatesChanged(true);
        } else if (oldAgg !== col.format.aggregate) {
          col.view.aggregatesChanged();
        }
      }
    },
    setParent: function setParent(parent) {
      if (parent instanceof Column) {
        this.parentColumn = parent;
        this.view = parent.view;
      } else {
        this.view = parent;
      }

      this._setUpColumn();

      this.updateChildColumns();
    },
    filter: function filter(value, subColumnType, operator) {
      var col = this;

      if ($.isBlank(value)) {
        col.clearFilter();
        return;
      }

      var md = $.extend(true, {}, col.view.metadata);
      var query = md.jsonQuery; // If there is already a filter for this column, clear it out

      col._clearFilterData(query);

      var colItem = {
        columnFieldName: col.fieldName
      };

      if (!$.isBlank(subColumnType) && _.isString(subColumnType)) {
        if (col.view._useSODA2) {
          colItem.subColumn = subColumnType.toLowerCase();
        } else {
          colItem.subColumn = subColumnType.toUpperCase();
        }
      } // Special handling for human_address in location


      if (col.renderTypeName == 'location' && !$.isBlank(subColumnType) && $.isPlainObject(value)) {
        value = JSON.stringify(value);
      } // Update the parent view with the new filter


      var filterItem = $.extend({
        operator: operator || 'EQUALS',
        value: value
      }, colItem);
      query.namedFilters = query.namedFilters || {};
      query.namedFilters['col' + col.id] = {
        where: filterItem
      }; // Store the filter in an easier format to deal with elsewhere;
      //  also keep a pointer back to the viewFilter

      col.currentFilter = {
        value: value,
        viewFilter: filterItem
      };
      col.view.update({
        metadata: md
      });
    },
    clearFilter: function clearFilter() {
      var col = this;
      var md = $.extend(true, {}, col.view.metadata);

      col._clearFilterData(md.jsonQuery);

      col.view.update({
        metadata: md
      });
    },
    remove: function remove(successCallback, errorCallback, isBatch) {
      var col = this;

      var colRemoved = function colRemoved() {
        if (!$.isBlank(col.parentColumn)) {
          col.parentColumn.clearChildColumn(col);
        } else {
          col.view.clearColumn(col);
        }

        if (!isBatch) {
          if (!$.isBlank(col.parentColumn)) {
            col.parentColumn.updateChildColumns();
          } else {
            col.view.updateColumns();
          }
        }

        if (_.isFunction(successCallback)) {
          successCallback(col);
        }
      };

      col.makeRequest({
        url: '/views/' + col.view.id + '/columns/' + col.id + '.json',
        type: 'DELETE',
        batch: isBatch,
        success: colRemoved,
        error: errorCallback
      });
    },
    convert: function convert(newType, successCallback, errorCallback) {
      var col = this;

      var columnConverted = function columnConverted(newCol) {
        // Got new ID, so manually need to copy that over
        col.id = newCol.id;
        col.tableColumnId = newCol.tableColumnId;
        col.update(newCol, true);
        col.invalidateData();

        if (!$.isBlank(col.parentColumn)) {
          col.parentColumn.updateChildColumns();
        } else {
          col.view.updateColumns();
        } // Need to refresh the view


        col.view.reload(true);

        if (_.isFunction(successCallback)) {
          successCallback(col);
        }
      };

      this.makeRequest({
        url: '/views/' + this.view.id + '/columns/' + this.id + '.json',
        params: {
          method: 'convert',
          type: newType
        },
        type: 'POST',
        success: columnConverted,
        error: errorCallback
      });
    },
    cleanCopy: function cleanCopy() {
      var col = this._super(); // Support for linked columns


      if (_.includes(['dataset_link'], col.dataTypeName)) {
        delete col.dropDownList;
      }

      return col;
    },
    // EN-17875 - Make grid view Socrata Viz table respond to OBE/NBE read
    // queries using old query path
    //
    // We need to pass a JSON representation of the view along to the Table
    // renderer by including the equivalent output of the /api/views endpoint in
    // the vif with which we instantiate the Table.
    //
    // Unfortunately, the `.cleanCopy()` method on the Dataset model omits the
    // `renderTypeName` property (since it is not a valid property to send back
    // to Core Server--presumably we assign a renderTypeName when we persist the
    // updated view).
    //
    // Accordingly, and in the spirit of making as few changes to existing code
    // as possible, I am adding an additional method that does not omit the
    // renderTypeName property for the specific use case described above.
    //
    // This is the Column component of the work; there are also similar
    // implementations in the Dataset and Base models located in this project at
    // `platform-ui/frontend/public/javascripts/util/dataset/dataset.js` and
    // `platform-ui/frontend/public/javascripts/util/base-model.js`,
    // respectively.
    //
    // BECAUSE YOU ASKED, here is a slightly more verbose explanation for why we
    // need to do this (taken from github.com/socrata/platform-ui/pull/5232):
    //
    //   It's actually the Column object that has the renderTypeName property.
    //   But one gets the serialized columns by getting the serialized view (the
    //   dataset implementation of the function with the same name, which
    //   function on dataset basically maps the list of visible columns with the
    //   version of the cleanCopyIncludingRenderTypeName implemented in the
    //   column model, and both will attempt to call
    //   cleanCopyIncludingRenderTypeName on the base model because they both
    //   call self._super(), and it's the whole big mess of the inheritance
    //   stuff that we abused so badly circa 2011.
    //
    // USE AT YOUR OWN RISK etc. etc.
    cleanCopyIncludingRenderTypeName: function cleanCopyIncludingRenderTypeName() {
      var col = this._super(); // Support for linked columns


      if (_.includes(['dataset_link'], col.dataTypeName)) {
        delete col.dropDownList;
      }

      return col;
    },
    _setUpColumn: function _setUpColumn() {
      var col = this;
      this.format = this.format || {};
      this.metadata = this.metadata || {};

      if (!$.isBlank(this.dropDown)) {
        this.dropDownList = this.dropDown;
      }

      delete this.dropDown;
      this.hidden = _.includes(this.flags || [], 'hidden');
      this.dataType = blist.datatypes[this.dataTypeName] || {};
      this.renderType = blist.datatypes[this.renderTypeName] || {};
      this.isMeta = this.dataTypeName == 'meta_data';

      if (!$.isBlank(col.view)) {
        col.lookup = col.view._useSODA2 ? col.fieldName : col.isMeta ? col.name : col.id; // The use of id and uuid potentially causes collision with user column field names.
        // We already do in the catalog dataset because it has another id column.
        // Not fixing this yet.  Suggest to use prefix ":" for system columns.

        if (!col.view._useSODA2 && col.isMeta && col.name == 'sid') {
          col.lookup = 'id';
        } else if (!col.view._useSODA2 && col.isMeta && col.name == 'id') {
          col.lookup = 'uuid';
        }
      } // Set up min width and default


      this.minWidth = 50;
      this.width = Math.max(this.minWidth, this.width || 100);

      if (!$.isBlank(this.format.grouping_aggregate) && !$.isBlank(this.format.drill_down)) {
        delete this.format.drill_down;
        this.width -= 30;
      } // EN-4561 - Unable to create column chart with data series grouping.
      //
      // When a filter is created using the dropdown as part of a column header, the
      // filter object is created in a certain format. When a filter is created using
      // the filtering pane, the filter object is created in a different, distinct
      // format. In the former case the creation of the filter also causes the column
      // being filtered to have a `currentFilter` property on the object representing
      // it in the dataset model, but this does not happen in the latter case.
      //
      // The substance of this bug is that this code path is executed when a filter is
      // created using the dropdown on the column header (but not when a filter is
      // created using the side pane), and this code path assumes that `this.view`
      // exists and has a metadata property.
      //
      // For reasons I do not comprehend, column objects sometimes, but not always,
      // have a `this.view` property and it appears to be ok if they don't have one,
      // except in this case when we throw an error trying to access a child property
      // of the non-existent view.
      //
      // This fix adds the two checks that `this.view` and `this.view.metadata` are
      // not undefined in order to avoid the TypeError trying to read
      // `this.view.metadata.jsonQuery`.


      if (!$.isBlank(this.currentFilter) && typeof this.view !== 'undefined' && typeof this.view.metadata !== 'undefined' && $.isBlank(((this.view.metadata.jsonQuery || {}).namedFilters || {})['col' + this.id])) {
        delete this.currentFilter;
      }
    },
    updateChildColumns: function updateChildColumns() {// Do nothing; provided for fallback
    },
    isLinked: function isLinked() {
      var col = this;
      return col.format && col.format.linkedKey != null;
    },
    underscoreName: function underscoreName(ds) {
      var col = this;
      var otherCol;
      var otherUname;
      var uname = Column.sanitizeName(col.name);

      for (var n = 0; n < ds.columns.length; n++) {
        otherCol = ds.columns[n];

        if (otherCol.id == col.id) {
          continue;
        }

        otherUname = Column.sanitizeName(otherCol.name);

        if (uname == otherUname) {
          uname += '_' + col.position;
          break;
        }
      }

      return uname;
    },
    _clearFilterData: function _clearFilterData(query) {
      var col = this;

      if ($.isBlank(col.currentFilter)) {
        return;
      }

      delete query.namedFilters['col' + col.id];
      delete col.currentFilter;
    },
    canBeDatasetLink: function canBeDatasetLink() {
      if (this.dataTypeName != 'text') {
        return false;
      }

      if (this.format && this.format.drill_down == true) {
        return false;
      }

      if (this.hidden) {
        return false;
      }

      return true;
    },
    canBeLinkSource: function canBeLinkSource() {
      if (_.includes(['dataset_link', 'drop_down_list'], this.dataTypeName)) {
        return false;
      }

      if (this.hidden) {
        return false;
      }

      if (this.dataTypeName.indexOf('obsolete') >= 0) {
        return false;
      }

      return true;
    },
    fieldNameForRollup: function fieldNameForRollup(rollup) {
      return rollup ? rollup + '(' + this.fieldName + ')' : this.fieldName;
    },
    isText: function isText() {
      switch (this.dataTypeName) {
        case 'text':
        case 'html':
          return true;

        default:
          return false;
      }
    },
    _validKeys: {
      childColumns: true,
      dataTypeName: true,
      defaultValues: true,
      description: true,
      dropDownList: true,
      fieldName: true,
      flags: true,
      format: true,
      id: true,
      metadata: true,
      name: true,
      position: true,
      tableColumnId: true,
      width: true
    }
  });

  Column.isNbePointColumn = function (dataset, column) {
    return _.get(dataset, 'newBackend') && _.get(column, 'dataTypeName') === 'point';
  };

  Column.sanitizeName = function (colName) {
    // refer to core server ViewColumn.underscoreName
    return colName.toLowerCase().replace(/^[^A-z]+/gi, '_').replace(/[^A-z0-9]+/gi, '_').replace(/^xml/gi, '_').replace(/_+/gi, '_');
  };

  Column.closestViewFormat = function (realCol, funcOrLocalCol) {
    var groupFunc = _.isString(funcOrLocalCol) || $.isBlank(funcOrLocalCol) ? funcOrLocalCol : funcOrLocalCol.format.group_function;

    if (groupFunc != realCol.format.group_function) {
      // Fix up view format
      var vt = realCol.renderType.viewTypes;

      if (_.isFunction(vt)) {
        vt = vt(groupFunc, true);
      }

      if (!_.some(vt, function (v) {
        return v.value == realCol.format.view;
      })) {
        if ($.isBlank(realCol.format.view)) {
          return _.first(vt).value;
        } // None found! Find a reasonable default
        // Prefer longest matching substring; otherwise use levenshtein distance


        return _.first(_.sortBy(_.map(vt, function (v) {
          return {
            value: v.value,
            distance: v.value.startsWith(realCol.format.view) ? 1 / realCol.format.view.length : realCol.format.view.startsWith(v.value) ? 1 / v.value.length : realCol.format.view.heuristicDistance(v.value)
          };
        }), 'distance')).value;
      }
    }

    return null;
  };

  if (blist.inBrowser) {
    window.Column = Column;
  } else {
    module.exports = Column;
  }
})();

/***/ }),

/***/ 3004:
/***/ (function(module, exports) {

(function () {
  var RowSet = ServerModel.extend({
    _init: function _init(ds, jsonQuery, query, parRS, initRows) {
      this._super();

      this._dataset = ds;
      this.registerEvent(['row_change', 'row_count_change', 'metadata_update']);
      this._rows = {};
      this._rowIDLookup = {};
      this._rowsLoading = {};
      this._pendingRowReqs = [];
      this._parent = parRS;
      this._query = query || {};
      this._jsonQuery = jsonQuery || {};
      this._loadedCount = 0;
      this._isComplete = false;
      this._matchesExpr = {
        where: blist.filter.matchesExpression(this._jsonQuery.where, this._dataset),
        having: blist.filter.matchesExpression(this._jsonQuery.having, this._dataset)
      };

      if (!_.isEmpty(initRows)) {
        this._addRows(initRows.rows, initRows.start);

        if (!$.isBlank(initRows.total)) {
          this._totalCount = initRows.total;
          delete this._potentialBuckets;
        }
      }

      this.formattingChanged();
      var rs = this;

      this._dataset.bind('columns_changed', function (changeType, lookupMap) {
        switch (changeType) {
          case 'lookupChange':
            rs.lookupsChanged(lookupMap);
            break;

          case 'visibility':
            delete rs._rowBuckets; // make nbe request rows to refresh

            break;
        }
      });
    },
    getKey: function getKey() {
      if ($.isBlank(this._key)) {
        this._key = RowSet.getQueryKey(this._jsonQuery);
      }

      return this._key;
    },
    rowForID: function rowForID(id) {
      return this._rowIDLookup[parseInt(id) || id];
    },
    rowForIndex: function rowForIndex(index) {
      return this._rows[index];
    },
    rowIndex: function rowIndex(id, successCallback) {
      var rs = this;

      if (!$.isBlank(rs.rowForID(id))) {
        successCallback(rs.rowForID(id).index);
      } else {
        var gotID = function gotID(data) {
          successCallback(data[id]);
        };

        if (rs._dataset._useSODA2) {
          // FIXME: Doesn't work for SODA2
          successCallback(0);
        } else {
          rs.makeRequest({
            inline: true,
            params: {
              method: 'getByIds',
              indexesOnly: true,
              ids: id
            },
            success: gotID
          });
        }
      }
    },
    childRowForID: function childRowForID(id, parRow, parCol) {
      // Someday an actual lookup for child rows might be good; but these
      // should be rare and small, so don't bother yet
      var cell = parRow.data[parCol.lookup];
      return _.find(cell || {}, function (sr) {
        return sr.id === id;
      });
    },
    getTotalRows: function getTotalRows(successCallback, errorCallback) {
      var rs = this;

      if ($.isBlank(rs._totalCount)) {
        rs.getRows(0, 1, successCallback, errorCallback);
      } else if (_.isFunction(successCallback)) {
        successCallback();
      }
    },
    totalRows: function totalRows() {
      return this._totalCount;
    },
    potentialBuckets: function potentialBuckets() {
      if (_.isUndefined(this._potentialBuckets)) {
        this._potentialBuckets = _.range(0, this._totalCount || 1, this._dataset.bucketSize);
      }

      return this._potentialBuckets;
    },
    // This function guarantees a valid return value. It *should* be impossible to
    // request a numerical index and fail to return a bucket.
    getRowBucket: function getRowBucket(index) {
      var rs = this;
      var bucketSize = rs._dataset.bucketSize;

      if (!_.isFunction(rs._dataset.usingBuckets) || !rs._dataset.usingBuckets()) {
        return {
          start: 0,
          finish: rs._totalCount
        };
      } // If this is the first load, then assume start is 0 because I don't know any better.


      if (!_.isNumber(rs._totalCount)) {
        return {
          start: 0,
          finish: bucketSize
        };
      } // Requesting an index before the first row yields the first bucket.


      if (index <= 0) {
        return {
          start: 0,
          finish: bucketSize
        };
      } // Memoize all potential buckets.
      // Requesting an index beyond the last row yields the last bucket.


      var bucketStart = _.findLast(rs.potentialBuckets(), function (start) {
        return start <= index;
      });

      return {
        start: bucketStart,
        finish: bucketStart + bucketSize
      };
    },
    bucketIndex: function bucketIndex(bucketStart) {
      if (!_.isNumber(this._totalCount)) {
        return;
      }

      return _.indexOf(this.potentialBuckets(), bucketStart);
    },
    totalBuckets: function totalBuckets() {
      if (!_.isNumber(this._totalCount)) {
        return;
      }

      return this.potentialBuckets().length;
    },
    getRows: function getRows(startOrIds, len, successCallback, errorCallback, sortOrderForRequest) {
      var rs = this; // If we aren't complete, but can grab data from our parent, pre-emptively do so
      // Also exclude client side filtering on the catalog dataset because its filtering is somewhat unusual.

      if (rs._dataset.resourceName !== 'datasets' && !rs._isComplete && (rs._parent || {})._isComplete && rs._jsonQuery.search === rs._parent._jsonQuery.search && _.isEmpty(rs._jsonQuery.group) && _.isEmpty(rs._parent._jsonQuery.group)) {
        var newRows = _.map(_.filter(rs._parent._rows, function (rowItem) {
          return rs._doesBelong(rowItem);
        }), function (rowItem) {
          return $.extend({}, rowItem);
        });

        rs._totalCount = newRows.length;
        delete rs._potentialBuckets;

        var sortVals = _.map(newRows, function (newRow) {
          return {
            sorts: [newRow.id],
            row: newRow
          };
        });

        _.each((rs._jsonQuery.order || []).slice().reverse(), function (ob) {
          var col = rs._dataset.columnForIdentifier(ob.columnFieldName);

          if ($.isBlank(col)) {
            return;
          }

          _.each(sortVals, function (sv) {
            var v = sv.row.data[col.lookup];

            if ($.isBlank(v)) {
              v = null;
            } else {
              if (_.isFunction(col.renderType.matchValue)) {
                v = col.renderType.matchValue(v, col);
              }
            }

            sv.sorts.unshift(v);
          });
        });

        var sorts = (rs._jsonQuery.order || []).slice(); // Add fake sort for position

        sorts.push({
          ascending: true
        });
        newRows = _.map(sortVals.sort(function (left, right) {
          var a = left.sorts;
          var b = right.sorts;
          var sortIndex = 0;

          while (sortIndex < a.length && a[sortIndex] === b[sortIndex]) {
            sortIndex++;
          } // Nulls always sort last


          if ($.isBlank(a[sortIndex])) {
            return 1;
          }

          if ($.isBlank(b[sortIndex])) {
            return -1;
          }

          return sortIndex === a.length ? 0 : (a[sortIndex] < b[sortIndex] ? -1 : 1) * (sorts[sortIndex].ascending ? 1 : -1);
        }), 'row');

        rs._addRows(newRows, 0, true);
      }

      var ids;
      var start;

      if (_.isNumber(startOrIds) && _.isNumber(len)) {
        start = startOrIds;
      } else if (_.isArray(startOrIds)) {
        ids = startOrIds;
      } else {
        if (_.isFunction(errorCallback)) {
          errorCallback({
            message: 'Missing start and length or ids'
          });
        }

        return;
      }

      var pageSize = 100;
      var reqs = [];
      var curReq;
      var pendReq;
      var finish = start + len - 1;
      var loaded = [];
      var pendingRemoved = [];
      var now = new Date().getTime();

      var doLoaded = function doLoaded() {
        if (loaded.length > 0 || rs._totalCount === 0) {
          if (_.isFunction(successCallback)) {
            successCallback(loaded);
          }

          loaded = [];
        }
      };

      if (len && !$.isBlank(start)) {
        // In NBE + SODA2, we want to make fewer, but larger, requests for rows.
        // Current strategy is to bucket in chunks of 1000.
        //
        // This code block ignores things like "rowsLoading" because there's not an
        // apparent need for it.
        if (rs._dataset.newBackend) {
          var bucketSize = rs._dataset.bucketSize;
          var bucket = {
            start: Math.floor(finish / bucketSize) * bucketSize,
            finish: Math.ceil(finish / bucketSize) * bucketSize - 1
          };

          if (_.isUndefined(rs._rowBuckets)) {
            rs._rowBuckets = [];
          } // Note: _rowBuckets should *only* contain bucket indices that we've already
          // fetched. Building this out is a bad idea.


          if (!_.includes(rs._rowBuckets, bucket.start) && bucket.start < bucket.finish) {
            reqs.push(bucket); // The bucket is being requested; do not fetch it again.
            // Only saving the `start` value to cargo cult for speed.

            rs._rowBuckets.push(bucket.start);

            rs._rowBuckets.sort();
          } else {
            // Special case when looking for just one row.
            if (start === finish) {
              curReq = {
                start: start,
                finish: start
              };
            } // The while loop is back! These numbers are based off the screen size,
            // so it's unlikely to be insane.


            while (start <= finish) {
              if (rs._rows[start]) {
                loaded.push(rs._rows[start]);
              }

              start++;
            }
          }
        } else {
          while (start <= finish && ($.isBlank(rs._totalCount) || start < rs._totalCount)) {
            var r = rs._rows[start]; // If this is an expired pending row, clean it out and mark
            // it null so it gets reloaded

            if (!$.isBlank(r) && r.pending && now > r.expires) {
              delete rs._rows[r.index];
              delete rs._rowIDLookup[r.id];
              pendingRemoved.push(r);
              r = null;
            }

            if ($.isBlank(r)) {
              doLoaded();

              if (rs._rowsLoading[start]) {
                if (!$.isBlank(curReq)) {
                  reqs.push(curReq);
                  curReq = null;
                }

                if ($.isBlank(pendReq)) {
                  pendReq = {
                    start: start,
                    length: 1,
                    successCallback: successCallback,
                    errorCallback: errorCallback
                  };
                } else {
                  pendReq.length++;
                }
              } else {
                if (!$.isBlank(pendReq)) {
                  rs._pendingRowReqs.push(pendReq);

                  pendReq = null;
                }

                if ($.isBlank(curReq)) {
                  curReq = {
                    start: start,
                    finish: start
                  };
                } else {
                  if (start - curReq.start + 1 > pageSize) {
                    reqs.push(curReq);
                    curReq = {
                      start: start
                    };
                  } else {
                    curReq.finish = start;
                  }
                }
              }
            } else {
              if (!$.isBlank(curReq)) {
                reqs.push(curReq);
                curReq = null;
              }

              if (!$.isBlank(pendReq)) {
                rs._pendingRowReqs.push(pendReq);

                pendReq = null;
              }

              loaded.push(r);
            }

            start++;
          }
        }
      } else {
        ids = _.reject(ids || [], function (id) {
          var row = rs._rowIDLookup[id];

          if (row) {
            return loaded.push(row);
          }
        });

        for (var i = 0; i < ids.length; i += 100) {
          reqs.push({
            ids: ids.slice(i, i + 100)
          });
        }
      }

      doLoaded();

      if (pendingRemoved.length > 0) {
        rs.trigger('row_change', [pendingRemoved, true]);
      }

      if (!$.isBlank(curReq)) {
        if (_.isUndefined(curReq.finish)) {
          curReq.finish = curReq.start;
        }

        reqs.push(curReq);
        curReq = null;
      }

      if (!$.isBlank(pendReq)) {
        rs._pendingRowReqs.push(pendReq);

        pendReq = null;
      }

      if (reqs.length > 0) {
        if (sortOrderForRequest) {
          _.each(reqs, function (req) {
            req.sortOrderForRequest = sortOrderForRequest;
          });
        }

        var loadAllRows = function loadAllRows() {
          // If we got here, and totalRows is still blank, bail, because something
          // has changed in the meantime and this load is just invalid
          if ($.isBlank(rs._totalCount)) {
            if (_.isFunction(errorCallback)) {
              errorCallback({
                cancelled: true
              });
            }

            return;
          }

          _.each(reqs, function (req) {
            var reqLen;
            var requestOptions = {
              sortOrderForRequest: req.sortOrderForRequest
            };

            if (req.finish && !$.isBlank(req.start)) {
              if (req.start >= rs._totalCount) {
                return;
              }

              if (req.finish >= rs._totalCount) {
                req.finish = rs._totalCount - 1;
              }

              reqLen = req.finish - req.start + 1;
            }

            rs._loadRows(req.ids || req.start, reqLen, requestOptions, successCallback, errorCallback);
          });
        };

        if ($.isBlank(rs._totalCount) || rs._rerequestMeta) {
          // Need to make init req to get all the meta
          var initReq = reqs.shift();
          var initReqLen;

          if (!$.isBlank(initReq.finish) && !$.isBlank(initReq.start)) {
            initReqLen = initReq.finish - initReq.start + 1;
          }

          var options = {
            includeMeta: true,
            sortOrderForRequest: initReq.sortOrderForRequest
          };

          rs._loadRows(initReq.ids || initReq.start, initReqLen, options, function (rows) {
            if (_.isFunction(successCallback)) {
              successCallback(rows);
            }

            loadAllRows();
          }, errorCallback);

          delete rs._rerequestMeta;
        } else {
          // Just request rows
          loadAllRows();
        }
      }
    },
    getAllRows: function getAllRows(successCallback, errorCallback) {
      var rs = this;
      rs.getTotalRows(function () {
        var loadedRows = 0;
        rs.getRows(0, rs._totalCount, function (rows) {
          loadedRows += rows.length;

          if (loadedRows >= rs._totalCount) {
            rs.getRows(0, rs._totalCount, successCallback, errorCallback);
          }
        }, errorCallback);
      }, errorCallback);
    },
    loadedRows: function loadedRows() {
      return this._rows;
    },

    /**
     * @function primaryKeyExists
     * @description
     * Ensures there is not a row with the candidate primary key.
     *
     * Methodology:
     * - Look through all loaded rows, if found return row, otherwise
     * - Attempt to contact the API for this dataset and
     *   ask for any rows that have the candidate primary key.
     * @param {Any} candidatePrimaryKey - The candidate key that has been requested as an addition.
     * @return {Promise}
     */
    primaryKeyExists: function primaryKeyExists(candidatePrimaryKey) {
      var rs = this;
      var ds = rs._dataset;
      var primaryKeyColumnID = (ds.rowIdentifierColumn || {}).lookup || ':id'; // Check all loaded rows for the primary key candidate.

      var row = _.find(rs._rows, function (r) {
        var unchanged = !r.changed[primaryKeyColumnID];
        var alreadyHasPrimaryKey = r.data[primaryKeyColumnID] === candidatePrimaryKey;
        return unchanged && alreadyHasPrimaryKey;
      });

      if (row) {
        return $.when(row);
      } else {
        // Check API rows for the primary key candidate.
        var deferred = $.Deferred(); // eslint-disable-line new-cap

        var params = {
          '$where': primaryKeyColumnID + '="' + candidatePrimaryKey + '"'
        };
        var url = '/api/id/' + ds.id + '.json?' + $.toParam(params);
        $.getJSON(url).done(function (rows) {
          if (Array.isArray(rows)) {
            deferred.resolve(rows[0]);
          } else {
            deferred.reject();
          }
        }).fail(deferred.reject);
        return deferred.promise();
      }
    },
    // This function fetches all the fileIds present in the row data.
    getFileIds: function getFileIds() {
      var rs = this;

      var blobColumnLookups = _(rs._dataset.realColumns).filter(function (col) {
        return col.renderTypeName === 'blob';
      }).map('lookup').value();

      var fileIds = _(rs._rows).map(function (row) {
        return _.map(blobColumnLookups, function (lookup) {
          return _.get(row, 'data.' + lookup);
        });
      }).flatten().compact().uniq().value();

      return fileIds;
    },
    // This function creates a fileId->row mapping which is used to decorate rows
    // with fileData information.
    mapFileIdsToRows: function mapFileIdsToRows() {
      var rs = this;

      var blobColumnLookups = _(rs._dataset.realColumns).filter(function (col) {
        return col.renderTypeName === 'blob';
      }).map('lookup').value();

      if (_.isUndefined(rs._fileIdToRowMapping)) {
        rs._fileIdToRowMapping = {};
      }

      _.each(rs._rows, function (row) {
        _.each(blobColumnLookups, function (lookup) {
          var fileId = _.get(row, 'data.' + lookup);

          if (fileId) {
            rs._fileIdToRowMapping[fileId] = {
              row: row,
              lookup: lookup
            };
          }
        });
      });
    },
    // Returns the row if and only if a change was made.
    applyFileDataToRow: function applyFileDataToRow(fileData) {
      var rs = this;

      var mapping = _.get(rs, '_fileIdToRowMapping.' + fileData.id);

      var row = _.get(mapping, 'row');

      var lookupPath = 'fileData.' + _.get(mapping, 'lookup');

      var rowHasSameIdAsFileData = _.get(row, lookupPath + '.id') === fileData.id;

      if (_.isUndefined(mapping) || rowHasSameIdAsFileData) {
        return false;
      }

      return _.set(mapping.row, lookupPath, fileData);
    },
    addRow: function addRow(newRow, idx) {
      if (!this._doesBelong(newRow)) {
        return;
      }

      var row = $.extend({}, newRow);
      row.index = $.isBlank(idx) ? this._totalCount : idx;

      this._setRowFormatting(row);

      $.addItemsToObject(this._rows, row, row.index);
      this._rowIDLookup[row.id] = row;
      delete this._aggCache; // Not going to change isComplete

      this._loadedCount++;
      this._totalCount++;
      this.trigger('row_count_change');
    },
    updateRow: function updateRow(row, oldID) {
      var curRow = this._rowIDLookup[$.isBlank(oldID) ? row.id : oldID]; // When updateRow is called by Dataset#_updateRows, there is no guarantee
      // that all row sets will have the row being updated. If curRow doesn't
      // exist, we can just exit early.

      if (!curRow) {
        return;
      }

      $.extend(curRow, row, {
        index: curRow.index
      });

      this._setRowFormatting(curRow);

      delete this._aggCache;

      if (!$.isBlank(oldID) && oldID !== curRow.id) {
        this._rowIDLookup[curRow.id] = curRow;
        delete this._rowIDLookup[oldID];
      }

      if (!this._doesBelong(curRow)) {
        this.removeRow(curRow);
      }
    },
    removeRow: function removeRow(origRow) {
      var row = this.rowForID(origRow.id);

      if ($.isBlank(row)) {
        return;
      }

      $.removeItemsFromObject(this._rows, row.index, 1);
      delete this._rowIDLookup[row.id];
      delete this._aggCache; // Not going to change isComplete

      this._loadedCount--;
      this._totalCount--;
    },
    markRow: function markRow(markType, value, origRow) {
      var row = this.rowForID((origRow || {}).id);

      if ($.isBlank(row) || (row.sessionMeta || {})[markType] === value) {
        return;
      }

      row.sessionMeta = row.sessionMeta || {};
      row.sessionMeta[markType] = value;
    },
    reload: function reload(successCallback, errorCallback) {
      var rs = this;
      delete rs._totalCount;
      delete rs._potentialBuckets;
      delete rs._rows;
      delete rs._rowIDLookup;
      delete rs._aggCache;

      rs._loadRows(0, 1, {
        includeMeta: true,
        fullLoad: true
      }, successCallback, errorCallback);
    },
    getAggregates: function getAggregates(callback, customAggs) {
      var rs = this;
      var aggs = [];

      var callResults = function callResults() {
        callback(aggs);
      };

      var gotAggs = function gotAggs(recAggs) {
        rs._aggCache = rs._aggCache || {};

        _.each(recAggs, function (agg) {
          rs._aggCache[agg.columnIdent] = rs._aggCache[agg.columnIdent] || {};
          rs._aggCache[agg.columnIdent][agg.name] = agg.value;
          aggs.push(agg);
        });
      };

      rs._aggCache = rs._aggCache || {};
      var args = {
        params: {
          method: 'getAggregates'
        },
        inline: true
      };
      var needReq = false;
      var soda2Aggs = [];

      if (!$.isBlank(customAggs)) {
        var ilViews = [];

        _.each(customAggs, function (aggList, cId) {
          var curCol = rs._dataset.columnForIdentifier(cId);

          if ($.isBlank(curCol)) {
            return;
          }

          _.each($.makeArray(aggList), function (a, i) {
            if ($.subKeyDefined(rs._aggCache, curCol.fieldName + '.' + a)) {
              aggs.push({
                columnIdent: curCol.fieldName,
                name: a,
                value: rs._aggCache[curCol.fieldName][a]
              });
            } else if (rs._isComplete) {
              gotAggs([{
                columnIdent: curCol.fieldName,
                name: a,
                value: rs._calculateAggregate(curCol.fieldName, a)
              }]);
            } else {
              if (rs._dataset._useSODA2) {
                soda2Aggs.push({
                  method: blist.datatypes.soda2Aggregate(a),
                  column: curCol.fieldName
                });
              } else {
                needReq = true;

                if ($.isBlank(ilViews[i])) {
                  ilViews[i] = rs._dataset.cleanCopy();
                }

                var col = _.find(ilViews[i].columns, function (c) {
                  return c.fieldName === curCol.fieldName;
                });

                col.format.aggregate = a;
              }
            }
          });
        });

        if (!rs._dataset._useSODA2) {
          if (needReq) {
            args.success = function (resAggs) {
              gotAggs(_.map(resAggs, function (ra) {
                return {
                  columnIdent: ra.fieldName,
                  name: ra.name,
                  value: ra.value
                };
              }));
            };

            _.each(ilViews, function (v) {
              if ($.isBlank(v)) {
                return;
              }

              var req = $.extend({}, args, {
                data: v,
                batch: true
              });
              rs.makeRequest(req);
            });

            ServerModel.sendBatch(callResults);
          } else {
            callResults();
          }
        }
      } else {
        var checkAgg = function checkAgg(c) {
          if ($.subKeyDefined(c, 'format.aggregate')) {
            if ($.subKeyDefined(rs._aggCache, c.fieldName + '.' + c.format.aggregate)) {
              aggs.push({
                columnIdent: c.fieldName,
                name: c.format.aggregate,
                value: rs._aggCache[c.fieldName][c.format.aggregate]
              });
            } else if (rs._isComplete) {
              gotAggs([{
                columnIdent: c.fieldName,
                name: c.format.aggregate,
                value: rs._calculateAggregate(c.fieldName, c.format.aggregate)
              }]);
            } else if (rs._dataset._useSODA2) {
              soda2Aggs.push({
                method: blist.datatypes.soda2Aggregate(c.format.aggregate),
                column: c.fieldName
              });
            } else {
              needReq = true;
            }
          }
        };

        _.each(rs._dataset.realColumns, function (c) {
          checkAgg(c);

          _.each(c.realChildColumns, function (cc) {
            checkAgg(cc);
          });
        });

        if (!rs._dataset._useSODA2) {
          if (needReq) {
            aggs = [];

            args.success = function (recAggs) {
              gotAggs(recAggs);
              gotAggs(_.map(recAggs, function (ra) {
                return {
                  columnIdent: ra.fieldName,
                  name: ra.name,
                  value: ra.value
                };
              }));
              callResults();
            };

            rs.makeRequest(args);
          } else {
            callResults();
          }
        }
      }

      if (soda2Aggs.length > 0) {
        var sel = _.map(soda2Aggs, function (a) {
          return a.method + '(' + a.column + ')';
        }).join(',');

        rs.makeRequest({
          params: {
            '$select': sel
          },
          success: function success(resp) {
            gotAggs(_.map(resp[0], function (v, k) {
              var i = k.indexOf('_');
              return {
                columnIdent: k.slice(i + 1),
                name: blist.datatypes.aggregateFromSoda2(k.slice(0, i)),
                value: v
              };
            }));
            callResults();
          }
        });
      } else if (rs._dataset._useSODA2) {
        callResults();
      }
    },
    activate: function activate() {
      var rs = this;
      rs._isActive = true;
      rs.trigger('row_change', [_.values(rs._rows), true]);

      _.defer(function () {
        rs.trigger('row_count_change');
      });
    },
    deactivate: function deactivate() {
      this._isActive = false;
      var pending = this._pendingRowReqs;
      this._pendingRowReqs = []; // Tell pending requests they are being cancelled

      _.each(pending, function (p) {
        if (_.isFunction(p.errorCallback)) {
          p.errorCallback({
            cancelled: true
          });
        }
      });

      delete this._curMetaReq;
      delete this._curMetaReqMeta;
      this.trigger('row_change', [_.values(this._rows), true]);
    },
    invalidate: function invalidate(rowCountChanged, columnsChanged) {
      var invRows = _.values(this._rows);

      this._rows = {};
      this._rowsLoading = {};
      var pending = this._pendingRowReqs;
      this._pendingRowReqs = []; // Tell pending requests they are being cancelled

      _.each(pending, function (p) {
        if (_.isFunction(p.errorCallback)) {
          p.errorCallback({
            cancelled: true
          });
        }
      });

      delete this._curMetaReq;
      delete this._curMetaReqMeta;
      this._rowIDLookup = {};
      this._loadedCount = 0;
      this._isComplete = false;
      delete this._aggCache;

      if (rowCountChanged) {
        delete this._totalCount;
      }

      if (columnsChanged) {
        this._columnsInvalid = true;
      }

      _.each(this._dataset.columns || [], function (c) {
        c.invalidateData();
      });

      this.trigger('row_change', [invRows, true]);
    },
    invalidateMeta: function invalidateMeta() {
      this._rerequestMeta = true;
    },
    formattingChanged: function formattingChanged(condFmt) {
      var rs = this;

      var format = condFmt || $.subKeyDefined(rs, '_dataset.metadata.conditionalFormatting') && rs._dataset.metadata.conditionalFormatting;

      if (!_.isArray(format)) {
        rs._condFmt = null;
      } else {
        rs._condFmt = _.map(format, function (c) {
          return $.extend({}, c, {
            matches: blist.filter.matchesExpression(c.condition, rs._dataset)
          });
        });
      }

      _.each(rs._rows, function (r) {
        rs._setRowFormatting(r);
      });
    },
    lookupsChanged: function lookupsChanged(lookupMap) {
      var rs = this;

      _.each(rs._rows, function (row) {
        _.each(lookupMap, function (newLookup, oldLookup) {
          _.each(['data', 'changed', 'error', 'invalid'], function (subdatum) {
            row[subdatum][newLookup] = row[subdatum][oldLookup];
          });
        });
      });
    },
    canDerive: function canDerive(otherQ) {
      return canDeriveExpr(addParents(this._jsonQuery.where, true), addParents(otherQ.where, true)) && canDeriveExpr(addParents(this._jsonQuery.having, true), addParents(otherQ.having, true)) && _.isEqual(this._jsonQuery.group, otherQ.group);
    },
    makeRequest: function makeRequest(args) {
      // Always get federated datasets cross-domain
      args.headers = $.extend(args.headers, {
        'X-Socrata-Federation': 'Honey Badger'
      });
      var rs = this; // Adding $$query_timeout_seconds to the NBE search request. This parameter has no effect on, and is
      // harmless to send on OBE queries. We're adding it here due to EN-10852 in order to limit the amount
      // of time the database allows in-dataset-search queries to run before being terminated.
      // The TTL for these queries can be controlled by setting inDatasetSearchQueryTimeoutSeconds which is
      // derived from the "nbe_query_timeouts" domain configuration using the "in_dataset_search" property.

      if ($.deepGet(rs, '_dataset', 'metadata', 'inDatasetSearch') === true) {
        args.params.$$query_timeout_seconds = $.deepGet(blist, 'configuration', 'inDatasetSearchQueryTimeoutSeconds') || 30;
      }

      if (rs._dataset._useSODA2) {
        rs._makeSODA2Request(args);
      } else {
        if (args.inline) {
          var d;

          if (!$.isBlank(args.data)) {
            d = _.isString(args.data) ? JSON.parse(args.data) : args.data;
          } else {
            d = rs._dataset.cleanCopy();
          }

          if (!_.isEmpty(rs._query)) {
            d.query = d.query || {};
            d.query.orderBys = rs._query.orderBys;
            d.query.groupBys = rs._query.groupBys;
            d.query.filterCondition = rs._query.filterCondition;
          }

          if ($.subKeyDefined(d, 'metadata.jsonQuery.select')) {
            _.each(d.metadata.jsonQuery.select, function (s) {
              var col = _.find(d.columns, function (c) {
                s.columnFieldName === c.fieldName;
              });

              if ($.isBlank(col)) {
                return;
              }

              if (col instanceof Column) {
                col = col.cleanCopy();
              }

              if (!$.isBlank(s.aggregate)) {
                col.format = col.format || {};
                col.format.grouping_aggregate = blist.datatypes.aggregateFromSoda2(s.aggregate);
              }
            });
          }

          args.data = JSON.stringify(d);
        }

        rs._dataset.makeRequest(args);
      }
    },
    _generateQueryParams: function _generateQueryParams(args) {
      var rs = this;

      if (_.isUndefined(args)) {
        args = {};
      }

      if ($.isBlank(this._dataset._queryBase)) {
        throw new Error('Please ensure that <Dataset>.getQueryBase() is called before ' + 'attempting to call <RowSet>._generateQueryParams().');
      }

      var params = args.params || {};
      var baseQuery = rs._dataset._queryBase.metadata.jsonQuery;
      var hasGroups = !_.isEmpty(rs._jsonQuery.group);
      var hasBaseQueryGroups = !_.isEmpty(baseQuery.group);
      var baseQueryIsQuery = rs._dataset.id === rs._dataset._queryBase.id; // Need to take the difference from queryBase, and adjust columns if necessary

      var adjSearchString = rs._jsonQuery.search === baseQuery.search ? '' : rs._jsonQuery.search;

      if (!$.isBlank(adjSearchString)) {
        params.$search = adjSearchString;
      }

      if (!_.isEmpty(rs._jsonQuery.where)) {
        // Can't apply a where on top of a true base query group by
        if (!hasBaseQueryGroups || baseQueryIsQuery && hasBaseQueryGroups) {
          var soqlWhere = '';
          var where = blist.filter.generateSOQLWhere(rs._jsonQuery.where, rs._dataset);
          var baseWhere = blist.filter.generateSOQLWhere(baseQuery.where, rs._dataset._queryBase);
          var hasWhere = !_.isEmpty(where);
          var hasBaseWhere = !_.isEmpty(baseWhere); // If we have a multiple possible where's
          // we simply join them with an AND, as opposed
          // to using subtractQueries.

          if (hasWhere && hasBaseWhere) {
            soqlWhere = where + ' and ' + baseWhere;
          } else if (hasBaseWhere) {
            soqlWhere = baseWhere;
          } else if (hasWhere) {
            soqlWhere = where;
          } // This is a cheat. Maps NBE interface. Appending viewport.


          if ($.isPresent(rs._jsonQuery.where.soql)) {
            if (soqlWhere.length > 0) {
              soqlWhere += ' and ';
            }

            soqlWhere += rs._jsonQuery.where.soql;
          }

          params.$where = !$.isBlank(params.$where) ? params.$where + ' and ' + soqlWhere : soqlWhere;
        }
      }

      if (!_.isEmpty(rs._jsonQuery.having)) {
        var soqlHaving = '';
        var having = blist.filter.generateSOQLWhere(rs._jsonQuery.having, rs._dataset);
        var baseHaving = blist.filter.generateSOQLWhere(baseQuery.having, rs._dataset._queryBase);
        var hasHaving = !_.isEmpty(having);
        var hasBaseHaving = !_.isEmpty(baseHaving);

        if (hasHaving && hasBaseHaving) {
          soqlHaving = having + ' and ' + baseHaving;
        } else if (hasBaseHaving) {
          soqlHaving = baseHaving;
        } else if (hasHaving) {
          soqlHaving = having;
        }

        params.$having = !$.isBlank(params.$having) ? params.$having + ' and ' + soqlHaving : soqlHaving;
      } // If queryBase has any group bys, we can't add more


      if (hasGroups && !hasBaseQueryGroups || hasGroups && hasBaseQueryGroups && baseQueryIsQuery) {
        var soqlGroup = [];
        var groupSelect = [];

        _.each(rs._jsonQuery.group, function (gb) {
          var qbCF = Dataset.translateColumnToQueryBase(gb.columnFieldName, rs._dataset);

          if ($.isBlank(qbCF)) {
            return;
          }

          if ($.isBlank(gb.groupFunction)) {
            soqlGroup.push(qbCF);
            groupSelect.push(qbCF);
          } else {
            var k = qbCF + '__' + gb.groupFunction;
            soqlGroup.push(k);
            groupSelect.push(gb.groupFunction + '(' + qbCF + ') as ' + k);
          }
        });

        soqlGroup = _.uniq(soqlGroup).join(',');
        params.$group = !$.isBlank(params.$group) ? params.$group + ',' + soqlGroup : soqlGroup;
        groupSelect = _.uniq(groupSelect.concat(_.compact(_.map(rs._jsonQuery.select, function (s) {
          if (!$.isBlank(s.aggregate)) {
            var qbCF = Dataset.translateColumnToQueryBase(s.columnFieldName, rs._dataset);

            if ($.isBlank(qbCF)) {
              return null;
            }

            return rs._soqlFnCall(s.aggregate, qbCF);
          }

          return null;
        })))).join(',');
        var sel = (params.$select || '').replace(/:\*,\*/, '');
        params.$select = !$.isBlank(sel) ? sel + ',' + groupSelect : groupSelect;
      }

      if (!_.isEmpty(rs._jsonQuery.order)) {
        var selectCols = _.reject((params.$select || '').split(','), _.isEmpty).map($.trim),
            selectingAllCols = _.isEmpty(selectCols) || _.includes(selectCols, '*'); // Just apply all orderBys, because they can safely be applied on top without harm


        params.$order = _.compact(_.map(rs._jsonQuery.order, function (ob) {
          var orderByColumn = rs._dataset.columnForIdentifier(ob.columnFieldName);

          if ($.isBlank(orderByColumn)) {
            return null;
          }

          var qbC = Dataset.translateColumnToQueryBase(orderByColumn, rs._dataset);

          if ($.isBlank(qbC)) {
            return null;
          }

          var aggregateFn = Dataset.aggregateForColumn(qbC.fieldName, rs._jsonQuery);
          var aggregateFieldName = qbC.fieldNameForRollup(aggregateFn);

          var aggregateFieldNameWithAlias = rs._soqlFnCall(aggregateFn, qbC.fieldName);

          if (!(selectingAllCols || _.includes(selectCols, ob.columnFieldName) || _.includes(selectCols, aggregateFieldNameWithAlias))) {
            return null;
          }

          return aggregateFieldName + (ob.ascending ? '' : ' desc');
        })).join(',');
      }

      if (args.sortOrderForRequest === 'reversed') {
        var orderBys = params.$order.split(',');
        params.$order = orderBys.map(function (orderBy) {
          if (_.endsWith(orderBy, ' desc')) {
            return orderBy.split(' ')[0]; // desc -> asc
          } else {
            return orderBy + ' desc'; // asc -> desc
          }
        }).join(',');
      }

      return params;
    },
    _makeSODA2Request: function _makeSODA2Request(args) {
      var rs = this;

      if ($.isBlank(rs._dataset._queryBase)) {
        rs._dataset.getQueryBase(function () {
          rs._makeSODA2Request(args);
        });

        return;
      }

      var viewId = this._dataset.nbe_view_id || this._dataset._queryBase.id;
      args.isSODA = true;
      args.url = args.url || "/api/id/".concat(viewId, ".json");
      args.params = this._generateQueryParams(args);

      rs._dataset.makeRequest(args);
    },
    clone: function clone() {
      return new RowSet(this._dataset, this._jsonQuery, this._query, this._parent);
    },
    _soqlFnCall: function _soqlFnCall(fn, field) {
      return fn + '(' + field + ') as ' + fn + '_' + field;
    },
    _loadRows: function _loadRows(startOrIds, len, options, successCallback, errorCallback) {
      var rs = this;
      options = options || {};
      var includeMeta = options.includeMeta;
      var fullLoad = options.fullLoad;
      var sortOrderForRequest = options.sortOrderForRequest;
      var params = rs._dataset.newBackend ? {
        $select: ':*,*'
      } : rs._dataset._useSODA2 ? {
        $$exclude_system_fields: false
      } : {
        method: 'getByIds',
        asHashes: true
      };
      var start;

      if (_.isNumber(startOrIds) && _.isNumber(len)) {
        start = startOrIds;
        $.extend(params, rs._dataset._useSODA2 ? {
          $offset: start,
          $limit: len
        } : {
          start: start,
          length: len
        });

        if (sortOrderForRequest === 'reversed' && _.isNumber(rs._totalCount)) {
          params.$offset = rs._totalCount - (start + len);
        }
      } else if (_.isArray(startOrIds)) {
        if (rs._dataset._useSODA2) {
          params.$where = 'any_of(:id,' + startOrIds.join(',') + ')';
        } else {
          params.ids = startOrIds;
        }
      } else {
        if (_.isFunction(errorCallback)) {
          errorCallback({
            message: 'Missing start and length, or ids'
          });
        }

        return;
      }

      var reqData = rs._dataset.cleanCopy();

      if (!_.isEmpty(rs._query)) {
        reqData.query = reqData.query || {};
        reqData.query.orderBys = rs._query.orderBys;
        reqData.query.groupBys = rs._query.groupBys;
        reqData.query.filterCondition = rs._query.filterCondition;
      }

      if ((fullLoad || (includeMeta || $.isBlank(rs._totalCount) || rs._columnsInvalid) && !_.isEqual(reqData, rs._curMetaReqMeta)) && !rs._dataset._useSODA2) {
        params.meta = true;
      }

      if ($.isBlank(rs._totalCount) && rs._dataset._useSODA2) {
        params.$$row_count = 'approximate';
      } // really gives the exact count


      var reqId = _.uniqueId();

      var rowsLoaded = function rowsLoaded(result, ___, xhr) {
        if (sortOrderForRequest === 'reversed') {
          result.reverse();
        }

        if (len && !$.isBlank(start)) {
          // Mark all rows as not in-process
          for (var rowIndex = 0; rowIndex < len; rowIndex++) {
            delete rs._rowsLoading[rowIndex + start];
          }
        }

        var oldCount = rs._totalCount;

        if (!$.isBlank(result.meta)) {
          // If another meta request started while this was loading, then
          // skip this one, and only use the latest
          if (rs._curMetaReq !== reqId) {
            if (_.isFunction(errorCallback)) {
              _.defer(function () {
                errorCallback({
                  cancelled: true
                });
              });
            }

            return;
          }

          delete rs._curMetaReq;
          delete rs._curMetaReqMeta;
          rs._totalCount = result.meta.totalRows;
          delete rs._potentialBuckets;
          delete rs._columnsInvalid;
          var metaToUpdate;

          if (rs._dataset._useSODA2) {
            metaToUpdate = {
              columns: result.meta.view.columns
            }; // If we're grouped, then filter out fake columns

            if (rs._dataset.isGrouped()) {
              metaToUpdate.columns = _.reject(metaToUpdate.columns, function (c) {
                if ($.subKeyDefined(c, 'format.grouping_aggregate')) {
                  return true;
                } // Is it a group function column?


                var indexOfGroupingCol = c.fieldName.indexOf('__');

                var realC = rs._dataset.columnForFieldName(c.fieldName.slice(0, indexOfGroupingCol));

                return !$.isBlank(realC) && realC.format.group_function === blist.datatypes.groupFunctionFromSoda2(c.fieldName.slice(indexOfGroupingCol + 2));
              });
            }
          } else {
            metaToUpdate = result.meta.view;
          }

          if (!fullLoad && !rs._dataset._useSODA2) {
            // I would rather get rid of triggering a metadata_update
            // all the time, since if this isn't a full load, I don't
            // think any relevant metadata has changed. But various UI
            // already depends on events triggered from a metadata
            // update, so we're stuck with this for the moment.
            // Mitigate race conditions by using the current version of
            // data on the dataset for items that are known to cause
            // problems
            metaToUpdate.query.filterCondition = rs._dataset.query.filterCondition;

            if (!$.isBlank(rs._dataset.query.namedFilters)) {
              metaToUpdate.query.namedFilters = rs._dataset.query.namedFilters;
            }

            metaToUpdate.metadata = rs._dataset.metadata;
          }

          rs.trigger('metadata_update', [metaToUpdate, !rs._dataset._useSODA2, !rs._dataset._useSODA2]);
        } else if (rs._dataset._useSODA2) {
          // In SODA2 we get basic columns back in the header
          var rowCount = JSON.parse(xhr.getResponseHeader('X-SODA2-Row-Count') || 'null');

          if (_.isNumber(rowCount)) {
            rs._totalCount = rowCount;
            delete rs._potentialBuckets;
          }

          var fields = JSON.parse(xhr.getResponseHeader('X-SODA2-Fields'));
          var types = JSON.parse(xhr.getResponseHeader('X-SODA2-Types') || '[]') || [];

          var newCols = _.map(fields, function (field, index) {
            var col = rs._dataset.findColumnForServerName(field);

            if ($.isBlank(col)) {
              if (field.startsWith(':')) {
                // metadata column, add it
                col = {
                  id: -1,
                  name: field.slice(1),
                  fieldName: field,
                  dataTypeName: 'meta_data',
                  renderTypeName: 'meta_data'
                };
              } else {
                // uh-oh, a column we don't know about
                $.debug('!!!!!!!!!!!! Unknown column: ' + field);
              }
            } else if (blist.datatypes[types[index]]) {
              col.dataTypeName = types[index];
              col.renderTypeName = types[index];
            }

            return col;
          });

          var hasSystemIDColumn = _.some(newCols, function (c) {
            return c && c.fieldName === ':id';
          });

          var hasIDColumn = !$.isBlank(rs._dataset.metaColumnForName('id'));

          if (!hasSystemIDColumn && !hasIDColumn) {
            newCols.push({
              id: -1,
              name: 'id',
              fieldName: ':id',
              dataTypeName: 'meta_data',
              renderTypeName: 'meta_data'
            });
          }

          newCols = _.compact(newCols);
          rs.trigger('metadata_update', [{
            columns: newCols
          }, false, true]);
        } else if ($.isBlank(rs._totalCount)) {
          // If we loaded without meta but don't have meta available, bail
          if (_.isFunction(errorCallback)) {
            _.defer(function () {
              errorCallback({
                cancelled: true
              });
            });
          }

          return;
        }

        var rows; // If this result is marked pending, then we got no data, and we need
        // placeholder rows

        if (result.pending && len && !$.isBlank(start)) {
          rows = [];
          var oldRows = []; // Make them expire after a short time, which will force a reload
          // the next time something wants to render them

          var expires = new Date().getTime() + 30000;

          for (var idx = 0; idx < len; idx++) {
            var newRow = {
              invalid: {},
              error: {},
              changed: {},
              index: idx + start,
              pending: true,
              expires: expires,
              id: 'pending_' + _.uniqueId()
            }; // If an existing row, clean it out

            if (!$.isBlank(rs._rows[newRow.index])) {
              var oldRow = rs._rows[newRow.index];
              oldRows.push(oldRow);
              delete rs._rowIDLookup[oldRow.id];
            }

            rs._rows[newRow.index] = newRow;
            rs._rowIDLookup[newRow.id] = newRow;
            rows.push(newRow);
          }

          if (oldRows.length > 0) {
            rs.trigger('row_change', [oldRows, true]);
          }
        } else {
          // Normal load
          rows = rs._addRows(result.data || result, start);
        }

        if (oldCount !== rs._totalCount) {
          rs.trigger('row_count_change');
        }

        if (!rs._isActive) {
          if (_.isFunction(errorCallback)) {
            _.defer(function () {
              errorCallback({
                cancelled: true
              });
            });
          }

          return;
        }

        if (_.isFunction(successCallback)) {
          successCallback(rows);
        }

        var pending = rs._pendingRowReqs;
        rs._pendingRowReqs = [];

        _.each(pending, function (p) {
          rs.getRows(p.start, p.length, p.successCallback, p.errorCallback);
        });

        if (rs._dataset.hasBlobColumns()) {
          rs._dataset.resyncFileDataForFileIds();
        }
      }; // end of rowsLoaded callback function


      if (len && !$.isBlank(start)) {
        // Keep track of rows that are being loaded
        for (var i = 0; i < len; i++) {
          rs._rowsLoading[i + start] = true;
        }
      } // Always be sorting by something to provide a stable row order.
      // Don't try this when there's a group-by because :id is no longer guaranteed.


      if (_.isEmpty(rs._jsonQuery.order) && _.isEmpty(rs._jsonQuery.group)) {
        params.$order = ':id';
      }

      if (params.$offset) {
        params.$offset = Math.max(0, params.$offset);
      } // TODO: CORE-1794: The correct fix is changing the ETag in the backend, but
      // that won't happen anytime soon and a customer wants this and the only impact
      // should be client-side repeated fetches for the same set of rows.


      if ($.browser.safari && !rs._dataset._useSODA2) {
        params.safariCacheBust = Math.random().toString().slice(2);
      }

      var req = {
        success: rowsLoaded,
        params: params,
        inline: !rs._dataset._useSODA2 && !fullLoad,
        type: rs._dataset._useSODA2 || fullLoad ? 'GET' : 'POST'
      };

      if (!rs._dataset._useSODA2 && fullLoad) {
        req.url = '/views/' + rs._dataset.id + '/rows.json';
      }

      if (params.meta) {
        rs._curMetaReq = reqId;
        rs._curMetaReqMeta = reqData;
      }

      if (rs._dataset._useSODA2 && $.parseParams().$$store) {
        req.params.$$store = $.parseParams().$$store;
      }

      req.sortOrderForRequest = sortOrderForRequest;
      rs.makeRequest(req);
    },
    _addRows: function _addRows(newRows, start, skipTranslate) {
      var rs = this;
      var adjRows = [];
      var oldRows = [];
      var hasIndex = !$.isBlank(start);

      _.each(newRows, function (r, i) {
        var newRow = skipTranslate ? r : RowSet.translateRow(r, rs._dataset, rs);
        var ind;

        if (hasIndex) {
          ind = start + i;
        } // If a row already exists at this index, clean it out


        var oldRow;

        if (hasIndex) {
          if (!$.isBlank(rs._rows[ind]) && ($.isBlank(newRow) || newRow.id !== rs._rows[ind].id)) {
            oldRow = rs._rows[ind];
            oldRows.push(oldRow);
            delete rs._rows[ind];
            delete rs._rowIDLookup[oldRow.id];
            rs._loadedCount--;
          }
        } else {
          oldRow = rs._rowIDLookup[newRow.id];

          if (!$.isBlank(oldRow)) {
            oldRows.push(oldRow);
            delete rs._rowIDLookup[oldRow.id];
            rs._loadedCount--;
          }
        }

        if ($.isBlank(newRow)) {
          return;
        }

        if (hasIndex) {
          newRow.index = ind;
          rs._rows[newRow.index] = newRow;
        }

        rs._rowIDLookup[newRow.id] = newRow;
        rs._loadedCount++;
        adjRows.push(newRow);
      });

      rs._isComplete = rs._totalCount === rs._loadedCount;

      if (oldRows.length > 0) {
        rs.trigger('row_change', [oldRows, true]);
      }

      return adjRows;
    },
    _doesBelong: function _doesBelong(row) {
      // If is grouped, assume where matches, since that is processed pre-aggregate.
      // But always evaluate having
      return (this._dataset.isGrouped() ? true : this._matchesExpr.where(row)) && this._matchesExpr.having(row);
    },
    _calculateAggregate: function _calculateAggregate(cId, aggName) {
      var rs = this;

      var col = rs._dataset.columnForIdentifier(cId);

      if ($.isBlank(col)) {
        return null;
      }

      var agg = _.find(col.renderType.aggregates, function (a) {
        return blist.datatypes.aggregateFromSoda2(a.value) === aggName;
      });

      if ($.isBlank(agg)) {
        return null;
      }

      var valuesForRows = function valuesForRows(rows) {
        var processRows = function processRows(memo, row) {
          if (row.invalid[col.lookup] !== true) {
            memo.push(row.data[col.lookup]);
          }

          return memo;
        };

        return _.reduce(rows, processRows, []);
      };

      return agg.calculate(valuesForRows(rs._rows));
    },
    _setRowFormatting: function _setRowFormatting(row) {
      // This reads metadata.conditionalFormatting, which is an ordered
      // array of conditions & colors. The row will get the color of the
      // first condition that it matches, or no color if it matches none
      // of them.
      // metadata.conditionalFormatting is an array. Each entry is an object
      // with two keys: color and condition.
      // * color: String of CSS color, such as '#ffffff' or
      //          'rgba(255, 255, 255, 1)'
      // * condition: Can be true, in which case any row will match this
      //          condition. This is a good way to make a default as the
      //          last item in the list. Otherwise it is an object. In the basic
      //          case, this has three keys:
      //   * tableColumnId: Identifies a column to look up the cell value in this
      //          row to use for comparision
      //   * subColumn: Identifies a sub-column to check for a value
      //   * operator: How to do the comparison; operators available are the same
      //          as for filter conditions
      //   * value: Value to compare against
      //   Alternately, you can have more complex expressions by providing
      //   a key of children which has an array of condition objects.
      //   In this case, operator is still required, but should be either
      //   'and' or 'or' to control how the multiple conditions are combined
      //
      // Simple example to mark rows that have too high a measurement, too low,
      // or within range:
      // metadata.conditionalFormatting: [
      //   {
      //     color: '#ff9999',
      //     condition: {
      //       tableColumnId: 123,
      //       operator: 'greater_than',
      //       value: 100
      //     }
      //   },
      //   {
      //     color: '#9999ff',
      //     condition: {
      //       tableColumnId: 123,
      //       operator: 'less_than',
      //       value: 20
      //     }
      //   },
      //   {
      //     color: '#99ff99',
      //     condition: true
      //   }
      // ]
      var rs = this; // First clear color & icon, as they will be set properly later

      row.color = row.icon = null;

      if (!_.isArray(rs._condFmt)) {
        return null;
      }

      var relevantCondition = _.find(rs._condFmt, function (c) {
        return c.matches(row);
      }) || {};

      if (relevantCondition.color) {
        row.color = relevantCondition.color;
      }

      if (relevantCondition.icon) {
        row.icon = relevantCondition.icon;
      }
    }
  });

  RowSet.translateRow = function (r, dataset, rowSet, parCol, skipMissingCols) {
    var adjVals = {
      invalid: {},
      changed: {},
      error: {},
      sessionMeta: {},
      data: {},
      metadata: {}
    };

    if (_.some(r, function (val, id) {
      var newVal = val;
      var c = dataset.findColumnForServerName(id, parCol);

      if ($.isBlank(c)) {
        return !skipMissingCols;
      }

      if (c.isMeta && c.name === 'meta' && _.isString(newVal)) {
        newVal = JSON.parse(newVal || 'null');
      }

      if ($.isPlainObject(newVal)) {
        // First, convert an empty array into a null
        // Booleans in the array don't count because location type
        // has a flag that may be set even if there is no data.  If
        // some type actually cares about only having a boolean,
        // this will need to be made more specific
        if (_.every(newVal, function (v) {
          return $.isBlank(v) || _.isBoolean(v);
        })) {
          newVal = null;
        }
      }

      if (dataset._useSODA2 && $.subKeyDefined(c, 'renderType.fromSoQLValue')) {
        newVal = c.renderType.fromSoQLValue(newVal, c);
      }

      if (c.renderTypeName === 'checkbox' && newVal === false || c.renderTypeName === 'stars' && newVal === 0) {
        newVal = null;
      }

      if (c.renderTypeName === 'geospatial' && r[dataset._useSODA2 ? ':id' : 'sid']) {
        newVal = $.extend({}, newVal, {
          row_id: r[dataset._useSODA2 ? ':id' : 'sid']
        });
      }

      if (!_.isUndefined(newVal)) {
        adjVals.data[c.lookup] = newVal;

        if (c.isMeta) {
          adjVals.metadata[c.lookup.startsWith(':') ? c.lookup.slice(1) : c.lookup] = newVal;
        }
      }

      return false;
    })) {
      return null;
    }

    if ($.isBlank(adjVals.metadata.id)) {
      // Have to make up an id
      adjVals.metadata.id = 'jsrowid-' + _.uniqueId();
      var metaColumn = dataset.metaColumnForName('id');

      if (!$.isBlank(metaColumn)) {
        adjVals.data[metaColumn.lookup] = adjVals.metadata.id;
      }
    }

    adjVals.id = adjVals.metadata.id;

    _.each((adjVals.metadata.meta || {}).invalidCells || {}, function (v, cId) {
      if (!$.isBlank(v)) {
        var childColumn = !$.isBlank(parCol) ? parCol.childColumnForIdentifier(cId) : dataset.columnForIdentifier(cId);

        if (!$.isBlank(childColumn) && $.isBlank(adjVals.data[childColumn.lookup])) {
          adjVals.invalid[childColumn.lookup] = true;
          adjVals.data[childColumn.lookup] = v;
        }
      }
    });

    delete (adjVals.metadata.meta || {}).invalidCells;

    _.each((dataset._commentLocations || {})[adjVals.id] || {}, function (v, tcId) {
      var column = dataset.columnForTCID(tcId);

      if (!$.isBlank(column)) {
        adjVals.annotations = adjVals.annotations || {};
        adjVals.annotations[column.lookup] = 'comments';
      }
    });

    if (!$.isBlank(rowSet)) {
      rowSet._setRowFormatting(adjVals);

      if ($.subKeyDefined(dataset, 'highlights.' + adjVals.id)) {
        rowSet.markRow('highlight', true, adjVals);
      }
    }

    return adjVals;
  };

  RowSet.getQueryKey = function (query) {
    return getSortKey(query.order) + '/' + getGroupKey(query.group) + '/' + blist.filter.getFilterKey(query.where) + '/' + blist.filter.getFilterKey(query.having) + '/' + getSelectKey(query.select) + '/' + query.search;
  };

  function getSortKey(ob) {
    if (_.isEmpty(ob)) {
      return '';
    }

    return '(' + _.map(ob, function (o) {
      return o.columnFieldName + ':' + o.ascending;
    }).join('|') + ')';
  }

  function getGroupKey(gb) {
    if (_.isEmpty(gb)) {
      return '';
    }

    return '(' + _.map(_.sortBy(gb, 'columnFieldName'), function (g) {
      return g.columnFieldName + ':' + g.groupFunction;
    }).join('|') + ')';
  }

  function getSelectKey(selects) {
    if (_.isEmpty(selects)) {
      return '';
    }

    return '(' + _.map(_.sortBy(selects, 'columnFieldName'), function (s) {
      return s.columnFieldName + ':' + s.aggregate;
    }).join('|') + ')';
  }

  function addParents(fc, safe) {
    if (safe) {
      fc = $.extend(true, {}, fc);
    }

    _.each(fc.children, function (c) {
      c._parent = fc;
      addParents(c);
    });

    return fc;
  }

  function canDeriveExpr(baseFC, otherFC) {
    if (_.isEmpty(baseFC)) {
      return true;
    }

    if (_.isEmpty(otherFC)) {
      return false;
    } // Find all leaves in both, and try to match them up on:
    // value, columnFieldName, tableColumnId, operator, subColumn (actually by key)


    var curLeaves = [];

    var processLeaves = function processLeaves(expr) {
      if (_.isArray(expr.children)) {
        _.each(expr.children, processLeaves);
      } else {
        if ($.isBlank(expr._key)) {
          expr._key = blist.filter.getFilterKey(expr);
        }

        curLeaves.push(expr);
      }
    };

    processLeaves(baseFC);
    var leftoverLeaves = [];
    var parDeriveCache = {};

    var processOther = function processOther(expr) {
      if (_.isArray(expr.children)) {
        var leftoverChildren = _.filter(expr.children, processOther); // If all children are added, then just add this expr, not each child


        if (leftoverChildren.length === expr.children.length) {
          return true;
        } else if (leftoverChildren.length > 0) {
          leftoverLeaves = leftoverLeaves.concat(leftoverChildren);
          return false;
        } // If all children matched, then check parents

      }

      if ($.isBlank(expr._key)) {
        expr._key = blist.filter.getFilterKey(expr);
      }

      var matchExpr;
      curLeaves = _.reject(curLeaves, function (cl) {
        // If we found a matching leaf, make sure the parents of each have
        // the proper relationship
        if (cl._key === expr._key) {
          var parMatch = cl._parent === baseFC && expr._parent === otherFC && baseFC.operator === otherFC.operator || $.isBlank(cl._parent) && $.isBlank(expr._parent) || $.isBlank(cl._parent) && expr._parent.operator.toLowerCase() === 'and' || $.isBlank(expr._parent) && cl._parent.operator.toLowerCase() === 'or';
          var k;

          if (!parMatch) {
            if ($.isBlank(cl._parent) || $.isBlank(expr._parent) || cl._parent.operator !== expr._parent.operator) {
              return false;
            }

            if ($.isBlank(cl._parent._key)) {
              cl._parent._key = blist.filter.getFilterKey(cl._parent);
            }

            if ($.isBlank(expr._parent._key)) {
              expr._parent._key = blist.filter.getFilterKey(expr._parent);
            }

            k = cl._parent._key + '::' + expr._parent._key;

            if ($.isBlank(parDeriveCache[k])) {
              parDeriveCache[k] = canDeriveExpr(cl._parent, expr._parent);
            }
          }

          if (parMatch || parDeriveCache[k]) {
            matchExpr = cl;
            return true;
          }
        }

        return false;
      });
      return $.isBlank(matchExpr);
    }; // If none of the leaves in otherQ matched, filter condition is completely different


    if (processOther(otherFC)) {
      return false;
    } // Reduce each set to highest common expr that completely changed
    // Combine removed items into higher-level ops if possible


    var reduceNodes = function reduceNodes(nodes) {
      var result = [];
      var madeChange = false;

      while (nodes.length > 0) {
        var n = nodes[0];

        if ($.isBlank(n._parent)) {
          result.push(nodes.shift());
          continue;
        }

        var p = n._parent;
        var found = [];
        nodes = _.reject(nodes, function (nn) {
          if (nn._parent === p) {
            found.push(nn);
            return true;
          }

          return false;
        });

        if (found.length === p.children.length) {
          result.push(p);
          madeChange = true;
        } else {
          result = result.concat(found);
        }
      }

      return madeChange ? reduceNodes(result) : result;
    };

    curLeaves = reduceNodes(curLeaves); // Added operator under AND, removed under OR are good

    return _.every(curLeaves, function (cl) {
      return !$.isBlank(cl._parent) && cl._parent.operator.toLowerCase() === 'or';
    }) && _.every(leftoverLeaves, function (ll) {
      return $.isBlank(ll._parent) || ll._parent.operator.toLowerCase() === 'and';
    });
  }

  if (blist.inBrowser) {
    window.RowSet = RowSet;
  } else {
    module.exports = RowSet;
  }
})();

/***/ }),

/***/ 3005:
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
* Updated July 2019 to support jquery 3.4.1
* - pipe() is deprecated: https://jquery.com/upgrade-guide/3.0/#backwards-compatibility
*/
var SocrataViewDataProvider = __webpack_require__(750)["default"];

var SoqlDataProvider = __webpack_require__(80)["default"];

var _require = __webpack_require__(21),
    FeatureFlags = _require.FeatureFlags;

(function () {
  function reportRowSetError(errorMessage) {
    // There are many contexts in the legacy frontend codebase that will silently
    // swallow exceptions, so we need to console.error as well. :-(
    if (window.console && window.console.error) {
      console.error(errorMessage);
    }

    throw new Error(errorMessage);
  }
  /* Properties on Dataset:
       + displayType: from core server, this can be set by the client to tell the
          front-end how to render data.  Available values: 'calendar', 'chart',
          'map', 'form', 'api'
      + viewType: set by core server, this defines whether a dataset is tabular data,
          blobby data, or an href.  Possible values: 'tabular', 'blobby', 'href', 'geo'
      + type: set by this Model, it rolls up several pieces of data to give a simple
          type for the Dataset that code can check against.  Possible values:
          'blist', 'filter', 'grouped', 'chart', 'map', 'form', 'calendar',
          'blob', 'href', 'api'
      + styleClass: set by this Model, this can be set as a class on an HTML element
          to pick up styling for this type of Dataset
      + displayName: set by this Model, a displayable string that should used in the
          UI to indicate this item.  For example, it can be 'dataset',
          'filtered view', 'grouped view', etc.
       + temporary: True if the dataset has been modified and not saved
      + minorChange: Only valid when temporary is set.  If this is true, it is a
          minor update (such as a map viewport being changed) and doesn't
          really invalidate most actions like sharing, embedding, etc.
  */


  var Dataset = ServerModel.extend({
    _init: function _init(v) {
      this._super();

      this.registerEvent(['columns_changed', 'valid', 'query_change', 'set_temporary', 'clear_temporary', 'row_change', 'blob_change', 'row_count_change', 'column_resized', 'displayformat_change', 'displaytype_change', 'column_totals_changed', 'removed', 'permissions_changed', 'new_comment', 'reloaded', 'conditionalformatting_change', 'saved', 'dataset_last_modified', 'grid_error_message', 'query_string_change']);
      var ds = this; // Avoid overwriting functions with static values from Rails (e.g., totalRows)

      _.each(v, function (curVal, key) {
        if (!_.isFunction(ds[key])) {
          ds[key] = curVal;
        }
      });

      this._fileDataForFileId = {};

      if (!(blist.sharedDatasetCache[this.id] instanceof Dataset)) {
        blist.sharedDatasetCache[this.id] = this;
      }

      if (!$.isBlank(this.resourceName) && !(blist.sharedDatasetCache[this.resourceName] instanceof Dataset)) {
        blist.sharedDatasetCache[this.resourceName] = this;
      } // EN-6784 - Race condition in useSODA2 + column .lookup
      // We need to determine useSoda2 before we construct the columns for this dataset
      // because column creation actually uses that flag.


      this._determineUseSODA2(); // This ID really shouldn't be changing; if it does, this URL
      // will be out-of-date...


      var selfUrl = '/views/' + this.id;
      Dataset.addProperties(this, ColumnContainer('column', //eslint-disable-line new-cap
      selfUrl + '.json', selfUrl + '/columns'), $.extend({}, this));

      if (!$.isBlank(this.approvalHistory)) {
        Dataset.addProperties(this, Dataset.modules.approvalHistory, $.extend({}, this));
      }

      this.updateColumns(this.initialMetaColumns, false, true);
      delete this.initialMetaColumns;

      this._adjustProperties(); // Note: _useSODA2 is set in _adjustProperties.


      if (!_.isUndefined(this.rowIdentifierColumnId)) {
        this.rowIdentifierColumn = this.columnForID(this.rowIdentifierColumnId);
        this.rowsNeedPK = this.newBackend && this._useSODA2; // BASICALLY A TAUTOLOGY.
      }

      var originalQuery = this._getQueryGrouping();

      this._syncQueries(originalQuery.oldJsonQuery, originalQuery.oldQuery, originalQuery.oldGroupings, originalQuery.oldGroupAggs);

      this.temporary = false;
      this.minorChange = true;
      this.valid = this._checkValidity();

      if (FeatureFlags.value('prohibit_use_of_row_set')) {// noop
      } else {
        // We need an active row set to start
        var cleanFC = ds.cleanJsonFilters();
        ds._savedRowSet = new RowSet(ds, $.extend({}, ds.metadata.jsonQuery, {
          where: cleanFC.where,
          having: cleanFC.having,
          namedFilters: null
        }), {
          orderBys: (ds.query || {}).orderBys,
          filterCondition: ds.cleanFilters(),
          groupBys: (ds.query || {}).groupBys,
          groupFuncs: ds._getGroupedFunctions()
        }, null, ds.initialRows);
        delete ds.initialRows;

        ds._activateRowSet(ds._savedRowSet);
      }

      this._pendingRowEdits = {};
      this._pendingRowDeletes = {};
      this._aggregatesStale = true;
      this._origObj = this.cleanCopy();
      this._commentCache = {};
      this._commentByID = {}; // Set up Polaroid image capturing

      if (window._phantom) {
        console.log('Running in PhantomJS.');

        if (_.isFunction(window.callPhantom)) {
          this._setupPolaroidImageCapturing();
        } else {
          console.log('window.callPhantom not present, skipping image capture');
        }
      }

      this.bucketSize = 1000;
      this._totalRows = undefined;
      this.initializeDerivedViews2018Controls();
      this.maybeEnableOrDisableDerivedViews2018Controls();
    },
    isDefault: function isDefault() {
      return _.includes(this.flags || [], 'default');
    },
    isPublic: function isPublic() {
      var ds = this;
      return _.some(this.grants || [], function (grant) {
        return _.includes(grant.flags || [], 'public') && (ds.type == 'form' && grant.type == 'contributor' || ds.type != 'form');
      });
    },
    isPendingPublic: function isPendingPublic() {
      var ds = this;
      return _.some(this.pendingGrants || [], function (grant) {
        return _.includes(grant.flags || [], 'public') && (ds.type == 'form' && grant.type == 'contributor' || ds.type != 'form');
      });
    },
    isAnonymous: function isAnonymous(isAnon) {
      if (!$.isBlank(isAnon)) {
        this._isAnon = isAnon;
      }

      if ($.isBlank(this._isAnon)) {
        this._isAnon = false;
      }

      return this._isAnon;
    },
    hasRight: function hasRight(right) {
      return _.includes(this.rights, right);
    },
    canEdit: function canEdit() {
      return (this.hasRight(blist.rights.view.WRITE) || this.hasRight(blist.rights.view.ADD) || this.hasRight(blist.rights.view.DELETE)) && !this.isGrouped() && !this.isAPI();
    },
    canUpdate: function canUpdate() {
      return (this.isUnpublished() || !this.isDefault()) && this.hasRight(blist.rights.view.UPDATE_VIEW);
    },
    isGrid: function isGrid() {
      return this.metadata.renderTypeConfig.visible.table;
    },
    // Checks to determine whether or not options such as calendar-create, map-create, or chart-config should be
    // visible. These options are only available if the availableDisplayTypes are a subset of
    // ['table', 'fatrow', 'page', 'assetinventory']
    shouldShowViewCreationOptions: function shouldShowViewCreationOptions() {
      return _.difference(this.metadata.availableDisplayTypes, ['table', 'fatrow', 'page', 'assetinventory']).length == 0;
    },
    isGrouped: function isGrouped() {
      return !_.isEmpty((this.metadata.jsonQuery || {}).group);
    },
    isFederated: function isFederated() {
      return !$.isBlank(this.domainCName);
    },
    getDownloadType: function getDownloadType() {
      if (!GeoHelpers.isGeoDataset(this) && !GeoHelpers.isGeoExportSupported(this)) {
        return 'normal';
      } else if (this.viewType === 'tabular') {
        return 'tabular_geo';
      } else {
        var backendPrefix = this.newBackend ? 'nbe_' : 'obe_';
        return backendPrefix + 'geo';
      }
    },
    isLayered: function isLayered() {
      //checks for layers as direct children
      if (GeoHelpers.isGeoDataset(this) && this.metadata.geo && typeof this.metadata.geo.layers === 'string' && this.metadata.geo.layers.split(',').length > 1) {
        return true;
      } //checks for layers from a separate dataset (derived views)


      if (this.displayFormat && this.displayFormat.viewDefinitions) {
        return _.some(this.displayFormat.viewDefinitions, function (viewDef) {
          return viewDef.uid != 'self';
        });
      }

      return false;
    },
    isApiGeospatial: function isApiGeospatial() {
      var customFields = _.merge(this.metadata || {}, this.privateMetadata || {}).custom_fields || {};
      return _.reduce(customFields, function (acc, fields, fieldset) {
        return acc || /^geo-?spatial api pre-?release$/i.test(fieldset) && (fields.Enabled || fields.enabled) === 'true';
      }, false);
    },
    isBlobby: function isBlobby() {
      return this.type == 'blob';
    },
    isHref: function isHref() {
      return this.type == 'href';
    },
    isDataLens: function isDataLens() {
      return this.displayType === 'data_lens';
    },
    isTabular: function isTabular() {
      return this.viewType == 'tabular';
    },
    isAPI: function isAPI() {
      return this.type == 'api';
    },
    isPublished: function isPublished() {
      return this.publicationStage == 'published';
    },
    isUnpublished: function isUnpublished() {
      return this.publicationStage == 'unpublished';
    },
    isSnapshot: function isSnapshot() {
      return this.publicationStage == 'snapshotted';
    },
    isImmutable: function isImmutable() {
      return this.isBlobby() || GeoHelpers.isGeoDataset(this);
    },
    renderWithArcGISServer: function renderWithArcGISServer() {
      // Render everything using ArcGIS Server since we can't preemptively tell
      // if something is more than 500 rows or not.
      return GeoHelpers.isArcGISDataset(this);
    },
    invalidMessage: function invalidMessage() {
      return this.message || $.t('controls.grid.required_cols_missing');
    },
    clean: function clean() {
      return cleanViewForSave(this);
    },
    save: function save(successCallback, errorCallback, allowedKeys) {
      var ds = this;

      if (!ds.hasRight(blist.rights.view.UPDATE_VIEW)) {
        return false;
      }

      var vizIds = $.isBlank(ds.visibleColumns) ? null : _.map(ds.visibleColumns, 'id');

      var dsSaved = function dsSaved(newDS) {
        // core always removes metadata.jsonQuery while frontend still depends on it.
        // This recreate metadata.jsonQuery from view.query
        var nds = createDatasetFromView(newDS);

        var originalQuery = nds._getQueryGrouping();

        nds._syncQueries(originalQuery.oldJsonQuery, originalQuery.oldQuery, originalQuery.oldGroupings, originalQuery.oldGroupAggs);

        if (FeatureFlags.value('prohibit_use_of_row_set')) {// noop
        } else {
          ds._savedRowSet = ds._activeRowSet;
        }

        ds._update(newDS, true, false, true);

        if (!$.isBlank(vizIds) && !_.isEqual(vizIds, _.map(ds.visibleColumns, 'id'))) {
          ds.setVisibleColumns(vizIds);
        }

        if (_.isFunction(successCallback)) {
          successCallback(ds);
        }

        ds.trigger('saved');
      };

      this.makeRequest({
        url: '/views/' + this.id + '.json',
        type: 'PUT',
        data: JSON.stringify(cleanViewForSave(ds, allowedKeys)),
        error: errorCallback,
        success: dsSaved
      });
      return true;
    },
    saveNew: function saveNew(useNBE, successCallback, errorCallback) {
      var urlParams = {
        nbe: useNBE
      };
      var deletedAt = $.urlParam(window.location.href, 'deleted_at');

      if (!_.isEmpty(deletedAt)) {
        urlParams.deleted_at = deletedAt;
      }

      var dsOrig = this;

      var dsCreated = function dsCreated(newDS) {
        newDS = createDatasetFromView(newDS);

        if (!$.isBlank(dsOrig.accessType)) {
          newDS.setAccessType(dsOrig.accessType);
        }

        if (_.isFunction(successCallback)) {
          successCallback(newDS);
        }
      };

      var ds = cleanViewForCreate(this); // Munge permissions for forms, since those don't get carried over
      // or inherited

      if (dsOrig.isPublic() && dsOrig.type == 'form') {
        ds.flags = ds.flags || [];
        ds.flags.push('dataPublicAdd');
      }

      this.makeRequest({
        url: '/views?' + $.toParam(urlParams),
        type: 'POST',
        data: JSON.stringify(ds),
        error: errorCallback,
        success: dsCreated
      });
    },
    update: function update(newDS, fullUpdate, minorUpdate, masterUpdate) {
      var ds = this; // If any updated key exists but is set to invalid, then we can't save
      // it on this dataset; so make minorUpdate false

      if (!_.isEqual(newDS, ds._cleanUnsaveable(newDS))) {
        minorUpdate = false;
      }

      var copyFunc = minorUpdate ? cleanViewForSave : cleanViewForCreate;
      var origCopy = copyFunc(this);

      this._update(newDS, fullUpdate, fullUpdate, masterUpdate);

      var updCopy = copyFunc(this);

      if (!_.isEqual(origCopy, updCopy)) {
        this._markTemporary(minorUpdate);
      } // EN-12888 - Don't Copy Parent Filters Into Child Grouped View
      //
      // See comment above the implementation of this function for details.


      maybeShowIncorrectGridPreviewNotice(origCopy, updCopy);
      this.maybeEnableOrDisableDerivedViews2018Controls();
    },

    /**
     * BEGIN: Functionality specific to Derived Views 2018 project
     */
    maybeEnableOrDisableDerivedViews2018Controls: function maybeEnableOrDisableDerivedViews2018Controls() {
      var forceUseOfModifyingLensIdInAllDerivedViews = _.get(window, 'socrata.featureFlags.force_use_of_modifying_lens_id_in_all_derived_views', false);

      if (forceUseOfModifyingLensIdInAllDerivedViews) {
        if (this.queryChanged()) {
          if (!this.isPublished()) {
            $('#save-view-button').removeClass('disabled');
          }

          $('#revert-view-button').removeClass('disabled');
          $('#create-view-button').addClass('disabled');
        } else {
          $('#save-view-button').addClass('disabled');
          $('#revert-view-button').addClass('disabled');
          $('#create-view-button').removeClass('disabled');
        }
      }
    },
    queryChanged: function queryChanged() {
      var viewDifference = this.differenceFromSavedView();

      var columnsWithMetadataChange = _.get(viewDifference, 'columns', []);

      return !_.isEmpty(columnsWithMetadataChange) || !_.isEmpty(_.get(viewDifference, 'query', {})) || !_.isEmpty(_.get(viewDifference, 'queryString', '')) || !_.isEmpty(_.get(viewDifference, 'searchString', '')) || !_.isEmpty(_.get(viewDifference, 'metadata.conditionalFormatting', {})) || !_.isEmpty(_.get(viewDifference, 'metadata.renderTypeConfig', {}));
    },
    differenceFromSavedView: function differenceFromSavedView() {
      // Generic 'give me a diff of two objects' implementation.
      // See: https://gist.github.com/Yimiprod/7ee176597fef230d1451
      var difference = function difference(outerObject, outerBase) {
        function changes(object, base) {
          return _.transform(object, function (result, value, key) {
            if (!_.isEqual(value, base[key])) {
              result[key] = _.isObject(value) && _.isObject(base[key]) ? changes(value, base[key]) : value;
            }
          });
        }

        return changes(outerObject, outerBase);
      };

      var currentView = this.cleanCopy();
      var viewDifference = difference(currentView, this._origObj);

      var actualColumnsDifference = _.get(viewDifference, 'columns', []).filter(function (column) {
        return !_.isEmpty(column);
      });

      var getChildren = function getChildren(astNode) {
        return _.get(astNode, 'children', []);
      };

      var isOperator = function isOperator(astNode) {
        return _.get(astNode, 'type', '') == 'operator';
      };

      var shouldPrune = function shouldPrune(node) {
        return _.isEmpty(getChildren(node)) && isOperator(node);
      }; // This function mutates its argument.


      var pruneAST = function pruneAST(ast) {
        ast.children = getChildren(ast).filter(function (child) {
          pruneAST(child);
          return !shouldPrune(child);
        });

        if (_.isEmpty(getChildren(ast))) {
          ast = {};
        }
      };

      var removeUnusedOptionsFromFilterCondition = function removeUnusedOptionsFromFilterCondition(filterCondition) {
        var ast = _.cloneDeep(filterCondition); // If there are no actual children, then we can skip this.


        if (_.has(ast, 'children')) {
          pruneAST(ast);
        } // If there are no actual children after we pruned the AST, we can ignore
        // the filterCondition entirely. Setting it to an empty object will cause
        // it to be removed from the diff returned by the parent scope.


        if (_.isEmpty(_.get(ast, 'children', []))) {
          ast = {};
        }

        return ast;
      };

      if (_.isEmpty(actualColumnsDifference)) {
        delete viewDifference.columns;
      }

      if (_.has(viewDifference, 'query.filterCondition')) {
        var updatedFilterCondition = removeUnusedOptionsFromFilterCondition(_.get(viewDifference, 'query.filterCondition', {}));

        if (!_.isEmpty(updatedFilterCondition)) {
          viewDifference.query.filterCondition = updatedFilterCondition;
        } else {
          delete viewDifference.query.filterCondition;
        }
      }

      if (_.isEmpty(_.get(viewDifference, 'query', {}))) {
        delete viewDifference.query;
      }

      if (_.isEmpty(_.get(viewDifference, 'flags', []))) {
        delete viewDifference.flags;
      }

      if (_.has(viewDifference, 'metadata.jsonQuery')) {
        delete viewDifference.metadata.jsonQuery;
      }

      if (_.has(viewDifference, 'metadata') && _.isEmpty(_.get(viewDifference, 'metadata', {}))) {
        delete viewDifference.metadata;
      }

      return viewDifference;
    },
    jsonColumnsWithoutGroupingsOrAggregations: function jsonColumnsWithoutGroupingsOrAggregations() {
      return _.get(this.cleanCopy(), 'columns', []).map(function (column) {
        var columnFormat = _.get(column, 'format', {});

        if (_.has(columnFormat, 'drill_down')) {
          delete column.format.drill_down;
        }

        if (_.has(columnFormat, 'group_function')) {
          delete column.format.group_function;
        }

        if (_.has(columnFormat, 'grouping_aggregate')) {
          delete column.format.grouping_aggregate;
        }

        return column;
      });
    },
    initializeDerivedViews2018Controls: function initializeDerivedViews2018Controls() {
      var forceUseOfModifyingLensIdInAllDerivedViews = _.get(window, 'socrata.featureFlags.force_use_of_modifying_lens_id_in_all_derived_views', false);

      if (forceUseOfModifyingLensIdInAllDerivedViews) {
        this.initializeSaveViewButton();
        this.initializeCreateViewButton();
        this.initializeRevertViewButton();
      }
    },
    buttonDoesNotExistOrIsAlreadyInitialized: function buttonDoesNotExistOrIsAlreadyInitialized($button) {
      return !$button.get(0) || !_.isUndefined(_.get($.data($button.get(0), 'events'), 'click'));
    },
    saveView: function saveView(successCallback, errorCallback) {
      var dataset = this;
      var viewToUpdate = dataset.cleanCopy();
      $.ajax({
        url: '/api/views/' + viewToUpdate.id + '.json',
        type: 'PUT',
        data: JSON.stringify(viewToUpdate),
        headers: {
          'Content-type': 'application/json',
          'X-App-Token': _.get(window, 'blist.configuration.appToken', '')
        },
        success: successCallback,
        error: errorCallback
      });
    },
    initializeSaveViewButton: function initializeSaveViewButton() {
      var dataset = this;
      var $button = $('#save-view-button'); // Quit early if the button doesn't exist or if it exists and there's already a
      // click event handler bound to it.

      if (this.buttonDoesNotExistOrIsAlreadyInitialized($button)) {
        return;
      }

      function getDisabledTooltipText() {
        return dataset.isPublished() ? $.t('screens.ds.bar.save_view_disabled_for_published_tooltip') : $.t('screens.ds.bar.save_view_disabled_tooltip');
      }

      $button.on('click', function () {
        if ($(this).hasClass('disabled')) {
          return;
        }

        $(this).addClass('disabled');

        var successCallback = function successCallback(response) {
          window.location.href = '/d/' + response.id + '/data';
        };

        var errorCallback = function errorCallback() {
          $(this).removeClass('disabled');
        };

        dataset.saveView(successCallback, errorCallback);
      });
      $button.on('mouseover', function () {
        var flyoutRenderer = window.blist.flyoutRenderer;
        var payload = {
          element: this,
          content: $(this).hasClass('disabled') ? getDisabledTooltipText() : $.t('screens.ds.bar.save_view_enabled_tooltip'),
          belowTarget: true,
          rightSideHint: false,
          dark: true
        };

        if (flyoutRenderer) {
          flyoutRenderer.render(payload);
        }
      });
      $button.on('mouseout', function () {
        var flyoutRenderer = window.blist.flyoutRenderer;

        if (flyoutRenderer) {
          flyoutRenderer.clear();
        }
      });
    },
    initializeRevertViewButton: function initializeRevertViewButton() {
      var dataset = this;
      var $button = $('#revert-view-button'); // Quit early if the button doesn't exist or if it exists and there's already a
      // click event handler bound to it.

      if (this.buttonDoesNotExistOrIsAlreadyInitialized($button)) {
        return;
      }

      function getEnabledTooltipText() {
        return dataset.isPublished() ? $.t('screens.ds.bar.revert_view_enabled_for_published_tooltip') : $.t('screens.ds.bar.revert_view_enabled_tooltip');
      }

      function getDisabledTooltipText() {
        return $.t('screens.ds.bar.revert_view_disabled_tooltip');
      }

      $button.on('click', function () {
        if ($(this).hasClass('disabled')) {
          return;
        } else {
          if (confirm($.t('screens.ds.bar.revert_view_warning'))) {
            window.location.reload(true);
          }
        }
      });
      $button.on('mouseover', function () {
        var flyoutRenderer = window.blist.flyoutRenderer;
        var payload = {
          element: this,
          content: $(this).hasClass('disabled') ? getDisabledTooltipText() : getEnabledTooltipText(),
          belowTarget: true,
          rightSideHint: false,
          dark: true
        };

        if (flyoutRenderer) {
          flyoutRenderer.render(payload);
        }
      });
      $button.on('mouseout', function () {
        var flyoutRenderer = window.blist.flyoutRenderer;

        if (flyoutRenderer) {
          flyoutRenderer.clear();
        }
      });
    },
    createView: function createView(successCallback, errorCallback) {
      var dataset = this;
      var viewToCreate = {
        columns: dataset.jsonColumnsWithoutGroupingsOrAggregations(),
        displayType: 'table',
        hideFromCatalog: dataset.hideFromCatalog,
        hideFromDataJson: dataset.hideFromDataJson,
        metadata: {
          availableDisplayTypes: ['table', 'fatrow', 'page'],
          renderTypeConfig: {
            visible: {
              table: true
            }
          }
        },
        name: $.t('screens.ds.bar.create_view_name_prefix') + ' ' + dataset.name,
        originalViewId: dataset.id,
        query: {},
        viewType: 'tabular'
      };
      $.ajax({
        url: '/api/views.json',
        type: 'POST',
        data: JSON.stringify(viewToCreate),
        headers: {
          'Content-type': 'application/json',
          'X-App-Token': _.get(window, 'blist.configuration.appToken', '')
        },
        success: successCallback,
        error: errorCallback
      });
    },
    initializeCreateViewButton: function initializeCreateViewButton() {
      var dataset = this;
      var $button = $('#create-view-button'); // Quit early if the button doesn't exist or if it exists and there's already a
      // click event handler bound to it.

      if (this.buttonDoesNotExistOrIsAlreadyInitialized($button)) {
        return;
      }

      function getDisabledTooltipText() {
        return $.t('screens.ds.bar.create_view_disabled_tooltip');
      }

      $button.on('click', function () {
        if ($(this).hasClass('disabled')) {
          return;
        }

        $(this).addClass('disabled');

        var successCallback = function (response) {
          window.location.href = '/d/' + response.id + '/data';
        }.bind(this);

        var errorCallback = function () {
          $(this).removeClass('disabled');
        }.bind(this);

        dataset.createView(successCallback, errorCallback);
      });
      $button.on('mouseover', function () {
        var flyoutRenderer = window.blist.flyoutRenderer;
        var payload = {
          element: this,
          content: $(this).hasClass('disabled') ? getDisabledTooltipText() : $.t('screens.ds.bar.create_view_enabled_tooltip'),
          belowTarget: true,
          rightSideHint: false,
          dark: true
        };

        if (flyoutRenderer) {
          flyoutRenderer.render(payload);
        }
      });
      $button.on('mouseout', function () {
        var flyoutRenderer = window.blist.flyoutRenderer;

        if (flyoutRenderer) {
          flyoutRenderer.clear();
        }
      });
    },

    /**
     * END: Functionality specific to Derived Views 2018 project
     */
    reload: function reload(reloadFromServer) {
      var ds = this;

      if (ds.isBlobby()) {
        ds.trigger('blob_change');
        return;
      }

      ds._aggregatesStale = true;

      if (reloadFromServer) {
        ds.makeRequest({
          url: '/api/views/' + ds.id + '.json',
          type: 'GET',
          success: function success(newDS) {
            ds._update(newDS, true, true, true);

            ds.trigger('reloaded');
          }
        });
      } else {
        // We can just restore to the original object
        ds._update(ds._origObj, true, true, true);

        ds.trigger('reloaded');
      }
    },
    simpleSort: function simpleSort(colId, ascending) {
      var ds = this;
      var md = $.extend(true, {}, ds.metadata);
      var query = md.jsonQuery;
      var col = ds.columnForIdentifier(colId);

      if ($.isBlank(col)) {
        delete query.order;
      } else {
        query.order = [{
          columnFieldName: col.fieldName,
          ascending: ascending === true
        }];
      }

      ds.update({
        metadata: md
      }, false, (query.order || []).length < 2);
    },
    showRenderType: function showRenderType(rt, activeUid, force) {
      var ds = this;

      if (!force && ds.metadata.renderTypeConfig.visible[rt]) {
        return;
      }

      var md = $.extend(true, {}, ds.metadata);
      md.renderTypeConfig.visible[rt] = true;

      if (activeUid && (activeUid != ds.id || force)) {
        $.deepSet(md, activeUid, 'renderTypeConfig', 'active', rt, 'id');
      }

      ds.update({
        metadata: md
      }, false, true);
    },
    hideRenderType: function hideRenderType(rt) {
      var ds = this;

      if (!ds.metadata.renderTypeConfig.visible[rt]) {
        return;
      }

      var md = $.extend(true, {}, ds.metadata);
      delete md.renderTypeConfig.visible[rt];
      ds.update({
        metadata: md
      }, false, true);
    },
    toggleRenderType: function toggleRenderType(rt) {
      if (this.metadata.renderTypeConfig.visible[rt]) {
        this.hideRenderType(rt);
      } else {
        this.showRenderType(rt);
      }
    },
    blobs: function blobs() {
      var ds = this;

      if (!$.isBlank(this._blobs)) {
        return this._blobs;
      }

      if (this.isBlobby()) {
        var b = {
          type: (this.blobMimeType || '').replace(/;.*/, ''),
          size: this.blobFileSize,
          href: '/api/views/' + ds.id + '/files/' + this.blobId + '?' + $.param({
            filename: this.blobFilename
          })
        };

        if (this.blobFilename != this.name) {
          b.name = this.blobFilename;
        }

        this._blobs = [b];
      } else if (this.isHref()) {
        this._blobs = [];

        if ($.subKeyDefined(this, 'metadata.accessPoints')) {
          _.each(this.metadata.accessPoints, function (v, k) {
            ds._blobs.push({
              href: v,
              type: k.toUpperCase()
            });
          });

          this._blobs = _.sortBy(this._blobs, 'type');
        } else if ($.subKeyDefined(this, 'metadata.href')) {
          this._blobs.push({
            href: this.metadata.href,
            type: 'Link',
            size: 'Unknown'
          });
        }
      }

      return this._blobs;
    },
    // CORE-2979: this.grants is unreliable because it's being cached.
    userGrants: function userGrants(successCallback, errorCallback) {
      var ds = this,
          success = function success() {
        var userGrants = _.reject(ds.grants, function (g) {
          return _.includes(g.flags || [], 'public');
        });

        if (_.isFunction(successCallback)) {
          successCallback(userGrants);
        }
      },
          callback = function callback(grants) {
        ds.grants = grants || [];
        success();
        ds._grantsFetched = true;
      };

      if (!this._grantsFetched) {
        ds.makeRequest({
          url: '/api/views/' + ds.id + '/grants.json',
          success: callback,
          error: errorCallback
        });
        this._grantsFetched = 'fetching';
      } else if (this._grantsFetched === true) {
        success();
      }
    },
    removeGrant: function removeGrant(grant, successCallback, errorCallback) {
      var ds = this;

      var grantDeleted = function grantDeleted() {
        ds.grants = _.reject(ds.grants || [], function (g) {
          return !$.isBlank(grant.userId) && grant.userId == g.userId || !$.isBlank(grant.userEmail) && grant.userEmail == g.userEmail;
        });

        if (_.isFunction(successCallback)) {
          successCallback();
        }
      };

      ds.makeRequest({
        url: '/api/views/' + ds.id + '/grants',
        params: {
          method: 'delete'
        },
        type: 'PUT',
        data: JSON.stringify(grant),
        success: grantDeleted,
        error: errorCallback
      });
    },
    createGrant: function createGrant(grant, successCallback, errorCallback, isBatch) {
      var ds = this;

      var grantCreated = function grantCreated(response) {
        ds.grants = ds.grants || [];
        ds.grants.push(response);

        if (_.isFunction(successCallback)) {
          successCallback();
        }
      };

      ds.makeRequest({
        url: '/api/views/' + ds.id + '/grants/',
        type: 'POST',
        data: JSON.stringify(grant),
        batch: isBatch,
        success: grantCreated,
        error: errorCallback
      });
    },
    replaceGrant: function replaceGrant(oldGrant, newGrant, successCallback, errorCallback) {
      var ds = this;

      var grantUpdated = function grantUpdated(response) {
        ds.grants = ds.grants || [];
        ds.grants.push(response);

        if (_.isFunction(successCallback)) {
          successCallback();
        }
      };

      var fallback = function fallback(error) {
        if (error.status == 404) {
          var grantDeleted = function grantDeleted() {
            ds.createGrant(newGrant, successCallback, errorCallback);
          }; // Core server only accepts creation or deletion for grants, so...


          ds.removeGrant(oldGrant, grantDeleted, errorCallback);
        }
      };

      var updateGrant = {
        'oldGrant': oldGrant,
        'newGrant': newGrant
      };
      ds.makeRequest({
        url: '/api/views/' + ds.id + '/grants',
        params: {
          method: 'update'
        },
        type: 'PUT',
        data: JSON.stringify(updateGrant),
        success: grantUpdated,
        error: fallback
      });
    },
    makePublic: function makePublic(successCallback, errorCallback) {
      var ds = this;

      var success = function success() {
        ds.trigger('permissions_changed');

        if (_.isFunction(successCallback)) {
          successCallback.apply(ds, arguments);
        }
      };

      if (!ds.isPublic()) {
        ds.grants = ds.grants || [];
        ds.grants.push({
          type: ds.type === 'form' ? 'contributor' : 'viewer',
          flags: ['public']
        });
        ds.makeRequest({
          url: '/views/' + ds.id,
          type: 'PUT',
          params: {
            method: 'setPermission',
            value: ds.type === 'form' ? 'public.add' : 'public.read'
          },
          success: success,
          error: errorCallback
        });
      } else {
        success();
      }
    },
    makePrivate: function makePrivate(successCallback, errorCallback) {
      var ds = this;

      var success = function success() {
        ds.trigger('permissions_changed');

        if (_.isFunction(successCallback)) {
          successCallback.apply(ds, arguments);
        }
      };

      if (ds.isPublic() || ds.isPendingPublic()) {
        ds.grants = _.reject(ds.grants, function (g) {
          return _.includes(g.flags || [], 'public') && g.inherited !== true;
        });
        ds.makeRequest({
          url: '/views/' + ds.id + '.json',
          type: 'PUT',
          params: {
            method: 'setPermission',
            value: 'private'
          },
          success: success,
          error: errorCallback
        });
      } else {
        success();
      }
    },
    resubmitRejectedNonPublicView: function resubmitRejectedNonPublicView(successCallback, errorCallback) {
      var ds = this;

      var success = function success() {
        ds.trigger('permissions_changed');

        if (_.isFunction(successCallback)) {
          successCallback.apply(ds, arguments);
        }
      };

      if (!ds.isPublic()) {
        // POST /api/views/<4x4>/approvals?method=startWorkflowSubmission
        // NOTE: the hard-coded submission body sent in this request is only correct for published,
        //       not-public assets.
        ds.makeRequest({
          url: '/views/' + ds.id + '/approvals',
          type: 'POST',
          params: {
            method: 'startWorkflowSubmission'
          },
          data: JSON.stringify({
            outcome: 'change_audience',
            object: 'public_audience_request',
            details: {
              permissionType: ds.type === 'form' ? 'ADD' : 'READ'
            }
          }),
          success: success,
          error: errorCallback
        });
      } else {
        console.warn('Dataset with id', ds.id, 'is already public');
        success();
      }
    },
    withdrawFromApproval: function withdrawFromApproval(successCallback, errorCallback) {
      var ds = this;

      var success = function success() {
        ds.trigger('permissions_changed');

        if (_.isFunction(successCallback)) {
          successCallback.apply(ds, arguments);
        }
      }; // DELETE /api/views/<4x4>/approvals/<submissionId>?method=cancelWorkflowSubmission


      ds.makeRequest({
        url: '/views/' + ds.id + '/approvals/' + ds.audienceSubmissionId,
        type: 'DELETE',
        params: {
          method: 'cancelWorkflowSubmission'
        },
        success: success,
        error: errorCallback
      });
    },
    makeCustomGeoregion: function makeCustomGeoregion(successCallback, errorCallback) {
      var ds = this;
      ds.makeRequest({
        url: '/admin/geo',
        data: JSON.stringify({
          id: ds.id
        }),
        type: 'POST',
        success: successCallback,
        error: errorCallback
      });
    },
    notifyUsers: function notifyUsers(successCallback, errorCallback) {
      this.makeRequest({
        url: '/api/views/' + this.id + '.json',
        params: {
          method: 'notifyUsers'
        },
        type: 'POST',
        success: successCallback,
        error: errorCallback
      });
    },
    addColumn: function addColumn(column, successCallback, errorCallback) {
      if (!$.isBlank((column || {}).parentId)) {
        var par = this.columnForID(column.parentId);

        if ($.isBlank(par)) {
          throw 'Column ' + column.parentId + ' not found';
        }

        par.addChildColumn(column, successCallback, errorCallback); // True means abort (don't handle)

        return true;
      }
    },
    getNewBackendId: function getNewBackendId() {
      var ds = this;

      if (!ds._nbeId && ds.newBackend) {
        ds._nbeId = ds.id;
      }

      if (!_.isUndefined(ds._nbeId)) {
        return $.when(ds._nbeId);
      }

      var deferred = $.Deferred(); // eslint-disable-line new-cap
      // getParentView returns the base asset when no parent asset exists

      ds.getParentView(function (parentOrSelf) {
        if (!parentOrSelf) {
          deferred.reject();
          return;
        }

        ds.makeRequestWithPromise({
          url: '/api/migrations/' + parentOrSelf.id
        }).done(function (migration) {
          // For some reason we had chosen to save only partial migration info,
          // which hampered some downstream methods. Should we store the OBE ID
          // as a side effect of asking for the NBE ID? No. Is it making the
          // existing spaghetti noticeably worse? Not in my opinion.
          ds._nbeId = migration.nbeId;
          ds._obeId = migration.obeId;
          deferred.resolve(ds._nbeId);
        }).fail(function () {
          deferred.reject();
        });
      });
      return deferred.promise();
    },
    getNewBackendMetadata: function getNewBackendMetadata() {
      var ds = this;

      if (!_.isUndefined(ds._newBackendMetadata)) {
        return $.when(ds._newBackendMetadata);
      }

      var deferred = $.Deferred(); //eslint-disable-line new-cap

      var reject = function reject() {
        deferred.reject();
      };

      ds.getNewBackendId().done(function (newBackendId) {
        if (newBackendId) {
          var datasetMetadataUrl = '/api/views/{0}.json';
          $.get(datasetMetadataUrl.format(newBackendId)).done(function (metadata) {
            ds._newBackendMetadata = metadata;
            deferred.resolve(ds._newBackendMetadata);
          }).fail(reject);
        } else {
          ds._newBackendMetadata = null;
          deferred.resolve(ds._newBackendMetadata);
        }
      }).fail(reject);
      return deferred.promise();
    },
    getClusters: function getClusters(viewport, displayFormat, minDistance, successCallback, errorCallback) {
      var ds = this;

      if (!ds._clusters) {
        ds._clusters = {};
      }

      if (!ds._rowClusterParents) {
        ds._rowClusterParents = {};
      }

      if (!($.subKeyDefined(displayFormat, 'plot.locationId') && _.includes(['location', 'point'], (ds.columnForIdentifier(displayFormat.plot.locationId) || {}).renderTypeName))) {
        errorCallback();
        return;
      }

      if (ds.newBackend) {
        if (FeatureFlags.value('prohibit_use_of_row_set')) {
          ds._getClustersViaSODA2WithoutRowSet.apply(ds, arguments);
        } else {
          ds._getClustersViaSODA2.apply(ds, arguments);
        }

        return;
      }

      var params = {
        method: 'clustered2'
      };

      _.each({
        'xmin': 'min_lon',
        'xmax': 'max_lon',
        'ymin': 'min_lat',
        'ymax': 'max_lat'
      }, function (newProp, oldProp) {
        params[newProp] = viewport[oldProp];
      });

      params['target_node_clusters'] = 250;
      params['min_distance_between_clusters'] = minDistance;

      if (!params['min_distance_between_clusters']) {
        params['min_distance_between_clusters'] = Math.min(viewport.xmax - viewport.xmin, viewport.ymax - viewport.ymin) / 10;

        if (params['min_distance_between_clusters'] > 5) {
          params['min_distance_between_clusters'] = 5;
        } else if (params['min_distance_between_clusters'] > 1) {
          params['min_distance_between_clusters'] = 1;
        }
      }

      var translateCluster = function translateCluster(c) {
        c.parent = ds._clusters[c.pathToRoot[0]];
        ds._clusters[c.id] = c;

        _.each(c.points, function (point) {
          ds._rowClusterParents[point] = c;
        });

        _.each(c.children, function (child) {
          if (ds._clusters[child] && !ds._clusters[child].parent) {
            ds._clusters[child].parent = ds._clusters[ds._clusters[child].pathToRoot[0]];
          }
        });

        _.each(c.polygon, function (vertex) {
          if (vertex.lat == 90) {
            vertex.lat -= 0.000001;
          } else if (vertex.lat == -90) {
            vertex.lat += 0.000001;
          }

          if (vertex.lon == 180) {
            vertex.lon -= 0.000001;
          } else if (vertex.lon == -180) {
            vertex.lon += 0.000001;
          }
        });

        c.leafNode = (c.points || []).length > 0;
      };

      var useInline = ds.isDefault() || $.subKeyDefined(ds, 'query.filterCondition') || ds.cleanFilters() || $.isPresent($.deepGetStringField(ds, 'metadata.jsonQuery.search')) || $.isPresent(displayFormat) && !_.isEqual(displayFormat, ds.displayFormat);
      var reqData;

      if (useInline) {
        if ($.subKeyDefined(ds, 'query.namedFilters.viewport')) {
          var tmp = ds.query.namedFilters.viewport;
          delete ds.query.namedFilters.viewport;
          reqData = ds.cleanCopy();
          ds.query.namedFilters.viewport = tmp;
        } else {
          reqData = ds.cleanCopy();
        }

        if (!$.isBlank(displayFormat)) {
          reqData.displayFormat = displayFormat;
        }

        reqData = JSON.stringify(reqData);
      }

      if (params['max_lon'] < params['min_lon']) {
        var viewportsLeft = 2;
        var totalData = [];

        var callback = function callback(data) {
          viewportsLeft--;
          totalData = totalData.concat(data);
          ds.trigger('row_count_change');

          if (viewportsLeft == 0) {
            successCallback(totalData);
          }
        };

        ds.makeRequest({
          url: '/views/' + ds.id + '/rows.json',
          params: $.extend({}, params, {
            'min_lon': -179.999999
          }),
          data: reqData,
          inline: useInline,
          success: function success(data) {
            _.each(data, translateCluster);

            callback(data);
          },
          error: errorCallback
        });
        ds.makeRequest({
          url: '/views/' + ds.id + '/rows.json',
          params: $.extend({}, params, {
            'max_lon': 179.999999
          }),
          data: reqData,
          inline: useInline,
          success: function success(data) {
            _.each(data, translateCluster);

            callback(data);
          },
          error: errorCallback
        });
      } else {
        ds.makeRequest({
          url: '/views/' + ds.id + '/rows.json',
          params: params,
          data: reqData,
          inline: useInline,
          success: function success(data) {
            _.each(data, translateCluster);

            ds.trigger('row_count_change');
            successCallback(data);
          },
          error: errorCallback
        });
      }
    },
    // inDatasetSearch - boolean - if set to true, it tells the backend to timeout faster than its default; see details in EN-10852
    setSearchString: function setSearchString(searchString, inDatasetSearch) {
      var metadata = $.extend(true, {}, this.metadata);
      metadata.jsonQuery.search = searchString;
      metadata.inDatasetSearch = inDatasetSearch;
      this.update({
        metadata: metadata
      });
    },
    blobColumns: function blobColumns() {
      return _.filter(this.realColumns, function (col) {
        return col.renderTypeName === 'blob';
      });
    },
    hasBlobColumns: function hasBlobColumns() {
      return !_.isEmpty(this.blobColumns());
    },
    fileDataForFileId: function fileDataForFileId(id) {
      return this._fileDataForFileId[id];
    },
    // This is only used by DataSlate.
    rowToSODA2: function rowToSODA2(row) {
      var r = {
        ':index': row.index
      };

      _.each(this.columns, function (c) {
        r[c.fieldName] = row.data[c.lookup];

        if (c.renderTypeName == 'location' && $.subKeyDefined(r[c.fieldName], 'human_address') && _.isString(r[c.fieldName].human_address)) {
          r[c.fieldName].human_address = JSON.parse(r[c.fieldName].human_address);
        } // Do we expect SODA2 to actually return real values or not? For
        // current use cases, this is valid; but maybe not forever


        if (c.renderTypeName == 'drop_down_list' && !$.isBlank(r[c.fieldName])) {
          r[c.fieldName] = c.renderType.renderer(r[c.fieldName], c, true);
        }
      }); // For backwards compatibility, make all the meta columns into non-: items
      // (unless that field is taken by a real column)


      _.each(this.columns, function (c) {
        if (c.isMeta && _.isUndefined(r[c.name])) {
          r[c.name] = r[c.fieldName];
        }
      });

      return r;
    },
    updateRating: function updateRating(rating, successCallback, errorCallback) {
      this.makeRequest({
        url: '/views/' + this.id + '/ratings.json',
        type: 'POST',
        data: JSON.stringify(rating),
        success: successCallback,
        error: errorCallback
      });
    },
    remove: function remove(successCallback, errorCallback) {
      var ds = this;

      var dsRemoved = function dsRemoved() {
        ds.trigger('removed');

        if (_.isFunction(successCallback)) {
          successCallback();
        }
      };

      if (ds.isDataLens()) {
        // Send a DELETE request to the NFE endpoint, which should propagate the delete to the
        // OBE representation.
        ds.makeRequestWithPromise({
          url: "/metadata/v1/page/".concat(ds.id),
          type: 'DELETE'
        }).then(dsRemoved, errorCallback);
      } else {
        ds.makeRequest({
          url: '/api/views/' + ds.id + '.json',
          type: 'DELETE',
          success: dsRemoved,
          error: errorCallback
        });
      }
    },
    registerOpening: function registerOpening(referrer) {
      // make network request.
      var params = {
        method: 'opening'
      };

      if ($.isPresent(referrer)) {
        params.referrer = referrer;
      }

      if (this._useSODA2 && $.parseParams().$$store) {
        params.$$store = $.parseParams().$$store;
      }

      this.makeRequest({
        url: '/views/' + this.id + '.json',
        params: params,
        type: 'POST'
      }); // store in local storage.

      Dataset.saveRecentDataset(this);
    },
    _isGeoExport: function _isGeoExport(ext) {
      var geoTypes = /(kml|kmz|shapefile|geojson)/i;
      return geoTypes.test(ext) || ext === 'original' && GeoHelpers.isGeoDataset(this);
    },
    downloadUrl: function downloadUrl(type) {
      var ext = (type || '').toLowerCase().split(' ')[0];

      if (this._isGeoExport(ext)) {
        return "/api/geospatial/".concat(this.id, "?method=export&format=").concat(type);
      }

      var bom = type == 'CSV for Excel' || type == 'CSV for Excel (Europe)' ? '&bom=true' : '';
      var format = type == 'CSV for Excel' || type == 'CSV for Excel (Europe)' ? '&format=true' : '';
      var delimiter = type == 'CSV for Excel (Europe)' ? '&delimiter=;' : ''; // EN-23885 - Allow sorting=true parameter in exports to be configurable by domain
      //
      // Some customers have been frustrated by the fact that when they export a dataset it does not
      // reflect the sorting that they have configured on the grid view. This feature flag will append
      // the 'sorting=true' parameter to a download URL when it is enabled. We will enable this feature
      // flag for the customers in question, but not by default, since it is likely to be more costly
      // in terms of computation to apply the sort on export.

      var sort = _.get(window, 'socrata.featureFlags.sort_dataset_on_export', false) ? '&sorting=true' : '';
      return "/api/views/".concat(this.id, "/rows.").concat(ext, "?accessType=DOWNLOAD").concat(bom).concat(format).concat(delimiter).concat(sort);
    },
    _getCommentCacheKey: function _getCommentCacheKey(comment) {
      return $.isBlank(comment.rowId) ? this.id : _.compact([comment.rowId, comment.tableColumnId]).join('_');
    },
    getComments: function getComments(callback) {
      var ds = this;
      var cacheId = ds.id;

      if ($.isBlank(ds._commentCache[cacheId])) {
        // Keep getComments cachable by the browser; even though it has no full
        // etag/cache-control handling internally. Comments just don't need to be
        // hitting the backend
        ds.makeRequest({
          url: '/views/' + ds.id + '/comments.json',
          params: null,
          type: 'GET',
          pageCache: true,
          success: function success(comms) {
            ds._commentCache[cacheId] = ds._commentCache[cacheId] || [];

            _.each(comms, function (c) {
              ds._commentByID[c.id] = c;

              ds._commentCache[cacheId].push(c);
            });

            callback(ds._commentCache[cacheId]);
          }
        });
      } else {
        callback(ds._commentCache[cacheId]);
      }
    },
    addComment: function addComment(comment, successCallback, errorCallback) {
      var ds = this;
      var cacheId = ds.id;

      var addedComment = function addedComment(newCom) {
        ds.numberOfComments++;

        if (!$.isBlank(ds._commentCache[cacheId])) {
          ds._commentCache[cacheId].unshift(newCom);
        }

        ds._commentByID[newCom.id] = newCom;
        ds.trigger('new_comment', [newCom, comment.parent]);

        if (_.isFunction(successCallback)) {
          successCallback(newCom);
        }
      };

      ds.makeRequest({
        url: '/views/' + ds.id + '/comments.json',
        type: 'POST',
        data: JSON.stringify(comment),
        success: addedComment,
        error: errorCallback
      });
    },
    removeComment: function removeComment(commentId, successCallback, errorCallback) {
      var ds = this;
      var com = ds._commentByID[commentId];
      if ($.isBlank(com)) return;
      ds.makeRequest({
        url: '/views/' + this.id + '/comments/' + commentId + '.json',
        type: 'DELETE',
        success: successCallback,
        error: errorCallback
      });
    },
    flagComment: function flagComment(commentId, successCallback, errorCallback) {
      var ds = this;
      var com = ds._commentByID[commentId];

      if (!$.isBlank(com)) {
        com.flags = com.flags || [];

        if (!_.includes(com.flags, 'flag')) {
          com.flags.push('flag');
        }
      }

      ds.makeRequest({
        url: '/views/' + this.id + '/comments/' + commentId + '.json',
        type: 'PUT',
        data: JSON.stringify({
          flags: ['flag']
        }),
        success: successCallback,
        error: errorCallback
      });
    },
    rateComment: function rateComment(commentId, thumbsUp, successCallback, errorCallback) {
      var ds = this;
      var com = ds._commentByID[commentId];

      if (!$.isBlank(com)) {
        if ((com.currentUserRating || {}).thumbUp !== thumbsUp) {
          var dir = thumbsUp ? 'up' : 'down';
          com[dir + 'Ratings']++;

          if (!$.isBlank(com.currentUserRating)) {
            com[(thumbsUp ? 'down' : 'up') + 'Ratings']--;
          }

          com.currentUserRating = com.currentUserRating || {};
          com.currentUserRating.thumbUp = thumbsUp;
        }
      }

      ds.makeRequest({
        url: '/views/' + ds.id + '/comments/' + commentId + '/ratings.json',
        params: {
          thumbsUp: thumbsUp
        },
        type: 'POST',
        success: successCallback,
        error: errorCallback
      });
    },
    getParentDataset: function getParentDataset(callback) {
      var ds = this;

      if (($.isBlank(ds._parent) || $.isBlank(ds._parent.columns)) && $.isBlank(ds.noParentAvailable)) {
        ds.makeRequest({
          url: "/views/".concat(this.id, ".json"),
          params: {
            method: 'getDefaultView'
          },
          success: function success(parDS) {
            if (parDS.id == ds.id) {
              ds._parent = ds;
            } else {
              ds._parent = createDatasetFromView(parDS);

              if (!$.isBlank(ds.accessType)) {
                ds._parent.setAccessType(ds.accessType);
              }
            }

            callback(ds._parent);
          },
          error: function error(xhr) {
            if (JSON.parse(xhr.responseText).code == 'permission_denied') {
              ds.noParentAvailable = true;
            }

            callback();
          }
        });
      } else {
        callback(ds._parent);
      }
    },
    // account for modifyingLens
    getParentView: function getParentView(callback) {
      var ds = this;

      if (($.isBlank(ds._modifyingView) || $.isBlank(ds._modifyingView.columns)) && $.isBlank(ds.noModifyingViewAvailable)) {
        if (!_.isUndefined(ds.modifyingViewUid)) {
          Dataset.createFromViewId(ds.modifyingViewUid, function (modifyingView) {
            ds._modifyingView = modifyingView;

            if (!$.isBlank(ds.accessType)) {
              ds._modifyingView.setAccessType(ds.accessType);
            }

            callback(ds._modifyingView);
          }, function (xhr) {
            // doesn't seem possible but let's be safe
            if (JSON.parse(xhr.responseText).code == 'permission_denied') {
              ds.noModifyingViewAvailable = true;
            }

            callback();
          });
        } else {
          ds.getParentDataset(callback);
        }
      } else {
        callback(ds._modifyingView);
      }
    },
    getRelatedViews: function getRelatedViews(callback) {
      var ds = this;

      if ($.isBlank(ds._relatedViews)) {
        ds._loadRelatedViews(function () {
          callback(ds._relatedViews);
        });
      } else {
        callback(ds._relatedViews);
      }
    },
    getPublishedView: function getPublishedView(callback) {
      var ds = this;

      if ($.isBlank(ds._publishedView)) {
        if (!$.isBlank(ds.publishedViewUid) && $.isBlank(ds.noPublishedViewAvailable)) {
          ds.makeRequest({
            url: "/views/".concat(this.publishedViewUid, ".json"),
            success: function success(pv) {
              ds._publishedView = createDatasetFromView(pv);
              callback(ds._publishedView);
            },
            error: function error(xhr) {
              if (JSON.parse(xhr.responseText).code == 'permission_denied') {
                ds.noPublishedViewAvailable = true;
              }

              callback();
            }
          });
        } else {
          callback();
        }
      } else {
        callback(ds._publishedView);
      }
    },
    getViewForDisplay: function getViewForDisplay(type, callback) {
      // in most cases, it's just the dataset
      var vft = this._childViewsForType(type);

      if (!vft) {
        callback(this);
        return;
      } // figure out which underlying view to show


      var typeDisplay = $.deepGet(true, this, 'metadata', 'renderTypeConfig', 'active', type);

      if (!typeDisplay.id || typeDisplay.id === 'self') {
        typeDisplay.id = vft[0];
      }

      this._getChildView(typeDisplay.id, callback);
    },
    getQueryBase: function getQueryBase(callback) {
      var ds = this;

      if (!$.isBlank(ds._queryBase)) {
        if (_.isFunction(callback)) {
          callback();
        }

        return;
      }

      var updateSelf = _.throttle(function () {
        // This might not actually be a real case, because if you can modify the current
        // view, query access ought to be based on the parent. But logically this is
        // a good thing to do.
        if (!$.isBlank(ds._queryBase) && ds._queryBase.id == ds.id) {
          ds._queryBase.reload(true);
        }
      }, 500, {
        leading: false
      }); // trailing throttle above to make sure reloads from 'columns_changed' events don't get dropped


      ds.bind('saved', updateSelf, ds);
      ds.bind('columns_changed', function (changeType) {
        if (changeType == 'added' || changeType == 'fullSet' || changeType == 'removed') {
          updateSelf();
        }
      }, ds);

      var selfForBase = function selfForBase() {
        Dataset.createFromViewId(ds.id, function (qb) {
          ds._queryBase = qb;

          if (_.isFunction(callback)) {
            callback();
          }
        });
      };

      var forceUseOfModifyingLensIdInAllDerivedViews = _.get(window, 'socrata.featureFlags.force_use_of_modifying_lens_id_in_all_derived_views', false);

      if (!forceUseOfModifyingLensIdInAllDerivedViews && ds.hasRight(blist.rights.view.UPDATE_VIEW) && !ds.isDefault()) {
        ds.getParentView(function (par) {
          if (!$.isBlank(par)) {
            ds._queryBase = par;

            if (_.isFunction(callback)) {
              callback();
            }
          } else {
            selfForBase();
          }
        });
      } else {
        // This is duct tape for some other race condition
        // when trying to render out a map. See: ONCALL-2845.
        _.defer(selfForBase);
      }
    },
    getChildOptionsForType: function getChildOptionsForType(type, callback) {
      var ds = this;

      var children = ds._childViewsForType(type);

      if (!children) {
        callback([ds]);
      } else {
        var options = [];

        _.each(children, function (childUid) {
          ds._getChildView(childUid, function (child) {
            options.push(child);
          }, true);
        });

        ServerModel.sendBatch(function () {
          // success
          callback(options);
        });
      }
    },

    /**
     * @function getFilteredFieldNames
     * @description
     * Attempts to grab the field names by recursively plucking
     * the attribute, columnFieldName, from dataset.query.
     * @returns {Array} - The unique field names currently being used as a filter.
     */
    getFilteredFieldNames: function getFilteredFieldNames() {
      return _.uniq(blist.util.recursivePluck(this.query, 'columnFieldName'));
    },
    redirectTo: function redirectTo(urlParams) {
      var url = this.url;
      var queryString = '';

      if (blist.configuration.dataset_landing_page_enabled) {
        url = url + '/data';
      }

      if (!$.isBlank(urlParams)) {
        queryString = '?' + $.toParam(urlParams);
      }

      window.location = url + queryString;
    },
    _cachedLinkedColumnOptions: {},
    getFullSnapshotUrl: function getFullSnapshotUrl(name) {
      name = this._getThumbNameOrDefault(name);

      if ($.isBlank(this._getCroppedThumbnailMeta(name))) {
        return null;
      }

      return this.getSnapshotNamed(name);
    },
    getSnapshotNamed: function getSnapshotNamed(name) {
      return '/api/views/' + this.id + '/snapshots/' + escape(name);
    },
    getCroppedSnapshotUrl: function getCroppedSnapshotUrl(name) {
      name = this._getThumbNameOrDefault(name); // make sure the crop has been created

      var meta = this._getCroppedThumbnailMeta(name);

      if ($.isBlank(meta)) {
        return null;
      }

      return this.getSnapshotNamed(meta.filename);
    },
    // ask the core server to take a new picture
    requestSnapshot: function requestSnapshot(name, callback) {
      this._updateSnapshot('snapshot', name, callback);
    },
    cropSnapshot: function cropSnapshot(name, callback) {
      this._updateSnapshot('cropExisting', name, callback);
    },
    // Publishing
    makeUnpublishedCopy: function makeUnpublishedCopy(successCallback, pendingCallback, errorCallback) {
      var ds = this;
      ds.makeRequest({
        url: '/api/views/' + ds.id + '/publication.json',
        params: {
          method: 'copy'
        },
        type: 'POST',
        pending: function pending() {
          ds.copyPending = true;

          if (_.isFunction(pendingCallback)) {
            pendingCallback();
          }
        },
        error: errorCallback,
        success: function success(r) {
          delete ds.copyPending;
          ds._unpublishedView = createDatasetFromView(r);

          if (_.isFunction(successCallback)) {
            successCallback(ds._unpublishedView);
          }
        }
      });
    },
    publish: function publish(successCallback, errorCallback) {
      var ds = this;
      ds.makeRequest({
        url: '/api/views/' + ds.id + '/publication.json',
        type: 'POST',
        error: errorCallback,
        success: function success(r) {
          var pubDS = createDatasetFromView(r);

          if (_.isFunction(successCallback)) {
            successCallback(pubDS);
          }
        }
      });
    },
    getPublishedDataset: function getPublishedDataset(callback) {
      var ds = this;

      if ($.isBlank(ds._publishedViews)) {
        ds._loadPublicationViews(function () {
          callback(_.find(ds._publishedViews, function (v) {
            return v.isDefault();
          }));
        });
      } else {
        callback(_.find(ds._publishedViews, function (v) {
          return v.isDefault();
        }));
      }
    },
    getUnpublishedDataset: function getUnpublishedDataset(callback) {
      var ds = this;

      if ($.isBlank(ds._publishedViews)) {
        ds._loadPublicationViews(function () {
          callback(ds._unpublishedView);
        });
      } else {
        callback(ds._unpublishedView);
      }
    },
    getUnpublishedView: function getUnpublishedView(callback) {
      var ds = this;

      if ($.isBlank(ds._unpublishedView) && $.isBlank(ds.noUnpublishedViewAvailable)) {
        ds.makeRequest({
          url: "/views/".concat(this.publishedViewUid, ".json"),
          params: {
            method: 'getPublicationGroup',
            stage: 'unpublished'
          },
          success: function success(pv) {
            ds._unpublishedView = createDatasetFromView(pv);
            callback(ds._unpublishedView);
          },
          error: function error(xhr) {
            if (JSON.parse(xhr.responseText).code == 'permission_denied') {
              ds.noUnpublishedViewAvailable = true;
            }

            callback(ds._unpublishedView);
          }
        });
      } else {
        callback(ds._unpublishedView);
      }
    },
    isPublicationStageChangeAvailable: function isPublicationStageChangeAvailable(isPublished, resultCallback) {
      var ds = this;
      var controlsGridStatusKey = "controls.grid.".concat(isPublished ? 'published' : 'unpublished');

      if (!ds.newBackend) {
        if (ds.columnsForType('location').length < 1) {
          resultCallback(true);
          return;
        }

        ds.makeRequest({
          url: "/api/geocoding/".concat(ds.id, ".json"),
          params: {
            method: 'pending'
          },
          success: function success(results) {
            resultCallback(results.view < 1, $.t("".concat(controlsGridStatusKey, ".geocodes_pending")));
          },
          error: function error() {
            resultCallback(false, $.t("".concat(controlsGridStatusKey, ".unknown_publication_stage_change_available_error")));
          }
        });
      } else if (ds.viewType === 'geo') {
        // resultCallback arguments are (isAvail, unavailMsg).
        // Because isAvail is always true, unavailMsg should be irrelevant.
        resultCallback(true, '');
      } else {
        // EN-10105 - Show “you can’t publish this! It’s geocoding!” message on grid view
        //
        //
        // Note that successCallback takes arguments:
        //
        // 1. boolean indicating whether publishing is available
        // 2. an error message to display if publishing is not available
        //
        // TODO: check for computed columns
        // or at least point and number columns?
        ds.makeRequest({
          url: "/api/views/".concat(ds.id, "/replication.json"),
          success: function success(replicationStatus) {
            var computationUpToDate = _.get(replicationStatus, 'asynchronous_computation_up_to_date', true);

            resultCallback(computationUpToDate, $.t("".concat(controlsGridStatusKey, ".asynchronous_computation_pending")));
          },
          error: function error() {
            resultCallback(false, $.t("".concat(controlsGridStatusKey, ".unknown_publication_stage_change_available_error")));
          }
        });
      }
    },
    // set _openBrowserRevision
    getOpenRevision: function getOpenRevision(callback) {
      var ds = this;

      if ($.isBlank(ds._openRevision)) {
        ds.makeRequest({
          url: "/api/publishing/v1/revision/".concat(this.id),
          params: {},
          success: function success(revisions) {
            if (revisions && revisions.length !== 0) {
              ds._openRevision = _(revisions).filter({
                'resource': {
                  'creation_source': 'browser'
                }
              }).reject('resource.closed_at').first();
              callback(ds._openRevision);
            }
          },
          error: function error(xhr) {
            console.error('Error getting revisions for view', xhr);
            callback(ds._openRevision);
          }
        });
      } else {
        callback(ds._openRevision);
      }
    },
    makeBrowserRevision: function makeBrowserRevision(successCallback, errorCallback) {
      var ds = this;

      var onSuccess = function onSuccess(openedRevision) {
        ds._openRevision = openedRevision;

        if (_.isFunction(successCallback)) {
          successCallback(ds._openRevision);
        }
      };

      ds.makeRequest({
        url: '/api/publishing/v1/revision/' + ds.id,
        params: {
          action: {
            type: 'replace'
          },
          creation_source: 'browser'
        },
        type: 'POST',
        error: errorCallback,
        success: function success(r) {
          if (ds.viewType === 'tabular') {
            ds.makeRequest({
              url: '/api/publishing/v1/revision/' + ds.id + '/' + r.resource.revision_seq + '/source',
              params: {
                source_type: {
                  type: 'view'
                }
              },
              type: 'POST',
              error: errorCallback,
              success: function success() {
                onSuccess(r);
              }
            });
          } else {
            // non tabular datasets don't need a view source opened
            onSuccess(r);
          }
        }
      });
    },
    getBackups: function getBackups(callback) {
      var ds = this;

      if (!ds.newBackend) {
        return;
      }

      var processTS = function processTS(timestamps) {
        var rv = _.map(timestamps, function (timestamp) {
          // Datasets in the NBE_ONLY migration phase may have previously existing
          // OBE snapshots. The BackupsService in core will return these OBE snapshots
          // along with any new NBE snapshots (which are CSV backups in S3).
          //
          // The BackupsService in core identifies NBE snapshots by their timestamp
          // as they are identified by Snapshotter (the service which maintains them)
          // while core identifies OBE snapshots by their view id.
          //
          // The BackupsService index method returns a list of timestamps representing
          // NBE snapshots and JSON objects with the following keys representing OBE
          // snapshots: "id" and "viewLastModifiedAt".
          var snapshotId = _.get(timestamp, 'id', timestamp);

          var snapshotTimestamp = _.get(timestamp, 'viewLastModifiedAt', timestamp);

          return {
            downloadLinks: {
              csv: "/api/views/".concat(ds.id, "/backups/").concat(snapshotId)
            },
            moment: moment(snapshotTimestamp)
          };
        });

        callback(rv);
      };

      ds.makeRequest({
        url: "/api/views/".concat(ds.id, "/backups"),
        type: 'GET',
        success: processTS
      });
    },
    makeBackup: function makeBackup(successCallback) {
      var ds = this;

      if (!ds.newBackend) {
        return;
      }

      if (!_.isFunction(successCallback)) {
        successCallback = function successCallback() {};
      }

      ds.makeRequest({
        url: "/api/views/".concat(ds.id, "/backups"),
        type: 'POST',
        success: function success() {
          successCallback();
        }
      });
    },
    deleteBackup: function deleteBackup(backupURI, successCallback) {
      var ds = this;

      if (!ds.newBackend) {
        return;
      }

      if (!_.isFunction(successCallback)) {
        successCallback = function successCallback() {};
      }

      ds.makeRequest({
        url: backupURI,
        type: 'DELETE',
        success: function success() {
          successCallback();
        }
      });
    },
    getSnapshotDatasets: function getSnapshotDatasets(callback) {
      var ds = this;

      if ($.isBlank(ds._snapshotViews)) {
        ds._loadPublicationViews(function () {
          callback(_.filter(ds._snapshotViews, function (v) {
            return v.isDefault();
          }));
        });
      } else {
        callback(_.filter(ds._snapshotViews, function (v) {
          return v.isDefault();
        }));
      }
    },
    getOperationStatuses: function getOperationStatuses(callback) {
      var ds = this;
      ds.makeRequest({
        url: '/views/' + ds.id,
        params: {
          method: 'operationStatuses'
        },
        success: callback
      });
    },
    cleanFilters: function cleanFilters(excludeTemporary) {
      var ds = this;
      var filters;

      if (!$.isBlank((ds.query || {}).filterCondition)) {
        filters = $.extend(true, {}, ds.query.filterCondition);
      }

      if (!$.isBlank((ds.query || {}).namedFilters)) {
        var newFilters = [];

        _.each(ds.query.namedFilters, function (nf) {
          if (_.isEmpty(nf) || excludeTemporary && nf.temporary) {
            return;
          } // Named filter keys off of main type; so just check displayType and
          // not renderTypeConfig.visible


          if (!$.isBlank(nf.displayTypes) && !_.includes(nf.displayTypes, ds.displayType)) {
            return;
          }

          nf = $.extend(true, {}, nf);
          delete nf.temporary;
          delete nf.displayTypes;
          newFilters.push(nf);
        });

        if (newFilters.length > 0) {
          if ($.isBlank(filters) && newFilters.length == 1) {
            filters = _.first(newFilters);
          } else {
            if ($.isBlank(filters)) {
              filters = {
                children: [],
                type: 'operator',
                value: 'AND'
              };
            } else if (filters.type != 'operator' || filters.value != 'AND') {
              filters = {
                type: 'operator',
                value: 'AND',
                children: [filters]
              };
            }

            filters.children = (filters.children || []).concat(newFilters);
          }
        }
      }

      return filters;
    },
    cleanJsonFilters: function cleanJsonFilters(excludeTemporary) {
      var ds = this;
      var filters = {};

      _.each(['where', 'having'], function (k) {
        if ($.subKeyDefined(ds, 'metadata.jsonQuery.' + k)) {
          filters[k] = $.extend(true, {}, ds.metadata.jsonQuery[k]);
        }
      });

      if ($.subKeyDefined(ds, 'metadata.jsonQuery.namedFilters')) {
        var newFilters = {
          where: [],
          having: []
        };

        _.each(ds.metadata.jsonQuery.namedFilters, function (nf) {
          if (excludeTemporary && nf.temporary) {
            return;
          } // Named filter keys off of main type; so just check displayType and
          // not renderTypeConfig.visible


          if (!$.isBlank(nf.displayTypes) && !_.includes(nf.displayTypes, ds.displayType)) {
            return;
          }

          nf = $.extend(true, {}, nf);
          delete nf.temporary;
          delete nf.displayTypes;
          newFilters.where.push(nf.where);
          newFilters.having.push(nf.having);
        });

        _.each(['where', 'having'], function (k) {
          newFilters[k] = _.compact(newFilters[k]);

          if (newFilters[k].length > 0) {
            if (_.isEmpty(filters[k]) && newFilters[k].length == 1) {
              filters[k] = _.first(newFilters[k]);
            } else {
              if (_.isEmpty(filters[k])) {
                filters[k] = {
                  children: [],
                  operator: 'AND'
                };
              } else if (filters[k].operator != 'AND') {
                filters[k] = {
                  operator: 'AND',
                  children: [filters[k]]
                };
              }

              filters[k].children = (filters[k].children || []).concat(newFilters[k]);
            }
          }
        });
      }

      return filters;
    },
    cleanCopy: function cleanCopy(allowedKeys) {
      var dsCopy = this._super(allowedKeys);

      if (!$.isBlank(dsCopy.query)) {
        dsCopy.query.filterCondition = this.cleanFilters();
        delete dsCopy.query.namedFilters;
      }

      if ($.subKeyDefined(dsCopy, 'metadata.jsonQuery')) {
        $.extend(dsCopy.metadata.jsonQuery, this.cleanJsonFilters());
        delete dsCopy.metadata.jsonQuery.namedFilters;
      }

      if (_.isEmpty(_.get(dsCopy, 'searchString', null))) {
        delete dsCopy.searchString;
      }

      return dsCopy;
    },
    // EN-17875 - Make grid view Socrata Viz table respond to OBE/NBE read
    // queries using old query path
    //
    // We need to pass a JSON representation of the view along to the Table
    // renderer by including the equivalent output of the /api/views endpoint in
    // the vif with which we instantiate the Table.
    //
    // Unfortunately, the `.cleanCopy()` method on the Dataset model omits the
    // `renderTypeName` property (since it is not a valid property to send back
    // to Core Server--presumably we assign a renderTypeName when we persist the
    // updated view).
    //
    // Accordingly, and in the spirit of making as few changes to existing code
    // as possible, I am adding an additional method that does not omit the
    // renderTypeName property for the specific use case described above.
    //
    // This is the Dataset component of the work; there are also similar
    // implementations in the Column and Base models located in this project at
    // `platform-ui/frontend/public/javascripts/util/dataset/column.js` and
    // `platform-ui/frontend/public/javascripts/util/base-model.js`,
    // respectively.
    //
    // BECAUSE YOU ASKED, here is a slightly more verbose explanation for why we
    // need to do this (taken from github.com/socrata/platform-ui/pull/5232):
    //
    //   It's actually the Column object that has the renderTypeName property.
    //   But one gets the serialized columns by getting the serialized view (the
    //   dataset implementation of the function with the same name, which
    //   function on dataset basically maps the list of visible columns with the
    //   version of the cleanCopyIncludingRenderTypeName implemented in the
    //   column model, and both will attempt to call
    //   cleanCopyIncludingRenderTypeName on the base model because they both
    //   call self._super(), and it's the whole big mess of the inheritance
    //   stuff that we abused so badly circa 2011.
    //
    // USE AT YOUR OWN RISK etc. etc.
    cleanCopyIncludingRenderTypeName: function cleanCopyIncludingRenderTypeName() {
      var dsCopy = this._super();

      if (!$.isBlank(dsCopy.query)) {
        // EN-27907 - Calendars road, then re-request rows and error
        //
        // Note that certain things, like having a calendar configured on a view,
        // will cause `<Dataset>.cleanFilters()` to return a root-level filter with
        // one (or maybe more?) child objects that are fully-empty objects. This
        // causes Core Server to respond with 400, since it can't figure out what
        // type of filter object the thing is (seeing as how it lacks a 'type'
        // key: value pair). Passing `true` as an argument to `<Dataset>.cleanFilters()`
        // fixes this, because the argument we are passing is called `excludeTemporary`,
        // which causes this method to not create empty objects as children of the
        // root-level filter object.
        dsCopy.query.filterCondition = this.cleanFilters(true);
        delete dsCopy.query.namedFilters;
      }

      if ($.subKeyDefined(dsCopy, 'metadata.jsonQuery')) {
        $.extend(dsCopy.metadata.jsonQuery, this.cleanJsonFilters());
        delete dsCopy.metadata.jsonQuery.namedFilters;
      }

      dsCopy.columns = this.realColumns.map(function (column) {
        return column.cleanCopyIncludingRenderTypeName();
      }); // EN-24581 - Ephemeral View Query Fails
      //
      // If we synthesize an ephemeral view we need to ensure that it has a 'name'
      // property, or else Core Server will fail its validation and send back a
      // 400 error. Note that a string of length 0 or of whitespace will still fail
      // validation, so this needs to be something that won't get collapsed down to
      // an empty string by trim() and so forth.

      if (!_.has(dsCopy, 'name')) {
        if (_.has(this, 'name')) {
          dsCopy.name = this.name;
        } else {
          dsCopy.name = $.t('screens.ds.bar.create_view_name_prefix') + ' ' + this.id;
        }
      }

      return dsCopy;
    },
    changeOwner: function changeOwner(userId, successCallback, errorCallback) {
      var ds = this;
      ds.makeRequest({
        url: '/views/' + ds.id + '?method=plagiarize&userId=' + userId,
        type: 'PUT',
        success: successCallback,
        error: errorCallback
      });
    },
    getShareTypes: function getShareTypes() {
      var stypes = ['Contributor', 'Owner'];

      if (this.type != 'form') {
        stypes.unshift('Viewer');
      }

      return stypes;
    },
    preferredImage: function preferredImage(size) {
      var ds = this;

      if ($.isBlank(size)) {
        size = 'thumb';
      }

      if (!$.isBlank(ds.iconUrl)) {
        return '/assets/' + escape(ds.iconUrl) + '?s=thumb';
      } else if ($.deepGet(ds, 'metadata', 'thumbnail', 'page', 'filename')) {
        var result = '';

        if (ds.isFederated()) {
          result += '//' + this.domainCName;
        }

        result += '/api/views/' + ds.id + '/snapshots/page?size=thumb';
        return result;
      }

      return null;
    },
    // TODO IDE says this is an unused method
    preferredImageType: function preferredImageType() {
      var ds = this;

      if (!$.isBlank(ds.iconUrl)) {
        return 'customImage';
      } else if ($.subKeyDefined(ds, 'metadata.thumbnail.page.filename')) {
        return 'thumbnail';
      }

      return '';
    },
    // Private methods
    _checkValidity: function _checkValidity() {
      return $.isBlank(this.message);
    },
    _markTemporary: function _markTemporary(minorChange) {
      var oldMinor = this.minorChange;
      this.minorChange = this.minorChange && (minorChange || false);

      if (!this.temporary || oldMinor !== this.minorChange) {
        this.temporary = true;
        this.trigger('set_temporary');

        if ((blist.debug || {}).temporary && (console || {}).trace) {
          console.groupCollapsed('markingTemporary');
          console.trace();
          console.groupEnd();
        }
      }
    },
    _clearTemporary: function _clearTemporary() {
      if (this.temporary) {
        this.temporary = false;
        this.minorChange = true;
        this.trigger('clear_temporary');
      }
    },
    _determineUseSODA2: function _determineUseSODA2() {
      var ds = this;

      if (ds.newBackend || blist.configuration.useSoda2) {
        ds._useSODA2 = true;
      } else {
        ds._useSODA2 = false;
      } // Allow explicit override of SODA version via URL parameter


      var sodaVersion = $.urlParam(window.location.href, 'soda');

      if (sodaVersion === '1') {
        ds._useSODA2 = false;
      }

      if (sodaVersion === '2') {
        ds._useSODA2 = true;
      }
    },
    _adjustProperties: function _adjustProperties() {
      var ds = this;
      ds.originalViewId = ds.id;

      ds._determineUseSODA2();

      ds.type = getType(ds);

      if (ds.isUnpublished()) {
        ds.styleClass = 'Unpublished';
      } else if (ds.type == 'blist' && ds.isSnapshot()) {
        ds.styleClass = 'Snapshotted';
      } else {
        ds.styleClass = ds.type.capitalize();
      }

      if ($.isBlank(ds.displayType)) {
        ds.displayType = {
          'tabular': 'table',
          'blobby': 'blob',
          'href': 'href'
        }[ds.viewType || 'tabular'];
      }

      ds.displayName = getDisplayName(ds); // Legacy support for SODA1 search strings.

      ds.searchString = ds.searchString || undefined; // If we are an invalid filter, we're not really that invalid, because
      // the core server has already removed the offending clause. So just
      // ignore the message, and the view will load fine without the clause
      // on the non-existant column

      if (!$.isBlank(ds.message) && ds.type == 'filter') {
        delete ds.message;
      }

      if (!ds._addedProperties) {
        var types = [ds.type];

        if ($.subKeyDefined(ds, 'metadata.availableDisplayTypes')) {
          // Make sure main type is last so that those functions get
          // priority. Yes, this is a hack; we should probably redo
          // the module system sometime soon...
          types = _.without(ds.metadata.availableDisplayTypes, ds.type);
          types.push(ds.type);
        }

        _.each(types, function (t) {
          Dataset.addProperties(ds, Dataset.modules[t] || {}, $.extend({}, ds));
        });

        ds._addedProperties = true;
      }

      ds.displayFormat = ds.displayFormat || {};
      ds.metadata = ds.metadata || {};

      if (_.isFunction(ds._convertLegacy)) {
        ds._convertLegacy();
      }

      if (!$.subKeyDefined(ds, 'metadata.availableDisplayTypes')) {
        var adt;

        if (_.includes(['blob', 'href', 'form', 'api'], ds.type)) {
          adt = [ds.type];
        } else {
          adt = ['table', 'fatrow', 'page'];

          if (!$.isBlank(ds.displayType) && !_.includes(['blist', 'filter', 'grouped'], ds.type)) {
            adt.unshift(ds.displayType);
          }
        }

        ds.metadata.availableDisplayTypes = adt;
      }

      if (!$.subKeyDefined(ds, 'metadata.renderTypeConfig.visible')) {
        ds.metadata = $.extend(true, {
          renderTypeConfig: {
            visible: {}
          }
        }, ds.metadata);
        ds.metadata.renderTypeConfig.visible[ds.displayType] = true;
      }

      if ($.subKeyDefined(ds, 'metadata.renderTypeConfig.active') && !_.some(ds.metadata.renderTypeConfig.active, function (t) {
        return t.id == 'self';
      })) {
        // Something needs to be set to self to properly hook up sidebar, etc.; so pick one at random
        ds.metadata.renderTypeConfig.active[_.first(_.keys(ds.metadata.renderTypeConfig.visible))] = {
          id: 'self'
        };
      }

      ds.url = ds._generateUrl();
      ds.fullUrl = ds._generateUrl(true);
      ds.shortUrl = ds._generateShortUrl(true);
      ds.apiUrl = ds._generateApiUrl();
      ds.domainUrl = ds._generateBaseUrl(ds.domainCName);
    },
    _getChildView: function _getChildView(uid, callback, isBatch) {
      if (!this.childViews) {
        throw 'No such child view';
      }

      this._childViews || (this._childViews = {});

      if (!this._childViews[uid]) {
        var self = this;

        var handleChild = function handleChild(child) {
          self._childViews[uid] = child;

          if (child != self) {
            child.unbind(null, null, self);
            child.bind('displaytype_change', function () {
              self.trigger('displaytype_change');
            }, self);
          }

          callback(child);
        };

        if (uid == 'self') {
          handleChild(self);
        } else {
          Dataset.lookupFromViewId(uid, handleChild, undefined, isBatch);
        }
      } else {
        callback(this._childViews[uid]);
      }
    },
    _childViewsForType: function _childViewsForType(type) {
      // but if we're displaying it as a map, there's only one
      // map to show
      if (type == 'map') {
        return false;
      } // we can only switch if they're trying to display a tabular-ish
      // grid thing


      if (!_.includes(['table', 'fatrow', 'page'], type)) {
        return false;
      }

      return this.childViews;
    },
    _update: function _update(newDS, forceFull, updateColOrder, masterUpdate) {
      var ds = this; // Back-update the ID, because we don't want the new temporary one

      newDS.id = ds.id; // Don't care about unsaved, want to keep default

      newDS.flags = _.without(newDS.flags || [], 'unsaved');

      if (_.includes(ds.flags || [], 'default') && !_.includes(newDS.flags || [], 'default')) {
        newDS.flags = newDS.flags || [];
        newDS.flags.push('default');

        if (_.includes(ds.flags || [], 'restorable')) {
          newDS.flags.push('restorable');
        }
      } // Don't decide this view is unsaved because of the shared flag


      if (_.includes(ds.flags || [], 'shared')) {
        newDS.flags = newDS.flags || [];
        newDS.flags.push('shared');
      }

      var oldQueryString = _.get(ds, 'queryString', null);

      var newQueryString = _.get(newDS, 'queryString', null);

      if (_.isEmpty(newQueryString)) {
        newQueryString = null;
      }

      var oldQuery = ds._getQueryGrouping();

      var oldDispFmt = $.extend(true, {}, ds.displayFormat);
      var oldDispType = ds.displayType;
      var oldRTConfig = $.extend(true, {}, ds.metadata.renderTypeConfig);
      var oldCondFmt = ds.metadata.conditionalFormatting;

      if (forceFull) {
        // If we are updating the entire dataset, then clean out all the
        // valid keys; then the next lines will copy all the new ones over
        _.each(ds._validKeys, function (v, k) {
          if (k != 'columns') {
            delete ds[k];
          }
        });
      }

      _.each(newDS, function (v, k) {
        if (k != 'columns' && ds._validKeys[k]) {
          ds[k] = v;
        }
      });

      ds._adjustProperties();

      if (!$.isBlank(newDS.columns)) {
        ds.updateColumns(newDS.columns, forceFull, updateColOrder, masterUpdate);
      }

      ds._syncQueries(oldQuery.oldJsonQuery, oldQuery.oldQuery, oldQuery.oldGroupings, oldQuery.oldGroupAggs);

      var needsDTChange;

      if (!_.isEqual(oldRTConfig.visible, ds.metadata.renderTypeConfig.visible) || !_.isEqual(oldRTConfig.active, ds.metadata.renderTypeConfig.active)) {
        // If we have a visible type that's not available, add it
        _.each(ds.metadata.renderTypeConfig.visible, function (v, type) {
          if (v && !_.includes(ds.metadata.availableDisplayTypes, type)) {
            ds.metadata.availableDisplayTypes.unshift(type);
          }
        }); // Can't hide everything


        if (_.isEmpty(ds.metadata.renderTypeConfig.visible)) {
          ds.metadata.renderTypeConfig.visible[ds.displayType] = true;
        } // displayType should always be the most important visible availableDisplayType


        ds.displayType = _.find(ds.metadata.availableDisplayTypes, function (adt) {
          return ds.metadata.renderTypeConfig.visible[adt];
        });
        needsDTChange = true;
      } else if (oldDispType != ds.displayType) {
        // displayType changed without rtConfig.visible being updated
        // If we're given a displayType not in our list, then add it
        if (!$.isBlank(ds.displayType) && !_.includes(ds.metadata.availableDisplayTypes, ds.displayType)) {
          ds.metadata.availableDisplayTypes.unshift(ds.displayType);
        } // Make only this type visible


        ds.metadata.renderTypeConfig.visible = {};
        ds.metadata.renderTypeConfig.visible[ds.displayType] = true;
        needsDTChange = true;
      }

      var needQueryChange = !_.isEqual(oldRTConfig.visible, ds.metadata.renderTypeConfig.visible) && _.some(ds.query.namedFilters || [], function (nf) {
        return _.some(nf.displayTypes || [], function (nd) {
          return oldRTConfig.visible[nd] || ds.metadata.renderTypeConfig.visible[nd];
        });
      });

      var cleanFC = ds.cleanJsonFilters();
      var jsonQ = $.extend({}, ds.metadata.jsonQuery, {
        where: cleanFC.where,
        having: cleanFC.having,
        namedFilters: null
      });

      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        var viewIsDifferent = JSON.stringify(ds.metadata.jsonQuery) !== JSON.stringify(oldQuery.oldJsonQuery) || JSON.stringify(ds.metadata.renderTypeConfig) !== JSON.stringify(oldRTConfig) || JSON.stringify(ds.displayType) !== JSON.stringify(oldDispType);

        if (needQueryChange || viewIsDifferent) {
          ds.trigger('query_change');
        } else if (!_.isEqual(oldCondFmt, ds.metadata.conditionalFormatting)) {
          ds.trigger('conditionalformatting_change');
        }
      } else {
        var newKey = RowSet.getQueryKey(jsonQ);

        if (needQueryChange || $.subKeyDefined(ds, '_activeRowSet._key') && ds._activeRowSet._key != newKey) {
          ds.aggregatesChanged();
          var filterChanged = needQueryChange || ds._activeRowSet._key != newKey;

          if (filterChanged) {
            if (!$.isBlank(ds._availableRowSets[newKey])) {
              ds._activateRowSet(ds._availableRowSets[newKey]);
            } else {
              // Find existing set to derive from
              var parRS = _.find(_.sortBy(ds._availableRowSets, function (rs, key) {
                // Sometimes the key argument is undefined :-(
                return -(rs._isComplete ? 1000000 : 1) * (key ? key.length : 1);
              }), function (rs) {
                return rs.canDerive(jsonQ);
              });

              ds._activateRowSet(new RowSet(ds, jsonQ, {
                orderBys: (ds.query || {}).orderBys,
                filterCondition: ds.cleanFilters(),
                groupBys: (ds.query || {}).groupBys,
                groupFuncs: ds._getGroupedFunctions()
              }, parRS));
            }
          } else {
            // Clear out the rows, since the data is different now
            ds._invalidateAll(filterChanged);
          }

          ds.trigger('query_change');
        } else if (!_.isEqual(oldCondFmt, ds.metadata.conditionalFormatting)) {
          // If we aren't invalidating all the rows, but conditional formatting
          // changed, then redo all the colors and re-render. We may not
          // have a row set if we're in the _init path.
          if (!$.isBlank(ds._availableRowSets) && !$.isBlank(ds._activeRowSet)) {
            _.each(ds._availableRowSets, function (rs) {
              rs.formattingChanged();
            });

            ds.trigger('row_change', [_.values(ds._activeRowSet._rows)]);
          }

          ds.trigger('conditionalformatting_change');
        }
      }

      if (needsDTChange) {
        ds.trigger('displaytype_change');
      }

      if (!_.isEqual(oldDispFmt, ds.displayFormat)) {
        ds.trigger('displayformat_change');
      }

      if (masterUpdate) {
        ds._clearTemporary();

        ds._origObj = ds.cleanCopy();
      } else if (_.isEqual(ds._origObj, ds.cleanCopy())) {
        ds._clearTemporary();
      }

      if (!_.isNull(newQueryString) && !_.isEqual(oldQueryString, newQueryString)) {
        ds.trigger('query_string_change');
      }

      var oldValid = ds.valid;
      ds.valid = ds._checkValidity();

      if (!oldValid && ds.valid) {
        ds.trigger('valid');
      }
    },
    _syncQueries: function _syncQueries(oldJsonQuery, oldQuery, oldGroupings, oldGroupAggs) {
      var ds = this; // the core server will do this anyway.

      ds.query = ds.query || {};
      ds.metadata.jsonQuery = ds.metadata.jsonQuery || {};
      var jsonQueryChanged = !_.isEqual($.deepCompact(oldJsonQuery), $.deepCompact(ds.metadata.jsonQuery));
      var hasOldJsonQuery = !_.isUndefined(oldJsonQuery);
      var hasNewJsonQuery = !_.isEmpty(ds.metadata.jsonQuery);

      var hasNoQuery = _.isEmpty(ds.query);

      var columnIdByColumnFieldName = {};

      _.forEach(ds.columns, function (col) {
        columnIdByColumnFieldName[col.fieldName] = col.id;
      }); // ds.query only gets properties set in this condition:


      if (hasOldJsonQuery && jsonQueryChanged || hasNewJsonQuery && hasNoQuery) {
        ds.query.filterCondition = blist.filter.generateSODA1(columnIdByColumnFieldName, ds.metadata.jsonQuery.where, ds.metadata.jsonQuery.having, ds.metadata.defaultFilters);
        ds.query.namedFilters = ds.query.namedFilters || {};

        _.each(ds.metadata.jsonQuery.namedFilters, function (nf, id) {
          ds.query.namedFilters[id] = $.extend(blist.filter.generateSODA1(columnIdByColumnFieldName, nf.where, nf.having), {
            temporary: nf.temporary,
            displayTypes: nf.displayTypes
          });
        });

        ds.query.orderBys = _.compact(_.map(ds.metadata.jsonQuery.order, function (ob) {
          var c = ds.columnForIdentifier(ob.columnFieldName);

          if ($.isBlank(c)) {
            return null;
          }

          return {
            expression: {
              columnId: c.id,
              type: 'column'
            },
            ascending: ob.ascending
          };
        }));
        ds.query.groupBys = _.compact(_.map(ds.metadata.jsonQuery.group, function (g) {
          var c = ds.columnForIdentifier(g.columnFieldName);

          if ($.isBlank(c)) {
            return null;
          }

          c.format.group_function = blist.datatypes.groupFunctionFromSoda2(g.groupFunction);
          return {
            columnId: c.id,
            type: 'column'
          };
        }));
        ds.searchString = ds.metadata.jsonQuery.search; // It's possible select was only set for aggregated columns; so fix it up to have grouped, too

        if (!_.isEmpty(ds.metadata.jsonQuery.group)) {
          ds.metadata.jsonQuery.select = ds.metadata.jsonQuery.select || []; // reverse() is mutable.  Clone/slice for a reversed copy.

          _.each(ds.metadata.jsonQuery.group.slice(0).reverse(), function (g) {
            if (!_.some(ds.metadata.jsonQuery.select, function (s) {
              return s.columnFieldName == g.columnFieldName;
            })) {
              ds.metadata.jsonQuery.select.unshift({
                columnFieldName: g.columnFieldName
              });
            }
          });
        }

        _.each(ds.metadata.jsonQuery.select, function (s) {
          var c = ds.columnForIdentifier(s.columnFieldName);

          if (!$.isBlank(c) && !$.isBlank(s.aggregate)) {
            c.format.grouping_aggregate = blist.datatypes.aggregateFromSoda2(s.aggregate);
          }
        });
      } else {
        // update jsonQuery (new version) if query has changed
        if (!_.isUndefined(oldQuery) && !_.isEqual($.deepCompact(oldQuery), $.deepCompact(ds.query)) || _.isEmpty(ds.metadata.jsonQuery) && !_.isEmpty(ds.query)) {
          ds.metadata.jsonQuery.group = Dataset.translateGroupBys(ds.query.groupBys, ds, ds._getGroupedFunctions());
          var tfc = Dataset.translateFilterCondition(ds.query.filterCondition, ds);
          ds.metadata.jsonQuery.where = tfc.where;
          ds.metadata.jsonQuery.having = tfc.having;
          var tfcDefaults = $.deepCompact(tfc.defaults);

          if ($.isPresent(tfcDefaults) && !$.isEmptyObject(tfcDefaults)) {
            ds.metadata.defaultFilters = tfc.defaults;
          }

          ds.metadata.jsonQuery.namedFilters = ds.metadata.jsonQuery.namedFilters || {};

          _.each(ds.query.namedFilters, function (nf, id) {
            var tnf = Dataset.translateFilterCondition(nf, ds); // One Simple Trick To Remove Undefineds!

            ds.metadata.jsonQuery.namedFilters[id] = $.extend({}, {
              where: tnf.where,
              having: tnf.having,
              temporary: nf.temporary,
              displayTypes: nf.displayTypes
            });
          });

          ds.metadata.jsonQuery.order = _.compact(_.map(ds.query.orderBys, function (ob) {
            var c = ds.columnForIdentifier(ob.expression.columnId);

            if ($.isBlank(c)) {
              return null;
            }

            return {
              columnFieldName: c.fieldName,
              ascending: ob.ascending
            };
          }));
        }

        ds.metadata.jsonQuery.search = ds.searchString;

        if (!_.isEmpty(ds.metadata.jsonQuery.group)) {
          ds.metadata.jsonQuery.select = _.compact(_.map(ds.metadata.jsonQuery.group, function (g) {
            return {
              columnFieldName: g.columnFieldName
            };
          }).concat(_.map(ds.realColumns, function (c) {
            return $.subKeyDefined(c, 'format.grouping_aggregate') ? {
              columnFieldName: c.fieldName,
              aggregate: blist.datatypes.soda2Aggregate(c.format.grouping_aggregate)
            } : null;
          })));
        } else {
          delete ds.metadata.jsonQuery.select;
        }
      } // Clean out any empty keys in the query


      _.each(['namedFilters', 'filterCondition', 'orderBys', 'groupBys'], function (k) {
        if (_.isEmpty(ds.query[k])) {
          delete ds.query[k];
        }
      }); // Clean out any empty keys in the new query


      _.each(['namedFilters', 'group', 'where', 'having', 'search', 'order', 'select'], function (k) {
        if (_.isEmpty(ds.metadata.jsonQuery[k])) {
          delete ds.metadata.jsonQuery[k];
        }
      });

      ds._updateGroupings(oldGroupings, oldGroupAggs); // Update sorts on each column


      _.each(ds.realColumns || [], function (c) {
        delete c.sortAscending;
      });

      _.each(ds.metadata.jsonQuery.order || [], function (ob) {
        var c = ds.columnForIdentifier(ob.columnFieldName);

        if (!$.isBlank(c)) {
          c.sortAscending = ob.ascending;
        }
      });
    },
    _getQueryGrouping: function _getQueryGrouping() {
      var ds = this;
      var q = {};
      q.oldGroupings = (ds.query || {}).groupBys;
      q.oldGroupAggs = {};

      if ((q.oldGroupings || []).length > 0) {
        _.each(ds.realColumns, function (c) {
          if ($.isPresent(c.format.grouping_aggregate)) {
            q.oldGroupAggs[c.id] = c.format.grouping_aggregate;
          }
        });
      }

      q.oldQuery = ds.query || {};
      q.oldJsonQuery = $.extend(true, {}, ds.metadata.jsonQuery);
      return q;
    },
    _updateGroupings: function _updateGroupings(oldGroupings, oldGroupAggs) {
      var ds = this; // Do we care if there was a grouping but now there isn't?
      // Yes

      if ($.isBlank((ds.query || {}).groupBys) && $.isBlank(oldGroupings)) {
        return;
      } // Save off original column order to restore later


      var isNewOrder = $.isBlank(oldGroupings);

      if (isNewOrder) {
        ds._origColOrder = _.map(ds.visibleColumns, 'id');
      }

      var colsChanged = false;
      var curGrouped = {};

      _.each(ds.realColumns, function (c) {
        if (c.format.drill_down) {
          curGrouped[c.id] = true;
        }

        delete c.format.drill_down;
      });

      var newColOrder = [];

      _.each(ds.query.groupBys || [], function (g) {
        var col = ds.columnForID(g.columnId);

        if ($.isBlank(col)) {
          return;
        }

        if ($.isBlank(col.format.grouping_aggregate)) {
          if (!curGrouped[col.id]) {
            col.width += 30;
            colsChanged = true;
          }

          col.format.drill_down = 'true';
        }

        if (col.hidden && !_.some(oldGroupings || [], function (og) {
          return og.columnId == col.id;
        })) {
          col.update({
            flags: _.without(col.flags, 'hidden')
          });
          colsChanged = true;
        }

        newColOrder.push(col.id);
      });

      var newGroupAggs = {};

      var columnsWithGroupAggregate = _.filter(ds.realColumns, function (c) {
        return !$.isBlank(c.format.grouping_aggregate);
      });

      _.each(columnsWithGroupAggregate, function (c) {
        if (c.hidden && !$.isBlank(oldGroupAggs) && !oldGroupAggs[c.id]) {
          c.update({
            flags: _.without(c.flags, 'hidden')
          });
        }

        newGroupAggs[c.id] = c.format.grouping_aggregate;
        newColOrder.push(c.id);
      });

      if ($.isBlank(oldGroupAggs)) {
        oldGroupAggs = newGroupAggs;
      }

      if (_.isEmpty(ds.query.groupBys)) {
        if (!$.isBlank(ds._origColOrder)) {
          ds.setVisibleColumns(ds._origColOrder, null, true);
        }
      } else {
        _.each(ds.realColumns, function (c) {
          var i = _.indexOf(newColOrder, c.id);

          if (i < 0 && !c.hidden) {
            var f = c.flags || [];
            f.push('hidden');
            c.update({
              flags: f
            });
            colsChanged = true;
          }

          if (isNewOrder) {
            if (i < 0) {
              i = c.position + newColOrder.length;
            }

            c.position = i + 1;
          }
        });

        ds.updateColumns();
      }

      if (colsChanged || !_.isEqual(oldGroupAggs, newGroupAggs)) {
        ds.trigger('columns_changed');
      }

      if (!_.isEqual(oldGroupAggs, newGroupAggs)) {
        if (FeatureFlags.value('prohibit_use_of_row_set')) {// noop
        } else {
          ds._invalidateAll(false, true);
        }
      }
    },
    _getGroupedFunctions: function _getGroupedFunctions() {
      var gf = {};

      _.each(this.realColumns, function (c) {
        if (!$.isBlank(c.format.group_function)) {
          gf[c.fieldName] = c.format.group_function;
        }
      });

      return gf;
    },
    makeRequest: function makeRequest(req) {
      req.headers = $.extend(req.headers, {
        'X-Socrata-Federation': 'Honey Badger'
      });

      if (req.inline) {
        req.url = '/views/INLINE/rows.json';
        req.type = 'POST';
        req.data = req.data || JSON.stringify(this.cleanCopy());
      }

      delete req.inline;

      if (this.isAnonymous()) {
        req.anonymous = true;
      }

      this._super(req);
    },
    // Capture custom SODA 2 header values in the dataset model.
    _captureSodaServerHeaders: function _captureSodaServerHeaders(xhr) {
      if (xhr && _.isFunction(xhr.getResponseHeader)) {
        var dataOutOfDate = xhr.getResponseHeader('X-SODA2-Data-Out-Of-Date');
        var truthLastModified = xhr.getResponseHeader('X-SODA2-Truth-Last-Modified');
        var secondaryLastModified = xhr.getResponseHeader('X-SODA2-Secondary-Last-Modified') || xhr.getResponseHeader('Last-Modified');

        if (this.newBackend) {
          if (dataOutOfDate === 'true' && truthLastModified && secondaryLastModified) {
            this._dataOutOfDate = dataOutOfDate;
            this._truthLastModified = truthLastModified;
            this._secondaryLastModified = secondaryLastModified;
            this.trigger('dataset_last_modified', [{
              age: moment(this._secondaryLastModified).from(this._truthLastModified, true) // True elides suffix

            }]);
          } else if (dataOutOfDate === 'false' && truthLastModified && secondaryLastModified) {
            this._secondaryLastModified = secondaryLastModified;
            this.trigger('dataset_last_modified', [{
              lastModified: moment(this._secondaryLastModified).format(blist.configuration.shortDateFormat)
            }]);
          }
        }
      }
    },
    _generateUrl: function _generateUrl(includeDomain) {
      var ds = this;
      var base = ''; // federated dataset has nonblank domain cname

      if (includeDomain || !$.isBlank(ds.domainCName)) {
        base = ds._generateBaseUrl(ds.domainCName);
      }

      var urlParts;

      if (ds.displayType === 'story') {
        urlParts = ['stories/s', ds.id];
      } else if (_.isUndefined(ds.name)) {
        urlParts = ['d', ds.id];
      } else {
        urlParts = [$.urlSafe(ds.category || 'dataset'), $.urlSafe(ds.name), ds.id];
      }

      return base + $.path('/' + urlParts.join('/'));
    },
    _generateShortUrl: function _generateShortUrl(includeDomain) {
      var ds = this;
      var base = ''; // federated dataset has nonblank domain cname

      if (includeDomain || !$.isBlank(ds.domainCName)) {
        base = ds._generateBaseUrl(ds.domainCName, true);
      }

      if (ds.displayType === 'story') {
        return base + $.path('/stories/s/' + ds.id);
      } else {
        return base + $.path('/d/' + ds.id);
      }
    },
    _generateApiUrl: function _generateApiUrl() {
      return this._generateBaseUrl() + '/api/views/' + this.id;
    },
    _viewRemoved: function _viewRemoved(view) {
      var ds = this;

      if (!$.isBlank(ds._relatedViews)) {
        ds._relatedViews = _.without(ds._relatedViews, view);
      }

      if (!$.isBlank(ds._relViewCount)) {
        ds._relViewCount--;
      }

      if (!$.isBlank(ds._parent) && ds._parent.id == view.id) {
        delete ds._parent;
      }
    },
    _loadRelatedViews: function _loadRelatedViews(callback) {
      callback = callback || _.noop;
      var ds = this; // add data lenses to the pane using a second getByTableId call

      var coreViewsPromise = this._loadRelatedCoreViews();

      var dataLensPromise = this._getRelatedDataLenses();

      $.whenever(coreViewsPromise, dataLensPromise).done(function (coreResult, dataLensResult) {
        var coreViews = coreResult ? coreResult[0] : [];
        var dataLensViews = dataLensResult ? dataLensResult : [];
        ds._relatedViews = ds._processRelatedViews(_.uniq([].concat(coreViews, dataLensViews), 'id'));
        callback();
      });
    },
    _processRelatedViews: function _processRelatedViews(views) {
      var ds = this;
      views = _.map(views, function (v) {
        if (v.id == ds.id) {
          v = ds;
        }

        if (v instanceof Dataset) {
          return v;
        }

        var nv = createDatasetFromView(v);
        nv.bind('removed', function () {
          ds._viewRemoved(this);
        });

        if (!$.isBlank(ds.accessType)) {
          nv.setAccessType(ds.accessType);
        }

        return nv;
      });

      var parDS = _.find(views, function (v) {
        return _.includes(v.flags || [], 'default');
      });

      if (!$.isBlank(parDS)) {
        ds._parent = parDS;
        views = _.without(views, parDS);
      }

      return views;
    },
    _loadRelatedCoreViews: function _loadRelatedCoreViews() {
      // Fully cachable
      return this.makeRequestWithPromise({
        url: '/views.json',
        pageCache: true,
        type: 'GET',
        data: {
          method: 'getByTableId',
          tableId: this.tableId
        }
      });
    },
    _getRelatedDataLenses: function _getRelatedDataLenses() {
      var ds = this;
      return this.getNewBackendId().then(_.bind(ds._fetchViewJson, ds)).then(function (result) {
        return ds._lookUpDataLensesByTableId(result.tableId);
      }).then(_.bind(ds._onlyDataLenses, ds));
    },
    _fetchViewJson: function _fetchViewJson(nbeId) {
      return this.makeRequestWithPromise({
        url: "/views/".concat(nbeId, ".json"),
        pageCache: true,
        type: 'GET'
      });
    },
    _lookUpDataLensesByTableId: function _lookUpDataLensesByTableId(nbeTableId) {
      if ($.isBlank(nbeTableId)) {
        throw new Error('nbeTableId is blank');
      }

      return this.makeRequestWithPromise({
        url: '/views.json',
        pageCache: true,
        type: 'GET',
        data: {
          method: 'getByTableId',
          tableId: nbeTableId
        }
      });
    },
    _onlyDataLenses: function _onlyDataLenses(views) {
      var dataLens = _.filter(views, function (view) {
        return view.displayType === 'data_lens' || view.displayType === 'visualization' || // Legacy support for now.
        view.displayType === 'visualization_canvas_table' || view.displayType === 'visualization_canvas_chart' || view.displayType === 'visualization_canvas_map';
      });

      return $.when(dataLens);
    },
    _loadPublicationViews: function _loadPublicationViews(callback) {
      var ds = this;

      var processDS = function processDS(views) {
        views = _.map(views, function (v) {
          if (v instanceof Dataset) {
            return v;
          }

          var nv = createDatasetFromView(v);

          if (!$.isBlank(ds.accessType)) {
            nv.setAccessType(ds.accessType);
          }

          return nv;
        });
        ds._publishedViews = _.filter(views, function (v) {
          return v.isPublished();
        });
        ds._snapshotViews = _.filter(views, function (v) {
          return v.isSnapshot();
        }); // There should be only one

        ds._unpublishedView = _.find(views, function (v) {
          return v.isUnpublished();
        });

        if (_.isFunction(callback)) {
          callback();
        }
      };

      ds.makeRequest({
        url: '/api/views/' + ds.id + '.json',
        pageCache: true,
        type: 'GET',
        params: {
          method: 'getPublicationGroup'
        },
        success: processDS
      });
    },
    // See util/dataset/map.js and util/dataset/chart.js for examples of asset
    // types which override the timeout value. NOTE: timeout must be less than
    // the render timeout of Polaroid!
    _setupPolaroidImageCapturing: function _setupPolaroidImageCapturing(timeout) {
      this.bind('request_finish', _.debounce(function () {
        console.log('Render complete.');
        window.callPhantom('snapshotReady');
      }, timeout || 5000));
    },
    _getThumbNameOrDefault: function _getThumbNameOrDefault(name) {
      return name || 'page';
    },
    _getCroppedThumbnailMeta: function _getCroppedThumbnailMeta(name) {
      return ((this.metadata || {}).thumbnail || {})[name];
    },
    _updateSnapshot: function _updateSnapshot(method, name, callback) {
      var ds = this;
      ds.makeRequest({
        success: function success(response) {
          ds._updateThumbnailCallback(response, callback);
        },
        error: callback,
        type: 'POST',
        url: '/views/' + ds.id + '/snapshots?method=' + method + '&name=' + ds._getThumbNameOrDefault(name)
      });
    },
    _updateThumbnailCallback: function _updateThumbnailCallback(response, callback) {
      if ((response.metadata || {}).thumbnail) {
        this.metadata.thumbnail = response.metadata.thumbnail;
      }

      callback(response);
    },
    _cleanUnsaveable: function _cleanUnsaveable(md) {
      var ds = this;
      var adjMD = md;

      if (ds.isPublished() && ds.isDefault()) {
        adjMD = $.extend(true, {}, md); // Can't save columns or any query but a sort-by on published datasets

        delete adjMD.columns; // If they give us a blank query obj, don't do unnecessary modifications

        if (!$.isBlank(adjMD.query) && _.isEmpty(adjMD.query)) {
          /* nothing */
        } else if ($.subKeyDefined(adjMD, 'query.orderBys')) {
          adjMD.query = {
            orderBys: adjMD.query.orderBys
          };
        } else {
          delete adjMD.query;
        }
      }

      return adjMD;
    },
    _getClustersViaSODA2WithoutRowSet: function _getClustersViaSODA2WithoutRowSet(viewport, displayFormat, minDistance, successCallback, errorCallback) {
      var ds = this;
      var colLookup = ds.columnForIdentifier(displayFormat.plot.locationId).lookup;
      var params = {
        method: 'soql_clustered'
      }; // Yay copy-paste

      params['target_node_clusters'] = 250;
      params['min_distance_between_clusters'] = minDistance;

      if (!params['min_distance_between_clusters']) {
        params['min_distance_between_clusters'] = Math.min(viewport.xmax - viewport.xmin, viewport.ymax - viewport.ymin) / 10;

        if (params['min_distance_between_clusters'] > 5) {
          params['min_distance_between_clusters'] = 5;
        } else if (params['min_distance_between_clusters'] > 1) {
          params['min_distance_between_clusters'] = 1;
        }
      }

      var translateCluster = function translateCluster(c) {
        c.parent = ds._clusters[c.pathToRoot[0]];
        ds._clusters[c.id] = c;

        _.each(c.points, function (point) {
          ds._rowClusterParents[point] = c;
        });

        _.each(c.children, function (child) {
          if (ds._clusters[child] && !ds._clusters[child].parent) {
            ds._clusters[child].parent = ds._clusters[ds._clusters[child].pathToRoot[0]];
          }
        });

        _.each(c.polygon, function (vertex) {
          if (vertex.lat == 90) {
            vertex.lat -= 0.000001;
          } else if (vertex.lat == -90) {
            vertex.lat += 0.000001;
          }

          if (vertex.lon == 180) {
            vertex.lon -= 0.000001;
          } else if (vertex.lon == -180) {
            vertex.lon += 0.000001;
          }
        });

        c.leafNode = (c.points || []).length > 0;
      };

      ds.getQueryBase(function () {
        // Build baseline query with row filtering.
        var baseQuery = ds._queryBase.metadata.jsonQuery;

        if (!ds._jsonQuery) {
          ds._jsonQuery = {};
        } // Pillaged from RowSet#_makeSODA2Request
        // Inject tears here because lack of DRYness.


        var soqlWhere = blist.filter.generateSOQLWhere(blist.filter.subtractQueries(Dataset.translateFilterColumnsToBase(ds._jsonQuery.where, ds), baseQuery.where), ds._queryBase);
        params.$where = soqlWhere;
        params.location = colLookup;
        var requests;

        _.each({
          'xmin': 'min_lon',
          'xmax': 'max_lon',
          'ymin': 'min_lat',
          'ymax': 'max_lat'
        }, function (newProp, oldProp) {
          params[newProp] = viewport[oldProp];
        });

        if (viewport.xmax < viewport.xmin) {
          // Add one query for each side of the date line.
          requests = _.map([{
            max_lon: 179.999999
          }, {
            min_lon: -179.999999
          }], function (bound) {
            return $.extend({}, params, bound);
          });
        } else {
          requests = [params];
        }

        var viewportsLeft = requests.length;
        var totalData = [];

        var callback = function callback(data) {
          viewportsLeft--;
          totalData = totalData.concat(data);
          ds.trigger('row_count_change');

          if (viewportsLeft == 0) {
            successCallback(totalData);
          }
        };

        _.each(requests, function (req) {
          ds.makeRequest({
            url: '/views/' + ds.id + '/rows.json',
            params: req,
            success: function success(data) {
              _.each(data, translateCluster);

              callback(data);
            },
            error: errorCallback
          });
        });
      });
    },
    _validKeys: {
      attribution: true,
      attributionLink: true,
      category: true,
      columns: true,
      description: true,
      disabledFeatureFlags: true,
      displayFormat: true,
      displayType: true,
      flags: true,
      hideFromCatalog: true,
      hideFromDataJson: true,
      iconUrl: true,
      id: true,
      licenseId: true,
      message: true,
      metadata: true,
      moderationStatus: true,
      name: true,
      originalViewId: true,
      privateMetadata: true,
      publicationAppendEnabled: true,
      query: true,
      queryString: true,
      resourceName: true,
      rowIdentifierColumnId: true,
      searchString: true,
      tags: true,
      termsAndConditions: true
    },

    /**
     * 2/5/2019 - Retiring `row-set`
     *
     * Now that we have a consistent way to fetch the rows represented by an
     * arbitrary view object, we are consolidating all of our data access to use
     * the same code.
     *
     * In `dataset.js`, this means replacing usages of the `row-set` class,
     * which extends the `server-model` class. `row-set` makes heavy use of
     * SODA1 idioms which, in actual practice, should be in a definite minority
     * of access patterns we encounter. It also fundamentally expects to be able
     * to fetch individual rows by id, which is not a thing we do any longer.
     * Part of the work to stop using `row-set` will include updating consumers
     * of its methods to not expect to get individual rows by id.
     *
     * The first step of this transition will be to isolate usage of `row-set`
     * as much as possible. This is not the hardest thing to do because most of
     * its usage is in `dataset.js`, which provides an interface that we can
     * implement using more conventional data fetching methods (specifically,
     * those provided by the SocrataViewDataProvider, which is already used by
     * the grid view and visualizations).
     */
    getRows: function getRows(start, len, successCallback, errorCallback, reversedSortOrder) {
      var self = this;

      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        /**
         * EN-30905 - Conditional formatting not applied in classic visualizations
         *
         * It turns out that row-set.js was decorating responses from the rows
         * API with the color that the row is supposed to be rendered as when
         * conditional formatting is configured.
         *
         * The function below is slightly modified from its original
         * implementation in row-set.js, and needs to live here from now on in
         * order to maintain backwards-compatibility with conditional
         * formatting. Note that this also means that we also need to keep
         * /platform-ui/frontend/public/javascripts/util/filter.js around for
         * the foreseeable future since it is a dependency of setRowFormatting.
         */
        var setRowColor = function setRowColor(datasetObj, row) {
          // Historical comment:
          //
          // This reads metadata.conditionalFormatting, which is an ordered
          // array of conditions & colors. The row will get the color of the
          // first condition that it matches, or no color if it matches none
          // of them.
          // metadata.conditionalFormatting is an array. Each entry is an object
          // with two keys: color and condition.
          // * color: String of CSS color, such as '#ffffff' or
          //          'rgba(255, 255, 255, 1)'
          // * condition: Can be true, in which case any row will match this
          //          condition. This is a good way to make a default as the
          //          last item in the list. Otherwise it is an object. In the basic
          //          case, this has three keys:
          //   * tableColumnId: Identifies a column to look up the cell value in this
          //          row to use for comparision
          //   * subColumn: Identifies a sub-column to check for a value
          //   * operator: How to do the comparison; operators available are the same
          //          as for filter conditions
          //   * value: Value to compare against
          //   Alternately, you can have more complex expressions by providing
          //   a key of children which has an array of condition objects.
          //   In this case, operator is still required, but should be either
          //   'and' or 'or' to control how the multiple conditions are combined
          //
          // Simple example to mark rows that have too high a measurement, too low,
          // or within range:
          // metadata.conditionalFormatting: [
          //   {
          //     color: '#ff9999',
          //     condition: {
          //       tableColumnId: 123,
          //       operator: 'greater_than',
          //       value: 100
          //     }
          //   },
          //   {
          //     color: '#9999ff',
          //     condition: {
          //       tableColumnId: 123,
          //       operator: 'less_than',
          //       value: 20
          //     }
          //   },
          //   {
          //     color: '#99ff99',
          //     condition: true
          //   }
          // ]
          var color = null;
          var formatting = datasetObj.metadata.conditionalFormatting;

          if (_.isArray(formatting)) {
            var relevantCondition = _.find(formatting, function (formattingClause) {
              // 2019 comment:
              //
              // blist.filter.matchesExpression returns a new function that
              // returns true or false based on whether or not it thinks the
              // filter condition used to generate the comparator function
              // matches the row data passed in to the comparator function.
              // This seems overly complex for what it's doing given that we
              // could just use an anonymous function here and the intent
              // would maybe be more clear, but it's certainly possible there
              // are layers of problems this thing is attempting to solve and
              // of which I am unaware.
              var comparatorFunction = blist.filter.matchesExpression(formattingClause.condition, datasetObj); // The comparator function expects an entire SODA1 row object,
              // but at this point we only have pieces of it so we need to
              // return the row data itself inside a fake outer row object.
              // The other sibling keys of 'data' on the SODA1 row object do
              // not matter for our purposes here, so it's ok to use a
              // fake wrapper around the row data  instead of the entire fake
              // SODA1 row object that we generate right before we call the
              // success callback passed to <Dataset>.getRows().

              return comparatorFunction({
                data: row
              });
            }) || {};

            if (relevantCondition.color) {
              color = relevantCondition.color;
            }
          }

          return color;
        };

        var socrataViewDataProvider = new SocrataViewDataProvider({
          domain: window.location.hostname
        });
        var currentView = this.cleanCopyIncludingRenderTypeName();
        currentView.newBackend = this.newBackend; // EN-31364 - Certain Classic Charts Not Displaying in Goal Pages
        //
        // In order to correctly forumlate the queries that power the legacy
        // 'data series grouping' experience we need to make sure that we select
        // only the single column that represents the category in the query we
        // make to get the possible category grouping values.
        //
        // Because the OO-style of calling methods on a live dataset instance is
        // quite different than our new style of passing values to more-
        // typically-static functions, I originally (and mistakenly) was passing
        // the currentView as the currentView, savedView and also the parentView
        // to the query below without realizing that other places in the code
        // were actually mutating the 'current view' in such a way that it would
        // short-circuit our test for whether this should be a 'select *'
        // because we're just looking at the saved view.
        //
        // Selecting * instead of selecting the single grouping column was
        // causing the data series grouping logic in d3.base.seriesGrouping to
        // get confused about how many unique values were being used for
        // categories, which led to its internal math being wrong and no rows
        // being drawn even though the legend _was_ being drawn.
        //
        // We now pass blist.dataset._origObj as both the savedView and the
        // parentView. blist.dataset._origObj is a clean JSON copy of the view
        // that is saved on the server, which is handy to check the 'current'
        // view against when trying to unravel how the current view instance has
        // been mutated over the lifetime of the page.
        //
        //
        // EN-31936 - Next Page button not working on NJ Explorers
        //
        // It turns out that some usees of this method do not actually assign
        // window.blist.dataset, so the fix applied for EN-31364 ended up
        // breaking those uses. Specifically, DataSlate pages do not assign
        // window.blist.dataset but do make use of this method.
        //
        // In order to unbreak this use case, we can read _origObj from 'this'
        // instead of from window, since the two should be equivalent when
        // window.blist.dataset is assigned but 'this' is guaranteed to be
        // present in this context.

        var queryConfig = {
          currentView: currentView,
          savedView: self._origObj,
          parentView: self._origObj,
          offset: start,
          // EN-30373 - Calendar not updating from NBE-migrated dataset
          //
          // The calendar visualization will apparently ask for all rows in the
          // dataset every time it makes a request for rows. When we are
          // providing a simulated SODA1 API for backward-compatibility,
          // however, we will only ever fetch the first n rows that the NBE
          // will return, and the calendar visualization asks for 500. In the
          // case of at least one calendar based on a dataset with more than 500
          // rows, this causes the calendars to appear blank, whereas what is
          // actually happening is that the chart is only asking for 500 rows
          // and all of the rows the NBE responds with fall outside the window
          // of dates that would be rendered by the calendar.
          limit: _.get(currentView, 'displayType') === 'calendar' ? 5000 : len
        };
        socrataViewDataProvider.query(queryConfig).then(function (response) {
          // Sample SODA1 row (which we need to emulate because existing usage
          // of this method expects SODA1-formatted responses):
          //
          // {
          //   "invalid": {},
          //   "changed": {},
          //   "error": {},
          //   "sessionMeta": {},
          //   "data": {
          //     "numoffatalcrashes": "80",
          //     "year": "2013-01-01T00:00:00.000",
          //     ":id": "jsrowid-2"
          //   },
          //   "metadata": {
          //     "id": "jsrowid-2"
          //   },
          //   "id": "jsrowid-2",
          //   "icon": null,
          //   "color": null,
          //   "index": 0
          // }
          self._totalRows = response.totalRowCount;
          var fakeSODA1Rows = response.rows.map(function (row, i) {
            var fakeSODA1RowData = {};
            response.columns.forEach(function (fieldName, j) {
              // EN-30349 - Return correct SODA1/OBE row semantics for OBE
              // datasets
              //
              // A note on column identifiers: Older parts of the codebase
              // that rely on SODA1 semantics will key the column values in
              // <row>.data by the column's id if the dataset is an OBE
              // dataset, and the column's fieldname if it is a NBE dataset.
              //
              // This logic is more or less lifted from `_setUpColumn` as
              // defined in column.js, but doesn't account for the additional
              // complexity of system columns because presumably people aren't
              // charting or mapping those, and this compatibility layer only
              // exists to provide backward compatibility for charts and maps.
              var identifier = self._useSODA2 ? fieldName : self.columnForFieldName(fieldName).id;
              fakeSODA1RowData[identifier] = row[j];
            });

            var fakeSODA1RowId = 'jsrowid-' + _.uniqueId();

            fakeSODA1RowData[':id'] = fakeSODA1RowId;
            return {
              invalid: {},
              changed: {},
              error: {},
              sessionMeta: {},
              data: fakeSODA1RowData,
              metadata: {
                id: fakeSODA1RowId
              },
              id: fakeSODA1RowId,
              color: setRowColor(self, fakeSODA1RowData),
              icon: null,
              // EN-31936 - Next Page button not working on NJ Explorers
              //
              // It appears that certain parts of DataSlate attempt to be
              // clever by not re-rendering rows that it thinks it has already
              // rendered. It was apparently treating the 'index' property on
              // a row as the index into the dataset (rather than the index
              // into the query result set) and rejecting any rows with the
              // same 'index' from the set of new rows to be rendered. The
              // ultimate effect of this behavior was that when this RowSet
              // backward compatibility layer was used by a table rendered
              // by the DataSlate 'repeater' (component/data/repeater.js)
              // trying to view a different page of data (e.g. by clicking the
              // 'next page' button) would result in nothing apparently
              // happening even though the right query was issued--this was
              // because the index properties were always in the interval
              // [0..len), which DataSlate interpreted as a no-op after it had
              // initially rendered the first page of results.
              //
              // To fix this we can attempt to make the 'index' property
              // equivalent to the row's index into the dataset with the given
              // (or implicit) ordering. I am not currently aware of any other
              // use of this property, and if there is there is a good chance
              // that other use is making a similar assumption, since it is
              // probably of a similar vintage.
              index: start + i
            };
          });
          successCallback(fakeSODA1Rows);
        })["catch"](function (error) {
          errorCallback(error);
        });
      } else {
        // Callback may be called multiple times with smaller batches of rows
        this._activeRowSet.getRows(start, len, successCallback, errorCallback, reversedSortOrder);
      }
    },
    getAllRows: function getAllRows(successCallback, errorCallback) {
      var self = this;

      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        // EN-30885 - `prohibit_use_of_row_set` breaks when used with
        //            dataset.getAllRows
        //
        // This invocation used to pass incorrect arguments to getRows, such
        // that the start offset would be the success callback and the length
        // would be the error callback.
        //
        // Instead, we can break this apart into a two-step query:
        //
        // First get the total number of rows in the result set.
        self.getTotalRows(function (totalRows) {
          // Then get all the rows in the result set based on the value of
          // totalRows.
          //
          // Note that we probably can't just read from this._totalRows even
          // if it exists and is a number because changes to the query (e.g.
          // adding a where clause) might cause the number of rows in the
          // result set to change without invalidating this._totalRows.
          self.getRows(0, totalRows, successCallback, errorCallback);
        }, errorCallback);
      } else {
        this._activeRowSet.getAllRows(successCallback, errorCallback);
      }
    },
    getRowsByIds: function getRowsByIds(ids, successCallback, errorCallback) {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset.getRowsByIds() was called.');
      } else {
        this._activeRowSet.getRows(ids, null, successCallback, errorCallback);
      }
    },
    primaryKeyExists: function primaryKeyExists(candidatePrimaryKey) {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset.primaryKeyExists() was called.');
      } else {
        return this._activeRowSet.primaryKeyExists(candidatePrimaryKey);
      }
    },
    loadedRows: function loadedRows() {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset.loadedRows() was called.');
      } else {
        return this._activeRowSet.loadedRows();
      }
    },
    invalidateMeta: function invalidateMeta() {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset.invalidateMeta() was called.');
      } else {
        // Should be all row-sets?
        this._activeRowSet.invalidateMeta();
      }
    },
    invalidateRows: function invalidateRows() {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset.invalidateRows() was called.');
      } else {
        // Should be all row-sets?
        this._activeRowSet.invalidate();
      }
    },
    usingBuckets: function usingBuckets() {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset.usingBuckets() was called.');
      } else {
        return this.newBackend;
      }
    },
    setBucketSize: function setBucketSize(bucketSize) {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset.setBucketSize() was called.');
      } else {
        return this.bucketSize = bucketSize;
      }
    },
    rowForID: function rowForID(id) {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset.rowForID() was called.');
      } else {
        return this._activeRowSet.rowForID(id);
      }
    },
    rowForIndex: function rowForIndex(index) {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset.rowForIndex() was called.');
      } else {
        return this._activeRowSet.rowForIndex(index);
      }
    },
    rowIndex: function rowIndex(id, successCallback) {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset.rowIndex() was called.');
      } else {
        this._activeRowSet.rowIndex(id, successCallback);
      }
    },
    getTotalRows: function getTotalRows(successCallback, errorCallback) {
      var self = this;

      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        this.getRows(0, 1, function () {
          successCallback(self.totalRows());
        }, function () {
          errorCallback();
        });
      } else {
        this._activeRowSet.getTotalRows(successCallback, errorCallback);
      }
    },
    totalRows: function totalRows() {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        return this._totalRows;
      } else {
        return this._activeRowSet.totalRows();
      }
    },
    getRowBucket: function getRowBucket(index) {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset.getRowBucket() was called.');
      } else {
        return this._activeRowSet.getRowBucket(index);
      }
    },
    bucketIndex: function bucketIndex(bucketStart) {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset.bucketIndex() was called.');
      } else {
        return this._activeRowSet.bucketIndex(bucketStart);
      }
    },
    totalBuckets: function totalBuckets() {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset.totalBuckets() was called.');
      } else {
        return this._activeRowSet.totalBuckets();
      }
    },
    createRowWithPK: function createRowWithPK(pkValue) {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset.createRowWithPK() was called.');
      } else {
        return this.createRow(null, null, null, pkValue);
      }
    },
    // Assume it goes at the end
    createRow: function createRow(data, parRowId, parColId, pkValue, successCallback, errorCallback) {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset.createRow() was called.');
      } else {
        var ds = this;
        var parCol;

        if (!$.isBlank(parColId)) {
          parCol = this.columnForID(parColId);
        }

        var parRow;

        if (!$.isBlank(parRowId)) {
          parRow = this.rowForID(parRowId);
        }

        data = data || {
          data: {}
        };
        var newRow = {
          data: {},
          metadata: $.extend({}, data.metadata),
          invalid: {},
          error: {},
          changed: {}
        };

        _.each(!$.isBlank(parCol) ? parCol.childColumns : ds.columns, function (c) {
          if (!$.isBlank(data.data[c.lookup])) {
            newRow.data[c.lookup] = data.data[c.lookup];
          }
        });

        newRow.id = 'saving' + _.uniqueId();
        delete newRow.data.uuid;

        _.each(!$.isBlank(parCol) ? parCol.realChildColumns : ds.realColumns, function (c) {
          newRow.changed[c.lookup] = true;
        });

        if (ds.rowsNeedPK) {
          if (pkValue) {
            newRow.data[ds.rowIdentifierColumn.lookup] = pkValue;
          } else {
            // Now what happens is a round-trip to the server, which will return a 500.
            // We'll take that and render it as an error on the UX.
            // Because GOOD DESIGN.
            console.error('tried to create a row without a pk value');
            newRow.error[ds.rowIdentifierColumn.lookup] = true;
            newRow.valid = false;
          }
        }

        if ($.isBlank(parRow)) {
          ds._addRow(newRow, data.index);
        } else {
          parRow.data[parCol.lookup] = parRow.data[parCol.lookup] || [];

          if (!$.isBlank(data.index)) {
            parRow.data[parCol.lookup].splice(data.index, 0, newRow);
          } else {
            parRow.data[parCol.lookup].push(newRow);
          }

          ds._updateRow(parRow);

          ds.trigger('row_change', [[parRow], true]);
        }

        var key = newRow.id;

        if (!$.isBlank(parRow)) {
          key += ':' + parRow.id + ':' + parCol.id;
        } // This feels like a hack.
        // The purpose of creating this array normally is to anticipate an edit.
        // Because row creation on an NBE dataset will fail, we need to
        // NOT anticipate the edit, because it will not be forthcoming.


        if (!ds.newBackend) {
          ds._pendingRowEdits[key] = [];
        }

        var savingLookups;

        if (ds._useSODA2) {
          savingLookups = _.map(ds.realColumns, 'lookup');
        } else {
          savingLookups = _.map($.isBlank(parCol) ? ds.realColumns : parCol.realChildColumns, 'id');
        } // Don't bother actually doing separate row creation unless it's OBE.
        // In NBE, the entire purpose of this function is to do some UX work and then
        // return a temporary ID.


        if (!ds.newBackend) {
          var reqObj = {
            row: newRow,
            rowData: ds._rowData(newRow, savingLookups, parCol),
            parentRow: parRow,
            parentColumn: parCol,
            success: successCallback,
            error: errorCallback
          };

          if ($.isBlank(ds._pendingRowCreates)) {
            ds._serverCreateRow(reqObj);

            ds._pendingRowCreates = [];
          } else {
            ds._pendingRowCreates.push(reqObj);
          }
        }

        return newRow.id;
      }
    },
    _serverCreateRow: function _serverCreateRow(req, isBatch) {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset._serverCreateRow() was called.');
      } else {
        var ds = this;

        var rowCreated = function rowCreated(rr) {
          var oldID = req.row.id;

          if (!ds._useSODA2) {
            // Add metadata to new row
            // FIXME: The server response for this should be changing; we can
            // run into problems if there is a user column named something like
            // '_id'
            _.each(rr, function (v, k) {
              if (k.startsWith('_')) {
                var adjName = k.slice(1);
                var c = !$.isBlank(req.parentColumn) ? req.parentColumn.childColumnForID(adjName) : ds.columnForID(adjName);
                var l = $.isBlank(c) ? adjName : c.lookup;
                req.row.data[l] = v;
                req.row.metadata[l] = v;
              }
            });

            req.row.id = req.row.metadata.id;
          } else {
            // Pretty sure this code path never gets called.
            // Response keys = [:updated_meta, :id, :updated_at, :created_meta, :position, :created_at]
            req.row.id = req.row.metadata.id = req.row.data[':id'] = rr[':id'];
          }

          if (req.row.underlying) {
            req.row.noMatch = true;
            req.row.underlying = null;
          }

          var oldKey = oldID;
          var newKey = req.row.id;

          if (!$.isBlank(req.parentRow)) {
            oldKey += ':' + req.parentRow.id + ':' + req.parentColumn.id;
            newKey += ':' + req.parentRow.id + ':' + req.parentColumn.id;
          }

          ds._pendingRowEdits[newKey] = ds._pendingRowEdits[oldKey];
          delete ds._pendingRowEdits[oldKey];
          ds._pendingRowDeletes[newKey] = ds._pendingRowDeletes[oldKey];
          delete ds._pendingRowDeletes[oldKey];

          if (ds._useSODA2) {
            _.each(ds._pendingRowEdits[newKey], function (pre) {
              pre.rowData[':id'] = req.row.id;
            });

            _.each(ds._pendingRowDeletes[newKey], function (pre) {
              pre.rowId = req.row.id;
            });
          } // We can have old IDs embedded in child row keys; so messy cleanup...


          if ($.isBlank(req.parentRow)) {
            var updateKeys = function updateKeys(pendingItems) {
              _.each(_.keys(pendingItems), function (k) {
                var nk = k.replace(':' + oldKey + ':', ':' + newKey + ':');

                if (nk != k) {
                  pendingItems[nk] = pendingItems[k];
                  delete pendingItems[k];
                }
              });
            };

            updateKeys(ds._pendingRowEdits);
            updateKeys(ds._pendingRowDeletes);
          }

          _.each(!$.isBlank(req.parentColumn) ? req.parentColumn.realChildColumns : ds.realColumns, function (c) {
            delete req.row.changed[c.lookup];
          });

          if ($.isBlank(req.parentRow)) {
            ds._updateRow(req.row, oldID);
          } else {
            ds._updateRow(req.parentRow);
          }

          ds.trigger('row_change', [[{
            id: oldID
          }, req.parentRow || req.row]]);

          ds._processPending(req.row.id, (req.parentRow || {}).id, (req.parentColumn || {}).id);

          ds.aggregatesChanged();

          if (_.isFunction(req.success)) {
            req.success(req.row);
          }
        };

        var rowErrored = function rowErrored() {
          _.each(!$.isBlank(req.parentColumn) ? req.parentColumn.realChildColumns : ds.realColumns, function (c) {
            req.row.error[c.lookup] = true;
          });

          ds._updateRow(req.parentRow || req.row);

          ds.trigger('row_change', [[req.parentRow || req.row]]);

          if (_.isFunction(req.error)) {
            req.error();
          }
        }; // On complete, kick off any pending creates


        var rowCompleted = function rowCompleted() {
          if ((ds._pendingRowCreates || []).length > 0) {
            while (ds._pendingRowCreates.length > 0) {
              ds._serverCreateRow(ds._pendingRowCreates.shift(), true);
            }

            ServerModel.sendBatch();
          } else {
            delete ds._pendingRowCreates;
          }
        };

        var url = ds._useSODA2 ? '/api/id/' + ds.id : '/views/' + ds.id + '/rows';

        if (!$.isBlank(req.parentRow)) {
          url += '/' + req.parentRow.id + '/columns/' + req.parentColumn.id + '/subrows';
        }

        url += '.json';
        var rd = req.rowData;

        if (ds._useSODA2) {
          rd = $.extend(true, {}, rd);
          delete rd[':id'];
        }

        ds.makeRequest({
          url: url,
          isSODA: ds._useSODA2,
          type: 'POST',
          data: JSON.stringify(rd),
          batch: isBatch,
          success: rowCreated,
          error: rowErrored,
          complete: rowCompleted
        });
      }
    },
    removeRows: function removeRows(rowIds, parRowId, parColId, successCallback, errorCallback) {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset.removeRow() was called.');
      } else {
        var ds = this;
        rowIds = $.makeArray(rowIds);
        var parCol;

        if (!$.isBlank(parColId)) {
          parCol = this.columnForID(parColId);
        }

        var parRow;

        if (!$.isBlank(parRowId)) {
          parRow = this.rowForID(parRowId);
        }

        _.each(rowIds, function (rId) {
          // Subrows need UUID
          var uuid;

          if ($.isBlank(parRow)) {
            var r = ds.rowForID(rId);

            if ($.isBlank(r)) {
              return;
            }

            uuid = ds._useSODA2 ? r.id : r.metadata.uuid;

            if (ds.rowsNeedPK) {
              uuid = r.data[ds.rowIdentifierColumn.lookup];
            }

            ds._removeRow(r);
          } else {
            parRow.data[parCol.lookup] = _.reject(parRow.data[parCol.lookup], function (cr) {
              if (cr.id == rId) {
                uuid = ds._useSODA2 ? cr.id : cr.metadata.uuid;
                return true;
              }

              return false;
            });

            ds._updateRow(parRow);
          }

          var key = rId;

          if (!$.isBlank(parRow)) {
            key += ':' + parRow.id + ':' + parCol.id;
          }

          if (!$.isBlank(ds._pendingRowEdits[key])) {
            ds._pendingRowDeletes[key] = {
              rowId: uuid,
              parRowId: parRowId,
              parColId: parColId
            };
            return;
          }

          ds._serverRemoveRow(uuid, parRowId, parColId, true);
        });

        if (!$.isBlank(parRow)) {
          ds.trigger('row_change', [[parRow], true]);
        } else {
          ds.trigger('row_count_change');
        }

        ds._aggregatesStale = true;

        _.each(!$.isBlank(parCol) ? parCol.realChildColumns : ds.realColumns, function (c) {
          c.invalidateData();
        });

        ServerModel.sendBatch({
          success: successCallback,
          error: errorCallback
        });
      }
    },
    _serverRemoveRow: function _serverRemoveRow(rowId, parRowId, parColId, isBatch) {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset._serverRemoveRow() was called.');
      } else {
        var ds = this;

        var rowRemoved = function rowRemoved() {
          ds.aggregatesChanged();
        };

        var url = ds._useSODA2 ? '/api/id/' + ds.id : '/views/' + ds.id + '/rows/';

        if (!$.isBlank(parRowId)) {
          url += parRowId + '/columns/' + parColId + '/subrows/';
        }

        if (!ds._useSODA2) {
          url += rowId + '.json';
        }

        var rowData = {
          ':deleted': true
        };
        var idColName = ':id';

        if (ds.rowsNeedPK) {
          idColName = ds.rowIdentifierColumn.lookup;
        }

        rowData[idColName] = rowId; // Because reasons!

        if (ds.newBackend) {
          rowData = [rowData];
        }

        ds.makeRequest({
          batch: isBatch,
          url: url,
          type: ds._useSODA2 ? 'POST' : 'DELETE',
          isSODA: ds._useSODA2,
          data: JSON.stringify(rowData),
          success: rowRemoved
        });
      }
    },
    _processPending: function _processPending(rowId, parRowId, parColId) {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset._processPending() was called.');
      } else {
        var ds = this;
        var key = rowId;

        if (!$.isBlank(parRowId)) {
          key += ':' + parRowId + ':' + parColId;
        } // Are there any pending edits to this row?
        // If so, save the next one


        if (ds._pendingRowEdits[key] && ds._pendingRowEdits[key].length > 0) {
          while (ds._pendingRowEdits[key].length > 0) {
            // Do save
            ds._serverSaveRow(ds._pendingRowEdits[key].shift(), true);
          }

          ServerModel.sendBatch();
        } else {
          delete ds._pendingRowEdits[key];

          if (ds._pendingRowDeletes[key]) {
            var pd = ds._pendingRowDeletes[key];

            ds._serverRemoveRow(pd.rowId, pd.parRowId, pd.parColId);

            delete ds._pendingRowDeletes[key];
          }
        }
      }
    },
    _rowData: function _rowData(row, savingLookups, parCol) {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset._rowData() was called.');
      } else {
        var ds = this;
        var data = {};

        _.each(savingLookups, function (cL) {
          data[cL] = row.data[cL];
        }); // Hard-coding here is bad; but sometimes we don't get the meta column back :/


        var fieldMeta = (ds.metaColumnForName('meta') || {}).lookup || ds._useSODA2 ? ':meta' : 'meta'; // Copy over desired metadata columns

        data[fieldMeta] = row.metadata.meta; // Invalid values need to be saved into metadata

        _.each(row.invalid, function (isI, cId) {
          if (isI) {
            var c = !$.isBlank(parCol) ? parCol.childColumnForID(cId) : ds.columnForID(cId);
            data[fieldMeta] = data[fieldMeta] || {};
            data[fieldMeta].invalidCells = data[fieldMeta].invalidCells || {};
            data[fieldMeta].invalidCells[c.fieldName] = data[cId];
            data[cId] = null;
          }
        }); // Metadata is a JSON string


        if (!$.isBlank(data[fieldMeta])) {
          data[fieldMeta] = JSON.stringify(data[fieldMeta]);
        }

        if (ds._useSODA2) {
          data[':id'] = row.id;
        }

        return data;
      }
    },
    setRowValue: function setRowValue(value, rowId, columnId, isInvalid, parRowId, parColId) {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset.setRowValue() was called.');
      } else {
        var parCol;
        var col;

        if (!$.isBlank(parColId)) {
          parCol = this.columnForID(parColId);
          col = parCol.childColumnForID(columnId);
        } else {
          col = this.columnForID(columnId);
        }

        if ($.isBlank(col)) {
          throw 'Column ' + columnId + ' not found';
        }

        if (col.isMeta) {
          throw 'Cannot modify metadata on rows: ' + columnId;
        }

        var row;

        if (!$.isBlank(parRowId)) {
          var parRow = this.rowForID(parRowId);
          row = this._activeRowSet.childRowForID(rowId, parRow, parCol);
        } else {
          row = this.rowForID(rowId);
        }

        if ($.isBlank(row)) {
          throw 'Row ' + rowId + ' not found while setting value ' + value;
        } // Save this off because we'll need it for upserting.


        if (col == this.rowIdentifierColumn && _.isUndefined(row.originalPrimaryKeyValue)) {
          row.originalPrimaryKeyValue = row.data[col.lookup];
        }

        row.data[col.lookup] = value;
        delete row.error[col.lookup];
        row.changed[col.lookup] = true;
        row.invalid[col.lookup] = isInvalid || false; // If the dataset has no PK, the row is always save-able.
        // If the dataset has a PK, but it isn't set, the row is not saveable.
        // This row-level validity has nothing to do with cell-level validity.
        // Confused yet?

        row.valid = !this.rowsNeedPK || !_.isUndefined(row.data[this.rowIdentifierColumn.lookup]);

        this._activeRowSet.updateRow(parRow || row);

        this.trigger('row_change', [[parRow || row]]);
      }
    },
    saveRow: function saveRow(rowId, parRowId, parColId, successCallback, errorCallback, useBatch) {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset.saveRow() was called.');
      } else {
        var ds = this;
        var parCol;

        if (!$.isBlank(parColId)) {
          parCol = this.columnForID(parColId);
        }

        var parRow;
        var row;

        if (!$.isBlank(parRowId)) {
          parRow = this.rowForID(parRowId);
          row = this._activeRowSet.childRowForID(rowId, parRow, parCol);
        } else {
          row = this.rowForID(rowId);
        }

        if ($.isBlank(row)) {
          throw 'Row ' + rowId + ' not found while saving';
        } // NBE does not accept invalid data. Just toss the query.


        if (_.some(row.invalid) && ds.newBackend) {
          console.error('this row has invalid columns, so we didn\'t submit it.');
          return;
        } // Keep track of which columns need to be saved, and only use those values


        var saving = _.keys(row.changed);

        if (ds.rowsNeedPK) {
          if (!_.includes(saving, ds.rowIdentifierColumn.lookup)) {
            saving.push(ds.rowIdentifierColumn.lookup);
          }
        }

        var sendRow = ds._rowData(row, saving, parCol); // Cleanup the fallout from a failed attempt to create a row on NBE.


        if (ds.newBackend && !_.has(row.metadata, 'version')) {
          if (/^saving\d+/.test(row.id)) {
            delete sendRow[':id'];
          }

          delete sendRow[':meta'];
        } // When attempting to modify the pk value, need to issue an upsert first.
        // 1. Throw away our sendRow. We need to re-build the entire row.
        // 2. Send a delete command on the existing row.
        // 3. Send an insert on the *entire* row, since "everything" is changed now.


        if (_.has(row.metadata, 'version') && row.changed[(ds.rowIdentifierColumn || {}).lookup]) {
          // ds.rowIdentifierColumn should be guaranteed since
          // row.changed[null] should be undefined.
          sendRow = [];
          var deleteCmd = {
            ':deleted': true
          };
          deleteCmd[ds.rowIdentifierColumn.lookup] = row.originalPrimaryKeyValue;
          sendRow.push(deleteCmd);
          sendRow.unshift(ds._rowData(row, _.map(ds.realColumns, 'lookup'), parCol));
        }

        var doRequest = function doRequest() {
          var reqObj = {
            row: row,
            rowData: sendRow,
            columnsSaving: saving,
            parentRow: parRow,
            parentColumn: parCol,
            success: successCallback,
            error: errorCallback
          };
          var key = row.id;

          if (!$.isBlank(parRow)) {
            key += ':' + parRow.id + ':' + parCol.id;
          }

          if (!$.isBlank(ds._pendingRowEdits[key])) {
            ds._pendingRowEdits[key].push(reqObj);

            return;
          }

          ds._pendingRowEdits[key] = [];

          ds._serverSaveRow(reqObj, useBatch);
        }; // This check only needs to happen if there's a primary key. You can't modify
        // the server-generated :id column.


        if (ds.rowsNeedPK) {
          var primaryKeyColumnID = ds.rowIdentifierColumn.lookup;
          var hasChangedPrimaryKey = row.changed[primaryKeyColumnID];

          if (hasChangedPrimaryKey) {
            var candidatePrimaryKey = row.data[primaryKeyColumnID];
            ds.primaryKeyExists(candidatePrimaryKey).done(function (primaryKeyRow) {
              var hasPrimaryKeyRow = _typeof(primaryKeyRow) === 'object';
              var isDifferentRow = row.id !== (hasPrimaryKeyRow && primaryKeyRow.id);

              if (hasPrimaryKeyRow && isDifferentRow) {
                console.error('Attempted to change primary key to one that already exists.');
                row.error[ds.rowIdentifierColumn.lookup] = true;
                row.invalid[ds.rowIdentifierColumn.lookup] = true; // Update the UX.

                ds.trigger('row_change', [[row]]);
                ds.trigger('grid_error_message', [row, ds.rowIdentifierColumn, $.t('controls.grid.errors.primary_key_collision')]);
              } else {
                doRequest();
              }
            }).fail(function () {
              ds.trigger('grid_error_message', [row, ds.rowIdentifierColumn, $.t('controls.grid.errors.cannot_edit_at_this_time')]);
            });
          } else {
            doRequest();
          }
        } else {
          doRequest();
        }
      }
    },
    _serverSaveRow: function _serverSaveRow(r, isBatch) {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset._serverSaveRow() was called.');
      } else {
        var ds = this; // On save, unmark each item, and fire an event

        var rowSaved = function rowSaved(result) {
          _.each(r.columnsSaving, function (cL) {
            delete r.row.changed[cL];
          });

          _.each(r.columnsSaving, function (cL) {
            var col = !$.isBlank(r.parentColumn) ? r.parentColumn.childColumnForIdentifier(cL) : ds.columnForIdentifier(cL);

            ds._updateLinkedColumns(col, r.row, result);
          });

          if (!result._underlying) {
            r.row.noMatch = null;
          } // This is the code path when creating a new row in NBE, so
          // we tell the RowSet, here, to update the row with the new id now
          // because this is the point at which we receive it.
          //
          // This is a NOOP in OBE land.


          var oldRowId = undefined;

          if (ds._useSODA2 && result[':id']) {
            oldRowId = r.row.id;
            r.row.id = result[':id'];
          }

          ds._updateRow(r.parentRow || r.row, oldRowId);

          ds.trigger('row_change', [[r.parentRow || r.row]]);
          ds.aggregatesChanged();

          if (_.isFunction(r.success)) {
            r.success(r.row);
          }
        }; // On error, mark as such and notify


        var rowErrored = function rowErrored() {
          _.each(r.columnsSaving, function (cL) {
            r.row.error[cL] = true;
          });

          ds._updateRow(r.parentRow || r.row);

          ds.trigger('row_change', [[r.parentRow || r.row]]);

          if (_.isFunction(r.error)) {
            r.error();
          }
        }; // On complete, kick off any pending saves/deletes


        var rowCompleted = function rowCompleted() {
          ds._processPending(r.row.id, (r.parentRow || {}).id, (r.parentColumn || {}).id);
        };

        var url = ds._useSODA2 ? '/api/id/' + ds.id : '/views/' + ds.id + '/rows';

        if (!$.isBlank(r.parentRow)) {
          url += '/' + r.parentRow.id + '/columns/' + r.parentColumn.id + '/subrows';
        }

        url += (ds._useSODA2 ? '' : '/' + r.row.metadata.uuid) + '.json';
        ds.makeRequest({
          url: url,
          type: ds._useSODA2 ? 'POST' : 'PUT',
          data: JSON.stringify(r.rowData),
          isSODA: ds._useSODA2,
          batch: isBatch,
          success: rowSaved,
          error: rowErrored,
          complete: rowCompleted
        });
        ds._aggregatesStale = true;

        _.each(r.columnsSaving, function (cL) {
          (!$.isBlank(r.parentColumn) ? r.parentColumn.childColumnForIdentifier(cL) : ds.columnForIdentifier(cL)).invalidateData();
        });
      }
    },
    markRow: function markRow(markType, value, row) {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset.markRow() was called.');
      } else {
        _.each(this._availableRowSets, function (rs) {
          rs.markRow(markType, value, row);
        });
      }
    },
    getAggregates: function getAggregates(callback, customAggs) {
      var self = this;

      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        // Substitute for the deprecated RowSet.getAggregates()
        var soqlDataProvider = new SoqlDataProvider({
          domain: window.location.hostname,
          datasetUid: this.id
        });
        var columnAggregatePairs = [];

        var soqlGroupingAggregate = function soqlGroupingAggregate(groupingAggregate) {
          switch (groupingAggregate) {
            case 'average':
              return 'avg';

            case 'minimum':
              return 'min';

            case 'maximum':
              return 'max';

            default:
              return groupingAggregate;
          }
        };

        Object.keys(customAggs).forEach(function (columnId) {
          var columnFieldName = _.get(self.columnForID(columnId), 'fieldName', null);

          if (!_.isNull(columnFieldName)) {
            customAggs[columnId].forEach(function (aggregateFunction) {
              columnAggregatePairs.push("".concat(soqlGroupingAggregate(aggregateFunction), "(").concat(columnFieldName, ")"));
            });
          }
        });
        var queryString = "select ".concat(columnAggregatePairs.join(', ') || '*');
        soqlDataProvider.rawQuery(queryString).then(function (response) {
          Object.keys(customAggs).forEach(function (columnId) {
            var column = self.columnForID(columnId);

            if (column) {
              customAggs[columnId].forEach(function (aggregate) {
                column.aggregates[aggregate] = parseFloat(response[0]["".concat(soqlGroupingAggregate(aggregate), "_").concat(column.fieldName)]);
              });
            }
          });
          callback();
        })["catch"](function () {
          var errorMessage = 'Failed to get aggregates.';

          if (window.console && window.console.error) {
            console.error(errorMessage);
          }

          throw new Error(errorMessage);
        }); // End of substitute for the deprecated RowSet.getAggregates()
      } else {
        var ds = this;

        var aggResult = function aggResult(aggs) {
          _.each(aggs, function (a) {
            var c = ds.columnForIdentifier(a.columnIdent);

            if (!$.isBlank(c)) {
              c.aggregates[a.name] = $.isBlank(a.value) ? null : parseFloat(a.value);
            }
          });

          ds._aggregatesStale = false;
          ds.trigger('column_totals_changed');

          if (_.isFunction(callback)) {
            callback();
          }
        }; // If aggregates are stale, clear them all out to avoid confusion


        if (ds._aggregatesStale) {
          _.each(ds.realColumns, function (c) {
            c.aggregates = {};
          });
        }

        var isStale = ds._aggregatesStale || _.some(customAggs || {}, function (aList, cId) {
          var col = ds.columnForID(cId);

          if ($.isBlank(col)) {
            return true;
          }

          return _.some($.makeArray(aList), function (a) {
            return $.isBlank(col.aggregates[a]);
          });
        }) || $.isBlank(customAggs) && _.some(ds.visibleColumns, function (c) {
          return $.subKeyDefined(c.format.aggregate) && $.isBlank(c.aggregates[c.format.aggregate]);
        });

        if (isStale) {
          ds._activeRowSet.getAggregates(aggResult, customAggs);
        } else if (_.isFunction(callback)) {
          callback();
        }
      }
    },
    // File Data exists at the Dataset level, not the RowSet level.
    resyncFileDataForFileIds: function resyncFileDataForFileIds(ids) {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset.resyncFileDataForFileIds() was called.');
      } else {
        var ds = this; // We choose to be overzealous here because we'll reject them in the next step.

        if (_.isUndefined(ids)) {
          ids = ds._activeRowSet.getFileIds();

          ds._activeRowSet.mapFileIdsToRows();
        }

        var fileIds = _.reject(ids, _.bind(this.fileDataForFileId, ds));

        if (_.isEmpty(fileIds)) {
          return $.when(ds._fileDataForFileId);
        }

        var deferred = $.Deferred(); //eslint-disable-line new-cap

        $.ajax({
          url: "/views/".concat(ds.id, "/files.json?method=getAll"),
          data: JSON.stringify({
            fileIds: fileIds
          }),
          contentType: 'application/json',
          type: 'post',
          dataType: 'json'
        }).done(function (responseData) {
          var rowsChanged = _(responseData).map(function (data) {
            ds._fileDataForFileId[data.id] = data;
            return ds._activeRowSet.applyFileDataToRow(data);
          }).filter(_.identity). // Dump falses.
          value();

          if (rowsChanged.length > 0) {
            ds._activeRowSet.trigger('row_change', [rowsChanged, false]);
          }

          deferred.resolve(ds._fileDataForFileId);
        });
        return deferred.promise();
      }
    },
    _activateRowSet: function _activateRowSet(newRS) {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset._activateRowSet() was called.');
      } else {
        var ds = this;

        if (newRS == ds._activeRowSet) {
          return;
        }

        if (!$.isBlank(ds._activeRowSet)) {
          ds._activeRowSet.deactivate();

          _.each(['row_change', 'row_count_change', 'metadata_update'], function (evName) {
            ds._activeRowSet.unbind(evName, null, ds);
          });
        }

        ds._activeRowSet = newRS;
        ds._availableRowSets = ds._availableRowSets || {};

        var k = ds._activeRowSet.getKey();

        if (ds._availableRowSets[k] != ds._activeRowSet) {
          ds._availableRowSets[k] = ds._activeRowSet;
        }

        if (!$.isBlank(ds._activeRowSet)) {
          _.each(['row_change', 'row_count_change'], function (evName) {
            ds._activeRowSet.bind(evName, function () {
              ds.trigger(evName, arguments);
            }, ds);
          });

          ds._activeRowSet.bind('metadata_update', function () {
            ds._update.apply(ds, arguments);
          });

          ds._activeRowSet.activate();
        }
      }
    },
    _addRow: function _addRow(newRow, idx) {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset._addRow() was called.');
      } else {
        var ds = this;

        _.each(ds._availableRowSets, function (rs) {
          rs.addRow(newRow, rs == ds._activeRowSet ? idx : null);
        });
      }
    },
    _updateRow: function _updateRow(row, oldID) {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset._updateRow() was called.');
      } else {
        _.each(this._availableRowSets, function (rs) {
          rs.updateRow(row, oldID);
        });
      }
    },
    _removeRow: function _removeRow(row) {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset._removeRow() was called.');
      } else {
        _.each(this._availableRowSets, function (rs) {
          rs.removeRow(row);
        });
      }
    },
    _invalidateAll: function _invalidateAll() {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset._invalidateAll() was called.');
      } else {
        var ds = this;
        delete ds._availableRowSets;
        var cleanFC = ds.cleanJsonFilters();

        ds._activateRowSet(new RowSet(ds, $.extend({}, ds.metadata.jsonQuery, {
          where: cleanFC.where,
          having: cleanFC.having,
          namedFilters: null
        }), {
          orderBys: (ds.query || {}).orderBys,
          filterCondition: ds.cleanFilters(),
          groupBys: (ds.query || {}).groupBys,
          groupFuncs: ds._getGroupedFunctions()
        }));
      }
    },
    _getClustersViaSODA2: function _getClustersViaSODA2(viewport, displayFormat, minDistance, successCallback, errorCallback) {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset._getClustersViaSODA2() was called.');
      } else {
        var ds = this;
        var colLookup = ds.columnForIdentifier(displayFormat.plot.locationId).lookup;
        var params = {
          method: 'soql_clustered'
        }; // Yay copy-paste

        params['target_node_clusters'] = 250;
        params['min_distance_between_clusters'] = minDistance;

        if (!params['min_distance_between_clusters']) {
          params['min_distance_between_clusters'] = Math.min(viewport.xmax - viewport.xmin, viewport.ymax - viewport.ymin) / 10;

          if (params['min_distance_between_clusters'] > 5) {
            params['min_distance_between_clusters'] = 5;
          } else if (params['min_distance_between_clusters'] > 1) {
            params['min_distance_between_clusters'] = 1;
          }
        }

        var translateCluster = function translateCluster(c) {
          c.parent = ds._clusters[c.pathToRoot[0]];
          ds._clusters[c.id] = c;

          _.each(c.points, function (point) {
            ds._rowClusterParents[point] = c;
          });

          _.each(c.children, function (child) {
            if (ds._clusters[child] && !ds._clusters[child].parent) {
              ds._clusters[child].parent = ds._clusters[ds._clusters[child].pathToRoot[0]];
            }
          });

          _.each(c.polygon, function (vertex) {
            if (vertex.lat == 90) {
              vertex.lat -= 0.000001;
            } else if (vertex.lat == -90) {
              vertex.lat += 0.000001;
            }

            if (vertex.lon == 180) {
              vertex.lon -= 0.000001;
            } else if (vertex.lon == -180) {
              vertex.lon += 0.000001;
            }
          });

          c.leafNode = (c.points || []).length > 0;
        };

        ds.getQueryBase(function () {
          // Build baseline query with row filtering.
          var baseQuery = ds._queryBase.metadata.jsonQuery,
              rs = ds._activeRowSet; // Pillaged from RowSet#_makeSODA2Request
          // Inject tears here because lack of DRYness.

          var soqlWhere = blist.filter.generateSOQLWhere(blist.filter.subtractQueries(Dataset.translateFilterColumnsToBase(rs._jsonQuery.where, ds), baseQuery.where), ds._queryBase);
          params.$where = soqlWhere;
          params.location = colLookup;
          var requests;

          _.each({
            'xmin': 'min_lon',
            'xmax': 'max_lon',
            'ymin': 'min_lat',
            'ymax': 'max_lat'
          }, function (newProp, oldProp) {
            params[newProp] = viewport[oldProp];
          });

          if (viewport.xmax < viewport.xmin) {
            // Add one query for each side of the date line.
            requests = _.map([{
              max_lon: 179.999999
            }, {
              min_lon: -179.999999
            }], function (bound) {
              return $.extend({}, params, bound);
            });
          } else {
            requests = [params];
          }

          var viewportsLeft = requests.length;
          var totalData = [];

          var callback = function callback(data) {
            viewportsLeft--;
            totalData = totalData.concat(data);
            ds.trigger('row_count_change');

            if (viewportsLeft == 0) {
              successCallback(totalData);
            }
          };

          _.each(requests, function (req) {
            ds.makeRequest({
              url: '/views/' + ds.id + '/rows.json',
              params: req,
              success: function success(data) {
                _.each(data, translateCluster);

                callback(data);
              },
              error: errorCallback
            });
          });
        });
      }
    },
    findColumnForServerName: function findColumnForServerName(name, parCol) {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset.findColumnForServerName() was called.');
      } else {
        var ds = this;
        name = ds._useSODA2 ? name : {
          sid: 'id',
          'id': 'uuid'
        }[name] || name;
        var c = ds._useSODA2 ? $.isBlank(parCol) ? ds.columnForFieldName(name) : parCol.childColumnForFieldName(name) : $.isBlank(parCol) ? ds.columnForID(name) : parCol.childColumnForID(name);

        if ($.isBlank(c)) {
          if (ds._useSODA2 && ds.isGrouped()) {
            // Maybe a group function?
            var i = name.indexOf('__');
            var gf = name.slice(i + 2);
            var mId = name.slice(0, i);
            c = $.isBlank(parCol) ? ds.columnForIdentifier(mId) : parCol.childColumnForIdentifier(mId);

            if ($.isBlank(c) || c.format.group_function != blist.datatypes.groupFunctionFromSoda2(gf)) {
              // Maybe this is an aggregate column?
              i = name.indexOf('_');
              var agg = name.slice(0, i);
              name = name.slice(i + 1);
              c = $.isBlank(parCol) ? ds.columnForIdentifier(name) : parCol.childColumnForIdentifier(name);

              if ($.isBlank(c) || c.format.grouping_aggregate != blist.datatypes.aggregateFromSoda2(agg)) {
                return null;
              }
            }
          } else {
            return null;
          }
        }

        return c;
      }
    },
    _updateLinkedColumns: function _updateLinkedColumns(keyCol, row, newRow) {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset._updateLinkedColumns() was called.');
      } else {
        var ds = this;

        if (keyCol.dataTypeName == 'dataset_link') {
          for (var n = ds.columns.length - 1; n >= 0; n--) {
            var col = ds.columns[n];
            if (!col.isLinked()) continue;
            var uname = col.underscoreName(ds);
            row.data[col.lookup] = newRow[uname];
          }
        }
      }
    },
    hasDatasetLinkColumn: function hasDatasetLinkColumn() {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset.hasDatasetLinkColumn() was called.');
      } else {
        // no link column in bnb
        var ds = this;

        if (ds && ds.parentId) {
          return false;
        }

        return _.some(ds.columns, function (c) {
          return c.dataTypeName == 'dataset_link';
        });
      }
    },
    getLinkedColumnOptions: function getLinkedColumnOptions(keyCol, notUsed, $field, curVal) {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset.getLinkedColumnOptions() was called.');
      } else {
        var ds = this;
        var localKeyColumnId = keyCol && keyCol['format.linkedKey'] ? keyCol['format.linkedKey'] : keyCol;

        if ($.isBlank(localKeyColumnId) || isNaN(localKeyColumnId)) {
          return [];
        }

        var viewUid = ds.columnForID(localKeyColumnId).format.linkedDataset;

        if ($.isBlank(viewUid) || !viewUid.match(blist.util.patterns.UID)) {
          return [];
        }

        if ($.isBlank(ds._cachedLinkedColumnOptions[viewUid])) {
          // ETag handling is fully implemented for views
          ds.makeRequest({
            url: '/api/views/' + viewUid + '.json',
            pageCache: true,
            type: 'GET',
            error: function error(req) {
              alert(JSON.parse(req.responseText).message);
            },
            success: function success(linkedDataset) {
              var lds = createDatasetFromView(linkedDataset);

              if (!$.isBlank(ds.accessType)) {
                lds.setAccessType(ds.accessType);
              }

              ds._cachedLinkedColumnOptions[viewUid] = [];
              var cldo = ds._cachedLinkedColumnOptions[viewUid];
              var opt;

              _.each(lds.columns || [], function (c) {
                if (c.canBeLinkSource()) {
                  opt = {
                    value: String(c.fieldName),
                    text: c.name,
                    dataType: c.dataTypeName
                  };
                  cldo.push(opt);
                }
              });

              if (ds._cachedLinkedColumnOptions[viewUid].length <= 0) {
                alert('Dataset ' + viewUid + ' does not have any columns.');
              } else {
                $field.data('linkedFieldValues', '_reset');

                _.each($field.data('linkedGroup'), function (f) {
                  $(f).trigger('change');
                });

                _.defer(function () {
                  $field.val(curVal);
                });
              }
            }
          });
          return [];
        } // set up another key to get the remote columns.  used by add new
        // column dialog.


        ds._cachedLinkedColumnOptions[localKeyColumnId] = ds._cachedLinkedColumnOptions[viewUid];
        return ds._cachedLinkedColumnOptions[viewUid];
      }
    },
    getLinkSourceDataType: function getLinkSourceDataType(col, linkSrcColId, keyColId) {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset.getLinkSourceDataType() was called.');
      } else {
        var localKeyColId = col && col.format ? col.format.linkedKey : keyColId;
        var ds = blist.dataset;
        var keyCol = ds.columnForID(localKeyColId);

        if (keyCol == undefined) {
          return null;
        }

        var viewUid = keyCol.format.linkedDataset;
        var remoteColumns = ds._cachedLinkedColumnOptions[viewUid];

        if (remoteColumns == null) {
          return null;
        }

        for (var n = remoteColumns.length - 1; n >= 0; n--) {
          if (remoteColumns[n].value == linkSrcColId) {
            var dt = remoteColumns[n].dataType;
            return {
              value: dt,
              text: blist.datatypes[dt].title
            };
          }
        }

        return null;
      }
    },
    aggregatesChanged: function aggregatesChanged(skipStale) {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset.aggregatesChanged() was called.');
      } else {
        if (!skipStale) {
          this._aggregatesStale = true;
        }

        this.trigger('column_totals_changed');
      }
    },
    // TODO IDE says this is an unused method
    _adjustVisibleColumns: function _adjustVisibleColumns(visColIds) {
      if (FeatureFlags.value('prohibit_use_of_row_set')) {
        reportRowSetError('prohibit_use_of_row_set: Dataset._adjustVisibleColumns() was called.');
      } else {
        var ds = this;

        if (ds.isGrouped()) {
          // Hide columns not grouped or rolled-up
          visColIds = _.filter(visColIds, function (cId) {
            var c = ds.columnForID(cId);
            return !$.isBlank(c.format.grouping_aggregate) || _.some(ds.query.groupBys, function (g) {
              return g.columnId == c.id;
            });
          });
        }

        return visColIds;
      }
    }
    /**
     * End of `row-set` usage.
     */

  });
  Dataset.modules = {};
  var cachedLinkedDatasetOptions = {};

  Dataset.getLinkedDatasetOptions = function (linkedDatasetUid, col, $field, curVal, useRdfKeyAsDefault) {
    if (FeatureFlags.value('prohibit_use_of_row_set')) {
      reportRowSetError('prohibit_use_of_row_set: Dataset::getLinkedDatasetOptions() was called.');
    } else {
      var viewUid = linkedDatasetUid;

      if ($.isBlank(viewUid) || !viewUid.match(blist.util.patterns.UID)) {
        return [];
      }

      if (cachedLinkedDatasetOptions[viewUid] == null) {
        $.Tache.Get({
          //eslint-disable-line new-cap
          url: '/api/views/' + viewUid + '.json',
          error: function error(req) {
            alert(JSON.parse(req.responseText).message);
          },
          success: function success(linkedDataset) {
            var lds = createDatasetFromView(linkedDataset);
            cachedLinkedDatasetOptions[viewUid] = [];
            var cldo = cachedLinkedDatasetOptions[viewUid];
            var opt;
            var rdfSubject = linkedDataset && linkedDataset.metadata && linkedDataset.metadata.rdfSubject ? linkedDataset.metadata.rdfSubject : undefined;

            _.each(lds.columns || [], function (c) {
              if (c.canBeDatasetLink()) {
                opt = {
                  value: String(c.fieldName),
                  text: c.name
                };

                if (useRdfKeyAsDefault && opt.value === rdfSubject) {
                  opt.selected = true;
                }

                cldo.push(opt);
              }
            });

            if (cachedLinkedDatasetOptions[viewUid].length <= 0) {
              alert($.t('controls.grid.no_columns', {
                uid: viewUid
              }));
            } else {
              $field.data('linkedFieldValues', '_reset');

              _.each($field.data('linkedGroup'), function (f) {
                $(f).trigger('change');
              });

              _.defer(function () {
                $field.val(curVal);
              });
            }
          }
        });
        return [];
      }

      return cachedLinkedDatasetOptions[viewUid];
    }
  };

  Dataset.getLinkedDatasetOptionsDefault = function (linkedDatasetUid, col, $field, curVal) {
    if (FeatureFlags.value('prohibit_use_of_row_set')) {
      reportRowSetError('prohibit_use_of_row_set: Dataset::getLinkedDatasetOptionsDefault() was called.');
    } else {
      return Dataset.getLinkedDatasetOptions(linkedDatasetUid, col, $field, curVal, true);
    }
  };

  Dataset.getLinkedDatasetOptionsNoDefault = function (linkedDatasetUid, col, $field, curVal) {
    if (FeatureFlags.value('prohibit_use_of_row_set')) {
      reportRowSetError('prohibit_use_of_row_set: DatasetgetLinkedDatasetOptionsNoDefault() was called.');
    } else {
      return Dataset.getLinkedDatasetOptions(linkedDatasetUid, col, $field, curVal, false);
    }
  };

  Dataset.createFromMapLayerUrl = function (url, successCallback, errorCallback) {
    $.ajax({
      url: '/api/layers.json?method=createMapLayerDataset&url=' + escape(url),
      type: 'POST',
      contentType: 'application/json',
      dataType: 'json',
      success: function success(view) {
        if (_.isFunction(successCallback)) {
          successCallback(createDatasetFromView(view));
        }
      },
      error: errorCallback
    });
  };

  Dataset.lookupFromResourceName = function (resourceName, successCallback, errorCallback, isBatch, isAnonymous) {
    Dataset._create(false, resourceName, successCallback, errorCallback, isBatch, isAnonymous, true);
  };

  Dataset.createFromResourceName = function (resourceName, successCallback, errorCallback, isBatch, isAnonymous) {
    Dataset._create(true, resourceName, successCallback, errorCallback, isBatch, isAnonymous, true);
  };

  Dataset.lookupFromViewId = function (id, successCallback, errorCallback, isBatch, isAnonymous) {
    Dataset._create(false, id, successCallback, errorCallback, isBatch, isAnonymous);
  };

  Dataset.createFromViewId = function (id, successCallback, errorCallback, isBatch, isAnonymous) {
    Dataset._create(true, id, successCallback, errorCallback, isBatch, isAnonymous);
  }; // method for grabbing the most recently opened datasets by this user on this
  // computer, including anonymous access. in 99% of cases, this should be the
  // correct behaviour. in 1%, it will probably confuse the user and cause some
  // support burden. can't win it all.


  Dataset.getRecentDatasets = function (fetchResources, successCallback, errorCallback) {
    if (typeof localStorage === 'undefined') {
      successCallback([]);
    } // get all recent datasets, and anonymous access sets.


    var allRecents = _getRecentsFromStorage();

    var ourRecents = allRecents['anon-mous'] || []; // merge in logged-in user's sets if they are logged in.

    if (!$.isBlank(blist.currentUserId)) {
      ourRecents = ourRecents.concat(allRecents[blist.currentUserId] || []);
    } // massage recents, grab ids.


    var ids = _.map(_cleanedMostRecent(ourRecents), 'id'); // get the actual datasets if requested, otherwise just return.


    if (fetchResources === true) {
      var results = [];
      ServerModel.startBatch();

      _.each(ids, function (id) {
        Dataset.createFromViewId(id, function (ds) {
          results[ids.indexOf(id)] = ds;
        }, null, // it's okay if we fail; probably an auth issue.
        true);
      });

      ServerModel.sendBatch(function () {
        successCallback(_.compact(results));
      }, errorCallback);
    } else {
      successCallback(ids);
    }
  }; // method for saving the above.


  Dataset.saveRecentDataset = function (ds) {
    if (typeof localStorage === 'undefined') {
      return;
    } // grab the bucket we're qualified under.


    var allRecents = _getRecentsFromStorage();

    var userId = blist.currentUserId || 'anon-mous';
    var ourBucket = allRecents[userId] || []; // insert ourselves; do some house cleaning.

    ourBucket.push({
      id: ds.id,
      at: new Date().getTime()
    });
    ourBucket = _cleanedMostRecent(ourBucket); // saveback.

    allRecents[userId] = ourBucket;
    localStorage.setItem('socrataRecentDS', JSON.stringify(allRecents));
  }; // util method for fetching the recents obj from localstorage.


  var _getRecentsFromStorage = function _getRecentsFromStorage() {
    return JSON.parse(localStorage.getItem('socrataRecentDS') || '{}');
  }; // util method for getting the top relevant most recent ds from an array.


  var _cleanedMostRecent = function _cleanedMostRecent(mostRecents) {
    // sort, dedupe, prune, pluck ids.
    // we sort THEN dedupe so that we keep the most recent time always.
    var sorted = _.sortBy(mostRecents, function (x) {
      return x.at * -1;
    });

    var unique = _.uniq(sorted, true, function (x) {
      return x.id;
    });

    return unique.slice(0, 10); // pruned
  };

  Dataset._create = function (clone, id, successCallback, errorCallback, isBatch, isAnonymous, isResourceName) {
    var cachedView = clone ? blist.viewCache[id] : blist.sharedDatasetCache[id] || blist.viewCache[id];
    isAnonymous = !!isAnonymous;

    if (!_.isUndefined(cachedView)) {
      if (cachedView === false && _.isFunction(errorCallback)) {
        errorCallback({
          responseText: JSON.stringify({
            code: 'permission_denied',
            message: $.t('controls.grid.permission_denied')
          })
        });
      } else if (cachedView !== false && _.isFunction(successCallback)) {
        var ds;

        if (cachedView instanceof Dataset) {
          if (clone || cachedView.isAnonymous() != isAnonymous) {
            ds = cachedView.clone();
          } else {
            ds = cachedView;
          }
        } else {
          ds = createDatasetFromView(cachedView);
        }

        if (isAnonymous) {
          ds.isAnonymous(isAnonymous);
        }

        successCallback(ds);
      }
    } else {
      $.socrataServer.makeRequest({
        url: isResourceName ? '/api/views.json' : '/api/views/' + id + '.json',
        headers: {
          'X-Socrata-Federation': 'Honey Badger'
        },
        params: isResourceName ? {
          method: 'getByResourceName',
          name: id
        } : {},
        success: function success(view) {
          var dsToReturn = null;

          if (_.isUndefined(blist.viewCache[view.id])) {
            blist.viewCache[view.id] = view;
          }

          if (_.isUndefined(blist.sharedDatasetCache[view.id])) {
            blist.sharedDatasetCache[view.id] = createDatasetFromView(view);
          }

          if (!$.isBlank(view.resourceName) && _.isUndefined(blist.viewCache[view.resourceName])) {
            blist.viewCache[view.resourceName] = blist.viewCache[view.id];
          }

          if (!$.isBlank(view.resourceName) && _.isUndefined(blist.sharedDatasetCache[view.resourceName])) {
            blist.sharedDatasetCache[view.resourceName] = blist.sharedDatasetCache[view.id];
          }

          if (_.isFunction(successCallback)) {
            if (clone || blist.sharedDatasetCache[view.id].isAnonymous() != isAnonymous) {
              dsToReturn = createDatasetFromView(view);
            } else {
              dsToReturn = blist.sharedDatasetCache[view.id];
            }

            if (isAnonymous) {
              dsToReturn.isAnonymous(isAnonymous);
            }

            successCallback(dsToReturn);
          }
        },
        batch: isBatch,
        anonymous: isAnonymous,
        pageCache: !isBatch,
        error: errorCallback
      });
    }
  };

  Dataset.search = function (params, successCallback, errorCallback, isAnonymous) {
    $.socrataServer.makeRequest({
      pageCache: true,
      url: '/api/search/views.json',
      params: params,
      anonymous: isAnonymous,
      success: function success(results) {
        if (_.isFunction(successCallback)) {
          successCallback({
            count: results.count,
            views: _.map(results.results, function (v) {
              var ds = createDatasetFromView(v.view); // Put row results in a special safe key

              ds.rowResults = v.rows;
              ds.rowResultCount = v.totalRows;

              if (isAnonymous) {
                ds.isAnonymous(isAnonymous);
              }

              return ds;
            })
          });
        }
      },
      error: errorCallback
    });
  };

  var VIZ_TYPES = ['chart', 'annotatedtimeline', 'imagesparkline', 'areachart', 'barchart', 'columnchart', 'linechart', 'piechart'];
  var MAP_TYPES = ['map', 'geomap', 'intensitymap'];
  /* The type string is not always the simplest thing -- a lot of munging
   * goes on in Rails; we roughly duplicate it here */

  function getType(ds) {
    var type = ds.displayType || 'table';

    if (ds.viewType == 'blobby') {
      type = 'blob';
    } else if (ds.displayType == 'assetinventory') {
      type = 'table';
    } else if (ds.viewType == 'href') {
      type = 'href';
    } else if (ds.displayType == 'api') {
      type = 'api';
    } else if (_.includes(['table', 'fatrow', 'page'], type) && _.includes(ds.flags || [], 'default')) {
      type = 'blist';
    } else if (_.includes(VIZ_TYPES, type)) {
      type = 'chart';
    } else if (_.includes(MAP_TYPES, type)) {
      type = 'map';
    } else if (type == 'calendar') {// Do nothing; but avoid the else cases
    } else if (!$.isBlank(ds.query) && !$.isBlank(ds.query.groupBys) && // We have to inspect the message because if it is invalid, the groupBy is gone
    ds.query.groupBys.length > 0 || (ds.message || '').indexOf('roll up') >= 0) {
      type = 'grouped';
    } else if (_.includes(['table', 'fatrow', 'page'], type) && !_.includes(ds.flags || [], 'default')) {
      type = 'filter';
    }

    return type;
  }

  function getDisplayName(ds) {
    switch (ds.type) {
      case 'blist':
        return ds.isPublished() ? $.t('core.view_types.dataset') : $.t('core.view_types.working_copy');

      default:
        return $.t('core.view_types.' + ds.type);
    }
  }
  /**
   * EN-12888 - Don't Copy Parent Filters Into Child Grouped View
   *
   * Possibly in an attempt to be clever or fix 'performance', the platform will
   * behave differently when creating a grouped view based on a filtered view
   * depending on whether or not the current user has write acces to both the
   * parent and the new child views.
   *
   * When the user has write access to both, instead of relying on the chaining
   * or inheritance behavior of derived views (wherein filters present in a
   * parent view are applied before groupings and filters present in the child
   * view) the frontend will merge the filters from the parent view into the new
   * filters and groupings of the child view and post the resulting composite.
   *
   * This has the effect of creating a derived view that still counts as being
   * derived from the forebearing default view, but that does not have the
   * filters chained/applied according to that lineage but rather all at once
   * when the child view is queried.
   *
   * When the user does not have write access to both, the inheritance/chaining
   * behavior is applied.
   *
   * This becomes problematic because the order in which filters and groupings
   * are applied changes based on which properties are coming from the parent
   * and which from the child:
   *
   * Case 1: parent(grouping), child(filtering) -> [grouping then filtering]
   * Case 2: parent(filtering), child(grouping) -> [filtering then grouping]
   * Case 3: parent(none), child(both)          -> [grouping then filtering]
   * Case 4: parent(both), child(none)          -> [grouping then filtering]
   *
   * Note that cases 1, 3 an 4 are essentially a HAVING clause, whereas the
   * second is a WHERE clause. This function aspires to prevent what should be
   * the second case from being turned into the third case becasue of the
   * merging behavior, which is accomplished by removing the filters from the
   * parent view that get copied into the child view which is eventually POSTed
   * to the backend to create the new child view.
   *
   * See EN-12454 for information on the accompanying fix in Core Server which
   * will interpret the lack of filters in the child view that are present in
   * the parent view as an indication that the modifyingLensId-based inheritance
   * should be used for the view in question as opposed to the derived-but-self-
   * sufficient type of behavior that ordinarily obtains when the user has write
   * access to both the parent and the child views.
   */


  function forceUseOfModifyingLensIdInNewChildViewIfGroupingWasAdded(originalDataset, newDataset) {
    // We need to compare the filters that were present on the original view
    // object from which the live dataset was constructed against the serialized
    // dataset as it exists at the time the user attempts to save. Somewhere in
    // the long string of mutations the live dataset undergoes after page load,
    // filter value literals (e.g. the '1' if the filter is 'col_a != 1') are
    // cast from strings (as they are sent by Core Server) to numbers (as they
    // get serialized when we send the updated view to Core Server).
    //
    // This method mutates an object tree to cast all filter value literals
    // (defined as the value of the 'value' key of an object that also has a
    // 'type' key, the value of which 'type' key is 'literal') to numbers so
    // that we can use _.isEqual() to compare the filters present in the
    // serialized form of the 'original' dataset against the filters in the
    // serialized form of the 'new' dataset in a reliable way.
    var convertStringifiedNumberLiteralsToNumbers = function convertStringifiedNumberLiteralsToNumbers(val, key) {
      if (key === 'children' && _.isArray(val)) {
        _.each(val, function (child) {
          if (_.isObject(child)) {
            if (child.hasOwnProperty('type') && child.hasOwnProperty('value') && _.get(child, 'type') === 'literal') {
              if (String(Number(child.value)) === child.value) {
                child.value = Number(child.value);
              }
            }

            _.forIn(child, convertStringifiedNumberLiteralsToNumbers);
          }
        });
      }
    };

    var extractFilterConditionOperators = function extractFilterConditionOperators(filterCondition) {
      var operators = [];

      var recursivelyExtractActualFilterConditionOperators = function recursivelyExtractActualFilterConditionOperators(children) {
        children.forEach(function (child) {
          if (child.hasOwnProperty('children')) {
            var atLeastOneOperatorGrandchild = _.includes(_.compact(_.get(child, 'children', []).map(function (grandchild) {
              return _.get(grandchild, 'type');
            })), 'operator');

            if (child.type === 'operator' && !atLeastOneOperatorGrandchild) {
              operators.push(_.cloneDeep(child));
            } else {
              recursivelyExtractActualFilterConditionOperators(_.get(child, 'children', []));
            }
          }
        });
      };

      if (_.isObject(filterCondition) && _.get(filterCondition, 'type', null) === 'operator') {
        operators.push(_.cloneDeep(filterCondition));
      }

      if (_.isObject(filterCondition) && _.get(filterCondition, 'children', []).length > 0) {
        recursivelyExtractActualFilterConditionOperators(_.get(filterCondition, 'children', []));
      }

      return operators;
    };

    var assignNewFiltersForJsonQuery = function assignNewFiltersForJsonQuery(dataset, filters) {
      if (filters.length === 1) {
        _.set(dataset, 'metadata.jsonQuery.where', filters[0]);
      } else if (filters.length > 1) {
        _.set(dataset, 'metadata.jsonQuery.where.children', filters);
      } else {
        _.set(dataset, 'metadata.jsonQuery.where', undefined);
      }
    };

    var originalDatasetGrouping = _.get(originalDataset, 'query.groupBys', null);

    var newDatasetGrouping = _.get(newDataset, 'query.groupBys', null);

    var groupingAddedToNewChildView = _.isNull(originalDatasetGrouping) && !_.isNull(newDatasetGrouping); // Hey, watch out here, occasionally instead of the filterCondition key not
    // existing, sometimes it does exist but is undefined! Argh!

    var shouldModifyQueryFilterCondition = !_.isUndefined(_.get(originalDataset, 'query.filterCondition')) && !_.isUndefined(_.get(newDataset, 'query.filterCondition')); // Hey, watch out here, occasionally instead of the where key not existing,
    // sometimes it does exist but is undefined! Argh!

    var shouldModifyJsonQueryWhere = !_.isUndefined(_.get(originalDataset, 'metadata.jsonQuery.where')) && !_.isUndefined(_.get(newDataset, 'metadata.jsonQuery.where')); // Just return the new dataset if no grouping is applied, or if the parent
    // had the same grouping as the child, since we don't need to take any
    // additional action in this case.

    if (!groupingAddedToNewChildView) {
      return newDataset;
    } // Otherwise, we need to remove any filters that are present in both the
    // original and the new dataset, which will cause the backend to create a
    // non-default view using modifyingLensId to inherit the parent's filters,
    // as opposed to the frontend copying the parent's filters into the new view
    // and then creating a non-default, but also not-inheriting, view.


    if (shouldModifyQueryFilterCondition) {
      var modifiedOriginalFilterCondition = blist.filter.generateSODA1({}, _.get(originalDataset, 'metadata.jsonQuery.where'), _.get(originalDataset, 'metadata.jsonQuery.having'), _.get(originalDataset, 'metadata.defaultFilters'));

      var newQueryFilterCondition = _.get(newDataset, 'query.filterCondition'); // Recursively apply convertStringifiedNumberLiteralsToNumbers to all
      // values of modifiedOriginalFilterCondition (_.forIn does not recurse,
      // but convertStringifiedNumberLiteralsToNumbers calls _.forIn recursively
      // as it descends).


      _.forIn(modifiedOriginalFilterCondition, convertStringifiedNumberLiteralsToNumbers);

      var newQueryFilterConditionIsSingleFilterClause = _.get(newQueryFilterCondition, 'children', []).filter(function (newFilter) {
        return _.get(newFilter, 'type') !== 'operator';
      }).length > 0; // If the children of newQueryFilterCondition constitute a single filter
      // condition (e.g. they are a pair of 'column' and 'literal' types as
      // opposed to a pair of 'operator' types each with their own 'column' and
      // 'literal' children) then we just need to check if the single new filter
      // condition matches any of the old ones.

      if (newQueryFilterConditionIsSingleFilterClause) {
        var newFilterExistsInOldFilterCondition = false;
        var filterConditionOperators = extractFilterConditionOperators(modifiedOriginalFilterCondition);
        filterConditionOperators.forEach(function (oldFilter) {
          if (_.isEqual(oldFilter, newQueryFilterCondition)) {
            newFilterExistsInOldFilterCondition = true;
          }
        });

        if (newFilterExistsInOldFilterCondition && newDataset.hasOwnProperty('query') && newDataset.query.hasOwnProperty('filterCondition')) {
          delete newDataset.query.filterCondition;
        } // Otherwise, we can actually iterate over newQueryFilterCondition's
        // children and compare them to the existing filters.

      } else {
        var newFiltersForQuery = _.get(newQueryFilterCondition, 'children', []).filter(function (newFilter) {
          var matchingOldFilter = _.get(modifiedOriginalFilterCondition, 'children', []).filter(function (oldFilter) {
            return _.isEqual(newFilter, oldFilter);
          });

          return matchingOldFilter.length === 0;
        });

        if (newFiltersForQuery.length > 0) {
          _.set(newDataset, 'query.filterCondition.children', newFiltersForQuery);
        } else {
          if (newDataset.hasOwnProperty('query') && newDataset.query.hasOwnProperty('filterCondition')) {
            delete newDataset.query.filterCondition;
          }
        }
      }
    } // We also need to remove any filters that are present in the other place
    // we store filters in a view object (metadata.jsonQuery.where v.s.
    // query.filterCondition, which is checked above) In comparison, however,
    // the representation of the current filters located at
    // metadata.jsonQuery.where does not differ between the original and new
    // copies of the dataset, so we can compare them directly without having to
    // mutate the original dataset.
    //
    // Fun fact: the jsonQuery where object only has a 'children' property if
    // there is more than one filter. Otherwise, it stores the filter parameters
    // at the root of the object.


    if (shouldModifyJsonQueryWhere) {
      var originalJsonQueryWhere = _.get(originalDataset, 'metadata.jsonQuery.where');

      var newJsonQueryWhere = _.get(newDataset, 'metadata.jsonQuery.where');

      var moreThanOneFilterPresent = originalJsonQueryWhere.hasOwnProperty('children') || newJsonQueryWhere.hasOwnProperty('children');

      if (moreThanOneFilterPresent) {
        var newFiltersForJsonQuery; // If there is more than one filter on the original jsonQuery where and
        // there is more than one filter on the new jsonQuery where, then we
        // need to only persist filters that are present on the new jsonQuery
        // where but not the old one.

        if (originalJsonQueryWhere.hasOwnProperty('children') && newJsonQueryWhere.hasOwnProperty('children')) {
          newFiltersForJsonQuery = _.get(newJsonQueryWhere, 'children', []).filter(function (newFilter) {
            var matchingOldFilter = _.get(originalJsonQueryWhere, 'children', []).filter(function (oldFilter) {
              return _.isEqual(newFilter, oldFilter);
            });

            return matchingOldFilter.length === 0;
          });
          assignNewFiltersForJsonQuery(newDataset, newFiltersForJsonQuery);
        } else if (originalJsonQueryWhere.hasOwnProperty('children')) {
          // Only save the single filter on newJsonQueryWhere if it does not
          // also exist in originalJsonQueryWhere.
          var singleNewFilterExistsInOriginalJsonQueryWhere = false;

          _.get(originalJsonQueryWhere, 'children', []).forEach(function (oldFilter) {
            if (_.isEqual(oldFilter, newJsonQueryWhere)) {
              singleNewFilterExistsInOriginalJsonQueryWhere = true;
            }
          });

          if (singleNewFilterExistsInOriginalJsonQueryWhere) {
            _.set(newDataset, 'metadata.jsonQuery.where', undefined);
          }
        } else if (newJsonQueryWhere.hasOwnProperty('children')) {
          // Save all filters on the new jsonQuery where that are not equal to
          // the original jsonQuery where.
          newFiltersForJsonQuery = _.get(newJsonQueryWhere, 'children', []).filter(function (newFilter) {
            return !_.isEqual(originalJsonQueryWhere, newFilter);
          });
          assignNewFiltersForJsonQuery(newDataset, newFiltersForJsonQuery);
        }
      } else {
        // If the filter is not the one that was taken from the saved view, then
        // we can just use that filter verbatim since the modifying-lens-id
        // inheritance wouldn't apply in any case.
        if (!_.isEqual(originalJsonQueryWhere, newJsonQueryWhere)) {
          _.set(newDataset, 'metadata.jsonQuery.where', newJsonQueryWhere);
        } else {
          if (newDataset.hasOwnProperty('metadata') && newDataset.metadata.hasOwnProperty('jsonQuery') && newDataset.metadata.jsonQuery.hasOwnProperty('where')) {
            delete newDataset.metadata.jsonQuery.where;
          }
        }
      }
    }

    return newDataset;
  }
  /**
   * EN-12888 - Don't Copy Parent Filters Into Child Grouped View
   *
   * If a grouping has been added to a previously-filtered view and the
   * relevant feature flag is enabled, then we need to display a notice to
   * the user that the grid preview may not reflect the actual computed
   * values, and that they'll need to 'Save As...' in order to see the
   * correct data.
   *
   * This is only the case when the 'old' view has filters but no grouping
   * and is then updated to have grouping as well.
   */


  function maybeShowIncorrectGridPreviewNotice(originalDataset, newDataset) {
    var shouldForceUseOfModifyingLensIdInGroupedChildView = _.get(window, 'socrata.featureFlags.force_use_of_modifying_lens_id_in_grouped_child_view', false);

    var originalDatasetHasGroupBys = !_.isUndefined(_.get(originalDataset, 'query.groupBys'));
    var originalDatasetHasFilterCondition = !_.isUndefined(_.get(originalDataset, 'query.filterCondition'));
    var newDatasetHasGroupBys = !_.isUndefined(_.get(newDataset, 'query.groupBys'));

    if (shouldForceUseOfModifyingLensIdInGroupedChildView && !originalDatasetHasGroupBys && originalDatasetHasFilterCondition && newDatasetHasGroupBys) {
      blist.datasetPage.flashTimedNotice($.t('controls.grid.group_bys_preview_potentially_invalid'), 20000);
    }
  }

  function cleanViewForSave(ds, allowedKeys) {
    var dsCopy = ds.cleanCopy(allowedKeys);

    if (ds.oldColumns) {
      // If we swapped in NBE columns, swap them out when saving.
      dsCopy.columns = ds.oldColumns;
    }

    dsCopy = ds._cleanUnsaveable(dsCopy); // cleanCopy already removes namedFilters, so we just need to get the updated fc here

    if (!$.isBlank(dsCopy.query)) {
      dsCopy.query.filterCondition = ds.cleanFilters(true);
    }

    if ($.subKeyDefined(dsCopy, 'metadata.jsonQuery')) {
      // Clear anything marked temporary.
      var jsonQuery = ds.cleanJsonFilters(true);
      $.extend(dsCopy.metadata.jsonQuery, jsonQuery);
      dsCopy.metadata.jsonQuery.where = jsonQuery.where;
      dsCopy.metadata.jsonQuery.having = jsonQuery.having;
    }

    return dsCopy;
  }

  function cleanViewForCreate(ds) {
    var dsCopy = ds.cleanCopy();

    if (!_.isUndefined(dsCopy.metadata)) {
      delete dsCopy.metadata.facets;
      delete dsCopy.metadata.filterCondition;
    }

    delete dsCopy.resourceName;
    delete dsCopy.rowIdentifierColumnId;

    if (!$.isBlank(dsCopy.query)) {
      dsCopy.query.filterCondition = ds.cleanFilters(true);
    }

    if ($.subKeyDefined(dsCopy, 'metadata.jsonQuery')) {
      // Clear anything marked temporary.
      var jsonQuery = ds.cleanJsonFilters(true);
      $.extend(dsCopy.metadata.jsonQuery, jsonQuery);
      dsCopy.metadata.jsonQuery.where = jsonQuery.where;
      dsCopy.metadata.jsonQuery.having = jsonQuery.having;
    }

    if (dsCopy.displayType == 'assetinventory') {
      delete dsCopy.displayType;
    }

    var shouldForceUseOfModifyingLensIdInGroupedChildView = _.get(window, 'socrata.featureFlags.force_use_of_modifying_lens_id_in_grouped_child_view', false); // See comment above implementation of forceUseOfModifyingLensId... for an
    // explanation of what this does and why we do it (spoiler: this is a
    // consequence of the inconsistent behavior of derived views).


    if (shouldForceUseOfModifyingLensIdInGroupedChildView) {
      forceUseOfModifyingLensIdInNewChildViewIfGroupingWasAdded(ds._origObj, dsCopy);
    }

    return dsCopy;
  }

  Dataset.translateSubFilter = function (fc, ds, simplify, isHaving) {
    // This is a cheat. Maps NBE interface.
    if ($.isPresent(fc) && _.isString(fc.soql)) {
      return fc;
    }

    if ($.isBlank(fc) || simplify && (fc.type != 'operator' || !_.isArray(fc.children) || fc.children.length == 0)) {
      return null;
    }

    var filterQ = {
      operator: fc.value
    };

    if (!$.isBlank(fc.metadata)) {
      filterQ.metadata = fc.metadata;
    }

    if (filterQ.operator == 'AND' || filterQ.operator == 'OR') {
      filterQ.children = _.compact(_.map(fc.children, function (c) {
        var fcc = Dataset.translateSubFilter(c, ds, simplify, isHaving);
        return fcc;
      }));

      if (simplify) {
        if (filterQ.children.length == 0) {
          return null;
        } else if (filterQ.children.length == 1) {
          var cf = filterQ.children[0];
          cf.metadata = $.extend(filterQ.metadata, cf.metadata);
          filterQ = cf;
        }
      }
    } else {
      var col;

      _.each(fc.children, function (c) {
        if (c.type == 'column') {
          if (!$.isBlank(ds)) {
            col = ds.columnForIdentifier(c.columnFieldName || c.columnId);
          }

          if (!$.isBlank(c.columnFieldName)) {
            filterQ.columnFieldName = c.columnFieldName;
          } else if (!$.isBlank(col)) {
            filterQ.columnFieldName = col.fieldName;
          }

          if (isHaving && $.subKeyDefined(col, 'format.grouping_aggregate') && ds._useSODA2) {
            filterQ.columnFieldName = blist.datatypes.soda2Aggregate(col.format.grouping_aggregate) + '_' + filterQ.columnFieldName;
          } // Don't put in redundant subcolumns (ie, when no sub-column)
          // Special case for 'url': subcolumn name is also 'url'.


          if (!$.isBlank(c.value) && (c.value == 'url' || c.value != (col || {}).dataTypeName)) {
            filterQ.subColumn = c.value;
          }
        } else if (c.type == 'literal') {
          var v = c.value;

          if ($.isBlank(filterQ.value)) {
            filterQ.value = v;
          } else {
            filterQ.value = $.makeArray(filterQ.value);
            filterQ.value.push(v);
          }
        }
      });
    }

    return filterQ;
  };

  Dataset.translateFilterCondition = function (fc, ds, simplify) {
    if ($.isBlank(simplify)) {
      simplify = true;
    }

    fc = $.extend(true, {}, fc);
    var dsIsGrouped = !_.isEmpty((ds.metadata.jsonQuery || {}).group);

    if (dsIsGrouped) {
      // Ugh, separate out having from where
      // We can only separate at an AND: an OR must stay together
      // We're only going to separate at the top level, b/c it gets complicated below that
      var splitWhere = fc,
          splitDefault,
          splitHaving;

      if (!$.isBlank(fc) && fc.type == 'operator' && _.isArray(fc.children) && fc.children.length > 0) {
        var havingCols = _.compact(_.map(ds.query.groupBys, function (gb) {
          return ds.columnForIdentifier(gb.columnId);
        }).concat(_.filter(ds.realColumns, function (c) {
          return $.subKeyDefined(c, 'format.grouping_aggregate');
        })));

        var isHaving = function isHaving(cond) {
          if (cond.type == 'column') {
            return _.some(havingCols, function (c) {
              return c.fieldName == cond.columnFieldName || c.id == cond.columnId;
            });
          } else if (!_.isEmpty(cond.children)) {
            return _.every(cond.children, function (cCond) {
              return isHaving(cCond);
            });
          } else {
            // literals
            return true;
          }
        };

        fc = blist.filter.collapseChildren(fc);

        if (fc.value == 'AND') {
          var children = _.groupBy(fc.children, function (cond) {
            // Find trees that only reference post-group columns
            if (_.isEmpty(cond.children)) {
              return 'defaults';
            } else if (isHaving(cond)) {
              return 'having';
            } else {
              return 'where';
            }
          });

          if (!_.isEmpty(children.having)) {
            splitHaving = {
              type: 'operator',
              value: 'AND',
              children: children.having
            };
            fc.children = _.difference(fc.children, children.having);
          }

          if (!_.isEmpty(children.defaults)) {
            splitDefault = {
              type: 'operator',
              value: 'AND',
              children: children.defaults
            };
            fc.children = _.difference(fc.children, children.defaults);
          }
        } else if (isHaving(fc)) {
          splitHaving = fc;
          splitWhere = null;
        }
      }

      return {
        where: Dataset.translateSubFilter(splitWhere, ds, simplify, false),
        having: Dataset.translateSubFilter(splitHaving, ds, simplify, true),
        defaults: Dataset.translateSubFilter(splitDefault, ds, false, false)
      };
    } else {
      var defaults = _.isEmpty(fc) ? null : _.filter(fc, function (cond) {
        return _.isEmpty(cond.children);
      });
      return {
        where: Dataset.translateSubFilter(fc, ds, simplify, false),
        defaults: Dataset.translateSubFilter(defaults, ds, false, false)
      };
    }
  };

  Dataset.translateGroupBys = function (gb, ds, groupFuncs) {
    if (_.isEmpty(gb)) {
      return null;
    }

    return _.sortBy(_.compact(_.map(gb, function (g) {
      var c = ds.columnForIdentifier(g.columnId);

      if ($.isBlank(c)) {
        return null;
      }

      return {
        columnFieldName: c.fieldName,
        groupFunction: blist.datatypes.soda2GroupFunction($.isBlank(groupFuncs) ? c.format.group_function : groupFuncs[c.fieldName], c)
      };
    })), 'columnFieldName');
  };

  Dataset.aggregateForColumn = function (column, jsonQuery) {
    return (_.find(jsonQuery.select, function (select) {
      return select.aggregate && select.columnFieldName == column;
    }) || {}).aggregate;
  };

  Dataset.translateColumnToQueryBase = function (c, dataset) {
    var isStr = _.isString(c);

    if (isStr) {
      c = dataset.columnForIdentifier(c);
    }

    if ($.isBlank(c)) {
      return null;
    }

    var qbc = dataset._queryBase.columnForIdentifier(c.fieldName) || dataset._queryBase.columnForIdentifier(c.tableColumnId);

    if ($.isBlank(qbc)) {
      return null;
    }

    return isStr ? qbc.fieldName : qbc;
  };

  Dataset.translateFilterColumnsToBase = function (filter, dataset) {
    var newF = $.extend({}, filter);

    if (!_.isEmpty(newF.children)) {
      newF.children = _.compact(_.map(newF.children, function (fc) {
        return Dataset.translateFilterColumnsToBase(fc, dataset);
      }));

      if (_.isEmpty(newF.children)) {
        return null;
      }
    }

    if (!$.isBlank(newF.columnFieldName)) {
      newF.columnFieldName = Dataset.translateColumnToQueryBase(newF.columnFieldName, dataset);

      if ($.isBlank(newF.columnFieldName)) {
        return null;
      }
    }

    return newF;
  };

  Dataset.getNumberOfDaysRestorable = function () {
    return parseInt($.ajax({
      url: '/views.json?method=numberOfDaysRestorable',
      async: false
    }).responseText);
  };

  if (blist.inBrowser) {
    window.Dataset = Dataset;
  } else {
    module.exports = Dataset;
  }
})();

/***/ }),

/***/ 3006:
/***/ (function(module, exports) {

(function () {
  Dataset.modules.calendar = {
    _checkValidity: function _checkValidity() {
      if ($.isBlank(this.displayFormat.startDateTableId) || $.isBlank(this.displayFormat.titleTableId)) {
        return false;
      }

      var startCol = this.columnForTCID(this.displayFormat.startDateTableId);
      var titleCol = this.columnForTCID(this.displayFormat.titleTableId);
      return !$.isBlank(startCol) && !$.isBlank(titleCol);
    },
    _convertLegacy: function _convertLegacy() {
      var view = this;

      _.each(['startDate', 'endDate', 'title', 'description'], function (n) {
        if ($.isBlank(view.displayFormat[n + 'TableId']) && !$.isBlank(view.displayFormat[n + 'Id'])) {
          var c = view.columnForID(view.displayFormat[n + 'Id']);

          if (!$.isBlank(c)) {
            view.displayFormat[n + 'TableId'] = c.tableColumnId;
          }

          delete view.displayFormat[n + 'Id'];
        }
      });

      if (!$.isBlank(view.displayFormat.descriptionTableId)) {
        view.displayFormat.descriptionColumns = [{
          tableColumnId: view.displayFormat.descriptionTableId
        }];
        delete view.displayFormat.descriptionTableId;
      }
    }
  };
})();

/***/ }),

/***/ 3007:
/***/ (function(module, exports) {

(function () {
  var legacyTypes = {
    imagesparkline: 'line',
    annotatedtimeline: 'timeline',
    areachart: 'area',
    barchart: 'bar',
    columnchart: 'column',
    linechart: 'line',
    piechart: 'pie'
  };
  Dataset.chart = {};
  Dataset.chart.textualTypes = ['text', 'html', 'email', 'url', 'drop_down_list', 'number', 'percent', 'money'];
  Dataset.chart.numericTypes = ['number', 'percent', 'money'];
  Dataset.chart.dateTypes = ['calendar_date', 'date'];
  Dataset.chart.textAndDateTypes = Dataset.chart.textualTypes.concat(Dataset.chart.dateTypes);

  var lineTranslate = function lineTranslate(view, displayFormat) {
    var newDF = $.extend(true, {}, displayFormat);
    newDF.fixedColumns = _.reject(displayFormat.fixedColumns, function (fc) {
      var c = view.columnForIdentifier(fc);

      if ($.isBlank(c)) {
        return true;
      }

      return !_.includes(Dataset.chart.textualTypes, c.renderTypeName);
    });
    newDF.valueColumns = _.reject(displayFormat.valueColumns, function (dc) {
      var c = view.columnForIdentifier(dc.fieldName || dc.tableColumnId);

      if ($.isBlank(c)) {
        return true;
      }

      return !_.includes(Dataset.chart.numericTypes, c.renderTypeName);
    });
    return newDF;
  };

  Dataset.chart.types = {
    area: {
      value: 'area',
      text: $.t('core.chart_types.area'),
      requiredColumns: [Dataset.chart.textualTypes, Dataset.chart.numericTypes],
      displayLimit: {
        labels: 50,
        points: 300
      }
    },
    bar: {
      value: 'bar',
      text: $.t('core.chart_types.bar'),
      requiredColumns: [Dataset.chart.textAndDateTypes, Dataset.chart.numericTypes],
      displayLimit: {
        points: 40
      }
    },
    bubble: {
      value: 'bubble',
      text: $.t('core.chart_types.bubble'),
      requiredColumns: [Dataset.chart.numericTypes],
      displayLimit: {
        labels: 50,
        points: 300
      },
      translateFormat: lineTranslate
    },
    column: {
      value: 'column',
      text: $.t('core.chart_types.column'),
      requiredColumns: [Dataset.chart.textAndDateTypes, Dataset.chart.numericTypes],
      displayLimit: {
        labels: 50,
        points: 100
      }
    },
    donut: {
      value: 'donut',
      text: $.t('core.chart_types.donut'),
      requiredColumns: [Dataset.chart.textualTypes, Dataset.chart.numericTypes],
      displayLimit: {
        points: 30
      },
      renderOther: true
    },
    line: {
      value: 'line',
      text: $.t('core.chart_types.line'),
      requiredColumns: [Dataset.chart.numericTypes],
      displayLimit: {
        labels: 50,
        points: 300
      },
      translateFormat: lineTranslate
    },
    pie: {
      value: 'pie',
      text: $.t('core.chart_types.pie'),
      requiredColumns: [Dataset.chart.textualTypes, Dataset.chart.numericTypes],
      displayLimit: {
        points: 30
      },
      renderOther: true
    },
    timeline: {
      value: 'timeline',
      text: $.t('core.chart_types.timeline'),
      requiredColumns: [Dataset.chart.dateTypes, Dataset.chart.numericTypes],
      displayLimit: {
        labels: 50,
        points: 300
      }
    },
    treemap: {
      value: 'treemap',
      text: $.t('core.chart_types.treemap'),
      requiredColumns: [Dataset.chart.textualTypes, Dataset.chart.numericTypes],
      displayLimit: {
        points: 100
      },
      renderOther: true
    }
  };
  Dataset.chart.types.stackedcolumn = $.extend({}, Dataset.chart.types.column, {
    value: 'stackedcolumn',
    text: $.t('core.chart_types.stackedcolumn')
  });
  Dataset.chart.types.stackedbar = $.extend({}, Dataset.chart.types.column, {
    value: 'stackedbar',
    text: $.t('core.chart_types.stackedbar')
  });

  Dataset.chart.hasRequiredColumns = function (cols, reqCols, includeHidden) {
    cols = cols.slice(); // We may have overlapping types in reqCols, so start with the most restrictive
    // (smallest) grouping

    reqCols = _.sortBy(reqCols, function (rc) {
      return rc.length;
    });
    return _.every(reqCols, function (rc) {
      var col = _.find(cols, function (c) {
        return _.includes(rc, c.renderTypeName) && (includeHidden || !c.hidden);
      });

      if ($.isBlank(col)) {
        return false;
      }

      cols = _.without(cols, col);
      return true;
    });
  };

  Dataset.chart.isValid = function (view, displayFormat, chartType) {
    if ($.isBlank(view)) {
      return false;
    }

    var foundCols = [];

    _.each(displayFormat.fixedColumns || [], function (fc) {
      foundCols.push(view.columnForIdentifier(fc));
    });

    _.each(displayFormat.valueColumns || [], function (vc) {
      foundCols.push(view.columnForIdentifier(vc.fieldName || vc.tableColumnId));
    });

    var ct = Dataset.chart.types[chartType];

    if ($.isBlank(ct)) {
      return false;
    }

    return Dataset.chart.hasRequiredColumns(_.compact(foundCols), ct.requiredColumns);
  };

  Dataset.modules.chart = {
    _setupPolaroidImageCapturing: function _setupPolaroidImageCapturing() {
      var polaroidDelay = _.get(this, 'displayFormat.seriesColumns', []).length ? 20000 : 10000;

      this._super(polaroidDelay);
    },
    _checkValidity: function _checkValidity() {
      if (!this._super()) {
        return false;
      }

      return Dataset.chart.isValid(this, this.displayFormat, this.displayFormat.chartType);
    },
    _convertLegacy: function _convertLegacy() {
      var view = this;

      if (!$.isBlank(legacyTypes[view.displayType])) {
        var dt = view.displayType;
        view.displayType = 'chart';
        view.displayFormat.chartType = legacyTypes[dt];
      } else if (!$.isBlank(legacyTypes[view.displayFormat.chartType])) {
        // Is this case needed?
        view.displayFormat.chartType = legacyTypes[view.displayFormat.chartType];
      }

      if ($.isBlank(view.displayFormat.dataColumns) && $.isBlank(view.displayFormat.fixedColumns) && $.isBlank(view.displayFormat.valueColumns) && !$.isBlank(view.visibleColumns)) {
        view.displayFormat.dataColumns = _.map(view.visibleColumns, function (col) {
          return col.tableColumnId;
        });
      }

      if (!$.isBlank(view.displayFormat.dataColumns)) {
        if (!$.isBlank(view.displayFormat.fixedCount)) {
          if (view.displayFormat.chartType == 'pie' && view.displayFormat.fixedCount > 1) {
            view.displayFormat.fixedCount--;
          }

          view.displayFormat.fixedColumns = view.displayFormat.dataColumns.splice(0, view.displayFormat.fixedCount);
        } else if ($.isBlank(view.displayFormat.valueColumns) && _.isArray(view.displayFormat.dataColumns) && view.displayFormat.dataColumns.length > 0) {
          var firstCol = view.columnForTCID(view.displayFormat.dataColumns[0]);

          if (!$.isBlank(firstCol) && !_.includes(Dataset.chart.numericTypes, firstCol.renderTypeName)) {
            view.displayFormat.fixedColumns = view.displayFormat.dataColumns.splice(0, 1);
          }
        }

        var valueCols = [];
        var vcVal;
        var i = 0;
        var cols = view.displayFormat.dataColumns.slice();

        while (cols.length > 0) {
          var tcid = cols.shift();
          var c = view.columnForTCID(tcid);

          if ($.isBlank(c)) {
            continue;
          }

          if (_.includes(Dataset.chart.numericTypes, c.renderTypeName)) {
            valueCols.push(vcVal);
            vcVal = {
              tableColumnId: tcid
            };

            if (!$.isBlank((view.displayFormat.colors || [])[i])) {
              vcVal.color = view.displayFormat.colors[i];
            }

            i++;
            continue;
          }

          if (!$.isBlank(vcVal)) {
            vcVal.supplementalColumns = vcVal.supplementalColumns || [];
            vcVal.supplementalColumns.push(tcid);
          }
        }

        if (!$.isBlank(vcVal)) {
          valueCols.push(vcVal);
        }

        view.displayFormat.valueColumns = _.compact(valueCols);
      }

      delete view.displayFormat.dataColumns;

      if ($.subKeyDefined(view.displayFormat, 'yAxis.marker')) {
        var markerColor = $.sanitizeColor(view.displayFormat.yAxis.markerColor);
        view.displayFormat.valueMarker = [{
          atValue: view.displayFormat.yAxis.marker,
          color: markerColor
        }];
      }

      if (view.displayFormat.chartType == 'treemap' && view.displayFormat.baseColor) {
        var baseColor = $.sanitizeColor(view.displayFormat.baseColor);
        view.displayFormat.colors = [baseColor, '#042656', '#19538b', '#6a9feb', '#bed6f7'];
      }

      if ((view.displayFormat.chartType == 'bar' || view.displayFormat.chartType == 'column') && view.displayFormat.stacking === true) {
        view.displayFormat.chartType = 'stacked' + view.displayFormat.chartType;
      }
    }
  };
})();

/***/ }),

/***/ 3008:
/***/ (function(module, exports) {

Dataset.modules.form = {
  _checkValidity: function _checkValidity() {
    // summary view gives us no columns; validity is irrelevant in that case anyway.
    this.visibleColumns = this.visibleColumns || [];
    return !_.isEmpty(this.visibleColumns);
  }
};

/***/ }),

/***/ 3009:
/***/ (function(module, exports) {

(function () {
  Dataset.map = {};

  Dataset.map.isValid = function (view, displayFormat) {
    if ($.isBlank(displayFormat)) {
      return false;
    }

    if (displayFormat.viewDefinitions) {
      return true;
    }

    if ($.isBlank(view)) {
      return false;
    }

    if (GeoHelpers.isArcGISDataset(view)) {
      return true;
    }

    if (GeoHelpers.isGeoDataset(view)) {
      return true;
    }

    if ($.isBlank(displayFormat.noLocations) && ($.isBlank(displayFormat.plot) || ($.isBlank(displayFormat.plot.latitudeId) || $.isBlank(displayFormat.plot.longitudeId)) && $.isBlank(displayFormat.plot.locationId)) || $.isBlank(displayFormat.type) || $.isBlank(displayFormat.plotStyle)) {
      return false;
    }

    var latCol = view.columnForIdentifier(displayFormat.plot.latitudeId);
    var longCol = view.columnForIdentifier(displayFormat.plot.longitudeId);
    var locCol = view.columnForIdentifier(displayFormat.plot.locationId);
    return !$.isBlank(locCol) || !$.isBlank(latCol) && !$.isBlank(longCol) || displayFormat.noLocations;
  };

  Dataset.map.convertToVersion2 = function (view, df) {
    if (!view) {
      return;
    }

    if (!df) {
      df = view.displayFormat;
    }

    if ($.isBlank(df.viewDefinitions)) {
      df.viewDefinitions = [$.extend(true, {}, df)];
      df.viewDefinitions[0].uid = 'self';
    }

    if (df.compositeMembers) {
      _.each(df.compositeMembers, function (uid) {
        df.viewDefinitions.push({
          uid: uid,
          plotStyle: 'point',
          legacy: true
        });
      });
    } // We don't want to force a base layer on any boundary maps we are migrating from
    // the legacy format. This is intended behavior.


    var notABoundaryMap = df.plotStyle != 'heatmap';

    if (notABoundaryMap) {
      if (df.type === 'google' || df.type === 'bing') {
        // Bing is no longer supported; use Google instead.
        df.type = 'google';
        df.exclusiveLayers = true;
        df.bkgdLayers = Dataset.map.backgroundLayerSet.Google;
      } else {
        // There are only three possible values for type: google, bing, or esri.
        // So the "else" case here is actually only esri.
        df.bkgdLayers = _.map(df.layers, function (layer) {
          if (layer.custom_url) {
            return {
              custom_url: layer.custom_url
            };
          } else {
            return {
              layerKey: (_.find(Dataset.map.backgroundLayers, function (lConfig) {
                return layer.url.indexOf((lConfig.options || {}).url) > -1;
              }) || {}).key
            };
          }
        });
      }
    }

    if (GeoHelpers.isArcGISDataset(view)) {
      if (!df.layers) {
        df.bkgdLayers = [{
          layerKey: 'World Street Map (ESRI)',
          opacity: 1.0
        }];
      }

      delete df.viewDefinitions[0].plotStyle;

      for (var key in df.viewDefinitions[0].plot) {
        if (!_.includes(['titleId', 'descriptionColumns'], key)) {
          delete df.viewDefinitions[0].plot[key];
        }
      }
    }

    if (GeoHelpers.isGeoDataset(view)) {
      df.exclusiveLayers = true;
      df.bkgdLayers = [{
        layerKey: 'Google Roadmap',
        alias: $.t('core.map_layers.google_roadmap_alias'),
        opacity: 1.0
      }, {
        layerKey: 'World Street Map (ESRI)',
        alias: 'ESRI',
        opacity: 1.0
      }];
      delete df.viewDefinitions[0].plotStyle;
      delete df.viewDefinitions[0].plot;
    }

    df.distinctLegend = true;
    view.update({
      displayFormat: df,
      flags: view.flags
    });
  };

  Dataset.map.backgroundLayers = [{
    key: 'Google Roadmap',
    alias: $.t('core.map_layers.roadmap'),
    className: 'Google',
    options: {
      type: 'ROADMAP'
    }
  }, {
    key: 'Google Satellite',
    alias: $.t('core.map_layers.satellite'),
    className: 'Google',
    zoomLevels: 20,
    options: {
      type: 'SATELLITE'
    }
  }, {
    key: 'Google Terrain',
    alias: $.t('core.map_layers.terrain'),
    className: 'Google',
    zoomLevels: 16,
    options: {
      type: 'TERRAIN'
    }
  }, {
    key: 'World Street Map (ESRI)',
    alias: $.t('core.map_layers.esri_world_street_map_alias'),
    className: 'ESRI',
    zoomLevels: 20,
    options: {
      url: 'World_Street_Map'
    }
  }, {
    key: 'Satellite Imagery (ESRI)',
    alias: $.t('core.map_layers.satellite'),
    className: 'ESRI',
    zoomLevels: 20,
    options: {
      url: 'World_Imagery'
    }
  }, {
    key: 'Detailed USA Topographic Map (ESRI)',
    alias: $.t('core.map_layers.esri_us_topo_alias'),
    className: 'ESRI',
    zoomLevels: 16,
    options: {
      url: 'USA_Topo_Maps'
    }
  }, {
    key: 'Annotated World Topographic Map (ESRI)',
    alias: $.t('core.map_layers.esri_world_topo_alias'),
    zoomLevels: 17,
    className: 'ESRI',
    options: {
      url: 'World_Topo_Map'
    }
  }, {
    key: 'Natural Earth Map (ESRI)',
    alias: $.t('core.map_layers.esri_natural_earth_alias'),
    className: 'ESRI',
    zoomLevels: 9,
    options: {
      url: 'World_Physical_Map'
    }
  }];
  Dataset.map.backgroundLayer = {
    custom: {
      name: 'custom',
      className: 'ESRI'
    }
  };
  Dataset.map.backgroundLayerSet = {};
  Dataset.map.backgroundLayerSet.Google = [{
    layerKey: 'Google Roadmap',
    alias: $.t('core.map_layers.roadmap'),
    opacity: 1
  }, {
    layerKey: 'Google Satellite',
    alias: $.t('core.map_layers.satellite'),
    opacity: 1
  }, {
    layerKey: 'Google Terrain',
    alias: $.t('core.map_layers.terrain'),
    opacity: 1
  }]; // Deprecation Support: Bing maps are now rendered as Google Maps.

  Dataset.map.backgroundLayerDeprecationMap = {
    'Bing Road': 'Google Roadmap',
    'Bing Aerial': 'Google Satellite'
  };
  Dataset.modules.map = {
    _setupPolaroidImageCapturing: function _setupPolaroidImageCapturing() {
      var polaroidDelay = this.viewType === 'geo' ? 20000 : 10000;

      this._super(polaroidDelay);
    },
    _checkValidity: function _checkValidity() {
      if (!this._super()) {
        return false;
      }

      return Dataset.map.isValid(this, this.displayFormat);
    },
    // Migrate legacy map configurations to the most current state of the world.
    //
    // Much of this code is copy-pasted into component/data/map.js but note that it is not an exact
    // copy of the configuration transformations happening in those functions. Be wary of making
    // breaking transformations here and not updating component/data/map.js!
    //
    // TODO: reconcile the differences between transformations here and ones in component/data/map.js
    _convertLegacy: function _convertLegacy() {
      var view = this;

      if (view._convertedLegacy) {
        return;
      }

      view._convertedLegacy = true; // Convert background layer configurations.

      if ($.subKeyDefined(view, 'displayFormat.bkgdLayers')) {
        view.displayFormat.bkgdLayers.forEach(function (layer) {
          // Convert layerName to layerKey.
          if ($.isBlank(layer.layerKey) && !$.isBlank(layer.layerName)) {
            layer.layerKey = layer.layerName;
            delete layer.layerName;
          } // Replace Bing keys with Google equivalents.


          if (Dataset.map.backgroundLayerDeprecationMap[layer.layerKey]) {
            layer.layerKey = Dataset.map.backgroundLayerDeprecationMap[layer.layerKey];
          }
        });
      } // Old Maps didn't have an explicit 'self' reference. This fixes
      // up the view to have correct self-references.


      if ($.subKeyDefined(view, 'displayFormat.viewDefinitions')) {
        var fixIds = function fixIds(checkView) {
          var fixFilter = function fixFilter(fc) {
            if ($.isBlank(fc)) {
              return;
            }

            if (fc.type == 'column' && !$.isBlank(fc.columnId)) {
              var checkCol = checkView.columnForID(fc.columnId);

              if (!$.isBlank(checkCol)) {
                var curCol = view.columnForTCID(checkCol.tableColumnId);

                if (!$.isBlank(curCol)) {
                  fc.columnId = curCol.id;
                }
              }
            } else if (!_.isEmpty(fc.children)) {
              _.each(fc.children, function (fcc) {
                fixFilter(fcc);
              });
            }
          };

          if (GeoHelpers.isArcGISOrGeoDataset(checkView)) {
            return false;
          }

          var checkId = checkView.id; // We've got some bad data; let's fix it

          var df = $.extend(true, {}, view.displayFormat);
          var md = $.extend(true, {}, view.metadata);
          var updateItems = {
            displayFormat: df,
            metadata: md
          };

          var vdResult = _.some(df.viewDefinitions, function (vd) {
            if (vd.uid == checkId) {
              vd.uid = 'self';
              return true;
            }

            return false;
          }); // renderTypeConfig.active


          if ($.subKeyDefined(md, 'renderTypeConfig.active')) {
            _.each(md.renderTypeConfig.active, function (rt) {
              if (rt.id == checkId) {
                rt.id = 'self';
              }
            });
          } // conditional formatting


          if ($.subKeyDefined(md, 'conditionalFormatting.' + checkId)) {
            md.conditionalFormatting.self = md.conditionalFormatting[checkId];
            delete md.conditionalFormatting[checkId];
          } // metadata.query


          if ($.subKeyDefined(md, 'query.' + checkId)) {
            // Well, if the view already has a query, then it should take precedence
            if (checkId != view.id && _.isEmpty(view.query.filterCondition)) {
              // Oh boy, copy over and translate
              var q = md.query[checkId];
              fixFilter(q.filterCondition);
              updateItems.query = q;
            }

            delete md.query[checkId];
          }

          view.update(updateItems);
          return vdResult;
        }; // Fix the IDs if none have a self-reference (indicating an old
        // format). If none were fixed, try fixing the parent view.


        if (!_.some(view.displayFormat.viewDefinitions, function (vd) {
          return vd.uid == 'self';
        }) && !fixIds(view)) {
          view.getParentView(function (parView) {
            if (!fixIds(parView) && !_.some(view.displayFormat.viewDefinitions, function (vd) {
              return vd.uid == 'self';
            })) {
              // OK, if things still weren't fixed, and none of the viewDefinitions are for
              // the current view, then look up the first one and fix it if is based on
              // the same dataset as the current view
              Dataset.lookupFromViewId(view.displayFormat.viewDefinitions[0].uid, function (relDS) {
                if (relDS.tableId == view.tableId) {
                  fixIds(relDS);
                }
              });
            }
          });
        } // EN-11257: when there are multiple 'self' viewDefinitions, the select dataset modal opens
        // (because base-pane.js gets confused... somewhere). To avoid heavily refactoring map-config.js
        // and/or base-pane.js, let's remove any duplicate viewDefinitions. Yes, this removes all
        // duplicate viewDefinitions, not just duplicate 'self' ones. We decided that it seems
        // unlikely that a user would want to add the exact same map layer twice and are removing
        // those duplicates aggressively.
        //
        // Caveat: the modal still pops up if you have added two different viewDefinitions from the
        // dataset the map was originally derived from (for instance, ones using different location
        // columns). That is a known issue that we should tackle another day.
        //
        // TODO: if we ever update lodash in the old ux from 3.7.0, use _.uniqBy instead of this.
        // Note that while _.uniq exists in 3.7.0, it does not do a deep comparison for objects, and
        // doesn't do what we need it to do.


        var dedupedViewDefinitions = _.filter(view.displayFormat.viewDefinitions, function (definition, i) {
          var otherViewDefinitions = _.slice(view.displayFormat.viewDefinitions, i + 1);

          return !_.some(otherViewDefinitions, function (otherDefinition) {
            return _.isEqual(otherDefinition, definition);
          });
        });

        view.displayFormat.viewDefinitions = dedupedViewDefinitions;
        return;
      }

      view.displayFormat.plot = view.displayFormat.plot || {};

      if (_.includes(['geomap', 'intensitymap'], view.displayType)) {
        view.displayType = 'map';
        view.displayFormat.type = 'heatmap';
        var region = view.displayFormat.region || '';
        view.displayFormat.heatmap = {
          type: region.toLowerCase().match(/^usa?$/) ? 'state' : 'countries'
        };

        _.each(['locationId', 'quantityId', 'descriptionId', 'redirectId'], function (key, index) {
          if (index < (view.visibleColumns || []).length) {
            view.displayFormat.plot[key] = parseInt(view.visibleColumns[index].tableColumnId);
          }
        });
      }

      if ($.isBlank(view.displayFormat.heatmap) && !$.isBlank(view.displayFormat.heatmapType)) {
        // Support for legacy config system.
        var heatmapType = view.displayFormat.heatmapType.split('_');
        var config = {
          type: heatmapType[1],
          region: heatmapType[0],
          colors: {
            low: view.displayFormat.lowcolor,
            high: view.displayFormat.highcolor
          }
        };
        view.displayFormat.heatmap = config;
        delete view.displayFormat.lowcolor;
        delete view.displayFormat.highcolor;
        delete view.displayFormat.heatmapType;
      }

      var colObj = view.displayFormat.plot || view.displayFormat;

      _.each(['latitudeId', 'longitudeId', 'titleId', 'descriptionId'], function (n) {
        if ($.isBlank(view.displayFormat.plot[n]) && !$.isBlank(colObj[n])) {
          view.displayFormat.plot[n] = colObj[n];
          delete colObj[n];
        }
      });

      _.each({
        'ycol': 'latitudeId',
        'xcol': 'longitudeId',
        'titleCol': 'titleId',
        'bodyCol': 'descriptionId'
      }, function (n, o) {
        if ($.isBlank(view.displayFormat.plot[n]) && !$.isBlank(colObj[o])) {
          view.displayFormat.plot[n] = view.columnForID(colObj[o]).tableColumnId;
          delete colObj[o];
        }
      });

      if (!$.isBlank(view.displayFormat.plot.descriptionId)) {
        view.displayFormat.plot.descriptionColumns = [{
          tableColumnId: view.displayFormat.plot.descriptionId
        }];
        delete view.displayFormat.plot.descriptionId;
      }

      if ($.isBlank(view.displayFormat.plotStyle)) {
        view.displayFormat.plotStyle = !$.isBlank(view.displayFormat.heatmap) ? 'heatmap' : 'point';
      }
    }
  };
})();

/***/ }),

/***/ 3010:
/***/ (function(module, exports) {

(function () {
  var GeoHelpers = {
    isArcGISDataset: function isArcGISDataset(view) {
      return !_.isNull(_.get(view, 'metadata.custom_fields.Basic.Source', null));
    },
    isGeoDataset: function isGeoDataset(view) {
      return !_.isNull(_.get(view, 'metadata.geo', null));
    },
    isArcGISOrGeoDataset: function isArcGISOrGeoDataset(view) {
      return this.isArcGISDataset(view) || this.isGeoDataset(view);
    },
    isGeoExportSupported: function isGeoExportSupported(view) {
      var geospatialColumnTypes = /^(point|line|polygon|multipoint|multiline|multipolygon)$/i;
      var hasSingleGeoColumn = _.filter(_.get(view, 'columns', []), function (col) {
        return geospatialColumnTypes.test(col.dataTypeName);
      }).length == 1;
      return hasSingleGeoColumn;
    }
  };

  if (blist.inBrowser) {
    window.GeoHelpers = GeoHelpers;
  } else {
    module.exports = GeoHelpers;
  }
})();

/***/ }),

/***/ 3011:
/***/ (function(module, exports) {

(function () {
  var createDatasetFromView = function createDatasetFromView(view) {
    return new Dataset(view);
  };

  if (blist.inBrowser) {
    window.createDatasetFromView = createDatasetFromView;
  } else {
    module.exports = createDatasetFromView;
  }
})();

/***/ }),

/***/ 3012:
/***/ (function(module, exports) {

(function () {
  if (_.isUndefined(blist.viewCache)) {
    blist.viewCache = {};
  }

  if (_.isUndefined(blist.sharedDatasetCache)) {
    blist.sharedDatasetCache = {};
  }

  $.extend(blist.viewCache, {
    invalidate: function invalidate(v) {
      var uid = _.isString(v) ? v : v.id;
      delete blist.viewCache[uid];
    }
  });
  $.extend(blist.sharedDatasetCache, {
    invalidate: function invalidate(v) {
      var uid = _.isString(v) ? v : v.id;
      delete blist.sharedDatasetCache[uid];
    }
  });
})();

/***/ }),

/***/ 3013:
/***/ (function(module, exports) {

$(function () {
  blist.namespace.fetch('blist.styles');
  var pendingRules = {};
  var styleRules = {};
  var cssSheets = {};

  var createCssSheet = function createCssSheet(sheetName) {
    // Create the stylesheet source
    var cssID = 'customStyles_' + sheetName;
    var cssText = ['<style type="text/css" id="', cssID, '">'];

    _.each(pendingRules[sheetName] || [], function (item) {
      cssText.push(item.rule);
      cssText.push(' {}\n');
    });

    cssText.push('</style>\n'); // Render the rules and retrieve the new Stylesheet object

    $('head').append(cssText.join(''));
    var cssElement = $('#' + cssID)[0];

    for (var i = 0; i < document.styleSheets.length; i++) {
      cssSheets[sheetName] = document.styleSheets[i];

      if (cssSheets[sheetName].ownerNode === cssElement) {
        break;
      }

      cssSheets[sheetName] = null;
    }

    if ($.isBlank(cssSheets[sheetName])) {
      throw 'Unable to locate stylesheet';
    }

    styleRules[sheetName] = {};
  };

  var createCssRules = function createCssRules(sheetName) {
    if ($.isBlank(cssSheets[sheetName])) {
      createCssSheet(sheetName);
    } // Give IDs to the rules


    var rules = cssSheets[sheetName].cssRules || cssSheets[sheetName].rules;

    _.each(rules, function (r, i) {
      styleRules[sheetName][pendingRules[sheetName][i].id] = r.style;
    });

    pendingRules[sheetName] = {};
  };

  blist.styles.getStyle = function (sheetName, id) {
    if ($.isBlank(styleRules[sheetName]) && !$.isBlank(pendingRules[sheetName])) {
      createCssRules(sheetName);
    }

    return styleRules[sheetName][id];
  };

  blist.styles.addStyle = function (sheetName, id, rule) {
    if ($.isBlank(cssSheets[sheetName])) {
      pendingRules[sheetName] = pendingRules[sheetName] || []; // A bit inefficient, but I'm guessing this pending shouldn't get too
      // large...

      if (_.some(pendingRules[sheetName], function (r) {
        return r.id == id;
      })) {
        return;
      }

      pendingRules[sheetName].push({
        id: id,
        rule: rule
      });
      return;
    }

    if (!$.isBlank(styleRules[sheetName][id])) {
      return;
    }

    var rules = cssSheets[sheetName].cssRules || cssSheets[sheetName].rules;
    cssSheets[sheetName].insertRule(rule + '{}', rules.length);
    styleRules[sheetName][id] = rules[rules.length - 1].style;
  }; // This will probably mainly be used for perf -- using addRule is really
  // slow in IE, so doing large batches of addStyle to an existing sheet
  // could be painful; but if you can regenerate the whole sheet in one shot,
  // that will be much faster


  blist.styles.resetSheet = function (sheetName) {
    if ($.isBlank(cssSheets[sheetName])) {
      return;
    }

    $('#customStyles_' + sheetName).remove();
    cssSheets[sheetName] = null;
    styleRules[sheetName] = null;
  };

  blist.styles.getReferenceProperty = function (name, prop) {
    var $sr = $('#styleReference');

    if ($sr.length < 1) {
      $('body').append('<div id="styleReference"></div>');
      $sr = $('#styleReference');
    }

    var $item = $sr.find('.' + name);

    if ($item.length < 1) {
      $sr.append('<div class="' + name + '"></div>');
      $item = $sr.find('.' + name);
    }

    return $item.css(prop);
  };
});

/***/ }),

/***/ 3014:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var common_views_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(192);


(function ($) {
  $.templates = $.templates || {}; // TEMPLATE:
  //   Downloads Table; renders a table with downloadable types for a view
  // DEPENDENCIES:
  //   combination-list.js

  var downloadTypesDirective = function downloadTypesDirective(typeName, isDynamic) {
    var directive = {};
    directive['downloadType<-' + typeName] = {
      '.type a': '#{downloadType}',
      '.type a@data-type': '#{downloadType}',
      '.type a@href': function typeAHref(args) {
        if (isDynamic) {
          return '#download';
        }

        return args.context.view.downloadUrl(args.item);
      },
      '@class+': function _class(args) {
        return args.item.toLowerCase() + 'Download';
      } // TODO: add download count when supported

    };
    return directive;
  };

  $.templates.downloadsTable = {
    downloadTypes: {
      'normal': common_views_constants__WEBPACK_IMPORTED_MODULE_0__[/* NORMAL_DATASET_DOWNLOAD_TYPES */ "a"],
      'tabular_geo': ['CSV', 'CSV for Excel', 'KML', 'KMZ', 'RDF', 'RSS', 'Shapefile', 'GeoJSON', 'XML', 'CSV for Excel (Europe)'],
      'layer_attributes': ['CSV', 'JSON'],
      // for obe and nbe monolayer datasets
      'layer_geojson_attributes': ['CSV', 'JSON', 'GeoJSON'],
      'obe_geo': ['KML', 'KMZ', 'Shapefile', 'Original'],
      'nbe_geo': ['KML', 'KMZ', 'Shapefile', 'Original', 'GeoJSON']
    },
    directive: {
      'normal': {
        '.downloadsTable .downloadsList tbody .item': downloadTypesDirective('downloadTypes')
      },
      'tabular_geo': {
        '.downloadsTable .downloadsList tbody .item': downloadTypesDirective('downloadTypes')
      },
      'obe_geo': {
        '.downloadsTable .downloadsList tbody .item': downloadTypesDirective('downloadTypes'),
        '.layerDownloadsContent .downloadsList tbody .item': downloadTypesDirective('layerDownloadTypes', true)
      },
      'nbe_geo': {
        '.downloadsTable .downloadsList tbody .item': downloadTypesDirective('downloadTypes'),
        '.layerDownloadsContent .downloadsList tbody .item': downloadTypesDirective('layerDownloadTypes', true)
      }
    },
    postRender: function postRender($elem) {
      $elem.find('table.gridList').combinationList({
        headerContainerSelector: $elem.find('.gridListWrapper'),
        initialSort: [[0, 0]],
        scrollableBody: false,
        selectable: false,
        sortGrouping: false,
        sortHeaders: {
          0: {
            sorter: 'text'
          }
        }
      });
    }
  };
})(jQuery);

/***/ }),

/***/ 3015:
/***/ (function(module, exports) {

blist.namespace.fetch('blist.filter');

(function ($) {
  var toUpperFn = function toUpperFn(arg) {
    return 'UPPER(' + arg + ')';
  };

  var identityFn = function identityFn(arg) {
    return arg;
  };

  var soqlInfix = function soqlInfix(c, op, v, fn) {
    if (!fn) {
      fn = identityFn;
    }

    return fn.call(this, c) + op + fn.call(this, v);
  };

  var soqlFunc = function soqlFunc(c, op, v, fn) {
    if (!fn) {
      fn = identityFn;
    }

    return op + '(' + fn.call(this, c) + (v === undefined ? '' : ',' + fn.call(this, v)) + ')';
  };

  var isText = function isText(fieldName, ds) {
    return ds.columnForFieldName(fieldName).isText();
  }; // Filtering
  // NOTE: New filter types also need an analogue template in
  // controls/maps/external-esri-map.js#transformFilterToLayerDefinition
  // -- michael.chui@socrata.com


  var filterOperators = {
    'EQUALS': {
      text: $.t('core.filters.informal.equals'),
      editorCount: 1,
      soql: function soql(c, v, ds) {
        return soqlInfix(c, '=', v, ds.newBackend && isText(c, ds) ? toUpperFn : identityFn);
      },
      opMatches: function opMatches(v, cv) {
        return _.isEqual(v, cv);
      }
    },
    'NOT_EQUALS': {
      text: $.t('core.filters.informal.not_equals'),
      editorCount: 1,
      soql: function soql(c, v, ds) {
        return soqlInfix(c, '!=', v, ds.newBackend && isText(c, ds) ? toUpperFn : identityFn);
      },
      opMatches: function opMatches(v, cv) {
        return !_.isEqual(v, cv);
      }
    },
    'STARTS_WITH': {
      text: $.t('core.filters.informal.starts_with'),
      editorCount: 1,
      soql: function soql(c, v, ds) {
        return soqlFunc(c, 'starts_with', v, ds.newBackend ? toUpperFn : identityFn);
      },
      opMatches: function opMatches(v, cv) {
        return (v || '').startsWith(cv);
      }
    },
    'CONTAINS': {
      text: $.t('core.filters.informal.contains'),
      editorCount: 1,
      soql: function soql(c, v) {
        return soqlFunc(c, 'contains', v);
      },
      opMatches: function opMatches(v, cv) {
        return (v || '').indexOf(cv) > -1;
      }
    },
    'NOT_CONTAINS': {
      text: $.t('core.filters.informal.not_contains'),
      editorCount: 1,
      soql: function soql(c, v) {
        return soqlFunc(c, 'not contains', v);
      },
      opMatches: function opMatches(v, cv) {
        return (v || '').indexOf(cv) < 0;
      }
    },
    // CONTAINS and NOT_CONTAINS behave differently in OBE vs NBE (case sensitivity). Due
    // to limitations of ViewFilterExpression in core we need a distinct operator
    // to indicate this behavioral difference. {NOT_}CONTAINS_INSENSITIVE is effectively
    // shorthand for contains(upper(column), upper(value)). These are only operators for the AST,
    // they are not valid SoQL keywords.
    // If we ever unify the core filter ASTs this will be the first thing against the wall.
    'CONTAINS_INSENSITIVE': {
      text: $.t('core.filters.informal.contains'),
      editorCount: 1,
      soql: function soql(c, v) {
        return soqlFunc(c, 'contains', v);
      },
      opMatches: function opMatches(v, cv) {
        return (v || '').indexOf(cv) > -1;
      }
    },
    'NOT_CONTAINS_INSENSITIVE': {
      text: $.t('core.filters.informal.not_contains'),
      editorCount: 1,
      soql: function soql(c, v) {
        return soqlFunc(c, 'not contains', v);
      },
      opMatches: function opMatches(v, cv) {
        return (v || '').indexOf(cv) < 0;
      }
    },
    'LESS_THAN': {
      text: $.t('core.filters.informal.less_than'),
      editorCount: 1,
      soql: function soql(c, v) {
        return soqlInfix(c, '<', v);
      },
      opMatches: function opMatches(v, cv) {
        return v < cv;
      }
    },
    'LESS_THAN_OR_EQUALS': {
      text: $.t('core.filters.informal.less_than_or_equals'),
      editorCount: 1,
      soql: function soql(c, v) {
        return soqlInfix(c, '<=', v);
      },
      opMatches: function opMatches(v, cv) {
        return v <= cv;
      }
    },
    'GREATER_THAN': {
      text: $.t('core.filters.informal.greater_than'),
      editorCount: 1,
      soql: function soql(c, v) {
        return soqlInfix(c, '>', v);
      },
      opMatches: function opMatches(v, cv) {
        return v > cv;
      }
    },
    'GREATER_THAN_OR_EQUALS': {
      text: $.t('core.filters.informal.greater_than_or_equals'),
      soql: function soql(c, v) {
        return soqlInfix(c, '>=', v);
      },
      editorCount: 1,
      opMatches: function opMatches(v, cv) {
        return v >= cv;
      }
    },
    'BETWEEN': {
      text: $.t('core.filters.informal.between'),
      editorCount: 2,
      soql: function soql(c, v, ds) {
        return [soqlInfix(c, '>=', v[0], ds.newBackend && isText(c, ds) ? toUpperFn : identityFn), soqlInfix(c, '<=', v[1], ds.newBackend && isText(c, ds) ? toUpperFn : identityFn)].join(' AND ');
      },
      opMatches: function opMatches(v, cv, cv2) {
        var cva = _.flatten(_.compact([cv, cv2]));

        if (!_.isArray(cva) || cva.length != 2) {
          return false;
        }

        return cva[0] <= v && v <= cva[1];
      }
    },
    'IS_BLANK': {
      text: $.t('core.filters.informal.is_blank'),
      editorCount: 0,
      soql: function soql(c) {
        return soqlInfix(c, ' is ', 'null');
      },
      opMatches: function opMatches(v) {
        return $.isBlank(v);
      }
    },
    'IS_NOT_BLANK': {
      text: $.t('core.filters.informal.is_not_blank'),
      editorCount: 0,
      soql: function soql(c) {
        return soqlInfix(c, ' is not ', 'null');
      },
      opMatches: function opMatches(v) {
        return !$.isBlank(v);
      }
    }
  };
  var filterGroups = blist.filter.groups = {
    textual: {
      orderedList: ['EQUALS', 'NOT_EQUALS', 'STARTS_WITH', 'CONTAINS', 'NOT_CONTAINS', 'CONTAINS_INSENSITIVE', 'NOT_CONTAINS_INSENSITIVE', 'IS_BLANK', 'IS_NOT_BLANK']
    },
    textObject: {
      orderedList: ['EQUALS', 'NOT_EQUALS', 'CONTAINS', 'NOT_CONTAINS', 'CONTAINS_INSENSITIVE', 'NOT_CONTAINS_INSENSITIVE', 'IS_BLANK', 'IS_NOT_BLANK']
    },
    numeric: {
      orderedList: ['EQUALS', 'NOT_EQUALS', 'LESS_THAN', 'LESS_THAN_OR_EQUALS', 'GREATER_THAN', 'GREATER_THAN_OR_EQUALS', 'BETWEEN', 'IS_BLANK', 'IS_NOT_BLANK']
    },
    date: {
      details: {
        'LESS_THAN': {
          text: $.t('core.filters.informal.is_before')
        },
        'GREATER_THAN': {
          text: $.t('core.filters.informal.is_after')
        }
      },
      orderedList: ['EQUALS', 'NOT_EQUALS', 'LESS_THAN', 'GREATER_THAN', 'BETWEEN', 'IS_BLANK', 'IS_NOT_BLANK']
    },
    comparable: {
      orderedList: ['EQUALS', 'NOT_EQUALS', 'IS_BLANK', 'IS_NOT_BLANK']
    },
    check: {
      details: {
        'IS_BLANK': {
          text: $.t('core.filters.informal.is_not_checked'),
          soql: function soql(c) {
            return 'not ' + c;
          }
        },
        'IS_NOT_BLANK': {
          text: $.t('core.filters.informal.is_checked'),
          soql: function soql(c) {
            return c;
          }
        }
      },
      orderedList: ['IS_BLANK', 'IS_NOT_BLANK']
    },
    blob: {
      details: {
        'IS_BLANK': {
          text: $.t('core.filters.informal.is_empty')
        },
        'IS_NOT_BLANK': {
          text: $.t('core.filters.informal.exists')
        }
      },
      orderedList: ['IS_BLANK', 'IS_NOT_BLANK']
    }
  };

  var setUpOperator = function setUpOperator(op, name) {
    op.name = name;

    op.matches = function () {
      // If we want to trim strings, we should do that here
      var vals = _.flatten(arguments);

      var getResult = function getResult(v, values) {
        return op.opMatches.apply(op, _.flatten([v, values]));
      };

      var matchVal = vals.shift();

      if ($.isPlainObject(matchVal)) {
        var func = op.name == 'IS_NOT_BLANK' ? 'any' : 'all';
        return _[func](matchVal, function (v, k) {
          var cv = vals[0];
          cv = $.isPlainObject(cv) ? cv[k] : cv;

          if (!$.isBlank(cv) || op.name.endsWith('_BLANK')) {
            return getResult(v, cv);
          }

          return true;
        });
      } else {
        return getResult(matchVal, vals);
      }
    };
  };

  _.each(filterOperators, function (op, name) {
    setUpOperator(op, name);
  });

  _.each(filterGroups, function (fg) {
    var d = {};

    _.each(fg.orderedList, function (op) {
      d[op] = filterOperators[op];
    });

    fg.details = $.extend(true, {}, d, fg.details);
  });

  var exprCache = {};

  blist.filter.matchesExpression = function (expr, colCont) {
    if (expr === true || _.isEmpty(expr)) {
      return function () {
        return true;
      };
    }

    if (!$.subKeyDefined(expr, 'operator')) {
      return function () {
        return false;
      };
    }

    if ($.isBlank(expr._key)) {
      expr._key = blist.filter.getFilterKey(expr);
    }

    var key = expr._key + '::' + (colCont || {}).id;

    if (!$.isBlank(exprCache[key])) {
      return exprCache[key];
    }

    function cacheAndReturn(f) {
      exprCache[key] = f;
      return f;
    } // Handle custom values with no children


    if (expr._key == 'customValues' && _.isEmpty(expr.children)) {
      return cacheAndReturn(function () {
        return true;
      });
    } // Handle array of sub-conditions


    if (!$.isBlank(expr.children)) {
      // Assume if not OR it is AND
      var func = expr.operator.toLowerCase() == 'or' ? 'some' : 'every';

      var childFuncs = _.map(expr.children, function (cExpr) {
        return blist.filter.matchesExpression(cExpr, colCont);
      });

      return cacheAndReturn(function (row) {
        return _[func](childFuncs, function (cf) {
          return cf(row);
        });
      });
    }

    if (!$.isBlank(colCont) && (!$.isBlank(expr.tableColumnId) || !$.isBlank(expr.columnFieldName))) {
      var col = colCont.columnForIdentifier(expr.tableColumnId || expr.columnFieldName);

      if ($.isBlank(col)) {
        return cacheAndReturn(function () {
          return false;
        });
      }

      var type = col.renderType;
      var subCol = (expr.subColumn || '').toLowerCase();

      if ($.subKeyDefined(type, 'subColumns.' + subCol)) {
        type = type.subColumns[subCol];
      }

      return cacheAndReturn(function (row) {
        var rowVal = row.data[col.lookup];

        if ($.isPlainObject(rowVal) && !$.isBlank(subCol)) {
          rowVal = rowVal[subCol];
        }

        return type.matches(expr.operator, col, rowVal, expr.value);
      });
    } else {
      var op = filterOperators[expr.operator.toUpperCase()];

      if ($.isBlank(op)) {
        return cacheAndReturn(function () {
          return false;
        });
      }

      return cacheAndReturn(function (row) {
        return op.matches(row, expr.value);
      });
    }
  };

  blist.filter.getFilterKey = function (fc) {
    if (_.isEmpty(fc)) {
      return '';
    }

    if (_.isString(fc.soql)) {
      return fc.soql;
    } // This is a cheat. Maps NBE interface.


    var op = fc.operator.toUpperCase();

    if (op == 'AND' || op == 'OR') {
      if (blist.filter.isEmptyPlaceholderFilter(fc)) {
        return 'customValues';
      }

      var childKeys = _.compact(_.map(fc.children, function (c) {
        return blist.filter.getFilterKey(c);
      }));

      return childKeys.length < 2 ? childKeys[0] || '' : '(' + childKeys.join('|' + op + '|') + ')';
    }

    return '(' + (fc.columnFieldName || fc.tableColumnId) + (!$.isBlank(fc.subColumn) ? '[' + fc.subColumn + ']' : '') + '|' + op + '|' + fc.value + ')';
  };

  blist.filter.generateSOQLWhere = function (fc, dataset) {
    if (_.isEmpty(fc)) {
      return '';
    }

    if (_.isString(fc.soql)) {
      return fc.soql;
    }

    var op = fc.operator.toUpperCase();

    if (op == 'AND' || op == 'OR') {
      var childKeys = _.map(fc.children, function (child) {
        return blist.filter.generateSOQLWhere(child, dataset);
      });

      return childKeys.length < 2 ? childKeys[0] || '' : '(' + childKeys.join(' ' + op + ' ') + ')';
    }

    var c = dataset.columnForIdentifier(fc.columnFieldName);
    var v = fc.value;

    if ($.subKeyDefined(c, 'renderType.soqlFilterValue')) {
      if (_.isArray(v)) {
        v = _.map(v, function (vv) {
          return c.renderType.soqlFilterValue(vv);
        });
      } else {
        v = c.renderType.soqlFilterValue(v);
      }
    } else if (_.isArray(v)) {
      v = _.map(v, function (vv) {
        return _.isString(vv) ? "'" + vv + "'" : vv;
      });
    } else if (_.isString(v)) {
      v = "'" + v + "'";
    } // Should be == to fc.columnFieldName unless fieldname changed since jsonQuery creation. \o/


    var fieldName = c.fieldName;

    if (!$.isBlank(fc.subColumn)) {
      fieldName += '.' + fc.subColumn;
    }

    if ($.subKeyDefined(c, 'renderType.soqlFieldWrapper')) {
      fieldName = c.renderType.soqlFieldWrapper(fieldName, op);
    }

    var soqlFunctionForOperator = filterOperators[op].soql;

    if ($.subKeyDefined(c, 'renderType.filterConditions.details.' + op + '.soql')) {
      soqlFunctionForOperator = c.renderType.filterConditions.details[op].soql;
    }

    return '(' + soqlFunctionForOperator(fieldName, v, dataset) + ')';
  };
  /* Recursively transforms the a table-derived filter condition
   * into a query_json-like condition structure.
   * e.g.
   * {
   *   "operator":"BETWEEN",           {
   *   "metadata":{                      "type": "operator",
   *     "unifiedVersion":2,        =>   "value": "BETWEEN",
   *   },                                "children": [
   *   "columnFieldName":"numbers",        {
   *   "value":[5,6]                         "type": "column",
   * }                                       "columnId": 123
   *                                       },
   *                                       {
   *                                         "type": "literal",
   *                                         "value": 5
   *                                       },
   *                                       {
   *                                         "type": "literal",
   *                                         "value": 6
   *                                       }
   *                                     ], ...
   *                                   }
   */


  function constructFilterCondition(fc, columnIdByColumnFieldName) {
    var result = {};

    if (_.isEmpty(fc)) {
      return result;
    }

    if (!fc.operator) {
      return {};
    }

    if (!$.isBlank(fc.metadata)) {
      result.metadata = fc.metadata;
    } else {
      result.metadata = {
        unifiedVersion: 2
      };
    }

    var op = fc.operator.toUpperCase();
    result.type = 'operator';
    result.value = op;

    if (op == 'AND' || op == 'OR') {
      result.children = _.map(fc.children, function (c) {
        return constructFilterCondition(c, columnIdByColumnFieldName);
      });
    } else {
      var child = {
        type: 'column'
      }; // If the columnIdByColumnFieldName map was passed down,
      // use the the columnId to identify this column.

      if (columnIdByColumnFieldName[fc.columnFieldName]) {
        child.columnId = columnIdByColumnFieldName[fc.columnFieldName];
      } else {
        child.columnFieldName = fc.columnFieldName;
      }

      result.children = [child]; // Can't have just a literal node with no value.
      // In particular, this is the case for the _BLANK operators

      if (!_.isUndefined(fc.value)) {
        _.each($.makeArray(fc.value), function (v) {
          result.children.push({
            type: 'literal',
            value: v
          });
        });
      }

      if (!$.isBlank(fc.subColumn)) {
        result.children[0].value = fc.subColumn;
      }
    }

    return result;
  }
  /* Transforms one or several filters passed from table data into a
   * query_json-like structure. */


  blist.filter.generateSODA1 = function (columnIdByColumnFieldName) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    // This is not _.compact because we need to throw away empty objects, too.
    args = _.filter(args, function (value) {
      return value && !_.isEmpty(value);
    });

    if (args.length > 0) {
      if (args.length === 1) {
        args = args[0];
      } else {
        args = {
          operator: 'AND',
          children: args
        };
      }

      return constructFilterCondition(args, columnIdByColumnFieldName);
    }
  };

  blist.filter.collapseChildren = function (fc) {
    fc = $.extend({}, fc);

    if ($.isBlank(fc.children)) {
      return fc;
    }

    var collapseChildren = function collapseChildren(children) {
      var newChildren = [];

      _.each(children, function (cond) {
        if (cond.type == 'operator' && cond.value == 'AND' || !$.isBlank(cond.operator) && cond.operator.toUpperCase() == 'AND') {
          newChildren = newChildren.concat(cond.children);
        } else if ((cond.type == 'operator' && cond.value == 'OR' || !$.isBlank(cond.operator) && cond.operator.toUpperCase() == 'OR') && _.isArray(cond.children) && cond.children.length == 1) {
          newChildren = newChildren.concat(cond.children);
        } else {
          newChildren.push(cond);
        }
      });

      newChildren = _.compact(newChildren);
      return _.isEqual(children, newChildren) ? false : newChildren;
    };

    var t;
    var newC = fc.children;

    while (t = collapseChildren(newC)) {
      // eslint-disable-line no-cond-assign
      newC = t;
    }

    fc.children = newC;
    return fc;
  };

  var isFCEqual = function isFCEqual(a, b) {
    if ($.isBlank(a)) {
      return $.isBlank(b);
    } else if ($.isBlank(b)) {
      return false;
    }

    if ($.isBlank(a.children)) {
      return $.isBlank(b.children) && a.columnFieldName == b.columnFieldName && a.operator == b.operator && a.value == b.value && a.subColumn == b.subColumn;
    } else if ($.isBlank(b.children) || a.operator != b.operator || a.children.length != b.children.length) {
      return false;
    }

    return _.every(a.children, function (ac) {
      return _.some(b.children, function (bc) {
        return isFCEqual(ac, bc);
      });
    });
  };

  blist.filter.subtractQueries = function (fc, baseFC) {
    fc = blist.filter.collapseChildren(fc);
    baseFC = blist.filter.collapseChildren(baseFC);

    if (!$.isBlank(fc.children) && fc.operator.toUpperCase() == 'AND') {
      if ($.isBlank(baseFC.children)) {
        fc.children = _.reject(fc.children, function (c) {
          return isFCEqual(c, baseFC);
        });
      } else if (baseFC.operator.toUpperCase() == 'AND') {
        fc.children = _.reject(fc.children, function (c) {
          return _.some(baseFC.children, function (bc) {
            return isFCEqual(c, bc);
          });
        });
      }

      return fc;
    } else if (isFCEqual(fc, baseFC)) {
      // They are the same; full subtraction!
      return null;
    } else {
      // Nothing to subtract
      return fc;
    }
  };

  blist.filter.isEmptyPlaceholderFilter = function (fc) {
    return _.isEmpty(fc.children) && fc.metadata && (fc.metadata.includeAuto || fc.metadata.customValues);
  };
})(jQuery);

/***/ }),

/***/ 3016:
/***/ (function(module, exports) {

// /!\ WARNING /!\
// This file does strange things with functions that don't work in strict mode.
// Therefore, we've disabled babel-loader on this file. Do not use any features not
// supported by browsers natively, and do not import any libraries.
//
// [lint pass]: This file has about 200 uses of double quotes, mostly in ways that
// give clarity.

/* eslint-disable quotes */
blist.namespace.fetch('blist.datatypes');

(function ($) {
  /*** RENDERERS ***/

  /* Textual types */
  var textualRegexes = {
    email: blist.util.patterns.core.emailValidator,
    url: blist.util.patterns.core.urlValidator,
    phone: /\d+/
  }; // Text & base textual

  var renderText = function renderText(value, column, plainText, inMenu, context, skipEscape) {
    var displayStyle = $.deepGet(column, 'format', 'displayStyle');

    switch (displayStyle) {
      case 'email':
        if (textualRegexes.email.test(value)) {
          return renderEmail.apply(null, arguments);
        }

        break;

      case 'url':
        if (textualRegexes.url.test(value)) {
          return renderURL.apply(null, arguments);
        }

        break;

      case 'phone':
        if (textualRegexes.phone.test(value)) {
          value = {
            phone_type: 'modern',
            phone_number: value
          };
          return renderPhone(value, column, plainText, inMenu);
        }

        break;
    }

    var v = inMenu ? $.htmlStrip(value) : $.isBlank(value) ? '' : value; // Can we get rid of htmlEscape here?

    return skipEscape ? v : $.htmlEscape(v);
  }; // HTML
  // TODO: Address potential XSS vector, tracked by EN-1959.


  var renderHtml = function renderHtml(value, col, plainText, inMenu) {
    if ($.isBlank(value)) {
      return '';
    }

    if (plainText || inMenu) {
      return $.htmlStrip(value);
    } // Add an extra wrapper so we can tweak the display to something
    // reasonable


    return '<span class="blist-html">' + value + '</span>';
  };
  /* Numeric types */


  var DIGITS = {
    "0": true,
    "1": true,
    "2": true,
    "3": true,
    "4": true,
    "5": true,
    "6": true,
    "7": true,
    "8": true,
    "9": true
  }; // Number & base numeric

  var numberHelper = function numberHelper(value, decimalPlaces, precisionStyle, prefix, suffix, humane, noCommas, mask, localization) {
    if ($.isBlank(value)) {
      return '';
    }

    localization = localization || {};
    var origValue = value.toString();

    if (_.isString(mask) && mask !== '') {
      value = '';
      var decSep = localization.decimalSeparator || '.';

      while (origValue.length && mask.length) {
        // decimals are weird things to have in a masked number,
        // so we'll just deal with it by unilaterally dumping them
        // as soon as the value gets there
        if (origValue.charAt(0) === '.') {
          value += decSep;
          origValue = origValue.slice(1);
        }

        if (mask.charAt(0) === '#') {
          value += origValue.charAt(0);
          origValue = origValue.slice(1);
        } else {
          value += mask.charAt(0);
        }

        mask = mask.slice(1);
      } // if the mask had run out of numbers, put the rest of
      // whatever might have been left in the output


      if (mask.indexOf('#') === -1) {
        value += mask;
      } // if the original value is longer than the mask, just
      // append whatever's left at the very end here


      value += origValue;
    } else {
      if (!_.isNumber(value)) {
        // Skip this if we already have a number as it is slow
        if (_.isString(value)) {
          value = value.replace(/[^0-9\.\+\-]/g, '');
        }

        value = parseFloat(value);

        if (_.isNaN(value)) {
          return origValue;
        }
      }

      if (precisionStyle == 'scientific') {
        if (decimalPlaces !== undefined) {
          value = value.toExponential(decimalPlaces);
        } else {
          value = value.toExponential();
        }
      } else if (decimalPlaces !== undefined) {
        value = value.toFixed(decimalPlaces);
      }

      if (humane === true || humane === 'true') {
        value = blist.util.toHumaneNumber(value, 2);
      }

      value = value.toString();
      var pos = value.indexOf('.');

      if (!$.isBlank(localization.decimalSeparator) && pos > -1) {
        value = value.substring(0, pos) + localization.decimalSeparator + value.substring(pos + 1);
      }

      if (noCommas !== true && noCommas != 'true') {
        if (pos == -1) {
          pos = value.length;
        }

        pos -= 3;

        while (pos > 0 && DIGITS[value.charAt(pos - 1)]) {
          value = value.substring(0, pos) + (localization.groupSeparator || ",") + value.substring(pos);
          pos -= 3;
        }
      }
    }

    var isNegative = value[0] === '-';

    if (precisionStyle === 'currency') {
      value = isNegative ? '-' + prefix + value.substring(1) : prefix + value;
    } else if (precisionStyle === 'financial' && isNegative) {
      value = prefix + value.substring(1) + suffix;
    } else if (precisionStyle !== 'financial' && prefix) {
      value = prefix + value;
    }

    if (precisionStyle !== 'financial' && suffix) {
      value += suffix;
    }

    return value;
  };

  var renderNumber = function renderNumber(value, column) {
    if (column.format.precisionStyle === 'percentage') {
      return renderPercent.apply(null, arguments);
    }

    var prefix = null;
    var suffix = null;

    switch (column.format.precisionStyle) {
      case 'currency':
        prefix = blist.datatypes.money.currencies[column.format.currencyStyle];
        break;

      case 'percentage':
        suffix = '%';
        break;

      case 'financial':
        prefix = '(';
        suffix = ')';
        break;
    }

    return numberHelper(value, column.format.precision, column.format.precisionStyle, prefix, suffix, false, column.format.noCommas, column.format.mask, {
      groupSeparator: column.format.groupSeparator,
      decimalSeparator: column.format.decimalSeparator
    });
  }; // Money


  var renderMoney = function renderMoney(value, column) {
    if (_.isString(value)) {
      value = value.replace(/[^0-9\.\-\+]/g, '');
    }

    return numberHelper(value, column.format.precision || 2, column.format.precisionStyle, blist.datatypes.money.currencies[column.format.currency || 'USD'], null, column.format.humane, false, null, {
      groupSeparator: column.format.groupSeparator,
      decimalSeparator: column.format.decimalSeparator
    });
  }; // Percent


  var renderPercent = function renderPercent(value, column, plainText, inMenu) {
    if (plainText || inMenu) {
      return numberHelper(value, column.format.precision, column.format.precisionStyle, null, '%', false, column.format.noCommas, null, {
        groupSeparator: column.format.groupSeparator,
        decimalSeparator: column.format.decimalSeparator
      });
    }

    var shouldRenderText;
    var shouldRenderBar;

    switch (column.format.view) {
      case 'percent_bar':
        shouldRenderText = false;
        shouldRenderBar = true;
        break;

      case 'percent_text':
        shouldRenderText = true;
        shouldRenderBar = false;
        break;

      default:
        shouldRenderText = shouldRenderBar = true;
        break;
    }

    var rv = ['<span class="blist-percent">'];

    if (shouldRenderBar && !!value) {
      var cls;
      var v = value;

      if (value > 0) {
        cls = 'blist-percent-bar-pos';
      } else {
        cls = 'blist-percent-bar-neg';
        v *= -1;
      }

      if (v > 100) {
        v = 100;
      }

      rv.push('<span class="blist-cell ', cls, '" style="width: ', v, '%"></span>');
    }

    if (shouldRenderText) {
      rv.push('<span class="blist-cell blist-percent-num">', numberHelper(value, column.format.precision, column.format.precisionStyle, null, '%', false, column.format.noCommas, null, {
        groupSeparator: column.format.groupSeparator,
        decimalSeparator: column.format.decimalSeparator
      }), '</span>');
    }

    rv.push('</span>');
    return rv.join('');
  };
  /* Date/time types */
  // Date & base date renderer
  // Optimized format for date/time rendering (datejs is a very inefficient
  // way to go)


  var OPTIMIZE_FORMAT_DATETIME1 = 'm/d/Y h:i:s A O';

  var renderDateDateTime1 = function renderDateDateTime1(value, stringParse) {
    if (value == null) {
      return '';
    }

    var d;

    if (_.isNumber(value)) {
      d = new Date(value * 1000);
    } else if (!$.isBlank(stringParse)) {
      d = Date.parseExact(value, stringParse);
    } else {
      d = Date.parse(value);
    }

    if (!d) {
      return '';
    }

    var hour = d.getHours();

    if (hour > 11) {
      hour -= 12;
      var meridian = ' PM';
    } else {
      meridian = ' AM';
    }

    if (!hour) {
      hour = 12;
    }

    if (hour < 10) {
      hour = "0" + hour;
    }

    var minute = d.getMinutes();

    if (minute < 10) {
      minute = "0" + minute;
    }

    var second = d.getSeconds();

    if (second < 10) {
      second = "0" + second;
    }

    var day = d.getDate();

    if (day < 10) {
      day = "0" + day;
    }

    var month = d.getMonth() + 1;

    if (month < 10) {
      month = "0" + month;
    }

    return month + "/" + day + "/" + d.getFullYear() + " " + hour + ":" + minute + ":" + second + meridian + " " + d.getUTCOffset();
  };

  var renderDate = function renderDate(value, column) {
    if ($.isBlank(value)) {
      return '';
    }

    var type = column.renderType || blist.datatypes.date;
    var format = type.formats[column.format.view] || type.formats['date_time'];

    if (format == OPTIMIZE_FORMAT_DATETIME1) {
      return renderDateDateTime1(value, type.stringParse);
    }

    var d;

    if (_.isNumber(value)) {
      d = new Date(value * 1000);
    } else {
      // Can't parse milliseconds
      value = value.replace(/\.\d{3}Z?/, '');

      if (!$.isBlank(type.stringParse)) {
        d = Date.parseExact(value, type.stringParse);
      } else {
        d = Date.parse(value);
      }
    }

    return d ? d.format(format) : '';
  };
  /* URI types */
  // Base URI


  var uriHelper = function uriHelper(value, captionIsHTML, plainText, baseUrl) {
    if (!value) {
      return '';
    }

    var url;
    var caption;

    if (value instanceof Array) {
      url = value[0];
      caption = value[1] || url;
    } else if (value instanceof Object) {
      url = value.url;
      caption = value.description || url;
    } else {
      caption = url = value + '';
    }

    if (url && url != '' && !url.match(/^([a-z]+):/i)) {
      if (!$.isBlank(baseUrl)) {
        url = baseUrl + url;
      } else if (url.indexOf('/') != 0) {
        url = 'http://' + url;
      }
    }

    if (!captionIsHTML) {
      caption = $.htmlEscape(caption);
    }

    if (plainText) {
      return url || caption || '';
    }

    return "<a target='blist-viewer' rel='external' href='" + $.htmlEscape(url) + "'>" + caption + "</a>";
  }; // Email


  var renderEmail = function renderEmail(value, col, plainText, inMenu) {
    return plainText || inMenu ? value : uriHelper(value && ['mailto:' + value, value]);
  }; // Phone


  var renderPhone = function renderPhone(value, column, plainText, inMenu) {
    if (!value) {
      return '';
    }

    var num;
    var type;

    if (_.isArray(value)) {
      num = value[0] || '';
      type = value[1];
    } else if ($.isPlainObject(value)) {
      num = value.phone_number || '';
      type = value.phone_type;
    } else {
      num = value + '';
    }

    var label = num + '';

    if (label.match(/^\d{10}$/)) {
      label = '(' + label.substring(0, 3) + ') ' + label.substring(3, 6) + '-' + label.substring(6, 10);
    } else if (label.match(/^\d{7}$/)) {
      label = label.substring(0, 3) + '-' + label.substring(3, 7);
    }

    var typeStr = type ? type.toLowerCase() : 'unknown';

    if (plainText) {
      if (type) {
        label += ' (' + typeStr + ')';
      }

      return label;
    }

    label = (inMenu && !type ? '' : '<span class="blist-phone-icon blist-phone-icon-' + typeStr + '">' + typeStr + '</span>&nbsp;') + $.htmlEscape(label);
    return inMenu ? label : uriHelper(['tel:' + num.replace(/[\-()\s]/g, ''), label], true);
  }; // URL


  var renderURL = function renderURL(value, column, plainText, inMenu) {
    var v = value;

    if (inMenu) {
      v = $.keyValueToObject('description', value.description || v[1]);

      if ($.isBlank(v.description)) {
        v.url = value.url || v[0];
      }
    }

    return uriHelper(value, false, plainText || inMenu, (column.format || {}).baseUrl);
  };
  /* Graphical types */
  // Checkbox


  var renderCheckbox = function renderCheckbox(value, column, plainText, inMenu) {
    if (plainText) {
      return value ? '&#10003;' : '';
    }

    return ['<span class="blist-cell blist-checkbox blist-checkbox-', value ? 'on' : 'off', '"', !inMenu ? ' title="' + (value ? 'True' : 'False') : '', '">', value ? 'True' : 'False', '</span>'].join('');
  }; // Stars


  var renderStars = function renderStars(value, column, plainText, inMenu, context) {
    var starWidth = 16;

    if ($.isBlank(value) || value <= 0) {
      return '';
    }

    var rv = [];

    if (plainText) {
      for (var i = 0; i < value; i++) {
        rv.push('*');
      }

      return rv.join('');
    }

    var range = parseFloat(column.format.range);

    if (range <= 0 || isNaN(range)) {
      range = 5;
    }

    range *= starWidth;

    if (inMenu) {
      rv.push('<div class="blist-tstars-wrapper">');
    }

    var on = Math.min(range, Math.round(value * starWidth));
    var off = range - on;
    rv.push('<span class="blist-tstars-render-wrapper" style="width:', range, 'px">');

    if ((context || {
      permissions: {}
    }).permissions.canEdit) {
      rv.push('<span class="blist-star-0"></span>');
    }

    rv.push('<span class="blist-tstars" style="width: ', range, 'px"><span class="blist-cell blist-tstar-on" style="width: ', on, 'px"></span><span class="blist-cell blist-tstar-off" style="width: ', off, 'px; background-position-x: ', -(on % starWidth), 'px"></span></span></span>');

    if (inMenu) {
      rv.push(value, '</div>');
    }

    return rv.join('');
  };
  /* Geographic types */
  // Location


  var renderLocation = function renderLocation(value, column, plainText, inMenu) {
    if ($.isBlank(value)) {
      return '';
    }

    var v = value;
    var view = column.format.view;

    if (this.name != 'location') {
      view = 'address_coords';
      v = $.keyValueToObject(this.name, v);
    }

    if ($.isBlank(view)) {
      view = 'address_coords';
    }

    var pieces = [];

    if (!$.isBlank(v.human_address) && view.startsWith('address')) {
      var a = _.isString(v.human_address) ? JSON.parse(v.human_address) : v.human_address;

      if (!$.isBlank(a.address) && a.address !== '') {
        pieces.push(a.address);
      }

      pieces.push(_.compact([_.compact([a.city, a.state]).join(', '), a.zip]).join(' '));
    }

    if (view.endsWith('coords') && (!$.isBlank(v.latitude) || !$.isBlank(v.longitude))) {
      pieces.push('(' + (v.latitude || '') + (plainText ? '' : '&deg;') + ', ' + (v.longitude || '') + (plainText ? '' : '&deg;') + ')');
    } else if (view.endsWith('coords') && _.isArray(v.coordinates) && v.coordinates.length === 2) {
      pieces.push('(' + (v.coordinates[1] || '') + (plainText ? '' : '&deg;') + ', ' + (v.coordinates[0] || '') + (plainText ? '' : '&deg;') + ')');
    }

    return pieces.join(plainText || inMenu ? ' \n' : '<br />');
  }; // Geospatial


  var renderGeospatial = function renderGeospatial(value, column) {
    if ($.isBlank(value)) {
      return '';
    }

    var rv = [];

    if (!$.isBlank(value.geometry)) {
      var width = '60';
      var height = '150';
      var imageUrl = $.addAppToken(column.baseUrl() + value.row_id + '?column=' + column.id + '&width=' + width + '&height=' + height);
      rv.push('<embed src="', imageUrl, '" width="', width, '" height="', height, '"></embed>');
    }

    return rv.join('');
  }; // depending on the dataset in quesiton, frontend uses either soda1 or soda2 to query core for rows.
  // soda1 returns wkt (well known text) which is the format we want to show in the grid.
  // soda2 returns geojson which needs to be converted to wkt.
  // this method is written to handle both cases (wkt is a string and geojson is an object).


  var renderWKT = function renderWKT(value) {
    if ($.isBlank(value)) {
      return '';
    }

    if (_.isString(value)) {
      return value;
    }

    return WKT.stringify(value) || '';
  };
  /* Blobby types */
  // Photo


  var renderPhoto = function renderPhoto(value, column, plainText, inMenu, context) {
    if ($.isBlank(value)) {
      return '';
    } // Motivation for URL checking:
    // Setting the config, use_soda2, causes an OBE dataset
    // to use SODA2 for rendering. In that case, photo blobs
    // are saved as whole URLs and not IDs.
    // Trim away extra space, as it can cause regexes to fail.


    value = value.trim(); // In other words, either starts with http or //.

    var isUrl = /^(https?:)?\/\//i.test(value);
    var url;

    if (isUrl) {
      var domainRegex = new RegExp('^https?://' + column.view.domainCName, 'i');

      var isSameOriginAndSODA2Configured = domainRegex.test(value) && column.view._useSODA2;

      if (isSameOriginAndSODA2Configured) {
        url = value;
      } else {
        url = '';
      }
    } else {
      url = escape(column.baseUrl() + value);
    }

    if (plainText) {
      return url;
    }

    if (!$.isBlank(column.format.size)) {
      url += '?size=' + column.format.size;
    }

    var img = '<img src="' + $.htmlEscape(url) + '"></img>';

    if ((context || {
      permissions: {}
    }).permissions.canEdit) {
      return img;
    }

    return uriHelper({
      url: value,
      description: img
    }, true, false, column.baseUrl());
  };

  var renderDocument = function renderDocument(value, column, plainText) {
    var url, name, size;

    if (!value) {
      return '';
    } else if (_.isArray(value)) {
      url = value[2];
      name = value[1];
      size = value[3];
    } else if ($.isPlainObject(value)) {
      if (value.id) {
        // old-style document
        url = value.id;
        name = value.filename;
        size = value.size;
      } else {
        // new-style document
        url = value.file_id + '?';
        var args = [];

        if (value.filename) {
          args.push('filename=' + escape(value.filename));
        }

        if (value.content_type) {
          args.push('content_type=' + escape(value.content_type));
        }

        url += args.join('&');
        name = value.filename;
        size = value.size;
      }
    } else {
      url = value + '';
    }

    if (!url) {
      return '';
    }

    if (plainText) {
      return name || '';
    }

    var rv = uriHelper([(column.baseUrl() || '') + url, name || 'Document']);

    if (!$.isBlank(size)) {
      size = Math.round(size / 1024);

      if (size == 0) {
        size = 1;
      }

      rv += '&nbsp;<span class="blist-document-size">(' + size + 'k)</span>';
    }

    return rv;
  };

  var renderBlob = function renderBlob(value, column, plainText, inMenu, context) {
    var ds = context.modelView,
        fileData;

    if (ds && (fileData = ds.fileDataForFileId(value))) {
      var documentObject = {
        file_id: fileData.id,
        size: fileData.size,
        content_type: fileData.contentType,
        // Not 100% sure we should do this.
        filename: fileData.filename // This doesn't come back. :(

      };
      return renderDocument(documentObject, column, plainText);
    } // Fallback when fileData isn't available.


    return renderDocument.apply(null, arguments);
  };
  /* Linking/customization types */
  // Drop-down lists, and other link types


  var renderLookupList = function renderLookupList(value, column, plainText) {
    if (!_.isString(value) || $.isBlank(value)) {
      return '';
    }

    var matchVal;
    var ddl = column.dropDownList || this.dropDownList;

    if (ddl) {
      var lcVal = value.toLowerCase();

      for (var i = 0; i < ddl.values.length; i++) {
        var v = ddl.values[i];

        if ((v.id || '').toLowerCase() == lcVal) {
          matchVal = v;
          break;
        }
      }
    }

    if ($.isBlank(matchVal)) {
      return plainText ? value : '<div class="blist-dataset-link-dangling">' + value + '</div>';
    }

    var view = column.format.view || (this.format || {}).view || 'icon_text';
    var result = [];

    if (!plainText) {
      result.push('<span class="blist-dropdownlist-wrapper blist-' + (this.cls || this.name) + '">');

      if (!$.isBlank(matchVal.icon) && view.startsWith('icon')) {
        result.push('<img class="blist-table-option-icon" src="', matchVal.icon, '" title="', $.htmlStrip(matchVal.description || ''), '" />');
      }
    }

    if (plainText || view.endsWith('text')) {
      result.push($.htmlStrip(matchVal.description || ''));
    }

    if (!plainText) {
      result.push('</span>');
    }

    return result.join('');
  };
  /* Generic types */
  // Object


  var renderObject = function renderObject(value) {
    return $.htmlEscape(value ? JSON.stringify(value) : '');
  };
  /** FILTER FUNCTIONS ***/


  var valueFilterCheckbox = function valueFilterCheckbox(value) {
    return value ? 1 : 0;
  };
  /*** DATA TYPE DEFINITIONS ***/
  // Aggregates


  var aggs = [{
    text: $.t('core.aggregates.average'),
    value: 'avg',
    calculate: function calculate(values) {
      var count = 0;

      var sum = _.reduce(values, function (memo, v) {
        if ($.isBlank(v)) {
          return memo;
        }

        count++;
        return memo + parseFloat(v);
      }, 0);

      return sum / (count || 1);
    }
  }, {
    text: $.t('core.aggregates.count'),
    value: 'count',
    calculate: function calculate(values) {
      return _.reduce(values, function (memo, v) {
        return memo + ($.isBlank(v) ? 0 : 1);
      }, 0);
    }
  }, {
    text: $.t('core.aggregates.sum'),
    value: 'sum',
    calculate: function calculate(values) {
      return _.reduce(values, function (memo, v) {
        return memo + ($.isBlank(v) ? 0 : parseFloat(v));
      }, 0);
    }
  }, {
    text: $.t('core.aggregates.maximum'),
    value: 'max',
    calculate: function calculate(values) {
      return _.reduce(values, function (memo, v) {
        return $.isBlank(memo) ? v : $.isBlank(v) ? memo : Math.max(memo, parseFloat(v));
      }, null);
    }
  }, {
    text: $.t('core.aggregates.minimum'),
    value: 'min',
    calculate: function calculate(values) {
      return _.reduce(values, function (memo, v) {
        return $.isBlank(memo) ? v : $.isBlank(v) ? memo : Math.min(memo, parseFloat(v));
      }, null);
    }
  }];

  blist.datatypes.soda2Aggregate = function (agg) {
    return {
      average: 'avg',
      minimum: 'min',
      maximum: 'max'
    }[agg] || agg;
  };

  blist.datatypes.aggregateFromSoda2 = function (agg) {
    return {
      avg: 'average',
      min: 'minimum',
      max: 'maximum'
    }[agg] || agg;
  };

  var nonNumericAggs = _.filter(aggs, function (a) {
    return 'count' == a.value;
  }); // Alignment


  var alignLeft = {
    text: $.t('core.alignment.left'),
    value: 'left'
  };
  var alignCenter = {
    text: $.t('core.alignment.center'),
    value: 'center'
  };
  var alignRight = {
    text: $.t('core.alignment.right'),
    value: 'right'
  };
  var alignment = [alignLeft, alignCenter, alignRight];
  var numericAlignment = [alignRight, alignLeft, alignCenter]; // Text Formatting

  var textAsText = {
    text: $.t('core.data_types.text'),
    value: 'plain'
  };
  var textAsEmail = {
    text: $.t('core.data_types.email'),
    value: 'email'
  };
  var textAsUrl = {
    text: $.t('core.data_types.url'),
    value: 'url'
  };
  var textAsPhone = {
    text: $.t('core.data_types.phone'),
    value: 'phone'
  };
  var textFormattingOptions = [textAsText, textAsEmail, textAsPhone, textAsUrl]; // Common convertable types

  var numericConvertTypes = ['money', 'number', 'percent', 'stars']; // Date-time formatting and views

  var shortTimeFormat = 'h:i A';
  var zShortTimeFormat = shortTimeFormat + ' O';
  var timeFormat = 'h:i:s A';
  var zTimeFormat = timeFormat + ' O';
  var baseDTFormats = {
    'date_time': 'm/d/Y',
    'date': 'm/d/Y',
    'date_dmy_time': 'd/m/Y',
    'date_dmy': 'd/m/Y',
    'date_ymd_time': 'Y/m/d',
    'date_ymd': 'Y/m/d',
    'date_monthdy_time': 'F d, Y',
    'date_monthdy': 'F d, Y',
    'date_shortmonthdy': 'M d, Y',
    'date_monthdy_shorttime': 'F d, Y',
    'date_dmonthy': 'd F Y',
    'date_dmonthy_time': 'd F Y',
    'date_shortmonthdy_shorttime': 'M d, Y',
    'date_ymonthd_time': 'Y F d',
    'date_ymonthd': 'Y F d',
    'date_my': 'm/Y',
    'date_ym': 'Y/m',
    'date_shortmonthy': 'M Y',
    'date_yshortmonth': 'Y M',
    'date_monthy': 'F Y',
    'date_ymonth': 'Y F',
    'date_y': 'Y'
  };
  var dateTimeFormats = {};
  var zDateTimeFormats = {};

  _.each(baseDTFormats, function (v, k) {
    dateTimeFormats[k] = v;
    zDateTimeFormats[k] = v;

    if (k.endsWith('_time')) {
      dateTimeFormats[k] += ' ' + timeFormat;
      zDateTimeFormats[k] += ' ' + zTimeFormat;
    } else if (k.endsWith('_shorttime')) {
      dateTimeFormats[k] += ' ' + shortTimeFormat;
      zDateTimeFormats[k] += ' ' + zShortTimeFormat;
    }
  });

  var possibleDateViews = [{
    value: 'date_time',
    text: 'month/day/year hour:minute'
  }, {
    value: 'date',
    text: 'month/day/year'
  }, {
    value: 'date_dmy_time',
    text: 'day/month/year hour:minute'
  }, {
    value: 'date_dmy',
    text: 'day/month/year'
  }, {
    value: 'date_ymd_time',
    text: 'year/month/day hour:minute'
  }, {
    value: 'date_ymd',
    text: 'year/month/day'
  }, {
    value: 'date_monthdy_shorttime',
    text: 'month day, year hour:minute'
  }, {
    value: 'date_monthdy',
    text: 'month day, year'
  }, {
    value: 'date_shortmonthdy',
    text: 'month day, year'
  }, {
    value: 'date_monthdy_time',
    text: 'month day, year hour:minute'
  }, {
    value: 'date_dmonthy',
    text: 'day month year'
  }, {
    value: 'date_dmonthy_time',
    text: 'day month year hour:minute'
  }, {
    value: 'date_shortmonthdy_shorttime',
    text: 'month day, year hour:minute'
  }, {
    value: 'date_ymonthd',
    text: 'year month day'
  }, {
    value: 'date_ymonthd_time',
    text: 'year month day hour:minute'
  }, {
    value: 'date_my',
    text: 'month/year',
    isMonth: true
  }, {
    value: 'date_ym',
    text: 'year/month',
    isMonth: true
  }, {
    value: 'date_shortmonthy',
    text: 'month year',
    isMonth: true
  }, {
    value: 'date_yshortmonth',
    text: 'year month',
    isMonth: true
  }, {
    value: 'date_monthy',
    text: 'month year',
    isMonth: true
  }, {
    value: 'date_ymonth',
    text: 'year month',
    isMonth: true
  }, {
    value: 'date_y',
    text: 'year',
    isYear: true
  }];

  var dateViews = function dateViews(funcOrCol, exclusive) {
    var func = _.isString(funcOrCol) || $.isBlank(funcOrCol) ? funcOrCol : funcOrCol.format.group_function;
    return _.filter(possibleDateViews, function (dv) {
      switch (func) {
        case 'date_ymd':
          return !dv.value.endsWith('time') && (!exclusive || !dv.isMonth && !dv.isYear);

        case 'date_ym':
          return dv.isMonth || !exclusive && dv.isYear;

        case 'date_y':
          return dv.isYear;

        default:
          return !exclusive || dv.value.endsWith('time');
      }
    });
  };

  var dateGroupFunctions = function dateGroupFunctions(prefix) {
    return [{
      text: $.t('core.group_function.date_day'),
      value: prefix + '_trunc_ymd'
    }, {
      text: $.t('core.group_function.date_month'),
      value: prefix + '_trunc_ym'
    }, {
      text: $.t('core.group_function.date_year'),
      value: prefix + '_trunc_y'
    }];
  };

  blist.datatypes.soda2GroupFunction = function (gf, col) {
    if ($.isBlank(gf)) {
      return gf;
    }

    var rf = '';

    if (gf.startsWith('date_')) {
      rf += col.renderTypeName == 'date' ? 'datez' : 'date';
    }

    rf += '_trunc_' + gf.slice(gf.indexOf('_') + 1);
    return rf;
  };

  blist.datatypes.groupFunctionFromSoda2 = function (gf) {
    if ($.isBlank(gf)) {
      return gf;
    }

    return gf.replace('datez_', 'date_').replace('_trunc_', '_');
  };

  blist.datatypes.interfaceTypes = {
    blob: {
      renderer: renderBlob
    },
    checkbox: {
      renderer: renderCheckbox
    },
    date: {
      renderer: renderDate
    },
    document: {
      renderer: renderDocument
    },
    email: {
      renderer: renderEmail
    },
    geospatial: {
      renderer: renderGeospatial
    },
    html: {
      renderer: renderHtml
    },
    location: {
      renderer: renderLocation
    },
    lookupList: {
      renderer: renderLookupList
    },
    money: {
      renderer: renderMoney
    },
    number: {
      renderer: renderNumber
    },
    object: {
      renderer: renderObject
    },
    percent: {
      renderer: renderPercent
    },
    phone: {
      renderer: renderPhone
    },
    photo: {
      renderer: renderPhoto
    },
    stars: {
      renderer: renderStars
    },
    text: {
      renderer: renderText
    },
    url: {
      renderer: renderURL
    },
    point: {
      renderer: renderWKT
    },
    multipoint: {
      renderer: renderWKT
    },
    line: {
      renderer: renderWKT
    },
    multiline: {
      renderer: renderWKT
    },
    polygon: {
      renderer: renderWKT
    },
    multipolygon: {
      renderer: renderWKT
    }
  };
  var groups = {
    standard: $.t('screens.ds.grid_sidebar.base.datatypes.groups.standard'),
    geometry: $.t('screens.ds.grid_sidebar.base.datatypes.groups.geometry')
  };
  /**
   * This is our main map of data types.
   */

  $.extend(blist.datatypes, {
    // Invalid type is special, not a real type
    invalid: {
      interfaceType: blist.datatypes.interfaceTypes.text
    },
    // Textual types
    text: {
      title: 'Plain Text',
      group: groups.standard,
      interfaceType: blist.datatypes.interfaceTypes.text,
      aggregates: nonNumericAggs,
      alignment: alignment,
      convertableTypes: ['html', 'calendar_date', 'date', 'phone', 'email', 'checkbox', 'flag'].concat(numericConvertTypes),
      createable: true,
      deleteable: true,
      displayOptions: textFormattingOptions,
      filterConditions: blist.filter.groups.textual,
      inlineType: true,
      matchValue: function matchValue(v) {
        if (_.isString(v)) {
          v = v.toLowerCase();
        }

        return v;
      },
      priority: 1,
      rollUpAggregates: nonNumericAggs,
      sortable: true
    },
    html: {
      title: 'Formatted Text',
      interfaceType: blist.datatypes.interfaceTypes.html,
      aggregates: nonNumericAggs,
      convertableTypes: ['text', 'calendar_date', 'date', 'phone', 'email', 'checkbox', 'flag'].concat(numericConvertTypes),
      createable: false,
      deleteable: true,
      deprecatedInNbe: true,
      deprecatedInWave1: true,
      filterConditions: $.extend(true, {
        details: {
          'EQUALS': {
            interfaceType: blist.datatypes.interfaceTypes.text
          },
          'NOT_EQUALS': {
            interfaceType: blist.datatypes.interfaceTypes.text
          },
          'STARTS_WITH': {
            interfaceType: blist.datatypes.interfaceTypes.text
          },
          'CONTAINS': {
            interfaceType: blist.datatypes.interfaceTypes.text
          },
          'NOT_CONTAINS': {
            interfaceType: blist.datatypes.interfaceTypes.text
          }
        }
      }, blist.filter.groups.textual),
      priority: 2,
      rollUpAggregates: nonNumericAggs,
      sortable: true
    },
    // Numeric types
    number: {
      title: 'Number',
      group: groups.standard,
      interfaceType: blist.datatypes.interfaceTypes.number,
      aggregates: aggs,
      alignment: numericAlignment,
      cls: 'number',
      convertableTypes: _.without(numericConvertTypes, 'number').concat('text'),
      createable: true,
      deleteable: true,
      filterConditions: blist.filter.groups.numeric,
      inlineType: true,
      matchValue: function matchValue(v) {
        v = parseFloat(v);
        return _.isNaN(v) ? null : v;
      },
      precisionStyle: [{
        text: $.t('core.precision_style.standard'),
        value: 'standard'
      }, {
        text: $.t('core.precision_style.scientific'),
        value: 'scientific'
      }, {
        text: $.t('core.precision_style.currency'),
        value: 'currency'
      }, {
        text: $.t('core.precision_style.percentage'),
        value: 'percentage'
      }, {
        text: $.t('core.precision_style.financial'),
        value: 'financial'
      }],
      priority: 3,
      rollUpAggregates: aggs,
      sortable: true
    },
    money: {
      title: 'Money',
      interfaceType: blist.datatypes.interfaceTypes.money,
      aggregates: aggs,
      alignment: numericAlignment,
      cls: 'money',
      convertableTypes: _.without(numericConvertTypes, 'money').concat('text'),
      createable: true,
      currencies: {
        "USD": "$",
        "GBP": "£",
        "EUR": "€",
        "JPY": "¥",
        "AFN": "؋",
        "ALL": "Lek",
        "ANG": "ƒ",
        "ARS": "$",
        "AUD": "$",
        "AWG": "ƒ",
        "AZN": "ман",
        "BAM": "KM",
        "BBD": "$",
        "BGN": "лв",
        "BMD": "$",
        "BND": "$",
        "BOB": "$b",
        "BRL": "R$",
        "BSD": "$",
        "BWP": "P",
        "BYR": "p.",
        "BZD": "BZ$",
        "CAD": "$",
        "CHF": "CHF",
        "CLP": "$",
        "CNY": "¥",
        "COP": "$",
        "CRC": "₡",
        "CUP": "₱",
        "CZK": "Kč",
        "DKK": "kr",
        "DOP": "RD$",
        "EEK": "kr",
        "EGP": "£",
        "FJD": "$",
        "FKP": "£",
        "GGP": "£",
        "GHC": "¢",
        "GIP": "£",
        "GTQ": "Q",
        "GYD": "$",
        "HKD": "$",
        "HNL": "L",
        "HRK": "kn",
        "HUF": "Ft",
        "INR": "Rp",
        "ILS": "₪",
        "IMP": "£",
        "IRR": "﷼",
        "ISK": "kr",
        "JEP": "£",
        "JMD": "J$",
        "KES": "KSh",
        "KGS": "лв",
        "KHR": "៛",
        "KPW": "₩",
        "KRW": "₩",
        "KYD": "$",
        "KZT": "лв",
        "LAK": "₭",
        "LBP": "£",
        "LKR": "₨",
        "LRD": "$",
        "LTL": "Lt",
        "LVL": "Ls",
        "MKD": "ден",
        "MNT": "₮",
        "MUR": "₨",
        "MXN": "$",
        "MYR": "RM",
        "MZN": "MT",
        "NAD": "$",
        "NGN": "₦",
        "NIO": "C$",
        "NOK": "kr",
        "NPR": "₨",
        "NZD": "$",
        "OMR": "﷼",
        "PAB": "B/.",
        "PEN": "S/.",
        "PHP": "Php",
        "PKR": "₨",
        "PLN": "zł",
        "PYG": "Gs",
        "QAR": "﷼",
        "RON": "lei",
        "RSD": "Дин.",
        "RUB": "руб",
        "SAR": "﷼",
        "SBD": "$",
        "SCR": "₨",
        "SEK": "kr",
        "SGD": "$",
        "SHP": "£",
        "SOS": "S",
        "SRD": "$",
        "SVC": "$",
        "SYP": "£",
        "THB": "฿",
        "TRL": "₤",
        "TRY": "TL",
        "TTD": "TT$",
        "TVD": "$",
        "TWD": "NT$",
        "UAH": "₴",
        "UYU": "$U",
        "UZS": "лв",
        "VEF": "Bs",
        "VND": "₫",
        "XCD": "$",
        "YER": "﷼",
        "ZAR": "R",
        "ZWD": "Z$"
      },
      deleteable: true,
      deprecatedInNbe: true,
      deprecatedInWave2: true,
      filterConditions: blist.filter.groups.numeric,
      soqlFilterValue: function soqlFilterValue(v) {
        return 'to_usd(' + v + ')';
      },
      inlineType: true,
      matchValue: function matchValue(v) {
        v = parseFloat(v);
        return _.isNaN(v) ? null : v;
      },
      priority: 4,
      rollUpAggregates: aggs,
      sortable: true
    },
    percent: {
      title: 'Percent',
      interfaceType: blist.datatypes.interfaceTypes.percent,
      aggregates: aggs,
      alignment: numericAlignment,
      cls: 'percent',
      convertableTypes: _.without(numericConvertTypes, 'percent').concat('text'),
      createable: true,
      deleteable: true,
      deprecatedInNbe: true,
      deprecatedInWave2: true,
      filterConditions: blist.filter.groups.numeric,
      matchValue: function matchValue(v) {
        v = parseFloat(v);
        return _.isNaN(v) ? null : v;
      },
      priority: 5,
      rollUpAggregates: aggs,
      sortable: true,
      viewTypes: [{
        value: 'percent_bar_and_text',
        text: 'Bar &amp; Text'
      }, {
        value: 'percent_bar',
        text: 'Bar Only'
      }, {
        value: 'percent_text',
        text: 'Text Only'
      }]
    },
    // Date/time types
    date: {
      title: 'Date & Time (with timezone)',
      interfaceType: blist.datatypes.interfaceTypes.date,
      aggregates: nonNumericAggs,
      alignment: alignment,
      cls: 'date',
      convertableTypes: ['text', 'calendar_date'],
      createable: true,
      deleteable: true,
      deprecatedInNbe: true,
      filterConditions: blist.filter.groups.date,
      filterValue: function filterValue(v) {
        var d = v;

        if (_.isNumber(v)) {
          d = new Date(v * 1000);
        } else {
          d = Date.parse(v);
        }

        return $.isBlank(d) ? '' : d.format('m/d/Y h:i:s A');
      },
      formats: zDateTimeFormats,
      fromSoQLValue: function fromSoQLValue(v) {
        var d = v;

        if (_.isString(v)) {
          // Don't use Date.parse because the Date.js library improperly ignores the Z (for GMT)
          d = new Date(d);

          if (!$.isBlank(d)) {
            d = d.getTime() / 1000;
          }
        }

        return d;
      },
      inlineType: true,
      matchValue: function matchValue(v) {
        var d = v;

        if (_.isString(v)) {
          d = Date.parse(v);

          if (!$.isBlank(d)) {
            d = d.getTime() / 1000;
          }
        }

        return d;
      },
      priority: 7,
      rollUpAggregates: nonNumericAggs,
      groupFunctions: dateGroupFunctions('datez'),
      soqlFilterValue: function soqlFilterValue(v) {
        var d = v;

        if (_.isString(v)) {
          d = Date.parse(v);
        } else if (_.isNumber(v)) {
          d = new Date(v * 1000);
        }

        if (_.isDate(d)) {
          d = "'" + d.toISOString().replace(/\.\d{3}/, '') + "'";
        }

        return d;
      },
      sortable: true,
      viewTypes: dateViews
    },
    calendar_date: {
      title: 'Date & Time',
      group: groups.standard,
      interfaceType: blist.datatypes.interfaceTypes.date,
      aggregates: nonNumericAggs,
      alignment: alignment,
      cls: 'date',
      convertableTypes: ['text', 'date'],
      createable: true,
      deleteable: true,
      filterConditions: blist.filter.groups.date,
      filterValue: function filterValue(v) {
        return v;
      },
      formats: dateTimeFormats,
      inlineType: true,
      priority: 6,
      rollUpAggregates: nonNumericAggs,
      groupFunctions: dateGroupFunctions('date'),
      sortable: true,
      // Giving an exact format to parse is quite a bit faster
      // than a general parse (at least in FF; not as much for IE)
      stringParse: 'yyyy-MM-ddTHH:mm:ss',
      stringFormat: 'yyyy-MM-ddTHH:mm:ss',
      viewTypes: dateViews
    },
    // URI types
    email: {
      title: 'Email',
      interfaceType: blist.datatypes.interfaceTypes.email,
      aggregates: nonNumericAggs,
      alignment: alignment,
      convertableTypes: ['text'],
      createable: false,
      deleteable: true,
      deprecatedInNbe: true,
      deprecatedInWave2: true,
      filterConditions: $.extend(true, {
        details: {
          'STARTS_WITH': {
            interfaceType: blist.datatypes.interfaceTypes.text
          },
          'CONTAINS': {
            interfaceType: blist.datatypes.interfaceTypes.text
          },
          'NOT_CONTAINS': {
            interfaceType: blist.datatypes.interfaceTypes.text
          }
        }
      }, blist.filter.groups.textual),
      inlineType: true,
      priority: 10,
      rollUpAggregates: nonNumericAggs,
      sortable: true
    },
    phone: {
      title: 'Phone',
      interfaceType: blist.datatypes.interfaceTypes.phone,
      aggregates: nonNumericAggs,
      alignment: alignment,
      cls: 'phone',
      convertableTypes: ['text'],
      createable: false,
      defaultFilterSubColumn: 'phone_type',
      deleteable: true,
      deprecatedInNbe: true,
      deprecatedInWave1: true,
      priority: 14,
      sortable: true,
      subColumns: {
        phone_number: {
          title: 'Number',
          interfaceType: blist.datatypes.interfaceTypes.text,
          filterConditions: blist.filter.groups.textual
        },
        phone_type: {
          title: 'Type',
          interfaceType: blist.datatypes.interfaceTypes.lookupList,
          dropDownList: {
            values: [{
              id: 'Cell',
              description: 'Cell',
              icon: '/stylesheets/images/content/table/phones/cell.png'
            }, {
              id: 'Home',
              description: 'Home',
              icon: '/stylesheets/images/content/table/phones/home.png'
            }, {
              id: 'Work',
              description: 'Work',
              icon: '/stylesheets/images/content/table/phones/work.png'
            }, {
              id: 'Fax',
              description: 'Fax',
              icon: '/stylesheets/images/content/table/phones/fax.png'
            }, {
              id: 'Other',
              description: 'Other',
              icon: '/stylesheets/images/content/table/phones/other.png'
            }]
          },
          filterConditions: blist.filter.groups.comparable
        }
      }
    },
    url: {
      title: 'Website URL',
      interfaceType: blist.datatypes.interfaceTypes.url,
      aggregates: nonNumericAggs,
      alignment: alignment,
      convertableTypes: ['text'],
      createable: true,
      defaultFilterSubColumn: 'description',
      deleteable: true,
      deprecatedInNbe: true,
      deprecatedInWave3: true,
      inlineType: true,
      priority: 9,
      rollUpAggregates: nonNumericAggs,
      sortable: true,
      subColumns: {
        url: {
          title: 'URL',
          interfaceType: blist.datatypes.interfaceTypes.url,
          cls: 'url_sub',
          filterConditions: $.extend(true, {
            details: {
              'STARTS_WITH': {
                interfaceType: blist.datatypes.interfaceTypes.text
              },
              'CONTAINS': {
                interfaceType: blist.datatypes.interfaceTypes.text
              },
              'NOT_CONTAINS': {
                interfaceType: blist.datatypes.interfaceTypes.text
              }
            }
          }, blist.filter.groups.textual)
        },
        description: {
          title: 'Description',
          interfaceType: blist.datatypes.interfaceTypes.text,
          filterConditions: blist.filter.groups.textual
        }
      }
    },
    // Graphical types
    checkbox: {
      title: 'Checkbox',
      group: groups.standard,
      interfaceType: blist.datatypes.interfaceTypes.checkbox,
      aggregates: nonNumericAggs,
      alignment: [alignCenter, alignLeft, alignRight],
      convertableTypes: ['text'],
      createable: true,
      deleteable: true,
      filterConditions: blist.filter.groups.check,
      filterValue: valueFilterCheckbox,
      isInlineEdit: true,
      priority: 11,
      rollUpAggregates: nonNumericAggs,
      sortable: true
    },
    flag: {
      title: 'Flag',
      interfaceType: blist.datatypes.interfaceTypes.lookupList,
      aggregates: nonNumericAggs,
      alignment: alignment,
      convertableTypes: ['text'],
      createable: false,
      deleteable: true,
      deprecatedInNbe: true,
      deprecatedInWave1: true,
      dropDownList: {
        values: [{
          id: 'red',
          description: 'Red',
          icon: '/stylesheets/images/content/table/flags/red.png'
        }, {
          id: 'blue',
          description: 'Blue',
          icon: '/stylesheets/images/content/table/flags/blue.png'
        }, {
          id: 'green',
          description: 'Green',
          icon: '/stylesheets/images/content/table/flags/green.png'
        }, {
          id: 'yellow',
          description: 'Yellow',
          icon: '/stylesheets/images/content/table/flags/yellow.png'
        }, {
          id: 'orange',
          description: 'Orange',
          icon: '/stylesheets/images/content/table/flags/orange.png'
        }, {
          id: 'purple',
          description: 'Purple',
          icon: '/stylesheets/images/content/table/flags/purple.png'
        }]
      },
      filterConditions: blist.filter.groups.comparable,
      format: {
        view: 'icon'
      },
      priority: 12,
      rollUpAggregates: nonNumericAggs,
      sortable: true
    },
    stars: {
      title: 'Star',
      interfaceType: blist.datatypes.interfaceTypes.stars,
      aggregates: _.reject(aggs, function (a) {
        return a.value == 'sum';
      }),
      alignment: alignment,
      cls: 'stars',
      convertableTypes: _.without(numericConvertTypes, 'stars').concat('text'),
      createable: false,
      deleteable: true,
      deprecatedInNbe: true,
      deprecatedInWave1: true,
      filterConditions: blist.filter.groups.numeric,
      isInlineEdit: true,
      priority: 13,
      rollUpAggregates: _.reject(aggs, function (a) {
        return a.value == 'sum';
      }),
      soqlFieldWrapper: function soqlFieldWrapper(f, op) {
        return op.endsWith('BLANK') ? f : 'to_number(' + f + ')';
      },
      sortable: true
    },
    // Geographic types
    location: {
      title: 'Location',
      interfaceType: blist.datatypes.interfaceTypes.location,
      alignment: alignment,
      createable: true,
      defaultFilterSubColumn: 'human_address',
      deleteable: true,
      deprecatedInNbe: true,
      priority: 8,
      disableNBEFilter: false,
      matchValue: function matchValue(v) {
        // human_address in a location column is a JSON string; but we really want to compare
        // the objects, without any of the blank keys. So munge it
        if (_.isString((v || {}).human_address)) {
          v = $.extend({}, v, {
            human_address: $.deepCompact(JSON.parse(v.human_address))
          });

          _.each(_.keys(v.human_address), function (k) {
            v.human_address[k] = v.human_address[k].toLowerCase();
          });
        }

        return v;
      },
      subColumns: {
        human_address: {
          title: 'Address',
          interfaceType: blist.datatypes.interfaceTypes.location,
          matchValue: function matchValue(v) {
            // human_address in a location column is a JSON string;
            // but we really want to compare the objects, without
            // any of the blank keys. So munge it
            if (_.isString(v)) {
              v = $.deepCompact(JSON.parse(v));

              _.each(_.keys(v), function (k) {
                v[k] = (v[k] || '').toLowerCase() || null;
              });
            }

            return v;
          },
          filterConditions: blist.filter.groups.textObject
        },
        latitude: {
          title: 'Latitude',
          interfaceType: blist.datatypes.interfaceTypes.number,
          filterConditions: blist.filter.groups.numeric,
          matchValue: function matchValue(v) {
            v = parseFloat(v);
            return _.isNaN(v) ? null : v;
          }
        },
        longitude: {
          title: 'Longitude',
          interfaceType: blist.datatypes.interfaceTypes.number,
          filterConditions: blist.filter.groups.numeric,
          matchValue: function matchValue(v) {
            v = parseFloat(v);
            return _.isNaN(v) ? null : v;
          }
        }
      },
      viewTypes: [{
        value: 'address_coords',
        text: 'Address &amp; Coordinates'
      }, {
        value: 'coords',
        text: 'Coordinates Only'
      }, {
        value: 'address',
        text: 'Address Only'
      }]
    },
    geospatial: {
      title: 'Geospatial',
      interfaceType: blist.datatypes.interfaceTypes.geospatial,
      alignment: alignment,
      createable: false,
      deleteable: false,
      priority: 20
    },
    // Blobby types
    blob: {
      title: 'Blob',
      cls: 'photo',
      // Because sometimes it is one! This is basically terrible.
      group: groups.standard,
      interfaceType: blist.datatypes.interfaceTypes.blob,
      aggregates: nonNumericAggs,
      createable: true,
      deleteable: true,
      nbeOnly: true,
      filterConditions: blist.filter.groups.blob,
      inlineType: true
    },
    document: {
      title: 'Document',
      interfaceType: blist.datatypes.interfaceTypes.document,
      aggregates: nonNumericAggs,
      createable: true,
      deleteable: true,
      deprecatedInNbe: true,
      deprecatedInWave3: true,
      filterConditions: blist.filter.groups.blob,
      inlineType: true,
      priority: 17
    },
    photo: {
      title: 'Photo (Image)',
      interfaceType: blist.datatypes.interfaceTypes.photo,
      aggregates: nonNumericAggs,
      cls: 'photo',
      createable: true,
      deleteable: true,
      deprecatedInNbe: true,
      deprecatedInWave3: true,
      filterConditions: blist.filter.groups.blob,
      priority: 16
    },
    // Linking/customization types
    drop_down_list: {
      title: 'Multiple Choice',
      interfaceType: blist.datatypes.interfaceTypes.lookupList,
      aggregates: nonNumericAggs,
      alignment: alignment,
      createable: false,
      deleteable: true,
      deprecatedInNbe: true,
      deprecatedInWave3: true,
      filterConditions: blist.filter.groups.comparable,
      matchValue: function matchValue(v, col) {
        if (col.view._useSODA2) {
          return v;
        } // This is a numeric comparison, so use indices


        _.some(col.dropDownList.values, function (ddv, i) {
          if (ddv.id == v) {
            v = i;
            return true;
          }

          return false;
        });

        return v;
      },
      fromSoQLValue: function fromSoQLValue(v, col) {
        // Might be description, might be id
        _.some(col.dropDownList.values, function (ddv) {
          if (ddv.id == v || ddv.description == v) {
            v = ddv.id;
            return true;
          }

          return false;
        });

        return v;
      },
      priority: 15,
      rollUpAggregates: nonNumericAggs,
      sortable: true
    },
    dataset_link: {
      title: 'Dataset Link',
      interfaceType: blist.datatypes.interfaceTypes.lookupList,
      aggregates: nonNumericAggs,
      alignment: alignment,
      convertableTypes: ['text'],
      createable: false,
      deleteable: true,
      deprecatedInNbe: true,
      filterConditions: $.extend(true, {
        details: {
          'STARTS_WITH': {
            interfaceType: blist.datatypes.interfaceTypes.text
          },
          'CONTAINS': {
            interfaceType: blist.datatypes.interfaceTypes.text
          },
          'NOT_CONTAINS': {
            interfaceType: blist.datatypes.interfaceTypes.text
          }
        }
      }, blist.filter.groups.textual),
      matchValue: function matchValue(v, col) {
        if (!$.isBlank(col.dropDownList)) {
          _.some(col.dropDownList.values, function (ddv) {
            if (ddv.id == v) {
              v = ddv.description;
              return true;
            }

            return false;
          });
        }

        return v;
      },
      priority: 19,
      rollUpAggregates: nonNumericAggs,
      sortable: true
    },
    // Generic types
    object: {
      title: 'Object',
      interfaceType: blist.datatypes.interfaceTypes.object,
      alignment: alignment,
      createable: false,
      deleteable: false,
      priority: 20
    },
    list: {
      title: 'List',
      interfaceType: blist.datatypes.interfaceTypes.object,
      createable: false,
      deleteable: false,
      alignment: alignment,
      priority: 21
    },
    point: {
      title: 'Point',
      group: groups.geometry,
      interfaceType: blist.datatypes.interfaceTypes.point,
      alignment: alignment,
      createable: false,
      deleteable: false,
      nbeModifiable: true,
      filterConditions: blist.filter.groups.blob,
      priority: 22
    },
    multipoint: {
      title: 'Multi-Point',
      group: groups.geometry,
      interfaceType: blist.datatypes.interfaceTypes.multipoint,
      alignment: alignment,
      createable: true,
      deleteable: true,
      nbeOnly: true,
      priority: 23
    },
    line: {
      title: 'Line-String',
      group: groups.geometry,
      interfaceType: blist.datatypes.interfaceTypes.line,
      alignment: alignment,
      createable: true,
      deleteable: true,
      nbeOnly: true,
      priority: 22
    },
    multiline: {
      title: 'Multi-Line-String',
      group: groups.geometry,
      interfaceType: blist.datatypes.interfaceTypes.multiline,
      alignment: alignment,
      createable: false,
      deleteable: false,
      nbeModifiable: true,
      priority: 23
    },
    polygon: {
      title: 'Polygon',
      group: groups.geometry,
      interfaceType: blist.datatypes.interfaceTypes.polygon,
      alignment: alignment,
      createable: true,
      deleteable: true,
      nbeOnly: true,
      priority: 22
    },
    multipolygon: {
      title: 'Multi-Polygon',
      group: groups.geometry,
      interfaceType: blist.datatypes.interfaceTypes.multipolygon,
      alignment: alignment,
      createable: false,
      deleteable: false,
      nbeModifiable: true,
      priority: 23
    }
  });

  var setUpType = function setUpType(type, name) {
    type.name = type.name || name;

    type.renderer = function () {
      if ($.subKeyDefined(type, 'interfaceType.renderer')) {
        return type.interfaceType.renderer.apply(type, arguments);
      }

      return '';
    };

    type.matches = function (op, col) {
      op = op.toUpperCase();

      if (!$.subKeyDefined(type, 'filterConditions.details.' + op)) {
        return false;
      }

      var vals = _.map(_.flatten(_.toArray(arguments).slice(2)), function (v) {
        // Transform
        if (_.isFunction(type.matchValue)) {
          v = type.matchValue(v, col);
        }

        return v;
      });

      return type.filterConditions.details[op].matches.apply(type, vals);
    };
  };

  _.each(blist.datatypes, function (type, name) {
    setUpType(type, name);

    _.each(type.subColumns || {}, function (sc, sn) {
      setUpType(sc, sn);
    });
  });
})(jQuery);
/* eslint-enable quotes */

/***/ }),

/***/ 3017:
/***/ (function(module, exports) {

(function () {
  window.a11y = {
    tableSummary: function tableSummary(options) {
      if (_.isEmpty(options.columns) || _.isEmpty(options.rows)) {
        return $.t('table.no_summary_available');
      }

      var rowHeadings = '';

      if (_.size(options, 'rows') < 5) {
        rowHeadings = _.get(options, 'rows', []).join(', ');
      }

      var templateOptions = {
        'data_description': _.get(options, 'tableDescription', ''),
        'column_heading_count': options.columns.length,
        'column_headings': _.get(options, 'columns', []).join(', '),
        'row_heading_count': options.rows.length,
        'row_headings': rowHeadings
      };
      return $.t('table.summary', templateOptions);
    }
  };
})();

/***/ }),

/***/ 3018:
/***/ (function(module, exports) {

(function ($) {
  $(function () {
    // OLD JQM CODE -- TO BE PHASED OUT DUE TO JQUERY 1.9
    $.fn.socrataJqm = function () {
      this.jqm({
        trigger: false,
        modal: true,
        onShow: function onShow(jqm) {
          jqm.w.find('iframe').each(function () {
            var $this = $(this),
                urlToLoad = $this.data('urltoload');

            if (!$.isBlank(urlToLoad)) {
              $this.attr('src', urlToLoad);
              $this.removeData('urltoload').removeAttr('data-urltoload');
            }
          });
          $('.menu').trigger('menu-close');

          if (!_.isUndefined(blist.events)) {
            $(document).trigger(blist.events.MODAL_SHOWN);
          }

          jqm.w.fadeIn('slow');
          jqm.o.fadeIn('slow');
        },
        onHide: function onHide(jqm) {
          jqm.w.fadeOut('slow');
          jqm.o.fadeOut('slow', function () {
            if (!_.isUndefined(blist.events)) {
              $(document).trigger(blist.events.MODAL_HIDDEN);
            }
          });
        }
      });
    }; // Set up modals


    $('.modalDialog, #modals > *').socrataJqm();
    $.live('a.jqmClose', 'click', function (event) {
      event.preventDefault();
      $(this).closest('.modalDialog').jqmHide();
    }); // /JQM

    var $overlay = $('.socrataModal');
    var $wrapper = $('.socrataModal .socrataModalWrapper');
    var $body = $('body');
    var modalAnimLength = 500; // could use webkitTransitionEnd but that's, well, webkit

    var scrollTops = []; // util

    var afterComplete = function afterComplete(f) {
      window.setTimeout(f, modalAnimLength);
    }; // state and setup


    $overlay.hide(); // can't do in css since we use classes to transition

    var overlayStatus = 'hidden'; // overlay funcs

    var showOverlay = function showOverlay() {
      if (overlayStatus !== 'hiding' && overlayStatus !== 'hidden') {
        return;
      }

      $overlay.show();
      $body.css('overflow-y', 'hidden');
      overlayStatus = 'showing';

      _.defer(function () {
        $wrapper.lockScroll(true);
        $overlay.addClass('shown');
        afterComplete(function () {
          if (overlayStatus === 'hiding') {
            return;
          } // if we let it always be auto we get render
          // artifacts on the transition


          $wrapper.css('overflow-y', 'scroll');
          overlayStatus = 'shown';
        });
      });
    };

    var hideOverlay = function hideOverlay() {
      if (overlayStatus !== 'showing' && overlayStatus !== 'shown') {
        return;
      }

      $overlay.removeClass('shown');
      overlayStatus = 'hiding';
      $wrapper.css('overflow-y', 'visible');
      $body.css('overflow-y', 'visible');
      $wrapper.lockScroll(false);
      afterComplete(function () {
        if (overlayStatus === 'showing') {
          return;
        }

        $overlay.hide();
        overlayStatus = 'hidden';
      });
    };

    var pushModal = function pushModal($contents) {
      // if we have no modal, show it
      if (overlayStatus !== 'showing' && overlayStatus !== 'shown') {
        showOverlay();
      } // now push the previous modal if it exists


      var $previous = $wrapper.children(':last-child');

      if ($previous.length > 0) {
        var top = $wrapper.scrollTop();
        scrollTops.push(top);
        $previous.css('top', (parseFloat($previous.css('top')) || 0) - top);
        $previous.addClass('pushed');
        afterComplete(function () {
          $previous.hide();
        });
      } // last deal with the new modal


      $contents.addClass('modalContents');
      $wrapper.append($contents);

      _.defer(function () {
        $contents.addClass('shown');
        $contents.find(':input:first').focus().filter(':text, textarea').caretToEnd(); // focus on an input if we can
      });
    };

    var popModal = function popModal(hideAll) {
      // first hide the last modal
      var $current = $wrapper.children(':last-child');
      $current.removeClass('shown');
      afterComplete(function () {
        $current.remove();
      }); // now either hide the overlay as well, or reshow the previous modal

      var $previous = $current.prev();

      if (hideAll === true) {
        $current.prevAll().remove();
        scrollTops = [];
        hideOverlay();
      } else if ($previous.length > 0) {
        $previous.show();

        _.defer(function () {
          $previous.removeClass('pushed');
          afterComplete(function () {
            var top = scrollTops.pop();
            $wrapper.scrollTop(top);
            $previous.css('top', parseFloat($previous.css('top')) + top);
          });
        });
      } else {
        hideOverlay();
      }
    };

    var modalLocked = function modalLocked() {
      return $wrapper.children('.locked').length > 0;
    };

    $.fn.showModal = function () {
      var $this = $(this);
      pushModal($this);
      return $this;
    };

    $.showModal = function (name) {
      return $('#newModals > #' + name).clone().showModal();
    };

    $.popModal = popModal;
    $(document).on('keyup', function (event) {
      if ($(event.target).is(':not(:input)') && event.keyCode === 27 && !modalLocked()) {
        popModal();
      }
    });
    $wrapper.on('click', function (event) {
      if (event.target === this && !modalLocked()) {
        popModal(true);
      }
    });
    $wrapper.on('click', '.jqmClose', function (event) {
      event.preventDefault();
      popModal();
    }); // Radio/Checkboxes don't get focused on click, so manually hack it

    $wrapper.on('click', ':radio, :checkbox', function () {
      $(this).focus();
    });
    $wrapper.on('keyup', function (event) {
      if (event.keyCode === 13) {
        $wrapper.trigger('submit', event);
      }
    });
  });
})(jQuery);

/***/ }),

/***/ 3019:
/***/ (function(module, exports) {

(function ($) {
  $.fn.isSocrataTip = function () {
    return !$.isBlank($(this[0]).data('socrataTip'));
  };

  $.fn.socrataTip = function (options) {
    var $elems = $(this); // If only one item, use object-return version

    if ($elems.length < 2) {
      // Check if object was already created
      var sTip = $elems.data('socrataTip');

      if (!sTip) {
        sTip = new STipObj(options, $elems[0]);
      }

      return sTip;
    } else {
      // Else create it on every item that is not initialized,
      // and return the elems
      $elems.each(function () {
        var $t = $(this);
        var curItem = $t.data('socrataTip');

        if (!curItem) {
          new STipObj(options, $t[0]);
        }
      });
      return $elems;
    }
  };

  var STipObj = function STipObj(options, dom) {
    if (typeof options == 'string') {
      options = {
        message: options
      };
    }

    this.settings = $.extend({}, STipObj.defaults, options);
    this.currentDom = dom;
    this.init();
  };

  $.extend(STipObj, {
    defaults: {
      closeOnClick: true,
      content: null,
      killTitle: false,
      fill: '#fefbef',
      isSolo: false,
      message: null,
      onShowCallback: null,
      overlap: 0,
      parent: 'body',
      positions: null,
      shownCallback: null,
      showSpike: true,
      shrinkToFit: true,
      stroke: '#999999',
      trigger: 'hover',
      width: '200px'
    },
    prototype: {
      init: function init() {
        var _sTipObj = this;

        var $domObj = _sTipObj.$dom();

        if (!$domObj.exists()) {
          return;
        }

        $domObj.data('socrataTip', _sTipObj);

        if ($.isBlank(_sTipObj.settings.message) && $.isBlank(_sTipObj.settings.content)) {
          return;
        }

        var pos = _sTipObj.settings.positions;

        if (_.isNull(pos)) {
          pos = ['bottom', 'top'];
        } else if (pos == 'auto') {
          pos = ['most'];
        } // gross hack for changing flyout behavior on stories-enabled domains
        // because forcing to top/bottom may cut off part of the flyout
        // in smaller iframes.
        //
        // 6/6/2018 update: This hack was too 'gross', because it prevented
        // us from using the positioning functionality when it was actually
        // appropriate. This update appends the second condition hoping that
        // the dataset will be unpublished when we want to show a notice e.g.
        // below the publish button but unpublished datasets are unlikely to
        // be embedded in iframes. ¯\_(ツ)_/¯


        if (blist.feature_flags.stories_enabled && _.get(window, 'blist.dataset.publicationStage') !== 'unpublished') {
          pos = ['most'];
        }

        var content = _sTipObj.settings.content;

        if ($.isBlank(content)) {
          content = $.tag({
            tagName: 'p',
            contents: _sTipObj.settings.message
          }, true);
        }

        var internalShownCallback = function internalShownCallback(box) {
          _sTipObj._tipBox = box;
          $(box).data('socrataTip-$element', $domObj);

          if (_.isFunction(_sTipObj.settings.shownCallback)) {
            _sTipObj.settings.shownCallback(box);
          }
        };

        var onModalZIndices = {
          wrapperzIndex: 10000,
          boxzIndex: 10001,
          textzIndex: 10002
        };
        var options = {
          content: _.isFunction(content) ? null : content,
          contentSelector: _.isFunction(content) ? content : null,
          fill: _sTipObj.settings.fill,
          strokeStyle: _sTipObj.settings.stroke,
          cornerRadius: 3,
          spikeGirth: 15,
          spikeLength: _sTipObj.settings.showSpike ? 12 : 0,
          shadow: true,
          shadowOffsetX: 0,
          shadowOffsetY: 0,
          shadowBlur: 3,
          shadowColor: 'rgba(0, 0, 0, 0.3)',
          noShadowOpts: {
            strokeWidth: 2
          },
          clickAnywhereToClose: _sTipObj.settings.closeOnClick,
          closeWhenOthersOpen: _sTipObj.settings.isSolo,
          onShowCallback: _sTipObj.settings.onShowCallback,
          postShow: internalShownCallback,
          shrinkToFit: _sTipObj.settings.shrinkToFit,
          trigger: _sTipObj.settings.trigger,
          positions: pos,
          explicitPosition: _sTipObj.settings.explicitPosition,
          overlap: _sTipObj.settings.overlap,
          offsetParent: _sTipObj.settings.parent,
          killTitle: _sTipObj.settings.killTitle,
          width: _sTipObj.settings.width,
          showTip: function showTip(box) {
            if (!_sTipObj._disabled) {
              _sTipObj._visible = true;
              $(box).fadeIn(300);
            }
          },
          hideTip: function hideTip(box, callback) {
            _sTipObj._visible = false;

            if (_sTipObj._isDestroy) {
              $(box).hide();

              _.defer(callback);
            } else {
              $(box).fadeOut(300, callback);
            }
          }
        };

        if (_sTipObj.settings.onModal) {
          $.extend(options, onModalZIndices);
        }

        $domObj.bt(options);
        _sTipObj._opts = $domObj[0]._opts;
      },
      $dom: function $dom() {
        if (!this._$dom) {
          this._$dom = $(this.currentDom);
        }

        return this._$dom;
      },
      show: function show() {
        if (!this._visible) {
          this.$dom().btOn();
        }
      },
      hide: function hide() {
        if (this._visible) {
          this.$dom().btOff();
        }
      },
      refreshSize: function refreshSize() {
        // ......uhhhh
        var _sTipObj = this;

        var oldHideFunction = _sTipObj._opts.hideTip;

        _sTipObj._opts.hideTip = function (box, callback) {
          _sTipObj._visible = false;
          $(box).hide();

          _.defer(function () {
            callback();

            _.defer(function () {
              _sTipObj.show();

              _sTipObj._opts.hideTip = oldHideFunction;
            });
          });
        };

        _sTipObj.hide();
      },

      /* These are used to temporarily hide/show the tooltip without fully
       * destroying it.  Visibility is used so we can continue tracking
       * the position */
      quickHide: function quickHide() {
        $getTipBox(this).css('visibility', 'hidden');
      },
      quickShow: function quickShow() {
        $getTipBox(this).css('visibility', 'visible');
      },
      disable: function disable() {
        this._disabled = true;
      },
      enable: function enable() {
        this._disabled = false;
      },
      destroy: function destroy() {
        this._isDestroy = true;
        this.hide();
        this.disable();
        this.$dom().btDestroy();
        this.$dom().removeData('socrataTip');
      },

      /* This is used to manually move a tooltip (for example, when
       * attached to something that scrolls) */
      adjustPosition: function adjustPosition(adjAmt) {
        var _sTipObj = this;

        if (_sTipObj._disabled || !_sTipObj._visible) {
          return;
        }

        var $tip = $getTipBox(_sTipObj);

        if (!$.isBlank(adjAmt.top)) {
          $tip.css('top', $tip.position().top + adjAmt.top);
        }

        if (!$.isBlank(adjAmt.left)) {
          $tip.css('left', $tip.position().left + adjAmt.left);
        }
      },

      /* This is used to figure out which side of the item the tip is
       * attached to */
      getTipPosition: function getTipPosition() {
        var _sTipObj = this;

        if (!_sTipObj._visible) {
          return null;
        }

        var $tip = $getTipBox(_sTipObj).find('.bt-content'); // HACK: This is a terrible hack; but the direction of the tip
        // isn't really stored anywhere...

        var pos = null;

        if (parseInt($tip.css('margin-bottom')) > 0) {
          pos = 'top';
        } else if (parseInt($tip.css('margin-top')) > 0) {
          pos = 'bottom';
        } else if (parseInt($tip.css('margin-right')) > 0) {
          pos = 'left';
        } else if (parseInt($tip.css('margin-left')) > 0) {
          pos = 'right';
        }

        return pos;
      }
    }
  });

  var $getTipBox = function $getTipBox(_sTipObj) {
    return $(_sTipObj._tipBox);
  };

  $.fn.socrataAlert = function (options) {
    if (typeof options == 'string') {
      options = {
        message: options
      };
    } // build main options before element iteration


    var opts = $.extend({}, $.fn.socrataAlert.defaults, options); // iterate and do stuff to each matched element

    return this.each(function () {
      var $socrataAlert = $(this); // build element specific options

      var config = $.meta ? $.extend({}, opts, $socrataAlert.data()) : opts;

      if (_.isNull(config.message)) {
        return;
      }

      if (config.overlay) {
        config.overlap = $socrataAlert.width() / 2;
        config.positions = ['left', 'right'];
        config.showSpike = false;
        delete config.overlay;
      }

      var hideTime = config.hideTime;
      delete config.hideTime;

      if ($socrataAlert.isSocrataTip()) {
        $socrataAlert.socrataTip().destroy();
      }

      $socrataAlert.socrataTip(config);

      if (!$.isBlank(hideTime)) {
        setTimeout(function () {
          $socrataAlert.socrataTip().hide();
        }, hideTime);
      }
    });
  }; //
  // plugin defaults
  //


  $.fn.socrataAlert.defaults = {
    hideTime: 5000,
    message: null,
    overlay: false,
    trigger: 'now'
  };

  $.fn.socrataTitleTip = function () {
    return this.each(function () {
      var $this = $(this); // This is returning with &nbsp;, so replace them all with
      // normal spaces

      $this.socrataTip({
        message: $this.attr('title').clean(),
        shrinkToFit: false,
        killTitle: true
      });
    });
  };
})(jQuery);

/***/ }),

/***/ 3020:
/***/ (function(module, exports) {

blist.namespace.fetch('blist.widgets.textPrompt');

(function ($) {
  $.fn.blistTextPrompt = function () {
    this.example(function () {
      return $(this).attr('title');
    });
    return this;
  };

  $.fn.example.defaults.className = 'prompt';
})(jQuery);

$(function () {
  $('.textPrompt').blistTextPrompt();

  if (!$.isBlank($.validator)) {
    // Monkey-patch required to support textPrompt
    var oldReq = $.validator.methods.required;

    $.validator.methods.required = function (value, element, param) {
      if ((element.nodeName.toLowerCase() == 'textarea' || element.nodeName.toLowerCase() == 'input' && element.type.toLowerCase() == 'text') && $(element).hasClass('prompt')) {
        return false;
      }

      return oldReq.apply(this, [value, element, param]);
    };
  }
});

/***/ }),

/***/ 3021:
/***/ (function(module, exports) {

(function ($) {
  $.fn.extend({
    /**
     * Set the value manager associated with an element.  The value() and values() function interact with the
     * value manager to get or set the element's value.
     */
    valueManager: function valueManager(_valueManager) {
      if (_valueManager === undefined) {
        return this.data('value-manager');
      }

      this.data('value-manager', _valueManager);
      return this;
    },

    /**
     * Access the name of the value provided by this element.  If a value manager is present, it is first given
     * the option of providing the name.  If this fails, the element's name or ID are used.
     */
    name: function name() {
      var name;
      var valueManager = this.data('value-manager');

      if (valueManager && valueManager.name) {
        name = typeof valueManager.name == 'function' ? valueManager.name() : valueManager.name;
      }

      if (name == null) {
        name = this.attr('name') || this.attr('id');
      }

      return name || undefined;
    },

    /**
     * Get or set the element's value.  If a value manager is present, the call is fielded by the manager.
     * Otherwise returns a value from the underlying HTML element if available.
     */
    value: function value(_value) {
      // Handle value get
      if (_value === undefined) {
        var returnValue = _value;
        this.each(function () {
          var $this = $(this);
          var valueManager = $this.data('value-manager');

          if (_value === undefined) {
            if (valueManager && valueManager.get) {
              returnValue = valueManager.get(_value);
            } else if (this.tagName == 'TEXTAREA') {
              returnValue = $this.val();

              if (returnValue === '') {
                // Convert empty textarea elements to a "null" value
                returnValue = null;
              }
            } else if (this.tagName == 'INPUT' || this.tagName == 'SELECT') {
              if ($this.attr('type') == 'checkbox' || $this.attr('type') == 'radio') {
                returnValue = $this.attr('checked') ? true : false;
              } else {
                returnValue = this.value;

                if (returnValue === '') {
                  // Convert empty form elements to a "null" value
                  returnValue = null;
                }
              }
            }

            if (returnValue !== undefined) {
              // Found a value
              return false;
            }
          }
        });
        return returnValue;
      } // Handle value set


      this.each(function () {
        var $this = $(this);
        var valueManager = $this.data('value-manager');

        if (valueManager && valueManager.set) {
          valueManager.set(_value);
        } else if (this.tagName == 'TEXTAREA') {
          $this.val(_value == null ? '' : _value);
        } else if (this.tagName == 'INPUT' || this.tagName == 'SELECT') {
          if ($this.attr('type') == 'checkbox' || $this.attr('type') == 'radio') {
            $this.attr('checked', _value ? true : false);
          } else {
            this.value = _value == null ? '' : _value;
          }
        }
      });
      return this;
    },

    /**
     * Get or set values from a tree of values.
     */
    values: function values(_values, get) {
      // Ensure values are present and default to get mode if the user didn't specify a mode
      if (_values === undefined) {
        _values = {};

        if (get == undefined) {
          get = true;
        }
      } // Apply to each child


      this.each(function () {
        // Determine if this node has a value; if not, no need to proceed
        var hasValue = false;
        var $this = $(this);

        if ($this.data('value-manager')) {
          // Element manages values explicitly
          hasValue = true;
        } else switch (this.tagName) {
          case 'INPUT':
          case 'SELECT':
          case 'TEXTAREA':
            // Uses built-in jQuery form value support
            hasValue = true;
            break;
        } // If the element provides a value, get or set the value


        if (hasValue) {
          var name = $this.name();

          if (name) {
            if (get) {
              _values[name] = $this.value();
            } else {
              $this.value(_values[name]);
            }
          }
        }
      }); // Recurse

      var $children = $(this).children();

      if ($children.length) {
        $children.values(_values, get);
      }

      return _values;
    },
    // TODO
    valuesRead: function valuesRead() {},
    // TODO
    valuesWrite: function valuesWrite() {}
  });
})(jQuery);

/***/ }),

/***/ 3022:
/***/ (function(module, exports) {

/**
* Updated July 2019 to support jquery 3.4.1
* - bind/unbind is deprecated: https://jquery.com/upgrade-guide/3.0/#deprecated-bind-and-delegate
* - Offset - first item in collection must be DOM element - https://jquery.com/upgrade-guide/3.0/#breaking-change-invalid-input-to-the-offset-method
*/
(function ($) {
  $.fn.menu = function (options) {
    var opts = $.extend({}, $.fn.menu.defaults, options); // Wrap in an extra array if necessary (one column)

    if (!_.isArray(opts.contents[0])) {
      opts.contents = [opts.contents];
    }

    var contents = _.map(opts.contents, function (column) {
      var dividerNext = false;
      return _.compact(_.map(column, function (item) {
        if (item.divider === true) {
          dividerNext = true;
          return null;
        }

        if (item.onlyIf === false) {
          return null;
        } else if (dividerNext) {
          item.className = (item.className || '') + ' divider';
          dividerNext = false;
        }

        return item;
      }));
    });

    var isSettingsMenu = opts.menuButtonElement && opts.menuButtonElement.hasClass('settings-icon');
    var itemDirective;

    if (isSettingsMenu) {
      itemDirective = {
        // inner array for rows
        '.@class+': 'row.className',
        'a .contents': 'row.text',
        'a@title': 'row.title'
      };
    } else {
      itemDirective = {
        // inner array for rows
        '.@class+': 'row.className',
        'a .contents': 'row.text',
        'a@href': 'row.href',
        'a@rel': 'row.rel',
        'a@title': 'row.title',
        'a .subtext': 'row.subtext'
      };
    }

    _.each(opts.additionalDataKeys, function (key) {
      itemDirective['a@data-' + key] = 'row.' + key;
    });

    _.each(opts.additionalJsonKeys, function (key) {
      itemDirective['a@data-' + key] = function (k) {
        return $.htmlEscape(JSON.stringify(k.item[key]));
      };
    });

    var renderDirective;

    if (isSettingsMenu) {
      renderDirective = {
        '.menuDropdown>ul>li': {
          'column<-columns': {
            // outer array for columns
            'ul>li': {
              'row<-column': itemDirective
            }
          }
        }
      };
    } else {
      renderDirective = {
        '+a.menuButton': 'menuButtonContents',
        'a.menuButton@title': 'menuButtonTitle',
        'a.menuButton@class': 'menuButtonClass',
        '.menuDropdown>ul>li': {
          'column<-columns': {
            // outer array for columns
            'ul>li': {
              'row<-column': itemDirective
            }
          }
        }
      };
    }

    return this.each(function () {
      var $menuContainer = $(this);
      var $menuButton;

      if (isSettingsMenu) {
        $menuContainer.empty().append($.renderTemplate('settings.menu', {
          columns: contents
        }, renderDirective));
        $menuButton = opts.menuButtonElement;
        $menuButton.attr('href', '#');
      } else {
        $menuContainer.empty().append($.renderTemplate('menu', {
          menuButtonClass: opts.menuButtonClass,
          menuButtonContents: opts.menuButtonContents,
          menuButtonTitle: opts.menuButtonTitle,
          columns: contents
        }, renderDirective));
        $menuButton = $menuContainer.children('a');
      }

      var $menuDropdown = $menuContainer.children('div');

      if ($menuButton.hasClass('settings-icon')) {
        $menuDropdown.addClass('settings');
      }

      $menuButton.on('click', function (event) {
        event.preventDefault();

        if ($menuDropdown.is(':visible')) {
          closeMenu(opts, $menuContainer, $menuButton, $menuDropdown);
        } else {
          openMenu(opts, $menuContainer, $menuButton, $menuDropdown);
        }
      });
      $menuContainer.on('menu-close', function () {
        if ($menuDropdown.is(':visible')) {
          closeMenu(opts, $menuContainer, $menuButton, $menuDropdown);
        }
      });
    });
  };

  var openMenu = function openMenu(opts, $menuContainer, $menuButton, $menuDropdown) {
    if (_.isFunction(opts.onOpen)) {
      opts.onOpen($menuContainer);
    } // close any menu that might already be open


    $(document).trigger('click.menu'); // cache the original height before we bump things out to measure

    var $par = $.isBlank(opts.parentContainer) ? $menuContainer.scrollParent() : $(opts.parentContainer);

    if (document.body.contains($par[0])) {
      var parOffset = $par.offset();
    } else {
      parOffset = {
        top: 0,
        left: 0
      };
    }

    var origContainerBottom = $par.height() + parOffset.top;
    var origContainerRight = $par.width() + parOffset.left;
    $menuContainer.addClass('open'); // reset then realign the menu if necessary; set styles as appropriate
    // show it so we can measure it

    $menuDropdown.css('width', '').css('right', '').css('bottom', '').css('top', '').show();

    if ($menuDropdown.offset().left + $menuDropdown.outerWidth(true) > origContainerRight) {
      // if the menu can be flipped left, do so; otherwise, crop it
      if ($menuContainer.offset().left + $menuButton.outerWidth(true) - $menuDropdown.outerWidth(true) < 0) {
        $menuDropdown.css('width', $(window).width() - $menuDropdown.offset().left - 10);
      } else if (!opts.noFlip) {
        $menuDropdown.css('right', 0);
      }
    }

    if ($menuDropdown.offset().top + $menuDropdown.outerHeight(true) > origContainerBottom) {
      // if the menu can be flipped up, do so; otherwise, leave it alone
      if ($menuContainer.offset().top - $menuDropdown.outerHeight(true) > 0) {
        $menuDropdown.css('bottom', $menuContainer.innerHeight());
      }
    } else {
      // if the menu should be on the bottom, make it so for the sake of IE7
      $menuDropdown.css('top', $menuButton.outerHeight());
    } // Rehide and animate


    $menuDropdown.hide().fadeIn(200); // Hook to hide menu

    $(document).off('click.menu'); // just to be sure

    $(document).on('click.menu', function (event) {
      // close if user clicked out || if user clicked in link || if user
      // clicked on link
      // Short-circuit test for event.target is document, since IE
      // throws errors when checking .has(document)
      var clickedDocument = event.target == document;
      var clickedOutsideMenu = event.target !== $menuButton[0] && $menuContainer.has(event.target).length === 0;
      var clickedDropdownLink = $menuDropdown.find('a').has(event.target).length > 0;
      var clickedDropdownOption = $(event.target).is('.menuDropdown a');

      if (clickedDocument || clickedOutsideMenu || clickedDropdownLink || clickedDropdownOption) {
        closeMenu(opts, $menuContainer, $menuButton, $menuDropdown);
      }
    });
  };

  var closeMenu = function closeMenu(opts, $menuContainer, $menuButton, $menuDropdown) {
    if (_.isFunction(opts.onClose)) opts.onClose($menuContainer);
    $(document).off('click.menu');
    $menuContainer.removeClass('open');

    if ($menuContainer.is(':visible')) {
      $menuDropdown.fadeOut(200);
    } else {
      $menuDropdown.hide();
    }
  };

  $.fn.menu.defaults = {
    additionalDataKeys: [],
    additionalJsonKeys: [],
    contents: [],
    menuButtonClass: 'menuButton',
    menuButtonContents: 'Menu',
    menuButtonTitle: 'Menu',
    menuButtonElement: null,
    onOpen: function onOpen() {},
    onClose: function onClose() {},
    parentContainer: null
  };
})(jQuery);

/***/ }),

/***/ 3023:
/***/ (function(module, exports) {

jQuery.metrics = {
  queue: [],
  pageLoadBucketNames: ['awesome', 'good', 'ok', 'poor', 'terrible'],
  pageLoadBuckets: [500, 1000, 2000, 4000],
  domLoadBuckets: [500, 1000, 2000, 4000],
  stopwatches: {},
  stopwatchFunction: window.performance !== undefined && _.isFunction(performance.now) ? function () {
    return performance.now();
  } : function () {
    return new Date().getTime();
  },
  increment: function increment(entity, metric, _increment) {
    // validate params
    if (entity === undefined || metric === undefined) {
      return false;
    } // bail if we did not load socrata server


    if ($.socrataServer === undefined) {
      return false;
    }

    $.metrics.queue.push({
      entity: entity,
      metric: metric,
      increment: _increment
    });

    if ($.metrics.queue.length >= 10) {
      $.metrics.flush_metrics();
    }
  },
  measure: window.performance !== undefined && _.isFunction(performance.now) ? function (entity, metric) {
    $.metrics.increment(entity, metric, performance.now());
  } : function () {},
  stopwatch: function stopwatch(entity, metric, action) {
    if (!$.metrics.stopwatches[entity + '/' + metric]) {
      $.metrics.stopwatches[entity + '/' + metric] = {
        entity: entity,
        metric: metric,
        pulses: [],
        start: function start() {
          this.pulses.push({
            type: 'start',
            timestamp: $.metrics.stopwatchFunction()
          });
          this.flush(); // Reset debounce timer.

          this.started = true;
        },
        pulse: function pulse() {
          if (!this.started) {
            return;
          }

          this.pulses.push({
            type: 'pulse',
            timestamp: $.metrics.stopwatchFunction()
          });
          this.flush(); // Reset debounce timer.
        },
        end: function end() {
          this.done = true;
          this.pulse();
        },
        flush: _.debounce(function () {
          if (!this.done) {
            return;
          }

          var start = _.find(this.pulses, function (pulse) {
            return pulse.type == 'start';
          }),
              lastPulse = _.find(this.pulses.slice().reverse(), function (pulse) {
            return pulse.type == 'pulse';
          });

          if (start && lastPulse) {
            $.metrics.increment(entity, metric, lastPulse.timestamp - start.timestamp);
          }

          this.pulses = [];
          this.done = false;
        }, 1000)
      };
    }

    if (action == 'clear') {
      delete $.metrics.stopwatches[entity + '/' + metric];
    } else {
      $.metrics.stopwatches[entity + '/' + metric][action]();
    }
  },
  mark: function mark(entity, metric) {
    $.metrics.increment(entity, metric, 1);
  },

  /**
   * async: Whether or not to send the metrics asynchronously. If null or undefined, assumed to be true.
   */
  flush_metrics: function flush_metrics(async) {
    if ($.metrics.queue.length === 0) {
      return;
    }

    if (async === null || async === undefined) {
      async = true;
    }

    var metricsBag = $.metrics.queue;
    $.metrics.queue = [];
    $.socrataServer.makeRequest({
      url: '/analytics/add',
      type: 'POST',
      async: async,
      data: JSON.stringify({
        'metrics': metricsBag
      }),
      anonymous: true,
      isSODA: true,
      headers: {
        'Content-Type': 'application/text'
      },
      success: function success()
      /* data */
      {// noop
      },
      error: function error()
      /* request */
      {// noop
      }
    });
  },
  collectPageTimings: function collectPageTimings() {
    $.metrics.mark('domain', 'js-page-view');
    $.metrics.mark('domain', 'browser-' + $.metrics.browser_name());
    $.metrics.mark('domain-intern', 'browser-' + $.metrics.browser_name());
    $.metrics.mark('domain', 'browser-' + $.metrics.browser_name() + '-' + $.browser.majorVersion);
    $.metrics.mark('domain-intern', 'browser-' + $.metrics.browser_name() + '-' + $.browser.majorVersion);
    var pageType = $.metrics.determinePageType();

    if ($.metrics.in_iframe()) {
      $.metrics.mark('domain', "js-page-view-embed-".concat(pageType));
    } else {
      $.metrics.mark('domain', "js-page-view-".concat(pageType));
    } // NavigationTiming not supported by safari
    // https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/NavigationTiming


    if (window.performance !== undefined) {
      var navStart = performance.timing.navigationStart;
      var domComplete = performance.timing.domComplete;
      var responseStart = performance.timing.responseStart; // Some browsers appear to return zero for navigationStart

      if (navStart > 0 && domComplete > 0 && responseStart > 0) {
        var tz = new Date().getTimezoneOffset();
        var jsPageLoadTime = domComplete - navStart;
        var jsDomLoadTime = domComplete - performance.timing.domLoading;
        $.metrics.mark('domain-intern', 'js-page-load-samples');
        $.metrics.increment('domain-intern', 'js-page-load-time', jsPageLoadTime);
        $.metrics.increment('domain-intern', 'js-page-load-tz-' + tz + '-time', jsPageLoadTime);
        $.metrics.increment('domain-intern', 'js-response-start-time', responseStart - navStart);
        $.metrics.increment('domain-intern', 'js-response-read-time', performance.timing.responseEnd - responseStart); // Socrata->Browser latency ( not including dns )

        $.metrics.increment('domain-intern', 'js-connect-time', performance.timing.connectEnd - performance.timing.connectStart);
        $.metrics.increment('domain-intern', 'js-connect-tz-' + tz + '-time', performance.timing.connectEnd - performance.timing.connectStart); // domComplete is always the value of the *first* state change to complete
        // subsequent interactive states will not be captured here

        $.metrics.increment('domain-intern', 'js-dom-load-time', jsDomLoadTime); // TODO: Start sending 'js-pageview-{pageType}'

        $.metrics.increment('domain-intern', pageType + '-js-dom-load-time', jsDomLoadTime);
        $.metrics.mark('domain-intern', pageType + '-js-dom-load-samples');
        $.metrics.increment('domain-intern', pageType + '-js-page-load-time', jsPageLoadTime);
        $.metrics.mark('domain-intern', pageType + '-js-page-load-samples');

        if (pageType == 'dataslate') {
          var numContexts = _.size($.dataContext.availableContexts),
              bucket = _.find([1, 2, 4, 8, 16, 32, 64, 128], function (b) {
            return numContexts < b;
          });

          $.metrics.increment('domain-intern', 'js-dataslate-lte-' + bucket + '-contexts-page-load-time', jsPageLoadTime);
        }
      }
    }

    $.metrics.flush_metrics();
  },
  in_iframe: function in_iframe() {
    try {
      return window.self !== window.top;
    } catch (e) {
      return true;
    }
  },
  determinePageType: function determinePageType() {
    var pageType = 'other'; //debugger;

    var path = window.location.pathname; // Currently abiding by ISO 639-1 localisation standard

    var localizationRegex = '[a-z]{2}'; // Front load the dataslate check because it is the only check not dependent on the URL Path

    if ($.subKeyDefined(blist, 'configuration.page')) {
      pageType = 'dataslate';
    } // TODO Client end page type classification.  This should instead be replaced with a more robust classify on consume model.


    if (!path || path.match("^/(".concat(localizationRegex, ")?/?$"))) {
      pageType = 'homepage';
    }

    if (blist.dataset) {
      var extra = _.compact(_.map({
        'order': 'sort',
        'group': 'grouped',
        'where': 'filter',
        'having': 'filter'
      }, function (name, qPart) {
        return !_.isEmpty($.deepGet(blist.dataset, 'metadata', 'jsonQuery', qPart)) ? name : null;
      }));

      if (extra.length > 1) {
        pageType = 'dataset-complex';
      } else if (extra.length == 1) {
        pageType = "dataset-".concat(extra[0]);
      } else {
        pageType = 'dataset';
      }
    } else if (path.match("^/(".concat(localizationRegex, "/)?admin"))) {
      pageType = 'admin';
    } else if (path.match("^/(".concat(localizationRegex, "/)?profile"))) {
      pageType = 'profile';
    } else if (path.match("^/(".concat(localizationRegex, "/)?browse"))) {
      pageType = 'browse' + (window.location.href.indexOf('q=') > -1 ? '-search' : '');
    } else if ($.subKeyDefined(blist, 'govstat')) {
      pageType = 'govstat';
    }

    return pageType;
  },
  browser_name: function browser_name() {
    return _.get($, 'ua.browser.name', 'other').toLowerCase();
  }
};
$(window).on('load', function () {
  _.defer($.metrics.collectPageTimings);
});
$(window).on('unload', function () {
  $.metrics.flush_metrics(false);
});

/***/ }),

/***/ 3024:
/***/ (function(module, exports) {

$(function () {
  var csrfCookieName = 'socrata-csrf-token';
  blist.util.enforceLodashFunctions(); // EN-15381: The html and body tags have a height of 100%, and the .siteOuterWrapper has a min-height
  // of 100%. This causes the footer to be pushed below the bottom of the page, even on pages where the
  // content doesn't take up the whole window.
  // This takes the site chrome footer height (dynamic, based on domain-specific content) and
  // re-calculates the min-height of .siteOuterWrapper based on the footer height.

  var footerHeight = $('#site-chrome-footer').height();
  $('.siteOuterWrapper').css('min-height', "calc(100% - ".concat(footerHeight, "px)")); // generic events

  $.live('a[rel$=external]', 'focus', function () {
    this.target = '_blank';
  });
  $.live('a[rel$=external]', 'mouseover', function () {
    this.target = '_blank';
  }); // blist.iframeHack is for CORE-1660, in order to allow opening catalog links in the same window.
  // This makes it possible to make the default behavior same-window and have modifier keys
  // properly open a new window/tab.

  blist.iframeHack = {
    modifierKeys: [16, 17, 18, 91, 93],
    pressed: {}
  };
  $('body').on('keydown', function (evt) {
    if (_.includes(blist.iframeHack.modifierKeys, evt.which)) {
      blist.iframeHack.pressed[evt.which] = true;
    }
  });
  $('body').on('keyup', function (evt) {
    if (_.includes(blist.iframeHack.modifierKeys, evt.which)) {
      blist.iframeHack.pressed[evt.which] = false;
    }
  });

  blist.iframeHack.isModified = function () {
    return _.some(_.values(blist.iframeHack.pressed));
  };

  $.live('a[rel$=video]', 'click', function (event) {
    event.preventDefault();
    window.open($(this).attr('href'), '', 'width=650,height=550,location=no,menubar=no,scrollbars=no,status=no,toolbar=no');
  }); // custom validation

  $.validator.addMethod('customUrl', function (value, element) {
    if (this.optional(element)) {
      return true;
    }

    var regEx = blist.util.patterns.customUrl;

    if (!/^(https?|ftp):\/\//i.test(value)) {
      if (regEx.test('http://' + value)) {
        $(element).val('http://' + value);
        return true;
      }
    } else {
      return regEx.test(value);
    }

    return false;
  });
  $.validator.addMethod('secureUrl', function (value, element) {
    if (this.optional(element)) {
      return true;
    }

    return /^https/.test(value);
  });
  $.validator.addMethod('customHttpMaybeSUrl', function (value, element) {
    var regex = blist.util.patterns.customHttpMaybeSUrl;
    return this.optional(element) || regex.test(value);
  });
  $.validator.addMethod('coordinateReferenceSystem', function (value, element) {
    if (this.optional(element)) {
      return true;
    } // Just check that it's an EPSG code in the format EPSG:<number>.


    return /^EPSG:\d+$/i.test(value);
  });
  $.validator.addMethod('validateOptions', function (value, element) {
    return $(element).find(':selected')[0].getAttribute('disabled') == null;
  }); // drop in translated default validation messages

  var messages = {};

  _.each($.validator.messages, function (__, key) {
    var message = $.tNull('core.validation.' + key);

    if (message) {
      messages[key] = message;
    }
  });

  _.each(['maxlength', 'minlength', 'rangelength', 'range', 'max', 'min'], function (key) {
    messages[key] = $.validator.format(messages[key]);
  });

  $.extend($.validator.messages, messages);

  if ($.cookies.get('logged_in') == 'true') {
    $('#siteHeader').addClass('loggedIn').find('.siteUserNav').addClass('loggedInNav');
  }
  /* User Flashes
   *
   * Types:
   * - Old Browser Warning
   * - Maintenance Message
   * - Custom Informational Message
   *
   * Structure:
   * - Condition
   * - Acknowledgement (?)
   * - Message
   * - Classes
   */


  blist.namespace.fetch('blist.configuration');

  if (window === window.top) {
    // Construct User Flashes
    var browserIsOld = function browserIsOld(cookie) {
      if (cookie) {
        return false;
      }

      return $.browser.msie && $.browser.majorVersion < 11 || $.browser.safari && $.browser.majorVersion < 7 || // Chrome & Firefox update regularly, so this may not be technically current - 1
      $.browser.chrome && $.browser.majorVersion < 38 || $.browser.mozilla && $.browser.majorVersion < 27;
    };

    var oldBrowserMessage = [{
      _: 'div',
      contents: $.t('core.unsupported_browser.message_no_date_html', {
        link_text: $.tag2({
          _: 'a',
          target: '_blank',
          href: 'https://support.socrata.com/hc/en-us/articles/202951618',
          contents: $.t('core.unsupported_browser.link_text')
        }, false)
      })
    }];
    var oldBrowserUserFlash = {
      shouldDisplay: browserIsOld,
      acknowledgementCookie: 'browser_ack',
      message: oldBrowserMessage,
      htmlClasses: ['error']
    };
    var userFlashes = [oldBrowserUserFlash];

    if (blist.configuration.maintenance_messages) {
      userFlashes = userFlashes.concat(blist.configuration.maintenance_messages);
    }

    var $noticeContainer = $('#noticeContainer');
    var closeIcon = {
      _: 'a',
      href: '#',
      className: 'close',
      contents: {
        _: 'span',
        className: 'socrata-icon-close'
      }
    };

    _.each(userFlashes, function (flash) {
      var cookie = $.cookies.get(flash.acknowledgementCookie);

      if (!!flash.shouldDisplay(cookie) === false) {
        return;
      } // Construct the flash.
      // Please make sure to define htmlClasses as an array and not as a string.


      var $flash = $.tag2({
        _: 'div',
        className: flash.htmlClasses.concat('flash').join(' '),
        contents: [closeIcon].concat(flash.message)
      });
      $noticeContainer.append($flash);
      $flash.find('a.close').on('click', function (event) {
        event.preventDefault();
        $flash.fadeOut();

        if (flash.acknowlegementCookie) {
          $.cookies.set(flash.acknowledgementCookie, true);
        } else if (_.isFunction(flash.acknowledge)) {
          flash.acknowledge();
        }
      });
    });
  }

  var csrfTokenFromMeta = $('meta[name="csrf-token"]').attr('content');

  if (!$.isBlank(csrfTokenFromMeta)) {
    document.cookie = "".concat(csrfCookieName, "=").concat(csrfTokenFromMeta, ";secure;path=/");
  }

  blist.configuration.appToken = 'U29jcmF0YS0td2VraWNrYXNz0';
  $.ajaxSetup({
    beforeSend: function beforeSend(xhrObj) {
      xhrObj.setRequestHeader('X-App-Token', blist.configuration.appToken);
      xhrObj.setRequestHeader('X-CSRF-Token', csrfTokenFromMeta);
    }
  }); // See also platform-ui/frontend/public/javascripts/screens/site-appearance.js
  // See also platform-ui/common/js_utils/getLocale.js
  // Fix dates for local timezone and blist locale

  var getLocale = function getLocale() {
    return _.get(window.blist, 'locale', _.get(window.serverConfig, 'locale', _.get(window.socrata, 'locale', _.get(window.socrataConfig, 'locales.currentLocale', 'en'))));
  };

  moment.locale(getLocale());

  var getTimezone = function getTimezone() {
    return _.get(window.blist, 'configuration.userTimeZoneName', jstz.determine().name() // eslint-disable-line no-undef
    );
  };

  blist.configuration.userTimeZoneName = jstz.determine().name(); // eslint-disable-line no-undef
  // If any of this logic changes, please make corrsponding changes to dateLocalize() in
  // frontend/public/javascripts/common/locale.js:dateLocalize()
  // Also formatDateWithLocale in common/dates.js.

  $('.dateLocalize').each(function () {
    var $dateSpan = $(this);
    var format = $dateSpan.data('format');
    var rawdate = $dateSpan.data('rawdatetime') * 1000;
    $dateSpan.text(moment(rawdate).tz(getTimezone()).locale(getLocale()).format(format));
  }); // Special clean-up for maintenance message

  var $mDates = $('.maintenanceNotice .dateLocalize');

  if (moment($mDates.eq(0).data('rawdatetime') * 1000).isSame($mDates.eq(1).data('rawdatetime') * 1000, 'day')) {
    var $date = $mDates.eq(1);
    $date.text(moment($date.data('rawdatetime') * 1000).format('LT'));
  }

  blist.configuration.shortDateFormat = 'llll'; // "Tue, Apr 1 2014 11:37 AM"

  blist.configuration.longDateFormat = 'LLLL'; // "Tuesday, April 1 2014 11:37 AM"

  var onCurrentUser = [];
  var onCurrentUserComplete = [];
  var currentUserDone = false;

  var dispatchCurrentUser = function dispatchCurrentUser(callbacks, user) {
    for (var i = 0; i < callbacks.length; i++) {
      var successCallback = callbacks[i];

      if (_.isFunction(successCallback)) {
        successCallback(user);
      }
    }
  };

  var createCurrentUser = function createCurrentUser(jsonData) {
    currentUserDone = true;
    blist.currentUser = new User(jsonData);
    blist.currentUserId = blist.currentUser.id;
    var callbacks = onCurrentUser.concat(onCurrentUserComplete);
    dispatchCurrentUser(callbacks, blist.currentUser);
  };

  var getCurrentUser = function getCurrentUser() {
    if (window.currentUserJson) {
      createCurrentUser(window.currentUserJson);
    } else {
      $.socrataServer.makeRequest({
        type: 'GET',
        url: '/api/users/current.json',
        cache: false,
        headers: {
          'Cache-Control': 'nocache'
        },
        success: createCurrentUser,
        error: function error() {
          // We dispatch an undefined user to anything waiting for this
          // process to complete
          currentUserDone = true;
          dispatchCurrentUser(onCurrentUserComplete);
        }
      });
    }
  }; // kick off the process of setting the current user


  if ($.cookies.get('logged_in') == 'true' && blist.currentUser === undefined) {
    getCurrentUser();
  } else {
    currentUserDone = true;
    dispatchCurrentUser(onCurrentUserComplete, blist.currentUser);
  } //  Callback mechanism for when the request for the
  //  current user is slow


  blist.configuration.onCurrentUser = function (successCallback) {
    if (blist.currentUser !== undefined) {
      successCallback(blist.currentUser);
    } else {
      onCurrentUser.push(successCallback);
    }
  }; //  Callback mechanism for when the current user has been checked
  //  or if there is no login cookie to check


  blist.configuration.onCurrentUserComplete = function (callback) {
    if (currentUserDone) {
      callback(blist.currentUser);
    } else {
      onCurrentUserComplete.push(callback);
    }
  };

  blist.configuration.onCurrentUser(function (user) {
    $('.accountLink .text .currentUser').text(user.displayName);
    $('.accountLink').removeClass('hide');
    $('.accountLikeLink').removeClass('hide');
    $('.signOutLink').removeClass('hide');
    $('.signInLink').addClass('hide');
    $('.signUpLink').addClass('hide');

    if (user !== undefined && user.rights && user.rights.length > 0) {
      $('.adminLink').removeClass('hide');
    }

    $('.myGoalsLink').toggleClass('hide', _.isUndefined(user) || !user.hasRight(blist.rights.user.EDIT_GOALS));
  }); // GovStat account links are setup in main.html; originally before any current
  // user is available. We look to see if the govstat cb is defined and execute
  // them afterwards instead.

  blist.configuration.onCurrentUserComplete(function (user) {
    if (blist.configuration.govstat_links_cb !== undefined) {
      blist.configuration.govstat_links_cb(user);
    }
  });
  blist.namespace.fetch('blist.nextgen');

  _.each(window.location.href.match(/\w+=nextgen/g), function (prop) {
    blist.nextgen[prop.slice(0, prop.indexOf('='))] = true;
  });
});

/***/ }),

/***/ 3025:
/***/ (function(module, exports) {

$(function () {
  var startSessionCheck = function startSessionCheck() {
    //do nothing if the user is not logged in.
    if (!blist.currentUserId) {
      return;
    }

    var $m;

    var createModal = function createModal() {
      //create the modal
      $('body').append($.tag2({
        _: 'div',
        className: 'modalDialog',
        id: 'sessionTimeoutModal',
        contents: [{
          _: 'h2',
          contents: $.t('core.dialogs.session_timeout.warning.title')
        }, {
          _: 'p',
          contents: $.t('core.dialogs.session_timeout.warning.body_html')
        }, {
          _: 'div',
          className: 'buttonWrapper',
          contents: [{
            _: 'a',
            id: 'keepSessionButton',
            className: 'button',
            contents: $.t('core.dialogs.session_timeout.warning.belay_button')
          }]
        }]
      }));
      $m = $('#sessionTimeoutModal');
      $m.jqm();
      $('#keepSessionButton').click(function (event) {
        event.preventDefault();
        $m.jqmHide();
        delayExpiration();
      });
    };

    var secondsUntilTimeout;
    var modalTimer;
    var countdownSeconds = 60;
    var secondsRemaining;
    var updateTimer; //determine how much time is left in the session

    function checkTime() {
      $.socrataServer.makeRequest({
        url: '/logout/expire_if_idle',
        success: function success(response) {
          if (response.expired) {
            window.document.location = '/signed_out?return_to=' + encodeURIComponent(window.document.location.pathname);
          } else {
            secondsUntilTimeout = parseFloat(response.seconds);

            if (secondsUntilTimeout > countdownSeconds) {
              if ($m) {
                $m.jqmHide();
              }

              scheduleCheckTime();
            } else {
              if (!$m) {
                createModal();
              }

              showModal();
            }
          }
        },
        anonymous: true,
        error: function error() {
          setTimeout(checkTime, 10 * 1000);
        }
      });
    }

    checkTime();

    function scheduleCheckTime() {
      if (modalTimer) {
        clearTimeout(modalTimer);
      }

      if (updateTimer) {
        clearTimeout(updateTimer);
      }

      modalTimer = setTimeout(checkTime, (secondsUntilTimeout - countdownSeconds) * 1000);
    }

    function showModal() {
      secondsRemaining = secondsUntilTimeout;

      if (updateTimer) {
        clearInterval(updateTimer);
      }

      updateTimer = setInterval(countdown, 1000);
      countdown();
      $m.jqmShow();
    }

    function countdown() {
      $('#secondsRemaining').text(secondsRemaining);

      if (secondsRemaining <= 0) {
        if (updateTimer) {
          clearInterval(updateTimer);
        }

        setTimeout(checkTime, 1000);
        return;
      }

      if (secondsRemaining > 0) {
        secondsRemaining--;
      }
    }

    function delayExpiration() {
      $.socrataServer.makeRequest({
        url: '/login/extend',
        success: function success(response) {
          secondsUntilTimeout = parseFloat(response.seconds);
          scheduleCheckTime();
          $m.jqmHide();
        },
        anonymous: false,
        error: function error() {
          secondsUntilTimeout = 1000 * 20;
          scheduleCheckTime();
        }
      });
    }
  };

  if (blist.configuration.onCurrentUser) {
    blist.configuration.onCurrentUser(startSessionCheck);
  }
});

/***/ }),

/***/ 5:
/***/ (function(module, exports) {

module.exports = jQuery;

/***/ })

/******/ });
//# sourceMappingURL=base.js.map